(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[2],{

/***/ "./node_modules/apexcharts/dist/apexcharts.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/apexcharts/dist/apexcharts.esm.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(setImmediate, module) {/*!
 * ApexCharts v3.6.3
 * (c) 2018-2019 Juned Chhipa
 * Released under the MIT License.
 */
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

/*
 ** Generic functions which are not dependent on ApexCharts
 */
var Utils =
/*#__PURE__*/
function () {
  function Utils() {
    _classCallCheck(this, Utils);
  }

  _createClass(Utils, [{
    key: "shadeRGBColor",
    value: function shadeRGBColor(percent, color) {
      var f = color.split(','),
          t = percent < 0 ? 0 : 255,
          p = percent < 0 ? percent * -1 : percent,
          R = parseInt(f[0].slice(4)),
          G = parseInt(f[1]),
          B = parseInt(f[2]);
      return 'rgb(' + (Math.round((t - R) * p) + R) + ',' + (Math.round((t - G) * p) + G) + ',' + (Math.round((t - B) * p) + B) + ')';
    }
  }, {
    key: "shadeHexColor",
    value: function shadeHexColor(percent, color) {
      var f = parseInt(color.slice(1), 16),
          t = percent < 0 ? 0 : 255,
          p = percent < 0 ? percent * -1 : percent,
          R = f >> 16,
          G = f >> 8 & 0x00ff,
          B = f & 0x0000ff;
      return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
    } // beautiful color shading blending code
    // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors

  }, {
    key: "shadeColor",
    value: function shadeColor(p, color) {
      if (color.length > 7) return this.shadeRGBColor(p, color);else return this.shadeHexColor(p, color);
    }
  }], [{
    key: "bind",
    value: function bind(fn, me) {
      return function () {
        return fn.apply(me, arguments);
      };
    }
  }, {
    key: "isObject",
    value: function isObject(item) {
      return item && _typeof(item) === 'object' && !Array.isArray(item) && item != null;
    } // to extend defaults with user options
    // credit: http://stackoverflow.com/questions/27936772/deep-object-merging-in-es6-es7#answer-34749873

  }, {
    key: "extend",
    value: function extend(target, source) {
      var _this = this;

      if (typeof Object.assign !== 'function') {

        (function () {
          Object.assign = function (target) {

            if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);

            for (var index = 1; index < arguments.length; index++) {
              var _source = arguments[index];

              if (_source !== undefined && _source !== null) {
                for (var nextKey in _source) {
                  if (_source.hasOwnProperty(nextKey)) {
                    output[nextKey] = _source[nextKey];
                  }
                }
              }
            }

            return output;
          };
        })();
      }

      var output = Object.assign({}, target);

      if (this.isObject(target) && this.isObject(source)) {
        Object.keys(source).forEach(function (key) {
          if (_this.isObject(source[key])) {
            if (!(key in target)) {
              Object.assign(output, _defineProperty({}, key, source[key]));
            } else {
              output[key] = _this.extend(target[key], source[key]);
            }
          } else {
            Object.assign(output, _defineProperty({}, key, source[key]));
          }
        });
      }

      return output;
    }
  }, {
    key: "extendArray",
    value: function extendArray(arrToExtend, resultArr) {
      var extendedArr = [];
      arrToExtend.map(function (item) {
        extendedArr.push(Utils.extend(resultArr, item));
      });
      arrToExtend = extendedArr;
      return arrToExtend;
    } // If month counter exceeds 12, it starts again from 1

  }, {
    key: "monthMod",
    value: function monthMod(month) {
      return month % 12;
    }
  }, {
    key: "addProps",
    value: function addProps(obj, arr, val) {
      if (typeof arr === 'string') {
        arr = arr.split('.');
      }

      obj[arr[0]] = obj[arr[0]] || {};
      var tmpObj = obj[arr[0]];

      if (arr.length > 1) {
        arr.shift();
        this.addProps(tmpObj, arr, val);
      } else {
        obj[arr[0]] = val;
      }

      return obj;
    }
  }, {
    key: "clone",
    value: function clone(source) {
      if (Object.prototype.toString.call(source) === '[object Array]') {
        var cloneResult = [];

        for (var i = 0; i < source.length; i++) {
          cloneResult[i] = this.clone(source[i]);
        }

        return cloneResult;
      } else if (_typeof(source) === 'object') {
        var _cloneResult = {};

        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            _cloneResult[prop] = this.clone(source[prop]);
          }
        }

        return _cloneResult;
      } else {
        return source;
      }
    }
  }, {
    key: "log10",
    value: function log10(x) {
      return Math.log(x) / Math.LN10;
    }
  }, {
    key: "roundToBase10",
    value: function roundToBase10(x) {
      return Math.pow(10, Math.floor(Math.log10(x)));
    }
  }, {
    key: "roundToBase",
    value: function roundToBase(x, base) {
      return Math.pow(base, Math.floor(Math.log(x) / Math.log(base)));
    }
  }, {
    key: "parseNumber",
    value: function parseNumber(val) {
      if (val === null) return val;
      return parseFloat(val);
    }
  }, {
    key: "getDimensions",
    value: function getDimensions(el) {
      var computedStyle = getComputedStyle(el);
      var ret = [];
      var elementHeight = el.clientHeight;
      var elementWidth = el.clientWidth;
      elementHeight -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
      elementWidth -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
      ret.push(elementWidth);
      ret.push(elementHeight);
      return ret;
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect(element) {
      var rect = element.getBoundingClientRect();
      return {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      };
    } // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-12342275

  }, {
    key: "hexToRgba",
    value: function hexToRgba() {
      var hex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#999999';
      var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.6;

      if (hex.substring(0, 1) !== '#') {
        hex = '#999999';
      }

      var h = hex.replace('#', '');
      h = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'));

      for (var i = 0; i < h.length; i++) {
        h[i] = parseInt(h[i].length === 1 ? h[i] + h[i] : h[i], 16);
      }

      if (typeof opacity !== 'undefined') h.push(opacity);
      return 'rgba(' + h.join(',') + ')';
    }
  }, {
    key: "getOpacityFromRGBA",
    value: function getOpacityFromRGBA(rgba) {
      rgba = rgba.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
      return rgba[3];
    }
  }, {
    key: "rgb2hex",
    value: function rgb2hex(rgb) {
      rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
      return rgb && rgb.length === 4 ? '#' + ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';
    }
  }, {
    key: "isColorHex",
    value: function isColorHex(color) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
    }
  }, {
    key: "polarToCartesian",
    value: function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
      var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
      return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians)
      };
    }
  }, {
    key: "escapeString",
    value: function escapeString(str) {
      var escapeWith = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
      var newStr = str.toString().slice();
      newStr = newStr.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, escapeWith);
      return newStr;
    }
  }, {
    key: "negToZero",
    value: function negToZero(val) {
      return val < 0 ? 0 : val;
    }
  }, {
    key: "moveIndexInArray",
    value: function moveIndexInArray(arr, old_index, new_index) {
      if (new_index >= arr.length) {
        var k = new_index - arr.length + 1;

        while (k--) {
          arr.push(undefined);
        }
      }

      arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
      return arr;
    }
  }, {
    key: "extractNumber",
    value: function extractNumber(s) {
      return parseFloat(s.replace(/[^\d\.]*/g, ''));
    }
  }, {
    key: "randomString",
    value: function randomString(len) {
      var text = '';
      var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';

      for (var i = 0; i < len; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
      }

      return text;
    }
  }, {
    key: "findAncestor",
    value: function findAncestor(el, cls) {
      while ((el = el.parentElement) && !el.classList.contains(cls)) {
      }

      return el;
    }
  }, {
    key: "setELstyles",
    value: function setELstyles(el, styles) {
      for (var key in styles) {
        if (styles.hasOwnProperty(key)) {
          el.style.key = styles[key];
        }
      }
    }
  }, {
    key: "isNumber",
    value: function isNumber(value) {
      return !isNaN(value) && parseFloat(Number(value)) === value && !isNaN(parseInt(value, 10));
    }
  }, {
    key: "isFloat",
    value: function isFloat(n) {
      return Number(n) === n && n % 1 !== 0;
    }
  }, {
    key: "isSafari",
    value: function isSafari() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }
  }, {
    key: "isFirefox",
    value: function isFirefox() {
      return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
    }
  }, {
    key: "isIE11",
    value: function isIE11() {
      if (window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.appVersion.indexOf('Trident/') > -1) {
        return true;
      }
    }
  }, {
    key: "isIE",
    value: function isIE() {
      var ua = window.navigator.userAgent;
      var msie = ua.indexOf('MSIE ');

      if (msie > 0) {
        // IE 10 or older => return version number
        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
      }

      var trident = ua.indexOf('Trident/');

      if (trident > 0) {
        // IE 11 => return version number
        var rv = ua.indexOf('rv:');
        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
      }

      var edge = ua.indexOf('Edge/');

      if (edge > 0) {
        // Edge (IE 12+) => return version number
        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
      } // other browser


      return false;
    }
  }]);

  return Utils;
}();

/**
 * ApexCharts Filters Class for setting hover/active states on the paths.
 *
 * @module Formatters
 **/

var Filters =
/*#__PURE__*/
function () {
  function Filters(ctx) {
    _classCallCheck(this, Filters);

    this.ctx = ctx;
    this.w = ctx.w;
  } // create a re-usable filter which can be appended other filter effects and applied to multiple elements


  _createClass(Filters, [{
    key: "getDefaultFilter",
    value: function getDefaultFilter(el) {
      var w = this.w;
      el.unfilter(true);
      var filter = new window.SVG.Filter();
      filter.size('120%', '180%', '-5%', '-40%');

      if (w.config.states.normal.filter !== 'none') {
        this.applyFilter(el, w.config.states.normal.filter.type, w.config.states.normal.filter.value);
      } else {
        if (w.config.chart.dropShadow.enabled) {
          this.dropShadow(el, w.config.chart.dropShadow);
        }
      }
    }
  }, {
    key: "addNormalFilter",
    value: function addNormalFilter(el) {
      var w = this.w;

      if (w.config.chart.dropShadow.enabled) {
        this.dropShadow(el, w.config.chart.dropShadow);
      }
    }
  }, {
    key: "addDesaturateFilter",
    value: function addDesaturateFilter(el) {
      var _this = this;

      var w = this.w;
      el.unfilter(true);
      var filter = new window.SVG.Filter();
      filter.size('120%', '180%', '-5%', '-40%');
      el.filter(function (add) {
        var shadowAttr = w.config.chart.dropShadow;

        if (shadowAttr.enabled) {
          filter = _this.addShadow(add, shadowAttr);
        } else {
          filter = add;
        }

        filter.colorMatrix('matrix', [0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 1.0, 0]).colorMatrix('saturate', 0);
      });
      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');
    } // appends dropShadow to the filter object which can be chained with other filter effects

  }, {
    key: "addLightenFilter",
    value: function addLightenFilter(el, attrs) {
      var _this2 = this;

      var w = this.w;
      var intensity = attrs.intensity;

      if (Utils.isFirefox()) {
        return;
      }

      el.unfilter(true);
      var filter = new window.SVG.Filter();
      filter.size('120%', '180%', '-5%', '-40%');
      el.filter(function (add) {
        var shadowAttr = w.config.chart.dropShadow;

        if (shadowAttr.enabled) {
          filter = _this2.addShadow(add, shadowAttr);
        } else {
          filter = add;
        }

        filter.componentTransfer({
          rgb: {
            type: 'linear',
            slope: 1.5,
            intercept: intensity
          }
        });
      });
      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');
    } // appends dropShadow to the filter object which can be chained with other filter effects

  }, {
    key: "addDarkenFilter",
    value: function addDarkenFilter(el, attrs) {
      var _this3 = this;

      var w = this.w;
      var intensity = attrs.intensity;

      if (Utils.isFirefox()) {
        return;
      }

      el.unfilter(true);
      var filter = new window.SVG.Filter();
      filter.size('120%', '180%', '-5%', '-40%');
      el.filter(function (add) {
        var shadowAttr = w.config.chart.dropShadow;

        if (shadowAttr.enabled) {
          filter = _this3.addShadow(add, shadowAttr);
        } else {
          filter = add;
        }

        filter.componentTransfer({
          rgb: {
            type: 'linear',
            slope: intensity
          }
        });
      });
      el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');
    }
  }, {
    key: "applyFilter",
    value: function applyFilter(el, filter) {
      var intensity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;

      switch (filter) {
        case 'none':
          {
            this.addNormalFilter(el);
            break;
          }

        case 'lighten':
          {
            this.addLightenFilter(el, {
              intensity: intensity
            });
            break;
          }

        case 'darken':
          {
            this.addDarkenFilter(el, {
              intensity: intensity
            });
            break;
          }

        case 'desaturate':
          {
            this.addDesaturateFilter(el);
            break;
          }

        default:
          // do nothing
          break;
      }
    } // appends dropShadow to the filter object which can be chained with other filter effects

  }, {
    key: "addShadow",
    value: function addShadow(add, attrs) {
      var blur = attrs.blur,
          top = attrs.top,
          left = attrs.left,
          color = attrs.color,
          opacity = attrs.opacity;
      var shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur).merge(add.source);
      return add.blend(add.source, shadowBlur);
    } // directly adds dropShadow to the element and returns the same element.
    // the only way it is different from the addShadow() function is that addShadow is chainable to other filters, while this function discards all filters and add dropShadow

  }, {
    key: "dropShadow",
    value: function dropShadow(el, attrs) {
      var top = attrs.top,
          left = attrs.left,
          blur = attrs.blur,
          color = attrs.color,
          opacity = attrs.opacity,
          noUserSpaceOnUse = attrs.noUserSpaceOnUse;
      el.unfilter(true);
      var filter = new window.SVG.Filter();
      filter.size('120%', '180%', '-5%', '-40%');
      el.filter(function (add) {
        var shadowBlur = null;

        if (Utils.isSafari() || Utils.isFirefox() || Utils.isIE()) {
          // safari/firefox has some alternative way to use this filter
          shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur);
        } else {
          shadowBlur = add.flood(color, opacity).composite(add.sourceAlpha, 'in').offset(left, top).gaussianBlur(blur).merge(add.source);
        }

        add.blend(add.source, shadowBlur);
      });

      if (!noUserSpaceOnUse) {
        el.filterer.node.setAttribute('filterUnits', 'userSpaceOnUse');
      }

      return el;
    }
  }, {
    key: "setSelectionFilter",
    value: function setSelectionFilter(el, realIndex, dataPointIndex) {
      var w = this.w;

      if (typeof w.globals.selectedDataPoints[realIndex] !== 'undefined') {
        if (w.globals.selectedDataPoints[realIndex].indexOf(dataPointIndex) > -1) {
          el.node.setAttribute('selected', true);
          var activeFilter = w.config.states.active.filter;

          if (activeFilter !== 'none') {
            this.applyFilter(el, activeFilter.type, activeFilter.value);
          }
        }
      }
    }
  }]);

  return Filters;
}();

/**
 * ApexCharts Animation Class.
 *
 * @module Animations
 **/

var Animations =
/*#__PURE__*/
function () {
  function Animations(ctx) {
    _classCallCheck(this, Animations);

    this.ctx = ctx;
    this.w = ctx.w;
    this.setEasingFunctions();
  }

  _createClass(Animations, [{
    key: "setEasingFunctions",
    value: function setEasingFunctions() {
      var easing;
      var userDefinedEasing = this.w.config.chart.animations.easing;

      switch (userDefinedEasing) {
        case 'linear':
          {
            easing = '-';
            break;
          }

        case 'easein':
          {
            easing = '<';
            break;
          }

        case 'easeout':
          {
            easing = '>';
            break;
          }

        case 'easeinout':
          {
            easing = '<>';
            break;
          }

        case 'swing':
          {
            easing = function easing(pos) {
              var s = 1.70158;
              return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
            };

            break;
          }

        case 'bounce':
          {
            easing = function easing(pos) {
              if (pos < 1 / 2.75) {
                return 7.5625 * pos * pos;
              } else if (pos < 2 / 2.75) {
                return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
              } else if (pos < 2.5 / 2.75) {
                return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
              } else {
                return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
              }
            };

            break;
          }

        case 'elastic':
          {
            easing = function easing(pos) {
              if (pos === !!pos) return pos;
              return Math.pow(2, -10 * pos) * Math.sin((pos - 0.075) * (2 * Math.PI) / 0.3) + 1;
            };

            break;
          }

        default:
          {
            easing = '<>';
          }
      }

      this.w.globals.easing = easing;
    }
  }, {
    key: "animateLine",
    value: function animateLine(el, from, to, speed) {
      el.attr(from).animate(speed).attr(to);
    }
    /*
     ** Animate radius of a circle element
     */

  }, {
    key: "animateCircleRadius",
    value: function animateCircleRadius(el, from, to, speed, easing) {
      if (!from) from = 0;
      el.attr({
        r: from
      }).animate(speed, easing).attr({
        r: to
      });
    }
    /*
     ** Animate radius and position of a circle element
     */

  }, {
    key: "animateCircle",
    value: function animateCircle(el, from, to, speed, easing) {
      el.attr({
        r: from.r,
        cx: from.cx,
        cy: from.cy
      }).animate(speed, easing).attr({
        r: to.r,
        cx: to.cx,
        cy: to.cy
      });
    }
    /*
     ** Animate rect properties
     */

  }, {
    key: "animateRect",
    value: function animateRect(el, from, to, speed, fn) {
      el.attr(from).animate(speed).attr(to).afterAll(function () {
        fn();
      });
    }
  }, {
    key: "animatePathsGradually",
    value: function animatePathsGradually(params) {
      var el = params.el,
          j = params.j,
          pathFrom = params.pathFrom,
          pathTo = params.pathTo,
          speed = params.speed,
          delay = params.delay,
          strokeWidth = params.strokeWidth;
      var me = this;
      var w = this.w;
      var delayFactor = 0;

      if (w.config.chart.animations.animateGradually.enabled) {
        delayFactor = w.config.chart.animations.animateGradually.delay;
      }

      if (w.config.chart.animations.dynamicAnimation.enabled && w.globals.dataChanged) {
        delayFactor = 0;
      }

      me.morphSVG(el, j, pathFrom, pathTo, speed, strokeWidth, delay * delayFactor);
    }
  }, {
    key: "showDelayedElements",
    value: function showDelayedElements() {
      this.w.globals.delayedElements.forEach(function (d) {
        var ele = d.el;
        ele.classList.remove('hidden');
      });
    } // SVG.js animation for morphing one path to another

  }, {
    key: "morphSVG",
    value: function morphSVG(el, j, pathFrom, pathTo, speed, strokeWidth, delay) {
      var _this = this;

      var w = this.w;

      if (!pathFrom) {
        pathFrom = el.attr('pathFrom');
      }

      if (!pathTo) {
        pathTo = el.attr('pathTo');
      }

      if (!pathFrom || pathFrom.indexOf('undefined') > -1 || pathFrom.indexOf('NaN') > -1) {
        pathFrom = "M 0 ".concat(w.globals.gridHeight);
        speed = 1;
      }

      if (pathTo.indexOf('undefined') > -1 || pathTo.indexOf('NaN') > -1) {
        pathTo = "M 0 ".concat(w.globals.gridHeight);
        speed = 1;
      }

      if (!w.globals.shouldAnimate) {
        speed = 1;
      }

      el.plot(pathFrom).animate(1, w.globals.easing, delay).plot(pathFrom).animate(speed, w.globals.easing, delay).plot(pathTo).afterAll(function () {
        // a flag to indicate that the original mount function can return true now as animation finished here
        if (Utils.isNumber(j)) {
          if (j === w.globals.series[w.globals.maxValsInArrayIndex].length - 2 && w.globals.shouldAnimate) {
            w.globals.animationEnded = true;
          }
        } else if (w.globals.shouldAnimate) {
          w.globals.animationEnded = true;

          if (typeof w.config.chart.events.animationEnd === 'function') {
            w.config.chart.events.animationEnd(_this.ctx, w);
          }
        }

        _this.showDelayedElements();
      });
    }
  }]);

  return Animations;
}();

/**
 * ApexCharts Graphics Class for all drawing operations.
 *
 * @module Graphics
 **/

var Graphics =
/*#__PURE__*/
function () {
  function Graphics(ctx) {
    _classCallCheck(this, Graphics);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(Graphics, [{
    key: "drawLine",
    value: function drawLine(x1, y1, x2, y2) {
      var lineColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '#a8a8a8';
      var dashArray = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var strokeWidth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      var w = this.w;
      var line = w.globals.dom.Paper.line().attr({
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        stroke: lineColor,
        'stroke-dasharray': dashArray,
        'stroke-width': strokeWidth
      });
      return line;
    }
  }, {
    key: "drawRect",
    value: function drawRect() {
      var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '#fefefe';
      var opacity = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
      var strokeWidth = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
      var strokeColor = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
      var strokeDashArray = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var w = this.w;
      var rect = w.globals.dom.Paper.rect();
      rect.attr({
        x: x1,
        y: y1,
        width: x2 > 0 ? x2 : 0,
        height: y2 > 0 ? y2 : 0,
        rx: radius,
        ry: radius,
        fill: color,
        opacity: opacity,
        'stroke-width': strokeWidth !== null ? strokeWidth : 0,
        stroke: strokeColor !== null ? strokeColor : 'none',
        'stroke-dasharray': strokeDashArray
      });
      return rect;
    }
  }, {
    key: "drawPolygon",
    value: function drawPolygon(polygonString) {
      var stroke = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#e1e1e1';
      var fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'none';
      var w = this.w;
      var polygon = w.globals.dom.Paper.polygon(polygonString).attr({
        fill: fill,
        stroke: stroke
      });
      return polygon;
    }
  }, {
    key: "drawCircle",
    value: function drawCircle(radius) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var w = this.w;
      var c = w.globals.dom.Paper.circle(radius * 2);

      if (attrs !== null) {
        c.attr(attrs);
      }

      return c;
    }
  }, {
    key: "drawPath",
    value: function drawPath(_ref) {
      var _ref$d = _ref.d,
          d = _ref$d === void 0 ? '' : _ref$d,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? '#a8a8a8' : _ref$stroke,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,
          fill = _ref.fill,
          _ref$fillOpacity = _ref.fillOpacity,
          fillOpacity = _ref$fillOpacity === void 0 ? 1 : _ref$fillOpacity,
          _ref$strokeOpacity = _ref.strokeOpacity,
          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,
          classes = _ref.classes,
          _ref$strokeLinecap = _ref.strokeLinecap,
          strokeLinecap = _ref$strokeLinecap === void 0 ? null : _ref$strokeLinecap,
          _ref$strokeDashArray = _ref.strokeDashArray,
          strokeDashArray = _ref$strokeDashArray === void 0 ? 0 : _ref$strokeDashArray;
      var w = this.w;

      if (strokeLinecap === null) {
        strokeLinecap = w.config.stroke.lineCap;
      }

      if (d.indexOf('undefined') > -1 || d.indexOf('NaN') > -1) {
        d = "M 0 ".concat(w.globals.gridHeight);
      }

      var p = w.globals.dom.Paper.path(d).attr({
        fill: fill,
        'fill-opacity': fillOpacity,
        stroke: stroke,
        'stroke-opacity': strokeOpacity,
        'stroke-linecap': strokeLinecap,
        'stroke-width': strokeWidth,
        'stroke-dasharray': strokeDashArray,
        class: classes
      });
      return p;
    }
  }, {
    key: "group",
    value: function group() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var w = this.w;
      var g = w.globals.dom.Paper.group();

      if (attrs !== null) {
        g.attr(attrs);
      }

      return g;
    }
  }, {
    key: "move",
    value: function move(x, y) {
      var move = ['M', x, y].join(' ');
      return move;
    }
  }, {
    key: "line",
    value: function line(x, y) {
      var hORv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var line = null;

      if (hORv === null) {
        line = ['L', x, y].join(' ');
      } else if (hORv === 'H') {
        line = ['H', x].join(' ');
      } else if (hORv === 'V') {
        line = ['V', y].join(' ');
      }

      return line;
    }
  }, {
    key: "curve",
    value: function curve(x1, y1, x2, y2, x, y) {
      var curve = ['C', x1, y1, x2, y2, x, y].join(' ');
      return curve;
    }
  }, {
    key: "quadraticCurve",
    value: function quadraticCurve(x1, y1, x, y) {
      var curve = ['Q', x1, y1, x, y].join(' ');
      return curve;
    }
  }, {
    key: "arc",
    value: function arc(rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y) {
      var relative = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
      var coord = 'A';
      if (relative) coord = 'a';
      var arc = [coord, rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y].join(' ');
      return arc;
    }
    /**
     * @memberof Graphics
     * @param {object}
     *  i = series's index
     *  realIndex = realIndex is series's actual index when it was drawn time. After several redraws, the iterating "i" may change in loops, but realIndex doesn't
     *  pathFrom = existing pathFrom to animateTo
     *  pathTo = new Path to which d attr will be animated from pathFrom to pathTo
     *  stroke = line Color
     *  strokeWidth = width of path Line
     *  fill = it can be gradient, single color, pattern or image
     *  animationDelay = how much to delay when starting animation (in milliseconds)
     *  dataChangeSpeed = for dynamic animations, when data changes
     *  className = class attribute to add
     * @return {object} svg.js path object
     **/

  }, {
    key: "renderPaths",
    value: function renderPaths(_ref2) {
      var i = _ref2.i,
          j = _ref2.j,
          realIndex = _ref2.realIndex,
          pathFrom = _ref2.pathFrom,
          pathTo = _ref2.pathTo,
          stroke = _ref2.stroke,
          strokeWidth = _ref2.strokeWidth,
          strokeLinecap = _ref2.strokeLinecap,
          fill = _ref2.fill,
          animationDelay = _ref2.animationDelay,
          initialSpeed = _ref2.initialSpeed,
          dataChangeSpeed = _ref2.dataChangeSpeed,
          className = _ref2.className,
          id = _ref2.id,
          _ref2$shouldClipToGri = _ref2.shouldClipToGrid,
          shouldClipToGrid = _ref2$shouldClipToGri === void 0 ? true : _ref2$shouldClipToGri,
          _ref2$bindEventsOnPat = _ref2.bindEventsOnPaths,
          bindEventsOnPaths = _ref2$bindEventsOnPat === void 0 ? true : _ref2$bindEventsOnPat;
      var w = this.w;
      var filters = new Filters(this.ctx);
      var anim = new Animations(this.ctx);
      var initialAnim = this.w.config.chart.animations.enabled;
      var dynamicAnim = initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
      var d;
      var shouldAnimate = !!(initialAnim && !w.globals.resized || dynamicAnim && w.globals.dataChanged && w.globals.shouldAnimate);

      if (shouldAnimate) {
        d = pathFrom;
      } else {
        d = pathTo;
        this.w.globals.animationEnded = true;
      }

      var strokeDashArrayOpt = w.config.stroke.dashArray;
      var strokeDashArray = 0;

      if (Array.isArray(strokeDashArrayOpt)) {
        strokeDashArray = strokeDashArrayOpt[realIndex];
      } else {
        strokeDashArray = w.config.stroke.dashArray;
      }

      var el = this.drawPath({
        d: d,
        stroke: stroke,
        strokeWidth: strokeWidth,
        fill: fill,
        fillOpacity: 1,
        classes: className,
        strokeLinecap: strokeLinecap,
        strokeDashArray: strokeDashArray
      });
      el.attr('id', "".concat(id, "-").concat(i));
      el.attr('index', realIndex);

      if (shouldClipToGrid) {
        el.attr({
          'clip-path': "url(#gridRectMask".concat(w.globals.cuid, ")")
        });
      } // const defaultFilter = el.filterer


      if (w.config.states.normal.filter.type !== 'none') {
        filters.getDefaultFilter(el, w.config.states.normal.filter.type, w.config.states.normal.filter.value);
      } else {
        if (w.config.chart.dropShadow.enabled) {
          if (!w.config.chart.dropShadow.enabledSeries || w.config.chart.dropShadow.enabledSeries && w.config.chart.dropShadow.enabledSeries.indexOf(realIndex) !== -1) {
            var shadow = w.config.chart.dropShadow;
            filters.dropShadow(el, shadow);
          }
        }
      }

      if (bindEventsOnPaths) {
        el.node.addEventListener('mouseenter', this.pathMouseEnter.bind(this, el));
        el.node.addEventListener('mouseleave', this.pathMouseLeave.bind(this, el));
        el.node.addEventListener('mousedown', this.pathMouseDown.bind(this, el));
      }

      el.attr({
        pathTo: pathTo,
        pathFrom: pathFrom
      });
      var defaultAnimateOpts = {
        el: el,
        j: j,
        pathFrom: pathFrom,
        pathTo: pathTo,
        strokeWidth: strokeWidth
      };

      if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {
        anim.animatePathsGradually(_objectSpread({}, defaultAnimateOpts, {
          speed: initialSpeed,
          delay: animationDelay
        }));
      } else {
        if (w.globals.resized || !w.globals.dataChanged) {
          anim.showDelayedElements();
        }
      }

      if (w.globals.dataChanged && dynamicAnim && shouldAnimate) {
        anim.animatePathsGradually(_objectSpread({}, defaultAnimateOpts, {
          speed: dataChangeSpeed
        }));
      }

      return el;
    }
  }, {
    key: "drawPattern",
    value: function drawPattern(style, width, height) {
      var stroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '#a8a8a8';
      var strokeWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var w = this.w;
      var p = w.globals.dom.Paper.pattern(width, height, function (add) {
        if (style === 'horizontalLines') {
          add.line(0, 0, height, 0).stroke({
            color: stroke,
            width: strokeWidth + 1
          });
        } else if (style === 'verticalLines') {
          add.line(0, 0, 0, width).stroke({
            color: stroke,
            width: strokeWidth + 1
          });
        } else if (style === 'slantedLines') {
          add.line(0, 0, width, height).stroke({
            color: stroke,
            width: strokeWidth
          });
        } else if (style === 'squares') {
          add.rect(width, height).fill('none').stroke({
            color: stroke,
            width: strokeWidth
          });
        } else if (style === 'circles') {
          add.circle(width).fill('none').stroke({
            color: stroke,
            width: strokeWidth
          });
        }
      });
      return p;
    }
  }, {
    key: "drawGradient",
    value: function drawGradient(style, gfrom, gto, opacityFrom, opacityTo) {
      var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var stops = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      var colorStops = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
      var i = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
      var w = this.w;
      var g;
      gfrom = Utils.hexToRgba(gfrom, opacityFrom);
      gto = Utils.hexToRgba(gto, opacityTo);
      var stop1 = 0;
      var stop2 = 1;
      var stop3 = 1;
      var stop4 = null;

      if (stops !== null) {
        stop1 = typeof stops[0] !== 'undefined' ? stops[0] / 100 : 0;
        stop2 = typeof stops[1] !== 'undefined' ? stops[1] / 100 : 1;
        stop3 = typeof stops[2] !== 'undefined' ? stops[2] / 100 : 1;
        stop4 = typeof stops[3] !== 'undefined' ? stops[3] / 100 : null;
      }

      var radial = !!(w.config.chart.type === 'donut' || w.config.chart.type === 'pie' || w.config.chart.type === 'bubble');

      if (colorStops === null || colorStops.length === 0) {
        g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (stop) {
          stop.at(stop1, gfrom, opacityFrom);
          stop.at(stop2, gto, opacityTo);
          stop.at(stop3, gto, opacityTo);

          if (stop4 !== null) {
            stop.at(stop4, gfrom, opacityFrom);
          }
        });
      } else {
        g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (stop) {
          var stops = Array.isArray(colorStops[i]) ? colorStops[i] : colorStops;
          stops.forEach(function (s) {
            stop.at(s.offset / 100, s.color, s.opacity);
          });
        });
      }

      if (!radial) {
        if (style === 'vertical') {
          g.from(0, 0).to(0, 1);
        } else if (style === 'diagonal') {
          g.from(0, 0).to(1, 1);
        } else if (style === 'horizontal') {
          g.from(0, 1).to(1, 1);
        } else if (style === 'diagonal2') {
          g.from(0, 1).to(2, 2);
        }
      } else {
        var offx = w.globals.gridWidth / 2;
        var offy = w.globals.gridHeight / 2;

        if (w.config.chart.type !== 'bubble') {
          g.attr({
            gradientUnits: 'userSpaceOnUse',
            cx: offx,
            cy: offy,
            r: size
          });
        } else {
          g.attr({
            cx: 0.5,
            cy: 0.5,
            r: 0.8,
            fx: 0.2,
            fy: 0.2
          });
        }
      }

      return g;
    }
  }, {
    key: "drawText",
    value: function drawText(opts) {
      var w = this.w;
      var x = opts.x,
          y = opts.y,
          text = opts.text,
          textAnchor = opts.textAnchor,
          fontSize = opts.fontSize,
          fontFamily = opts.fontFamily,
          foreColor = opts.foreColor,
          opacity = opts.opacity;

      if (!textAnchor) {
        textAnchor = 'start';
      }

      if (!foreColor) {
        foreColor = w.config.chart.foreColor;
      }

      fontFamily = fontFamily || w.config.chart.fontFamily;
      var elText;

      if (Array.isArray(text)) {
        elText = w.globals.dom.Paper.text(function (add) {
          for (var i = 0; i < text.length; i++) {
            add.tspan(text[i]);
          }
        });
      } else {
        elText = w.globals.dom.Paper.plain(text);
      }

      elText.attr({
        x: x,
        y: y,
        'text-anchor': textAnchor,
        'dominant-baseline': 'central',
        'font-size': fontSize,
        'font-family': fontFamily,
        fill: foreColor,
        class:  true ? opts.cssClass : undefined
      });
      elText.node.style.fontFamily = fontFamily;
      elText.node.style.opacity = opacity;
      return elText;
    }
  }, {
    key: "addTspan",
    value: function addTspan(textEl, text, fontFamily) {
      var tspan = textEl.tspan(text);

      if (!fontFamily) {
        fontFamily = this.w.config.chart.fontFamily;
      }

      tspan.node.style.fontFamily = fontFamily;
    }
  }, {
    key: "drawMarker",
    value: function drawMarker(x, y, opts) {
      x = x || 0;
      var size = opts.pSize || 0;
      var elPoint = null;

      if (opts.shape === 'square') {
        var radius = opts.pRadius === undefined ? size / 2 : opts.pRadius;

        if (y === null) {
          size = 0;
          radius = 0;
        }

        var nSize = size * 1.2 + radius;
        var p = this.drawRect(nSize, nSize, nSize, nSize, radius);
        p.attr({
          x: x - nSize / 2,
          y: y - nSize / 2,
          cx: x,
          cy: y,
          class: opts.class ? opts.class : '',
          fill: opts.pointFillColor,
          'fill-opacity': opts.pointFillOpacity ? opts.pointFillOpacity : 1,
          stroke: opts.pointStrokeColor,
          'stroke-width': opts.pWidth ? opts.pWidth : 0,
          'stroke-opacity': opts.pointStrokeOpacity ? opts.pointStrokeOpacity : 1
        });
        elPoint = p;
      } else if (opts.shape === 'circle') {
        if (!Utils.isNumber(y)) {
          size = 0;
          y = 0;
        } // let nSize = size - opts.pRadius / 2 < 0 ? 0 : size - opts.pRadius / 2


        elPoint = this.drawCircle(size, {
          cx: x,
          cy: y,
          class: opts.class ? opts.class : '',
          stroke: opts.pointStrokeColor,
          fill: opts.pointFillColor,
          'fill-opacity': opts.pointFillOpacity ? opts.pointFillOpacity : 1,
          'stroke-width': opts.pWidth ? opts.pWidth : 0,
          'stroke-opacity': opts.pointStrokeOpacity ? opts.pointStrokeOpacity : 1
        });
      }

      return elPoint;
    }
  }, {
    key: "pathMouseEnter",
    value: function pathMouseEnter(path, e) {
      var w = this.w;
      var filters = new Filters(this.ctx);
      var i = parseInt(path.node.getAttribute('index'));
      var j = parseInt(path.node.getAttribute('j'));

      if (typeof w.config.chart.events.dataPointMouseEnter === 'function') {
        w.config.chart.events.dataPointMouseEnter(e, this.ctx, {
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        });
      }

      this.ctx.fireEvent('dataPointMouseEnter', [e, this.ctx, {
        seriesIndex: i,
        dataPointIndex: j,
        w: w
      }]);

      if (w.config.states.active.filter.type !== 'none') {
        if (path.node.getAttribute('selected') === 'true') {
          return;
        }
      }

      if (w.config.states.hover.filter.type !== 'none') {
        if (w.config.states.active.filter.type !== 'none' && !w.globals.isTouchDevice) {
          var hoverFilter = w.config.states.hover.filter;
          filters.applyFilter(path, hoverFilter.type, hoverFilter.value);
        }
      }
    }
  }, {
    key: "pathMouseLeave",
    value: function pathMouseLeave(path, e) {
      var w = this.w;
      var filters = new Filters(this.ctx);
      var i = parseInt(path.node.getAttribute('index'));
      var j = parseInt(path.node.getAttribute('j'));

      if (typeof w.config.chart.events.dataPointMouseLeave === 'function') {
        w.config.chart.events.dataPointMouseLeave(e, this.ctx, {
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        });
      }

      this.ctx.fireEvent('dataPointMouseLeave', [e, this.ctx, {
        seriesIndex: i,
        dataPointIndex: j,
        w: w
      }]);

      if (w.config.states.active.filter.type !== 'none') {
        if (path.node.getAttribute('selected') === 'true') {
          return;
        }
      }

      if (w.config.states.hover.filter.type !== 'none') {
        filters.getDefaultFilter(path);
      }
    }
  }, {
    key: "pathMouseDown",
    value: function pathMouseDown(path, e) {
      var w = this.w;
      var filters = new Filters(this.ctx);
      var i = parseInt(path.node.getAttribute('index'));
      var j = parseInt(path.node.getAttribute('j'));
      var selected = 'false';

      if (path.node.getAttribute('selected') === 'true') {
        path.node.setAttribute('selected', 'false');

        if (w.globals.selectedDataPoints[i].indexOf(j) > -1) {
          var index = w.globals.selectedDataPoints[i].indexOf(j);
          w.globals.selectedDataPoints[i].splice(index, 1);
        }
      } else {
        if (!w.config.states.active.allowMultipleDataPointsSelection && w.globals.selectedDataPoints.length > 0) {
          w.globals.selectedDataPoints = [];
          var elPaths = w.globals.dom.Paper.select('.apexcharts-series path').members;
          var elCircles = w.globals.dom.Paper.select('.apexcharts-series circle, .apexcharts-series rect').members;
          elPaths.forEach(function (elPath) {
            elPath.node.setAttribute('selected', 'false');
            filters.getDefaultFilter(elPath);
          });
          elCircles.forEach(function (circle) {
            circle.node.setAttribute('selected', 'false');
            filters.getDefaultFilter(circle);
          });
        }

        path.node.setAttribute('selected', 'true');
        selected = 'true';

        if (typeof w.globals.selectedDataPoints[i] === 'undefined') {
          w.globals.selectedDataPoints[i] = [];
        }

        w.globals.selectedDataPoints[i].push(j);
      }

      if (selected === 'true') {
        var activeFilter = w.config.states.active.filter;

        if (activeFilter !== 'none') {
          filters.applyFilter(path, activeFilter.type, activeFilter.value);
        }
      } else {
        if (w.config.states.active.filter.type !== 'none') {
          filters.getDefaultFilter(path);
        }
      }

      if (typeof w.config.chart.events.dataPointSelection === 'function') {
        w.config.chart.events.dataPointSelection(e, this.ctx, {
          selectedDataPoints: w.globals.selectedDataPoints,
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        });
      }

      this.ctx.fireEvent('dataPointSelection', [e, this.ctx, {
        selectedDataPoints: w.globals.selectedDataPoints,
        seriesIndex: i,
        dataPointIndex: j,
        w: w
      }]); // if (this.w.config.chart.selection.selectedPoints !== undefined) {
      //   this.w.config.chart.selection.selectedPoints(w.globals.selectedDataPoints)
      // }
    }
  }, {
    key: "rotateAroundCenter",
    value: function rotateAroundCenter(el) {
      var coord = el.getBBox();
      var x = coord.x + coord.width / 2;
      var y = coord.y + coord.height / 2;
      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "getTextRects",
    value: function getTextRects(text, fontSize, fontFamily, transform) {
      var useBBox = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var w = this.w;
      var virtualText = this.drawText({
        x: -200,
        y: -200,
        text: text,
        textAnchor: 'start',
        fontSize: fontSize,
        fontFamily: fontFamily,
        foreColor: '#fff',
        opacity: 0
      });

      if (transform) {
        virtualText.attr('transform', transform);
      }

      w.globals.dom.Paper.add(virtualText);
      var rect = virtualText.bbox();

      if (!useBBox) {
        rect = virtualText.node.getBoundingClientRect();
      }

      virtualText.remove();
      return {
        width: rect.width,
        height: rect.height
      };
    }
    /**
     * append ... to long text
     * http://stackoverflow.com/questions/9241315/trimming-text-to-a-given-pixel-width-in-svg
     * @memberof Graphics
     **/

  }, {
    key: "placeTextWithEllipsis",
    value: function placeTextWithEllipsis(textObj, textString, width) {
      textObj.textContent = textString;

      if (textString.length > 0) {
        // ellipsis is needed
        if (textObj.getSubStringLength(0, textString.length) >= width) {
          for (var x = textString.length - 3; x > 0; x -= 3) {
            if (textObj.getSubStringLength(0, x) <= width) {
              textObj.textContent = textString.substring(0, x) + '...';
              return;
            }
          }

          textObj.textContent = '...'; // can't place at all
        }
      }
    }
  }], [{
    key: "setAttrs",
    value: function setAttrs(el, attrs) {
      for (var key in attrs) {
        if (attrs.hasOwnProperty(key)) {
          el.setAttribute(key, attrs[key]);
        }
      }
    }
  }]);

  return Graphics;
}();

const name = "en";
const options = {
	months: [
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
	],
	shortMonths: [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	],
	days: [
		"Sunday",
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday"
	],
	shortDays: [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	toolbar: {
		exportToSVG: "Download SVG",
		exportToPNG: "Download PNG",
		menu: "Menu",
		selection: "Selection",
		selectionZoom: "Selection Zoom",
		zoomIn: "Zoom In",
		zoomOut: "Zoom Out",
		pan: "Panning",
		reset: "Reset Zoom"
	}
};
var en = {
	name: name,
	options: options
};

var Options =
/*#__PURE__*/
function () {
  function Options() {
    _classCallCheck(this, Options);

    this.yAxis = {
      show: true,
      showAlways: false,
      seriesName: undefined,
      opposite: false,
      reversed: false,
      logarithmic: false,
      tickAmount: undefined,
      forceNiceScale: false,
      max: undefined,
      min: undefined,
      floating: false,
      decimalsInFloat: 2,
      labels: {
        show: true,
        minWidth: 0,
        maxWidth: 160,
        offsetX: 0,
        offsetY: 0,
        rotate: 0,
        padding: 20,
        style: {
          colors: [],
          fontSize: '11px',
          fontFamily: undefined,
          cssClass: ''
        },
        formatter: undefined
      },
      axisBorder: {
        show: false,
        color: '#78909C',
        offsetX: 0,
        offsetY: 0
      },
      axisTicks: {
        show: false,
        color: '#78909C',
        width: 6,
        offsetX: 0,
        offsetY: 0
      },
      title: {
        text: undefined,
        rotate: 90,
        offsetY: 0,
        offsetX: 0,
        style: {
          color: undefined,
          fontSize: '11px',
          fontFamily: undefined,
          cssClass: ''
        }
      },
      tooltip: {
        enabled: false,
        offsetX: 0
      },
      crosshairs: {
        show: true,
        position: 'front',
        stroke: {
          color: '#b6b6b6',
          width: 1,
          dashArray: 0
        }
      }
    };
    this.xAxisAnnotation = {
      x: 0,
      x2: null,
      strokeDashArray: 1,
      fillColor: '#c2c2c2',
      borderColor: '#c2c2c2',
      opacity: 0.3,
      offsetX: 0,
      offsetY: 0,
      label: {
        borderColor: '#c2c2c2',
        borderWidth: 1,
        text: undefined,
        textAnchor: 'middle',
        orientation: 'vertical',
        position: 'top',
        offsetX: 0,
        offsetY: 0,
        style: {
          background: '#fff',
          color: undefined,
          fontSize: '11px',
          fontFamily: undefined,
          cssClass: '',
          padding: {
            left: 5,
            right: 5,
            top: 2,
            bottom: 2
          }
        }
      }
    };
    this.yAxisAnnotation = {
      y: 0,
      y2: null,
      strokeDashArray: 1,
      fillColor: '#c2c2c2',
      borderColor: '#c2c2c2',
      opacity: 0.3,
      offsetX: 0,
      offsetY: 0,
      yAxisIndex: 0,
      label: {
        borderColor: '#c2c2c2',
        borderWidth: 1,
        text: undefined,
        textAnchor: 'end',
        position: 'right',
        offsetX: 0,
        offsetY: -3,
        style: {
          background: '#fff',
          color: undefined,
          fontSize: '11px',
          fontFamily: undefined,
          cssClass: '',
          padding: {
            left: 5,
            right: 5,
            top: 0,
            bottom: 2
          }
        }
      }
    };
    this.pointAnnotation = {
      x: 0,
      y: null,
      yAxisIndex: 0,
      seriesIndex: 0,
      marker: {
        size: 0,
        fillColor: '#fff',
        strokeWidth: 2,
        strokeColor: '#333',
        shape: 'circle',
        offsetX: 0,
        offsetY: 0,
        radius: 2,
        cssClass: ''
      },
      label: {
        borderColor: '#c2c2c2',
        borderWidth: 1,
        text: undefined,
        textAnchor: 'middle',
        offsetX: 0,
        offsetY: -15,
        style: {
          background: '#fff',
          color: undefined,
          fontSize: '11px',
          fontFamily: undefined,
          cssClass: '',
          padding: {
            left: 5,
            right: 5,
            top: 0,
            bottom: 2
          }
        }
      },
      customSVG: {
        SVG: undefined,
        cssClass: undefined,
        offsetX: 0,
        offsetY: 0
      }
    };
  }

  _createClass(Options, [{
    key: "init",
    value: function init() {
      return {
        annotations: {
          position: 'front',
          yaxis: [this.yAxisAnnotation],
          xaxis: [this.xAxisAnnotation],
          points: [this.pointAnnotation]
        },
        chart: {
          animations: {
            enabled: true,
            easing: 'easeinout',
            // linear, easeout, easein, easeinout, swing, bounce, elastic
            speed: 800,
            animateGradually: {
              delay: 150,
              enabled: true
            },
            dynamicAnimation: {
              enabled: true,
              speed: 350
            }
          },
          background: 'transparent',
          locales: [en],
          defaultLocale: 'en',
          dropShadow: {
            enabled: false,
            enabledSeries: undefined,
            top: 2,
            left: 2,
            blur: 4,
            color: '#000',
            opacity: 0.35
          },
          events: {
            animationEnd: undefined,
            beforeMount: undefined,
            mounted: undefined,
            updated: undefined,
            click: undefined,
            legendClick: undefined,
            selection: undefined,
            dataPointSelection: undefined,
            dataPointMouseEnter: undefined,
            dataPointMouseLeave: undefined,
            beforeZoom: undefined,
            zoomed: undefined,
            scrolled: undefined
          },
          foreColor: '#373d3f',
          fontFamily: 'Helvetica, Arial, sans-serif',
          height: 'auto',
          id: undefined,
          group: undefined,
          offsetX: 0,
          offsetY: 0,
          selection: {
            enabled: false,
            type: 'x',
            // selectedPoints: undefined, // default datapoints that should be selected automatically
            fill: {
              color: '#24292e',
              opacity: 0.1
            },
            stroke: {
              width: 1,
              color: '#24292e',
              opacity: 0.4,
              dashArray: 3
            },
            xaxis: {
              min: undefined,
              max: undefined
            },
            yaxis: {
              min: undefined,
              max: undefined
            }
          },
          sparkline: {
            enabled: false
          },
          brush: {
            enabled: false,
            autoScaleYaxis: false,
            target: undefined
          },
          stacked: false,
          stackType: 'normal',
          toolbar: {
            show: true,
            tools: {
              download: true,
              selection: true,
              zoom: true,
              zoomin: true,
              zoomout: true,
              pan: true,
              reset: true,
              customIcons: []
            },
            autoSelected: 'zoom' // accepts -> zoom, pan, selection

          },
          type: 'line',
          width: '100%',
          zoom: {
            enabled: true,
            type: 'x',
            // autoScaleYaxis: false, // TODO: rewrite the autoScaleY function
            zoomedArea: {
              fill: {
                color: '#90CAF9',
                opacity: 0.4
              },
              stroke: {
                color: '#0D47A1',
                opacity: 0.4,
                width: 1
              }
            }
          }
        },
        plotOptions: {
          bar: {
            horizontal: false,
            endingShape: 'flat',
            // TODO: deprecate in 4.0
            columnWidth: '70%',
            // should be in percent 0 - 100
            barHeight: '70%',
            // should be in percent 0 - 100
            distributed: false,
            colors: {
              ranges: [],
              backgroundBarColors: [],
              backgroundBarOpacity: 1
            },
            dataLabels: {
              position: 'top' // top, center, bottom
              // TODO: provide stackedLabels for stacked charts which gives additions of values

            }
          },
          candlestick: {
            colors: {
              upward: '#00B746',
              downward: '#EF403C'
            },
            wick: {
              useFillColor: true
            }
          },
          heatmap: {
            radius: 2,
            enableShades: true,
            shadeIntensity: 0.5,
            distributed: false,
            colorScale: {
              inverse: false,
              ranges: [],
              min: undefined,
              max: undefined
            }
          },
          radialBar: {
            size: undefined,
            inverseOrder: false,
            startAngle: 0,
            endAngle: 360,
            offsetX: 0,
            offsetY: 0,
            hollow: {
              margin: 5,
              size: '50%',
              background: 'transparent',
              image: undefined,
              imageWidth: 150,
              imageHeight: 150,
              imageOffsetX: 0,
              imageOffsetY: 0,
              imageClipped: true,
              position: 'front',
              dropShadow: {
                enabled: false,
                top: 0,
                left: 0,
                blur: 3,
                color: '#000',
                opacity: 0.5
              }
            },
            track: {
              show: true,
              startAngle: undefined,
              endAngle: undefined,
              background: '#f2f2f2',
              strokeWidth: '97%',
              opacity: 1,
              margin: 5,
              // margin is in pixels
              dropShadow: {
                enabled: false,
                top: 0,
                left: 0,
                blur: 3,
                color: '#000',
                opacity: 0.5
              }
            },
            dataLabels: {
              show: true,
              name: {
                show: true,
                fontSize: '16px',
                fontFamily: undefined,
                color: undefined,
                offsetY: 0
              },
              value: {
                show: true,
                fontSize: '14px',
                fontFamily: undefined,
                color: undefined,
                offsetY: 16,
                formatter: function formatter(val) {
                  return val + '%';
                }
              },
              total: {
                show: false,
                label: 'Total',
                color: '#373d3f',
                formatter: function formatter(w) {
                  return w.globals.seriesTotals.reduce(function (a, b) {
                    return a + b;
                  }, 0) / w.globals.series.length + '%';
                }
              }
            }
          },
          pie: {
            size: undefined,
            customScale: 1,
            offsetX: 0,
            offsetY: 0,
            expandOnClick: true,
            dataLabels: {
              // These are the percentage values which are displayed on slice
              offset: 0 // offset by which labels will move outside

            },
            donut: {
              size: '65%',
              background: 'transparent',
              labels: {
                // These are the inner labels appearing inside donut
                show: false,
                name: {
                  show: true,
                  fontSize: '16px',
                  fontFamily: undefined,
                  color: undefined,
                  offsetY: -10
                },
                value: {
                  show: true,
                  fontSize: '20px',
                  fontFamily: undefined,
                  color: undefined,
                  offsetY: 10,
                  formatter: function formatter(val) {
                    return val;
                  }
                },
                total: {
                  show: false,
                  label: 'Total',
                  color: '#373d3f',
                  formatter: function formatter(w) {
                    return w.globals.seriesTotals.reduce(function (a, b) {
                      return a + b;
                    }, 0);
                  }
                }
              }
            }
          },
          radar: {
            size: undefined,
            offsetX: 0,
            offsetY: 0,
            polygons: {
              // strokeColor: '#e8e8e8', // should be deprecated in the minor version i.e 3.2
              strokeColors: '#e8e8e8',
              connectorColors: '#e8e8e8',
              fill: {
                colors: undefined
              }
            }
          }
        },
        colors: undefined,
        dataLabels: {
          enabled: true,
          enabledOnSeries: undefined,
          formatter: function formatter(val) {
            return val;
          },
          textAnchor: 'middle',
          offsetX: 0,
          offsetY: 0,
          style: {
            fontSize: '12px',
            fontFamily: undefined,
            colors: undefined
          },
          dropShadow: {
            enabled: false,
            top: 1,
            left: 1,
            blur: 1,
            color: '#000',
            opacity: 0.45
          }
        },
        fill: {
          type: 'solid',
          colors: undefined,
          // array of colors
          opacity: 0.85,
          gradient: {
            shade: 'dark',
            type: 'horizontal',
            shadeIntensity: 0.5,
            gradientToColors: undefined,
            inverseColors: true,
            opacityFrom: 1,
            opacityTo: 1,
            stops: [0, 50, 100],
            colorStops: []
          },
          image: {
            src: [],
            width: undefined,
            // optional
            height: undefined // optional

          },
          pattern: {
            style: 'sqaures',
            // String | Array of Strings
            width: 6,
            height: 6,
            strokeWidth: 2
          }
        },
        grid: {
          show: true,
          borderColor: '#e0e0e0',
          strokeDashArray: 0,
          position: 'back',
          xaxis: {
            lines: {
              show: false,
              animate: false
            }
          },
          yaxis: {
            lines: {
              show: true,
              animate: true
            }
          },
          row: {
            colors: undefined,
            // takes as array which will be repeated on rows
            opacity: 0.5
          },
          column: {
            colors: undefined,
            // takes an array which will be repeated on columns
            opacity: 0.5
          },
          padding: {
            top: 0,
            right: 10,
            bottom: 0,
            left: 12
          }
        },
        labels: [],
        legend: {
          show: true,
          showForSingleSeries: false,
          showForNullSeries: true,
          showForZeroSeries: true,
          floating: false,
          position: 'bottom',
          // whether to position legends in 1 of 4
          // direction - top, bottom, left, right
          horizontalAlign: 'center',
          // when position top/bottom, you can specify whether to align legends left, right or center
          fontSize: '12px',
          fontFamily: undefined,
          width: undefined,
          height: undefined,
          formatter: undefined,
          offsetX: -20,
          offsetY: 0,
          labels: {
            colors: undefined,
            useSeriesColors: false
          },
          markers: {
            width: 12,
            height: 12,
            strokeWidth: 0,
            strokeColor: '#fff',
            radius: 12,
            customHTML: undefined,
            offsetX: 0,
            offsetY: 0,
            onClick: undefined
          },
          itemMargin: {
            horizontal: 0,
            vertical: 5
          },
          onItemClick: {
            toggleDataSeries: true
          },
          onItemHover: {
            highlightDataSeries: true
          }
        },
        markers: {
          discrete: [],
          size: 0,
          colors: undefined,
          //strokeColor: '#fff', // TODO: deprecate in major version 4.0
          strokeColors: '#fff',
          strokeWidth: 2,
          strokeOpacity: 0.9,
          fillOpacity: 1,
          shape: 'circle',
          radius: 2,
          offsetX: 0,
          offsetY: 0,
          hover: {
            size: undefined,
            sizeOffset: 3
          }
        },
        noData: {
          text: undefined,
          align: 'center',
          verticalAlign: 'middle',
          offsetX: 0,
          offsetY: 0,
          style: {
            color: undefined,
            fontSize: '14px',
            fontFamily: undefined
          }
        },
        responsive: [],
        // breakpoints should follow ascending order 400, then 700, then 1000
        series: undefined,
        states: {
          normal: {
            filter: {
              type: 'none',
              value: 0
            }
          },
          hover: {
            filter: {
              type: 'lighten',
              value: 0.15
            }
          },
          active: {
            allowMultipleDataPointsSelection: false,
            filter: {
              type: 'darken',
              value: 0.65
            }
          }
        },
        title: {
          text: undefined,
          align: 'left',
          margin: 10,
          offsetX: 0,
          offsetY: 0,
          floating: false,
          style: {
            fontSize: '14px',
            fontFamily: undefined,
            color: undefined
          }
        },
        subtitle: {
          text: undefined,
          align: 'left',
          margin: 10,
          offsetX: 0,
          offsetY: 30,
          floating: false,
          style: {
            fontSize: '12px',
            fontFamily: undefined,
            color: undefined
          }
        },
        stroke: {
          show: true,
          curve: 'smooth',
          // "smooth" / "straight" / "stepline"
          lineCap: 'butt',
          // round, butt , square
          width: 2,
          colors: undefined,
          // array of colors
          dashArray: 0 // single value or array of values

        },
        tooltip: {
          enabled: true,
          shared: true,
          followCursor: false,
          // when disabled, the tooltip will show on top of the series instead of mouse position
          intersect: false,
          // when enabled, tooltip will only show when user directly hovers over point
          inverseOrder: false,
          custom: undefined,
          fillSeriesColor: false,
          theme: 'light',
          style: {
            fontSize: '12px',
            fontFamily: undefined
          },
          onDatasetHover: {
            highlightDataSeries: false
          },
          x: {
            // x value
            show: true,
            format: 'dd MMM',
            // dd/MM, dd MMM yy, dd MMM yyyy
            formatter: undefined // a custom user supplied formatter function

          },
          y: {
            formatter: undefined,
            title: {
              formatter: function formatter(seriesName) {
                return seriesName;
              }
            }
          },
          z: {
            formatter: undefined,
            title: 'Size: '
          },
          marker: {
            show: true
          },
          items: {
            display: 'flex'
          },
          fixed: {
            enabled: false,
            position: 'topRight',
            // topRight, topLeft, bottomRight, bottomLeft
            offsetX: 0,
            offsetY: 0
          }
        },
        xaxis: {
          type: 'category',
          categories: [],
          offsetX: 0,
          offsetY: 0,
          labels: {
            show: true,
            rotate: -45,
            rotateAlways: false,
            hideOverlappingLabels: true,
            trim: true,
            minHeight: undefined,
            maxHeight: 120,
            showDuplicates: true,
            style: {
              colors: [],
              fontSize: '12px',
              fontFamily: undefined,
              cssClass: ''
            },
            offsetX: 0,
            offsetY: 0,
            format: undefined,
            formatter: undefined,
            // custom formatter function which will override format
            datetimeFormatter: {
              year: 'yyyy',
              month: "MMM 'yy",
              day: 'dd MMM',
              hour: 'HH:mm',
              minute: 'HH:mm:ss'
            }
          },
          axisBorder: {
            show: true,
            color: '#78909C',
            width: '100%',
            height: 1,
            offsetX: 0,
            offsetY: 0
          },
          axisTicks: {
            show: true,
            color: '#78909C',
            height: 6,
            offsetX: 0,
            offsetY: 0
          },
          tickAmount: undefined,
          tickPlacement: 'on',
          min: undefined,
          max: undefined,
          range: undefined,
          floating: false,
          position: 'bottom',
          title: {
            text: undefined,
            offsetX: 0,
            offsetY: 0,
            style: {
              color: undefined,
              fontSize: '12px',
              fontFamily: undefined,
              cssClass: ''
            }
          },
          crosshairs: {
            show: true,
            width: 1,
            // tickWidth/barWidth or an integer
            position: 'back',
            opacity: 0.9,
            stroke: {
              color: '#b6b6b6',
              width: 1,
              dashArray: 3
            },
            fill: {
              type: 'solid',
              // solid, gradient
              color: '#B1B9C4',
              gradient: {
                colorFrom: '#D8E3F0',
                colorTo: '#BED1E6',
                stops: [0, 100],
                opacityFrom: 0.4,
                opacityTo: 0.5
              }
            },
            dropShadow: {
              enabled: false,
              left: 0,
              top: 0,
              blur: 1,
              opacity: 0.4
            }
          },
          tooltip: {
            enabled: true,
            offsetY: 0,
            formatter: undefined,
            style: {
              fontSize: '12px',
              fontFamily: undefined
            }
          }
        },
        yaxis: this.yAxis,
        theme: {
          palette: 'palette1',
          // If defined, it will overwrite globals.colors variable
          monochrome: {
            // monochrome allows you to select just 1 color and fill out the rest with light/dark shade (intensity can be selected)
            enabled: false,
            color: '#008FFB',
            shadeTo: 'light',
            shadeIntensity: 0.65
          }
        }
      };
    }
  }]);

  return Options;
}();

/**
 * ApexCharts Annotations Class for drawing lines/rects on both xaxis and yaxis.
 *
 * @module Annotations
 **/

var Annotations =
/*#__PURE__*/
function () {
  function Annotations(ctx) {
    _classCallCheck(this, Annotations);

    this.ctx = ctx;
    this.w = ctx.w;
    this.graphics = new Graphics(this.ctx);

    if (this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.horizontal) {
      this.invertAxis = true;
    }

    this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }

  _createClass(Annotations, [{
    key: "drawAnnotations",
    value: function drawAnnotations() {
      var w = this.w;

      if (w.globals.axisCharts) {
        var yAnnotations = this.drawYAxisAnnotations();
        var xAnnotations = this.drawXAxisAnnotations();
        var pointAnnotations = this.drawPointAnnotations();
        var initialAnim = w.config.chart.animations.enabled;
        var annoArray = [yAnnotations, xAnnotations, pointAnnotations];
        var annoElArray = [xAnnotations.node, yAnnotations.node, pointAnnotations.node];

        for (var i = 0; i < 3; i++) {
          w.globals.dom.elGraphical.add(annoArray[i]);

          if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {
            annoElArray[i].classList.add('hidden');
          }

          w.globals.delayedElements.push({
            el: annoElArray[i],
            index: 0
          });
        } // after placing the annotations on svg, set any vertically placed annotations


        this.setOrientations(w.config.annotations.xaxis); // background sizes needs to be calculated after text is drawn, so calling them last

        this.annotationsBackground();
      }
    }
  }, {
    key: "addXaxisAnnotation",
    value: function addXaxisAnnotation(anno, parent, index) {
      var w = this.w;
      var min = this.invertAxis ? w.globals.minY : w.globals.minX;
      var range = this.invertAxis ? w.globals.yRange[0] : w.globals.xRange;
      var x1 = (anno.x - min) / (range / w.globals.gridWidth);

      if (w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) {
        var catIndex = w.globals.labels.indexOf(anno.x);
        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');

        if (xLabel) {
          x1 = parseFloat(xLabel.getAttribute('x'));
        }
      }

      var strokeDashArray = anno.strokeDashArray;
      if (x1 < 0 || x1 > w.globals.gridWidth) return;

      if (anno.x2 === null) {
        var line = this.graphics.drawLine(x1 + anno.offsetX, // x1
        0 + anno.offsetY, // y1
        x1 + anno.offsetX, // x2
        w.globals.gridHeight + anno.offsetY, // y2
        anno.borderColor, // lineColor
        strokeDashArray //dashArray
        );
        parent.appendChild(line.node);
      } else {
        var x2 = (anno.x2 - min) / (range / w.globals.gridWidth);

        if (x2 < x1) {
          var temp = x1;
          x1 = x2;
          x2 = temp;
        }

        var rect = this.graphics.drawRect(x1 + anno.offsetX, // x1
        0 + anno.offsetY, // y1
        x2 - x1, // x2
        w.globals.gridHeight + anno.offsetY, // y2
        0, // radius
        anno.fillColor, // color
        anno.opacity, // opacity,
        1, // strokeWidth
        anno.borderColor, // strokeColor
        strokeDashArray // stokeDashArray
        );
        parent.appendChild(rect.node);
      }

      var textY = anno.label.position === 'top' ? -3 : w.globals.gridHeight;
      var text = anno.label.text ? anno.label.text : '';
      var elText = this.graphics.drawText({
        x: x1 + anno.label.offsetX,
        y: textY + anno.label.offsetY,
        text: text,
        textAnchor: anno.label.textAnchor,
        fontSize: anno.label.style.fontSize,
        fontFamily: anno.label.style.fontFamily,
        foreColor: anno.label.style.color,
        cssClass: 'apexcharts-xaxis-annotation-label ' + anno.label.style.cssClass
      });
      elText.attr({
        rel: index
      });
      parent.appendChild(elText.node);
    }
  }, {
    key: "drawXAxisAnnotations",
    value: function drawXAxisAnnotations() {
      var _this = this;

      var w = this.w;
      var elg = this.graphics.group({
        class: 'apexcharts-xaxis-annotations'
      });
      w.config.annotations.xaxis.map(function (anno, index) {
        _this.addXaxisAnnotation(anno, elg.node, index);
      });
      return elg;
    }
  }, {
    key: "addYaxisAnnotation",
    value: function addYaxisAnnotation(anno, parent, index) {
      var w = this.w;
      var strokeDashArray = anno.strokeDashArray;
      var y1;
      var y2;

      if (this.invertAxis) {
        var catIndex = w.globals.labels.indexOf(anno.y);
        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-yaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');

        if (xLabel) {
          y1 = parseFloat(xLabel.getAttribute('y'));
        }
      } else {
        y1 = w.globals.gridHeight - (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);

        if (w.config.yaxis[anno.yAxisIndex].reversed) {
          y1 = (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);
        }
      }

      var text = anno.label.text ? anno.label.text : '';

      if (anno.y2 === null) {
        var line = this.graphics.drawLine(0 + anno.offsetX, // x1
        y1 + anno.offsetY, // y1
        w.globals.gridWidth + anno.offsetX, // x2
        y1 + anno.offsetY, // y2
        anno.borderColor, // lineColor
        strokeDashArray // dashArray
        );
        parent.appendChild(line.node);
      } else {
        if (this.invertAxis) {
          var _catIndex = w.globals.labels.indexOf(anno.y2);

          var _xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-yaxis-texts-g text:nth-child(' + (_catIndex + 1) + ')');

          if (_xLabel) {
            y2 = parseFloat(_xLabel.getAttribute('y'));
          }
        } else {
          y2 = w.globals.gridHeight - (anno.y2 - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);

          if (w.config.yaxis[anno.yAxisIndex].reversed) {
            y2 = (anno.y2 - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);
          }
        }

        if (y2 > y1) {
          var temp = y1;
          y1 = y2;
          y2 = temp;
        }

        var rect = this.graphics.drawRect(0 + anno.offsetX, // x1
        y2 + anno.offsetY, // y1
        w.globals.gridWidth + anno.offsetX, // x2
        y1 - y2, // y2
        0, // radius
        anno.fillColor, // color
        anno.opacity, // opacity,
        1, // strokeWidth
        anno.borderColor, // strokeColor
        strokeDashArray // stokeDashArray
        );
        parent.appendChild(rect.node);
      }

      var textX = anno.label.position === 'right' ? w.globals.gridWidth : 0;
      var elText = this.graphics.drawText({
        x: textX + anno.label.offsetX,
        y: (y2 || y1) + anno.label.offsetY - 3,
        text: text,
        textAnchor: anno.label.textAnchor,
        fontSize: anno.label.style.fontSize,
        fontFamily: anno.label.style.fontFamily,
        foreColor: anno.label.style.color,
        cssClass: 'apexcharts-yaxis-annotation-label ' + anno.label.style.cssClass
      });
      elText.attr({
        rel: index
      });
      parent.appendChild(elText.node);
    }
  }, {
    key: "drawYAxisAnnotations",
    value: function drawYAxisAnnotations() {
      var _this2 = this;

      var w = this.w;
      var elg = this.graphics.group({
        class: 'apexcharts-yaxis-annotations'
      });
      w.config.annotations.yaxis.map(function (anno, index) {
        _this2.addYaxisAnnotation(anno, elg.node, index);
      });
      return elg;
    }
  }, {
    key: "clearAnnotations",
    value: function clearAnnotations(ctx) {
      var w = ctx.w;
      var annos = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations');
      annos.forEach(function (a) {
        while (a.firstChild) {
          a.removeChild(a.firstChild);
        }
      });
    }
  }, {
    key: "addPointAnnotation",
    value: function addPointAnnotation(anno, parent, index) {
      var w = this.w;
      var x = 0;
      var y = 0;
      var pointY = 0;

      if (this.invertAxis) {
        console.warn('Point annotation is not supported in horizontal bar charts.');
      }

      if (typeof anno.x === 'string') {
        var catIndex = w.globals.labels.indexOf(anno.x);
        var xLabel = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g text:nth-child(' + (catIndex + 1) + ')');
        var xPos = parseFloat(xLabel.getAttribute('x'));
        x = xPos;
        var annoY = anno.y;

        if (anno.y === null) {
          annoY = w.globals.series[anno.seriesIndex][catIndex];
        }

        y = w.globals.gridHeight - (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;
        pointY = w.globals.gridHeight - (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);

        if (w.config.yaxis[anno.yAxisIndex].reversed) {
          y = (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) + parseInt(anno.label.style.fontSize) + anno.marker.size;
          pointY = (annoY - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);
        }
      } else {
        x = (anno.x - w.globals.minX) / (w.globals.xRange / w.globals.gridWidth);
        y = w.globals.gridHeight - (parseFloat(anno.y) - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;
        pointY = w.globals.gridHeight - (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);

        if (w.config.yaxis[anno.yAxisIndex].reversed) {
          y = (parseFloat(anno.y) - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight) - parseInt(anno.label.style.fontSize) - anno.marker.size;
          pointY = (anno.y - w.globals.minYArr[anno.yAxisIndex]) / (w.globals.yRange[anno.yAxisIndex] / w.globals.gridHeight);
        }
      }

      if (x < 0 || x > w.globals.gridWidth) return;
      var optsPoints = {
        pSize: anno.marker.size,
        pWidth: anno.marker.strokeWidth,
        pointFillColor: anno.marker.fillColor,
        pointStrokeColor: anno.marker.strokeColor,
        shape: anno.marker.shape,
        radius: anno.marker.radius,
        class: 'apexcharts-point-annotation-marker ' + anno.marker.cssClass
      };
      var point = this.graphics.drawMarker(x + anno.marker.offsetX, pointY + anno.marker.offsetY, optsPoints);
      parent.appendChild(point.node);
      var text = anno.label.text ? anno.label.text : '';
      var elText = this.graphics.drawText({
        x: x + anno.label.offsetX,
        y: y + anno.label.offsetY,
        text: text,
        textAnchor: anno.label.textAnchor,
        fontSize: anno.label.style.fontSize,
        fontFamily: anno.label.style.fontFamily,
        foreColor: anno.label.style.color,
        cssClass: 'apexcharts-point-annotation-label ' + anno.label.style.cssClass
      });
      elText.attr({
        rel: index
      });
      parent.appendChild(elText.node);

      if (anno.customSVG.SVG) {
        var g = this.graphics.group({
          class: 'apexcharts-point-annotations-custom-svg ' + anno.customSVG.cssClass
        });
        g.attr({
          transform: "translate(".concat(x + anno.customSVG.offsetX, ", ").concat(y + anno.customSVG.offsetY, ")")
        });
        g.node.innerHTML = anno.customSVG.SVG;
        parent.appendChild(g.node);
      }
    }
  }, {
    key: "drawPointAnnotations",
    value: function drawPointAnnotations() {
      var _this3 = this;

      var w = this.w;
      var elg = this.graphics.group({
        class: 'apexcharts-point-annotations'
      });
      w.config.annotations.points.map(function (anno, index) {
        _this3.addPointAnnotation(anno, elg.node, index);
      });
      return elg;
    }
  }, {
    key: "setOrientations",
    value: function setOrientations(annos) {
      var _this4 = this;

      var annoIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var w = this.w;
      annos.map(function (anno, index) {
        if (anno.label.orientation === 'vertical') {
          var i = annoIndex !== null ? annoIndex : index;
          var xAnno = w.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(i, "']"));

          if (xAnno !== null) {
            var xAnnoCoord = xAnno.getBoundingClientRect();
            xAnno.setAttribute('x', parseFloat(xAnno.getAttribute('x')) - xAnnoCoord.height + 4);

            if (anno.label.position === 'top') {
              xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) + xAnnoCoord.width);
            } else {
              xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) - xAnnoCoord.width);
            }

            var annoRotatingCenter = _this4.graphics.rotateAroundCenter(xAnno);

            var x = annoRotatingCenter.x;
            var y = annoRotatingCenter.y;
            xAnno.setAttribute('transform', "rotate(-90 ".concat(x, " ").concat(y, ")"));
          }
        }
      });
    }
  }, {
    key: "addBackgroundToAnno",
    value: function addBackgroundToAnno(annoEl, anno) {
      var w = this.w;
      var elGridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid').getBoundingClientRect();
      var coords = annoEl.getBoundingClientRect();
      var pleft = anno.label.style.padding.left;
      var pright = anno.label.style.padding.right;
      var ptop = anno.label.style.padding.top;
      var pbottom = anno.label.style.padding.bottom;

      if (anno.label.orientation === 'vertical') {
        ptop = anno.label.style.padding.left;
        pbottom = anno.label.style.padding.right;
        pleft = anno.label.style.padding.top;
        pright = anno.label.style.padding.bottom;
      }

      var x1 = coords.left - elGridRect.left - pleft;
      var y1 = coords.top - elGridRect.top - ptop;
      var elRect = this.graphics.drawRect(x1, y1, coords.width + pleft + pright, coords.height + ptop + pbottom, 0, anno.label.style.background, 1, anno.label.borderWidth, anno.label.borderColor, 0);
      return elRect;
    }
  }, {
    key: "annotationsBackground",
    value: function annotationsBackground() {
      var _this5 = this;

      var w = this.w;

      var add = function add(anno, i, type) {
        var annoLabel = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-annotations .apexcharts-").concat(type, "-annotation-label[rel='").concat(i, "']"));

        if (annoLabel) {
          var parent = annoLabel.parentNode;

          var elRect = _this5.addBackgroundToAnno(annoLabel, anno);

          parent.insertBefore(elRect.node, annoLabel);
        }
      };

      w.config.annotations.xaxis.map(function (anno, i) {
        add(anno, i, 'xaxis');
      });
      w.config.annotations.yaxis.map(function (anno, i) {
        add(anno, i, 'yaxis');
      });
      w.config.annotations.points.map(function (anno, i) {
        add(anno, i, 'point');
      });
    }
  }, {
    key: "addText",
    value: function addText(params, pushToMemory, context) {
      var x = params.x,
          y = params.y,
          text = params.text,
          textAnchor = params.textAnchor,
          _params$appendTo = params.appendTo,
          appendTo = _params$appendTo === void 0 ? '.apexcharts-inner' : _params$appendTo,
          foreColor = params.foreColor,
          fontSize = params.fontSize,
          fontFamily = params.fontFamily,
          cssClass = params.cssClass,
          backgroundColor = params.backgroundColor,
          borderWidth = params.borderWidth,
          strokeDashArray = params.strokeDashArray,
          radius = params.radius,
          borderColor = params.borderColor,
          _params$paddingLeft = params.paddingLeft,
          paddingLeft = _params$paddingLeft === void 0 ? 4 : _params$paddingLeft,
          _params$paddingRight = params.paddingRight,
          paddingRight = _params$paddingRight === void 0 ? 4 : _params$paddingRight,
          _params$paddingBottom = params.paddingBottom,
          paddingBottom = _params$paddingBottom === void 0 ? 2 : _params$paddingBottom,
          _params$paddingTop = params.paddingTop,
          paddingTop = _params$paddingTop === void 0 ? 2 : _params$paddingTop;
      var me = context;
      var w = me.w;
      var parentNode = w.globals.dom.baseEl.querySelector(appendTo);
      var elText = this.graphics.drawText({
        x: x,
        y: y,
        text: text,
        textAnchor: textAnchor || 'start',
        fontSize: fontSize || '12px',
        fontFamily: fontFamily || w.config.chart.fontFamily,
        foreColor: foreColor || w.config.chart.foreColor,
        cssClass:  true ? cssClass : undefined
      });
      parentNode.appendChild(elText.node);
      var textRect = elText.bbox();
      var elRect = this.graphics.drawRect(textRect.x - paddingLeft, textRect.y - paddingTop, textRect.width + paddingLeft + paddingRight, textRect.height + paddingBottom + paddingTop, radius, backgroundColor, 1, borderWidth, borderColor, strokeDashArray);
      elText.before(elRect);

      if (pushToMemory) {
        w.globals.memory.methodsToExec.push({
          context: me,
          method: me.addText,
          params: {
            x: x,
            y: y,
            text: text,
            textAnchor: textAnchor,
            appendTo: appendTo,
            foreColor: foreColor,
            fontSize: fontSize,
            cssClass: cssClass,
            backgroundColor: backgroundColor,
            borderWidth: borderWidth,
            strokeDashArray: strokeDashArray,
            radius: radius,
            borderColor: borderColor,
            paddingLeft: paddingLeft,
            paddingRight: paddingRight,
            paddingBottom: paddingBottom,
            paddingTop: paddingTop
          }
        });
      }

      return context;
    }
  }, {
    key: "addPointAnnotationExternal",
    value: function addPointAnnotationExternal(params, pushToMemory, context) {
      this.addAnnotationExternal({
        params: params,
        pushToMemory: pushToMemory,
        context: context,
        type: 'point',
        contextMethod: context.addPointAnnotation
      });
      return context;
    }
  }, {
    key: "addYaxisAnnotationExternal",
    value: function addYaxisAnnotationExternal(params, pushToMemory, context) {
      this.addAnnotationExternal({
        params: params,
        pushToMemory: pushToMemory,
        context: context,
        type: 'yaxis',
        contextMethod: context.addYaxisAnnotation
      });
      return context;
    } // The addXaxisAnnotation method requires a parent class, and user calling this method externally on the chart instance may not specify parent, hence a different method

  }, {
    key: "addXaxisAnnotationExternal",
    value: function addXaxisAnnotationExternal(params, pushToMemory, context) {
      this.addAnnotationExternal({
        params: params,
        pushToMemory: pushToMemory,
        context: context,
        type: 'xaxis',
        contextMethod: context.addXaxisAnnotation
      });
      return context;
    }
  }, {
    key: "addAnnotationExternal",
    value: function addAnnotationExternal(_ref) {
      var params = _ref.params,
          pushToMemory = _ref.pushToMemory,
          context = _ref.context,
          type = _ref.type,
          contextMethod = _ref.contextMethod;
      var me = context;
      var w = me.w;
      var parent = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-annotations"));
      var index = parent.childNodes.length + 1;
      var opt = new Options();
      var axesAnno = Object.assign({}, type === 'xaxis' ? opt.xAxisAnnotation : type === 'yaxis' ? opt.yAxisAnnotation : opt.pointAnnotation);
      var anno = Utils.extend(axesAnno, params);

      switch (type) {
        case 'xaxis':
          this.addXaxisAnnotation(anno, parent, index);
          break;

        case 'yaxis':
          this.addYaxisAnnotation(anno, parent, index);
          break;

        case 'point':
          this.addPointAnnotation(anno, parent, index);
          break;
      } // add background


      var axesAnnoLabel = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-annotations .apexcharts-").concat(type, "-annotation-label[rel='").concat(index, "']"));
      var elRect = this.addBackgroundToAnno(axesAnnoLabel, anno);
      parent.insertBefore(elRect.node, axesAnnoLabel);

      if (pushToMemory) {
        w.globals.memory.methodsToExec.push({
          context: me,
          method: contextMethod,
          params: params
        });
      }

      return context;
    }
  }]);

  return Annotations;
}();

/**
 * ApexCharts Default Class for setting default options for all chart types.
 *
 * @module Defaults
 **/

var Defaults =
/*#__PURE__*/
function () {
  function Defaults(opts) {
    _classCallCheck(this, Defaults);

    this.opts = opts;
  }

  _createClass(Defaults, [{
    key: "line",
    value: function line() {
      return {
        chart: {
          animations: {
            easing: 'swing'
          }
        },
        dataLabels: {
          enabled: false
        },
        stroke: {
          width: 5,
          curve: 'straight'
        },
        markers: {
          size: 0,
          hover: {
            sizeOffset: 6
          }
        },
        xaxis: {
          crosshairs: {
            width: 1
          }
        }
      };
    }
  }, {
    key: "sparkline",
    value: function sparkline(defaults) {
      this.opts.yaxis[0].labels.show = false;
      this.opts.yaxis[0].floating = true;
      var ret = {
        grid: {
          show: false,
          padding: {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }
        },
        legend: {
          show: false
        },
        xaxis: {
          labels: {
            show: false
          },
          tooltip: {
            enabled: false
          },
          axisBorder: {
            show: false
          }
        },
        chart: {
          toolbar: {
            show: false
          },
          zoom: {
            enabled: false
          }
        },
        dataLabels: {
          enabled: false
        }
      };
      return Utils.extend(defaults, ret);
    }
  }, {
    key: "bar",
    value: function bar() {
      return {
        chart: {
          stacked: false,
          animations: {
            easing: 'swing'
          }
        },
        plotOptions: {
          bar: {
            dataLabels: {
              position: 'center'
            }
          }
        },
        dataLabels: {
          style: {
            colors: ['#fff']
          }
        },
        stroke: {
          width: 0
        },
        fill: {
          opacity: 0.85
        },
        legend: {
          markers: {
            shape: 'square',
            radius: 2,
            size: 8
          }
        },
        tooltip: {
          shared: false
        },
        xaxis: {
          tooltip: {
            enabled: false
          },
          crosshairs: {
            width: 'barWidth',
            position: 'back',
            fill: {
              type: 'gradient'
            },
            dropShadow: {
              enabled: false
            },
            stroke: {
              width: 0
            }
          }
        }
      };
    }
  }, {
    key: "candlestick",
    value: function candlestick() {
      return {
        stroke: {
          width: 1,
          colors: ['#333']
        },
        dataLabels: {
          enabled: false
        },
        tooltip: {
          shared: true,
          custom: function custom(_ref) {
            var seriesIndex = _ref.seriesIndex,
                dataPointIndex = _ref.dataPointIndex,
                w = _ref.w;
            var o = w.globals.seriesCandleO[seriesIndex][dataPointIndex];
            var h = w.globals.seriesCandleH[seriesIndex][dataPointIndex];
            var l = w.globals.seriesCandleL[seriesIndex][dataPointIndex];
            var c = w.globals.seriesCandleC[seriesIndex][dataPointIndex];
            return '<div class="apexcharts-tooltip-candlestick">' + '<div>Open: <span class="value">' + o + '</span></div>' + '<div>High: <span class="value">' + h + '</span></div>' + '<div>Low: <span class="value">' + l + '</span></div>' + '<div>Close: <span class="value">' + c + '</span></div>' + '</div>';
          }
        },
        states: {
          active: {
            filter: {
              type: 'none'
            }
          }
        },
        xaxis: {
          crosshairs: {
            width: 1
          }
        }
      };
    }
  }, {
    key: "area",
    value: function area() {
      return {
        stroke: {
          width: 4
        },
        fill: {
          type: 'gradient',
          gradient: {
            inverseColors: false,
            shade: 'light',
            type: 'vertical',
            opacityFrom: 0.65,
            opacityTo: 0.5,
            stops: [0, 100, 100]
          }
        },
        markers: {
          size: 0,
          hover: {
            sizeOffset: 6
          }
        },
        tooltip: {
          followCursor: false
        }
      };
    }
  }, {
    key: "brush",
    value: function brush(defaults) {
      var ret = {
        chart: {
          toolbar: {
            autoSelected: 'selection',
            show: false
          },
          zoom: {
            enabled: false
          }
        },
        dataLabels: {
          enabled: false
        },
        stroke: {
          width: 1
        },
        tooltip: {
          enabled: false
        },
        xaxis: {
          tooltip: {
            enabled: false
          }
        }
      };
      return Utils.extend(defaults, ret);
    }
  }, {
    key: "stacked100",
    value: function stacked100() {
      var _this = this;

      this.opts.dataLabels = this.opts.dataLabels || {};
      this.opts.dataLabels.formatter = this.opts.dataLabels.formatter || undefined;
      var existingDataLabelFormatter = this.opts.dataLabels.formatter;
      this.opts.yaxis.forEach(function (yaxe, index) {
        _this.opts.yaxis[index].min = 0;
        _this.opts.yaxis[index].max = 100;
      });
      var isBar = this.opts.chart.type === 'bar';

      if (isBar) {
        this.opts.dataLabels.formatter = existingDataLabelFormatter || function (val) {
          if (typeof val === 'number') {
            return val ? val.toFixed(0) + '%' : val;
          }

          return val;
        };
      }
    } // This function removes the left and right spacing in chart for line/area/scatter if xaxis type = category for those charts by converting xaxis = numeric. Numeric/Datetime xaxis prevents the unnecessary spacing in the left/right of the chart area

  }, {
    key: "bubble",
    value: function bubble() {
      return {
        dataLabels: {
          style: {
            colors: ['#fff']
          }
        },
        tooltip: {
          shared: false,
          intersect: true
        },
        xaxis: {
          crosshairs: {
            width: 0
          }
        },
        fill: {
          type: 'solid',
          gradient: {
            shade: 'light',
            inverse: true,
            shadeIntensity: 0.55,
            opacityFrom: 0.4,
            opacityTo: 0.8
          }
        }
      };
    }
  }, {
    key: "scatter",
    value: function scatter() {
      return {
        dataLabels: {
          enabled: false
        },
        tooltip: {
          shared: false,
          intersect: true
        },
        markers: {
          size: 6,
          strokeWidth: 2,
          hover: {
            sizeOffset: 2
          }
        }
      };
    }
  }, {
    key: "heatmap",
    value: function heatmap() {
      return {
        chart: {
          stacked: false,
          zoom: {
            enabled: false
          }
        },
        fill: {
          opacity: 1
        },
        dataLabels: {
          style: {
            colors: ['#fff']
          }
        },
        stroke: {
          colors: ['#fff']
        },
        tooltip: {
          followCursor: true,
          marker: {
            show: false
          },
          x: {
            show: false
          }
        },
        legend: {
          position: 'top',
          markers: {
            shape: 'square',
            size: 10,
            offsetY: 2
          }
        },
        grid: {
          padding: {
            right: 20
          }
        }
      };
    }
  }, {
    key: "pie",
    value: function pie() {
      return {
        chart: {
          toolbar: {
            show: false
          }
        },
        plotOptions: {
          pie: {
            donut: {
              labels: {
                show: false
              }
            }
          }
        },
        dataLabels: {
          formatter: function formatter(val) {
            return val.toFixed(1) + '%';
          },
          style: {
            colors: ['#fff']
          },
          dropShadow: {
            enabled: true
          }
        },
        stroke: {
          colors: ['#fff']
        },
        fill: {
          opacity: 1,
          gradient: {
            shade: 'dark',
            shadeIntensity: 0.35,
            inverseColors: false,
            stops: [0, 100, 100]
          }
        },
        padding: {
          right: 0,
          left: 0
        },
        tooltip: {
          theme: 'dark',
          fillSeriesColor: true
        },
        legend: {
          position: 'right'
        }
      };
    }
  }, {
    key: "donut",
    value: function donut() {
      return {
        chart: {
          toolbar: {
            show: false
          }
        },
        dataLabels: {
          formatter: function formatter(val) {
            return val.toFixed(1) + '%';
          },
          style: {
            colors: ['#fff']
          },
          dropShadow: {
            enabled: true
          }
        },
        stroke: {
          colors: ['#fff']
        },
        fill: {
          opacity: 1,
          gradient: {
            shade: 'dark',
            shadeIntensity: 0.4,
            inverseColors: false,
            type: 'vertical',
            opacityFrom: 1,
            opacityTo: 1,
            stops: [70, 98, 100]
          }
        },
        padding: {
          right: 0,
          left: 0
        },
        tooltip: {
          theme: 'dark',
          fillSeriesColor: true
        },
        legend: {
          position: 'right'
        }
      };
    }
  }, {
    key: "radar",
    value: function radar() {
      this.opts.yaxis[0].labels.style.fontSize = '13px';
      this.opts.yaxis[0].labels.offsetY = 6;
      return {
        dataLabels: {
          enabled: true,
          style: {
            colors: ['#a8a8a8'],
            fontSize: '11px'
          }
        },
        stroke: {
          width: 2
        },
        markers: {
          size: 3,
          strokeWidth: 1,
          strokeOpacity: 1
        },
        fill: {
          opacity: 0.2
        },
        tooltip: {
          shared: false,
          intersect: true,
          followCursor: true
        },
        grid: {
          show: false
        },
        xaxis: {
          tooltip: {
            enabled: false
          },
          crosshairs: {
            show: false
          }
        }
      };
    }
  }, {
    key: "radialBar",
    value: function radialBar() {
      return {
        chart: {
          animations: {
            dynamicAnimation: {
              enabled: true,
              speed: 800
            }
          },
          toolbar: {
            show: false
          }
        },
        fill: {
          gradient: {
            shade: 'dark',
            shadeIntensity: 0.4,
            inverseColors: false,
            type: 'diagonal2',
            opacityFrom: 1,
            opacityTo: 1,
            stops: [70, 98, 100]
          }
        },
        padding: {
          right: 0,
          left: 0
        },
        legend: {
          show: false,
          position: 'right'
        },
        tooltip: {
          enabled: false,
          fillSeriesColor: true
        }
      };
    }
  }], [{
    key: "convertCatToNumeric",
    value: function convertCatToNumeric(opts) {
      opts.xaxis.type = 'numeric';
      opts.xaxis.convertedCatToNumeric = true;
      opts.xaxis.labels = opts.xaxis.labels || {};

      opts.xaxis.labels.formatter = opts.xaxis.labels.formatter || function (val) {
        return val;
      };

      opts.chart = opts.chart || {};
      opts.chart.zoom = opts.chart.zoom || window.Apex.chart && window.Apex.chart.zoom || {};
      var defaultFormatter = opts.xaxis.labels.formatter;
      var labels = opts.xaxis.categories && opts.xaxis.categories.length ? opts.xaxis.categories : opts.labels;

      if (labels && labels.length) {
        opts.xaxis.labels.formatter = function (val) {
          return defaultFormatter(labels[val - 1]);
        };
      }

      opts.xaxis.categories = [];
      opts.labels = [];
      opts.chart.zoom.enabled = false;
      return opts;
    }
  }]);

  return Defaults;
}();

/*
 ** Util functions which are dependent on ApexCharts instance
 */
var CoreUtils =
/*#__PURE__*/
function () {
  function CoreUtils(ctx) {
    _classCallCheck(this, CoreUtils);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(CoreUtils, [{
    key: "getStackedSeriesTotals",

    /**
     * @memberof CoreUtils
     * returns the sum of all individual values in a multiple stacked series
     * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]
     *  @return [34,36,48,13]
     **/
    value: function getStackedSeriesTotals() {
      var w = this.w;
      var total = [];

      for (var i = 0; i < w.globals.series[w.globals.maxValsInArrayIndex].length; i++) {
        var t = 0;

        for (var j = 0; j < w.globals.series.length; j++) {
          t += w.globals.series[j][i];
        }

        total.push(t);
      }

      w.globals.stackedSeriesTotals = total;
      return total;
    } // get total of the all values inside all series

  }, {
    key: "getSeriesTotalByIndex",
    value: function getSeriesTotalByIndex() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (index === null) {
        // non-plot chart types - pie / donut / circle
        return this.w.config.series.reduce(function (acc, cur) {
          return acc + cur;
        }, 0);
      } else {
        // axis charts - supporting multiple series
        return this.w.globals.series[index].reduce(function (acc, cur) {
          return acc + cur;
        }, 0);
      }
    }
  }, {
    key: "isSeriesNull",
    value: function isSeriesNull() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var r = [];

      if (index === null) {
        // non-plot chart types - pie / donut / circle
        r = this.w.config.series.filter(function (d) {
          return d !== null;
        });
      } else {
        // axis charts - supporting multiple series
        r = this.w.globals.series[index].filter(function (d) {
          return d !== null;
        });
      }

      return r.length === 0;
    }
  }, {
    key: "seriesHaveSameValues",
    value: function seriesHaveSameValues(index) {
      return this.w.globals.series[index].every(function (val, i, arr) {
        return val === arr[0];
      });
    } // maxValsInArrayIndex is the index of series[] which has the largest number of items

  }, {
    key: "getLargestSeries",
    value: function getLargestSeries() {
      var w = this.w;
      w.globals.maxValsInArrayIndex = w.globals.series.map(function (a) {
        return a.length;
      }).indexOf(Math.max.apply(Math, w.globals.series.map(function (a) {
        return a.length;
      })));
    }
  }, {
    key: "getLargestMarkerSize",
    value: function getLargestMarkerSize() {
      var w = this.w;
      var size = 0;
      w.globals.markers.size.forEach(function (m) {
        size = Math.max(size, m);
      });
      w.globals.markers.largestSize = size;
      return size;
    }
    /**
     * @memberof Core
     * returns the sum of all values in a series
     * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]
     *  @return [120, 11]
     **/

  }, {
    key: "getSeriesTotals",
    value: function getSeriesTotals() {
      var w = this.w;
      w.globals.seriesTotals = w.globals.series.map(function (ser, index) {
        var total = 0;

        if (Array.isArray(ser)) {
          for (var j = 0; j < ser.length; j++) {
            total += ser[j];
          }
        } else {
          // for pie/donuts/gauges
          total += ser;
        }

        return total;
      });
    }
  }, {
    key: "getSeriesTotalsXRange",
    value: function getSeriesTotalsXRange(minX, maxX) {
      var w = this.w;
      var seriesTotalsXRange = w.globals.series.map(function (ser, index) {
        var total = 0;

        for (var j = 0; j < ser.length; j++) {
          if (w.globals.seriesX[index][j] > minX && w.globals.seriesX[index][j] < maxX) {
            total += ser[j];
          }
        }

        return total;
      });
      return seriesTotalsXRange;
    }
    /**
     * @memberof CoreUtils
     * returns the percentage value of all individual values which can be used in a 100% stacked series
     * Eg. w.globals.series = [[32, 33, 43, 12], [2, 3, 5, 1]]
     *  @return [[94.11, 91.66, 89.58, 92.30], [5.88, 8.33, 10.41, 7.7]]
     **/

  }, {
    key: "getPercentSeries",
    value: function getPercentSeries() {
      var w = this.w;
      w.globals.seriesPercent = w.globals.series.map(function (ser, index) {
        var seriesPercent = [];

        if (Array.isArray(ser)) {
          for (var j = 0; j < ser.length; j++) {
            var total = w.globals.stackedSeriesTotals[j];
            var percent = 100 * ser[j] / total;
            seriesPercent.push(percent);
          }
        } else {
          var _total = w.globals.seriesTotals.reduce(function (acc, val) {
            return acc + val;
          }, 0);

          var _percent = 100 * ser / _total;

          seriesPercent.push(_percent);
        }

        return seriesPercent;
      });
    }
  }, {
    key: "getCalculatedRatios",
    value: function getCalculatedRatios() {
      var gl = this.w.globals;
      var yRatio = [];
      var invertedYRatio = 0;
      var xRatio = 0;
      var initialXRatio = 0;
      var invertedXRatio = 0;
      var zRatio = 0;
      var baseLineY = [];
      var baseLineInvertedY = 0.1;
      var baseLineX = 0;
      gl.yRange = [];

      if (gl.isMultipleYAxis) {
        for (var i = 0; i < gl.minYArr.length; i++) {
          gl.yRange.push(Math.abs(gl.minYArr[i] - gl.maxYArr[i]));
          baseLineY.push(0);
        }
      } else {
        gl.yRange.push(Math.abs(gl.minY - gl.maxY));
      }

      gl.xRange = Math.abs(gl.maxX - gl.minX);
      gl.zRange = Math.abs(gl.maxZ - gl.minZ); // multiple y axis

      for (var _i = 0; _i < gl.yRange.length; _i++) {
        yRatio.push(gl.yRange[_i] / gl.gridHeight);
      }

      xRatio = gl.xRange / gl.gridWidth;
      initialXRatio = Math.abs(gl.initialmaxX - gl.initialminX) / gl.gridWidth;
      invertedYRatio = gl.yRange / gl.gridWidth;
      invertedXRatio = gl.xRange / gl.gridHeight;
      zRatio = gl.zRange / gl.gridHeight * 16;

      if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {
        // Negative numbers present in series
        gl.hasNegs = true;
      }

      if (gl.isMultipleYAxis) {
        baseLineY = []; // baseline variables is the 0 of the yaxis which will be needed when there are negatives

        for (var _i2 = 0; _i2 < yRatio.length; _i2++) {
          baseLineY.push(-gl.minYArr[_i2] / yRatio[_i2]);
        }
      } else {
        baseLineY.push(-gl.minY / yRatio[0]);

        if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {
          baseLineInvertedY = -gl.minY / invertedYRatio; // this is for bar chart

          baseLineX = gl.minX / xRatio;
        }
      }

      return {
        yRatio: yRatio,
        invertedYRatio: invertedYRatio,
        zRatio: zRatio,
        xRatio: xRatio,
        initialXRatio: initialXRatio,
        invertedXRatio: invertedXRatio,
        baseLineInvertedY: baseLineInvertedY,
        baseLineY: baseLineY,
        baseLineX: baseLineX
      };
    }
  }, {
    key: "getLogSeries",
    value: function getLogSeries(series) {
      var w = this.w;
      w.globals.seriesLog = series.map(function (s, i) {
        if (w.config.yaxis[i] && w.config.yaxis[i].logarithmic) {
          return s.map(function (d) {
            if (d === null) return null;
            var logVal = (Math.log(d) - Math.log(w.globals.minYArr[i])) / (Math.log(w.globals.maxYArr[i]) - Math.log(w.globals.minYArr[i]));
            return logVal;
          });
        } else {
          return s;
        }
      });
      return w.globals.seriesLog;
    }
  }, {
    key: "getLogYRatios",
    value: function getLogYRatios(yRatio) {
      var _this = this;

      var w = this.w;
      var gl = this.w.globals;
      gl.yLogRatio = yRatio.slice();
      gl.logYRange = gl.yRange.map(function (yRange, i) {
        if (w.config.yaxis[i] && _this.w.config.yaxis[i].logarithmic) {
          var maxY = -Number.MAX_VALUE;
          var minY = Number.MIN_VALUE;
          var range = 1;
          gl.seriesLog.forEach(function (s, si) {
            s.forEach(function (v) {
              if (w.config.yaxis[si] && w.config.yaxis[si].logarithmic) {
                maxY = Math.max(v, maxY);
                minY = Math.min(v, minY);
              }
            });
          });
          range = Math.pow(gl.yRange[i], Math.abs(minY - maxY) / gl.yRange[i]);
          gl.yLogRatio[i] = range / gl.gridHeight;
          return range;
        }
      });
      return gl.yLogRatio;
    } // Some config objects can be array - and we need to extend them correctly

  }], [{
    key: "checkComboSeries",
    value: function checkComboSeries(series) {
      var comboCharts = false;
      var comboChartsHasBars = false; // if user specified a type in series too, turn on comboCharts flag

      if (series.length && typeof series[0].type !== 'undefined') {
        comboCharts = true;
        series.forEach(function (s) {
          if (s.type === 'bar' || s.type === 'column') {
            comboChartsHasBars = true;
          }
        });
      }

      return {
        comboCharts: comboCharts,
        comboChartsHasBars: comboChartsHasBars
      };
    }
  }, {
    key: "extendArrayProps",
    value: function extendArrayProps(configInstance, options) {
      if (options.yaxis) {
        options = configInstance.extendYAxis(options);
      }

      if (options.annotations) {
        if (options.annotations.yaxis) {
          options = configInstance.extendYAxisAnnotations(options);
        }

        if (options.annotations.xaxis) {
          options = configInstance.extendXAxisAnnotations(options);
        }

        if (options.annotations.points) {
          options = configInstance.extendPointAnnotations(options);
        }
      }

      return options;
    }
  }]);

  return CoreUtils;
}();

/**
 * ApexCharts Config Class for extending user options with pre-defined ApexCharts config.
 *
 * @module Config
 **/

var Config =
/*#__PURE__*/
function () {
  function Config(opts) {
    _classCallCheck(this, Config);

    this.opts = opts;
  }

  _createClass(Config, [{
    key: "init",
    value: function init() {
      var opts = this.opts;
      var options = new Options();
      var defaults = new Defaults(opts);
      this.chartType = opts.chart.type;

      if (this.chartType === 'histogram') {
        // technically, a histogram can be drawn by a column chart with no spaces in between
        opts.chart.type = 'bar';
        opts = Utils.extend({
          plotOptions: {
            bar: {
              columnWidth: '99.99%'
            }
          }
        }, opts);
      }

      opts.series = this.checkEmptySeries(opts.series);
      opts = this.extendYAxis(opts);
      opts = this.extendAnnotations(opts);
      var config = options.init();
      var newDefaults = {};

      if (opts && _typeof(opts) === 'object') {
        var chartDefaults = {};

        switch (this.chartType) {
          case 'line':
            chartDefaults = defaults.line();
            break;

          case 'area':
            chartDefaults = defaults.area();
            break;

          case 'bar':
            chartDefaults = defaults.bar();
            break;

          case 'candlestick':
            chartDefaults = defaults.candlestick();
            break;

          case 'histogram':
            chartDefaults = defaults.bar();
            break;

          case 'bubble':
            chartDefaults = defaults.bubble();
            break;

          case 'scatter':
            chartDefaults = defaults.scatter();
            break;

          case 'heatmap':
            chartDefaults = defaults.heatmap();
            break;

          case 'pie':
            chartDefaults = defaults.pie();
            break;

          case 'donut':
            chartDefaults = defaults.donut();
            break;

          case 'radar':
            chartDefaults = defaults.radar();
            break;

          case 'radialBar':
            chartDefaults = defaults.radialBar();
            break;

          default:
            chartDefaults = defaults.line();
        }

        if (opts.chart.brush && opts.chart.brush.enabled) {
          chartDefaults = defaults.brush(chartDefaults);
        }

        if (opts.chart.stacked && opts.chart.stackType === '100%') {
          defaults.stacked100();
        }

        opts.xaxis = opts.xaxis || window.Apex.xaxis || {};
        var combo = CoreUtils.checkComboSeries(opts.series);

        if ((opts.chart.type === 'line' || opts.chart.type === 'area' || opts.chart.type === 'scatter') && !combo.comboChartsHasBars && opts.xaxis.type !== 'datetime' && opts.xaxis.tickPlacement !== 'between') {
          opts = Defaults.convertCatToNumeric(opts);
        }

        if (opts.chart.sparkline && opts.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) {
          chartDefaults = defaults.sparkline(chartDefaults);
        }

        newDefaults = Utils.extend(config, chartDefaults);
      } // config should cascade in this fashion
      // default-config < global-apex-variable-config < user-defined-config
      // get GLOBALLY defined options and merge with the default config


      var mergedWithDefaultConfig = Utils.extend(newDefaults, window.Apex); // get the merged config and extend with user defined config

      config = Utils.extend(mergedWithDefaultConfig, opts); // some features are not supported. those mismatches should be handled

      config = this.handleUserInputErrors(config);
      return config;
    }
  }, {
    key: "extendYAxis",
    value: function extendYAxis(opts) {
      var options = new Options();

      if (typeof opts.yaxis === 'undefined') {
        opts.yaxis = {};
      } // extend global yaxis config (only if object is provided / not an array)


      if (opts.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array) {
        opts.yaxis = Utils.extend(opts.yaxis, window.Apex.yaxis);
      } // as we can't extend nested object's array with extend, we need to do it first
      // user can provide either an array or object in yaxis config


      if (opts.yaxis.constructor !== Array) {
        // convert the yaxis to array if user supplied object
        opts.yaxis = [Utils.extend(options.yAxis, opts.yaxis)];
      } else {
        opts.yaxis = Utils.extendArray(opts.yaxis, options.yAxis);
      }

      return opts;
    } // annotations also accepts array, so we need to extend them manually

  }, {
    key: "extendAnnotations",
    value: function extendAnnotations(opts) {
      if (typeof opts.annotations === 'undefined') {
        opts.annotations = {};
        opts.annotations.yaxis = [];
        opts.annotations.xaxis = [];
        opts.annotations.points = [];
      }

      opts = this.extendYAxisAnnotations(opts);
      opts = this.extendXAxisAnnotations(opts);
      opts = this.extendPointAnnotations(opts);
      return opts;
    }
  }, {
    key: "extendYAxisAnnotations",
    value: function extendYAxisAnnotations(opts) {
      var options = new Options();
      opts.annotations.yaxis = Utils.extendArray(typeof opts.annotations.yaxis !== 'undefined' ? opts.annotations.yaxis : [], options.yAxisAnnotation);
      return opts;
    }
  }, {
    key: "extendXAxisAnnotations",
    value: function extendXAxisAnnotations(opts) {
      var options = new Options();
      opts.annotations.xaxis = Utils.extendArray(typeof opts.annotations.xaxis !== 'undefined' ? opts.annotations.xaxis : [], options.xAxisAnnotation);
      return opts;
    }
  }, {
    key: "extendPointAnnotations",
    value: function extendPointAnnotations(opts) {
      var options = new Options();
      opts.annotations.points = Utils.extendArray(typeof opts.annotations.points !== 'undefined' ? opts.annotations.points : [], options.pointAnnotation);
      return opts;
    }
  }, {
    key: "checkEmptySeries",
    value: function checkEmptySeries(ser) {
      if (ser.length === 0) {
        return [{
          data: []
        }];
      }

      return ser;
    }
  }, {
    key: "handleUserInputErrors",
    value: function handleUserInputErrors(opts) {
      var config = opts; // conflicting tooltip option. intersect makes sure to focus on 1 point at a time. Shared cannot be used along with it

      if (config.tooltip.shared && config.tooltip.intersect) {
        throw new Error('tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.');
      }

      if (config.chart.scroller) {
        console.warn('Scroller has been deprecated since v2.0.0. Please remove the configuration for chart.scroller');
      }

      if (config.chart.type === 'bar' && config.plotOptions.bar.horizontal) {
        // No time series for horizontal bars
        if (config.xaxis.type === 'datetime') {
          throw new Error('Timelines on bars are not supported yet. Switch to column chart by setting plotOptions.bar.horizontal=false');
        } // No multiple yaxis for bars


        if (config.yaxis.length > 1) {
          throw new Error('Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false');
        }

        if (config.yaxis[0].reversed) {
          config.yaxis[0].opposite = true;
        }

        config.xaxis.tooltip.enabled = false; // no xaxis tooltip for horizontal bar

        config.yaxis[0].tooltip.enabled = false; // no xaxis tooltip for horizontal bar

        config.chart.zoom.enabled = false; // no zooming for horz bars
      }

      if (config.chart.type === 'bar') {
        if (config.tooltip.shared) {
          if (config.xaxis.crosshairs.width === 'barWidth' && config.series.length > 1) {
            console.warn('crosshairs.width = "barWidth" is only supported in single series, not in a multi-series barChart.');
            config.xaxis.crosshairs.width = 'tickWidth';
          }

          if (config.plotOptions.bar.horizontal) {
            config.states.hover.type = 'none';
          }

          if (!config.tooltip.followCursor) {
            console.warn('followCursor option in shared columns cannot be turned off.');
            config.tooltip.followCursor = true;
          }
        }
      }

      if (config.chart.type === 'candlestick') {
        if (config.yaxis[0].reversed) {
          console.warn('Reversed y-axis in candlestick chart is not supported.');
          config.yaxis[0].reversed = false;
        }
      }

      if (config.chart.group && config.yaxis[0].labels.minWidth === 0) {
        console.warn('It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour.');
      } // if user supplied array for stroke width, it will only be applicable to line/area charts, for any other charts, revert back to Number


      if (Array.isArray(config.stroke.width)) {
        if (config.chart.type !== 'line' && config.chart.type !== 'area') {
          console.warn('stroke.width option accepts array only for line and area charts. Reverted back to Number');
          config.stroke.width = config.stroke.width[0];
        }
      }

      return config;
    }
  }]);

  return Config;
}();

var Globals =
/*#__PURE__*/
function () {
  function Globals() {
    _classCallCheck(this, Globals);
  }

  _createClass(Globals, [{
    key: "globalVars",
    value: function globalVars(config) {
      return {
        chartID: null,
        // chart ID - apexcharts-cuid
        cuid: null,
        // chart ID - random numbers excluding "apexcharts" part
        events: {
          beforeMount: [],
          mounted: [],
          updated: [],
          clicked: [],
          selection: [],
          dataPointSelection: [],
          zoomed: [],
          scrolled: []
        },
        colors: [],
        fill: {
          colors: []
        },
        stroke: {
          colors: []
        },
        dataLabels: {
          style: {
            colors: []
          }
        },
        radarPolygons: {
          fill: {
            colors: []
          }
        },
        markers: {
          colors: [],
          size: config.markers.size,
          largestSize: 0
        },
        animationEnded: false,
        isTouchDevice: 'ontouchstart' in window || navigator.msMaxTouchPoints,
        isDirty: false,
        // chart has been updated after the initial render. This is different than dataChanged property. isDirty means user manually called some method to update
        initialConfig: null,
        // we will store the first config user has set to go back when user finishes interactions like zooming and come out of it
        lastXAxis: [],
        lastYAxis: [],
        series: [],
        // the MAIN series array (y values)
        seriesPercent: [],
        // the percentage values of the given series
        seriesTotals: [],
        stackedSeriesTotals: [],
        seriesX: [],
        // store the numeric x values in this array (x values)
        seriesZ: [],
        // The 3rd "Z" dimension for bubbles chart (z values)
        labels: [],
        // store the text to draw on x axis
        // Don't mutate the labels, many things including tooltips depends on it!
        timelineLabels: [],
        // store the timeline Labels in another variable
        seriesNames: [],
        // same as labels, used in non axis charts
        noLabelsProvided: false,
        // if user didn't provide any categories/labels or x values, fallback to 1,2,3,4...
        allSeriesCollapsed: false,
        collapsedSeries: [],
        // when user collapses a series, it goes into this array
        collapsedSeriesIndices: [],
        // this stores the index of the collapsedSeries instead of whole object for quick access
        ancillaryCollapsedSeries: [],
        // when user collapses an "alwaysVisible" series, it goes into this array
        ancillaryCollapsedSeriesIndices: [],
        // this stores the index of the collapsedSeries whose y-axis is always visible
        risingSeries: [],
        // when user re-opens a collapsed series, it goes here
        selectedDataPoints: [],
        ignoreYAxisIndexes: [],
        // when series are being collapsed in multiple y axes, ignore certain index
        padHorizontal: 0,
        maxValsInArrayIndex: 0,
        zoomEnabled: config.chart.toolbar.autoSelected === 'zoom' && config.chart.toolbar.tools.zoom && config.chart.zoom.enabled,
        panEnabled: config.chart.toolbar.autoSelected === 'pan' && config.chart.toolbar.tools.pan,
        selectionEnabled: config.chart.toolbar.autoSelected === 'selection' && config.chart.toolbar.tools.selection,
        yaxis: null,
        minY: Number.MIN_VALUE,
        //  is 5e-324, i.e. the smallest positive number
        // NOTE: If there are multiple y axis, the first yaxis array element will be considered for all y values calculations. Rest all will be calculated based on that
        maxY: -Number.MAX_VALUE,
        // is -1.7976931348623157e+308
        // NOTE: The above note for minY applies here as well
        minYArr: [],
        maxYArr: [],
        maxX: -Number.MAX_VALUE,
        // is -1.7976931348623157e+308
        initialmaxX: -Number.MAX_VALUE,
        minX: Number.MIN_VALUE,
        //  is 5e-324, i.e. the smallest positive number
        initialminX: Number.MIN_VALUE,
        minZ: Number.MIN_VALUE,
        // Max Z value in charts with Z axis
        maxZ: -Number.MAX_VALUE,
        // Max Z value in charts with Z axis
        mousedown: false,
        lastClientPosition: {},
        // don't reset this variable this the chart is destroyed. It is used to detect right or left mousemove in panning
        visibleXRange: undefined,
        yRange: [],
        // this property is the absolute sum of positive and negative values [eg (-100 + 200 = 300)] - yAxis
        zRange: 0,
        // zAxis Range (for bubble charts)
        xRange: 0,
        // xAxis range
        yValueDecimal: 0,
        // are there floating numbers in the series. If yes, this represent the len of the decimals
        total: 0,
        SVGNS: 'http://www.w3.org/2000/svg',
        // svg namespace
        svgWidth: 0,
        // the whole svg width
        svgHeight: 0,
        // the whole svg height
        noData: false,
        // whether there is any data to display or not
        locale: {},
        // the current locale values will be preserved here for global access
        dom: {},
        // for storing all dom nodes in this particular property
        // elWrap: null, // the element that wraps everything
        // elGraphical: null, // this contains lines/areas/bars/pies
        // elGridRect: null, // paths going outside this area will be clipped
        // elGridRectMask: null, // clipping will happen with this mask
        // elGridRectMarkerMask: null, // clipping will happen with this mask
        // elLegendWrap: null, // the whole legend area
        // elDefs: null, // [defs] element
        memory: {
          methodsToExec: []
        },
        shouldAnimate: true,
        delayedElements: [],
        // element which appear after animation has finished
        axisCharts: true,
        // chart type = line or area or bar
        // (refer them also as plot charts in the code)
        isXNumeric: false,
        // bool: data was provided in a {[x,y], [x,y]} pattern
        isDataXYZ: false,
        // bool: data was provided in a {[x,y,z]} pattern
        resized: false,
        // bool: user has resized
        resizeTimer: null,
        // timeout function to make a small delay before
        // drawing when user resized
        comboCharts: false,
        // bool: whether it's a combination of line/column
        comboChartsHasBars: false,
        // bool: whether it's a combination of line/column
        dataChanged: false,
        // bool: has data changed dynamically
        previousPaths: [],
        // array: when data is changed, it will animate from
        // previous paths
        seriesXvalues: [],
        // we will need this in tooltip (it's x position)
        // when we will have unequal x values, we will need
        // some way to get x value depending on mouse pointer
        seriesYvalues: [],
        // we will need this when deciding which series
        // user hovered on
        seriesCandleO: [],
        // candle stick open values
        seriesCandleH: [],
        // candle stick high values
        seriesCandleL: [],
        // candle stick low values
        seriesCandleC: [],
        // candle stick close values
        allSeriesHasEqualX: true,
        dataPoints: 0,
        // the longest series length
        pointsArray: [],
        // store the points positions here to draw later on hover
        // format is - [[x,y],[x,y]... [x,y]]
        dataLabelsRects: [],
        // store the positions of datalabels to prevent collision
        lastDrawnDataLabelsIndexes: [],
        hasNullValues: false,
        // bool: whether series contains null values
        easing: null,
        // function: animation effect to apply
        zoomed: false,
        // whether user has zoomed or not
        gridWidth: 0,
        // drawable width of actual graphs (series paths)
        gridHeight: 0,
        // drawable height of actual graphs (series paths)
        yAxisScale: [],
        xAxisScale: null,
        xAxisTicksPositions: [],
        timescaleTicks: [],
        rotateXLabels: false,
        defaultLabels: false,
        xLabelFormatter: undefined,
        // formatter for x axis labels
        yLabelFormatters: [],
        xaxisTooltipFormatter: undefined,
        // formatter for x axis tooltip
        ttKeyFormatter: undefined,
        ttVal: undefined,
        ttZFormatter: undefined,
        LINE_HEIGHT_RATIO: 1.618,
        xAxisLabelsHeight: 0,
        yAxisLabelsWidth: 0,
        scaleX: 1,
        scaleY: 1,
        translateX: 0,
        translateY: 0,
        translateYAxisX: [],
        yLabelsCoords: [],
        yTitleCoords: [],
        yAxisWidths: [],
        translateXAxisY: 0,
        translateXAxisX: 0,
        tooltip: null,
        tooltipOpts: null
      };
    }
  }, {
    key: "init",
    value: function init(config) {
      var globals = this.globalVars(config);
      globals.initialConfig = Utils.extend({}, config);
      globals.initialSeries = JSON.parse(JSON.stringify(globals.initialConfig.series));
      globals.lastXAxis = JSON.parse(JSON.stringify(globals.initialConfig.xaxis));
      globals.lastYAxis = JSON.parse(JSON.stringify(globals.initialConfig.yaxis));
      return globals;
    }
  }]);

  return Globals;
}();

/**
 * ApexCharts Base Class for extending user options with pre-defined ApexCharts config.
 *
 * @module Base
 **/

var Base =
/*#__PURE__*/
function () {
  function Base(opts) {
    _classCallCheck(this, Base);

    this.opts = opts;
  }

  _createClass(Base, [{
    key: "init",
    value: function init() {
      var config = new Config(this.opts).init();
      var globals = new Globals().init(config);
      var w = {
        config: config,
        globals: globals
      };
      return w;
    }
  }]);

  return Base;
}();

/**
 * ApexCharts Fill Class for setting fill options of the paths.
 *
 * @module Fill
 **/

var Fill =
/*#__PURE__*/
function () {
  function Fill(ctx) {
    _classCallCheck(this, Fill);

    this.ctx = ctx;
    this.w = ctx.w;
    this.opts = null;
    this.seriesIndex = 0;
  }

  _createClass(Fill, [{
    key: "clippedImgArea",
    value: function clippedImgArea(params) {
      var w = this.w;
      var cnf = w.config;
      var svgW = parseInt(w.globals.gridWidth);
      var svgH = parseInt(w.globals.gridHeight);
      var size = svgW > svgH ? svgW : svgH;
      var fillImg = params.image;
      var imgWidth = 0;
      var imgHeight = 0;

      if (typeof params.width === 'undefined' && typeof params.height === 'undefined') {
        if (cnf.fill.image.width !== undefined && cnf.fill.image.height !== undefined) {
          imgWidth = cnf.fill.image.width + 1;
          imgHeight = cnf.fill.image.height;
        } else {
          imgWidth = size + 1;
          imgHeight = size;
        }
      } else {
        imgWidth = params.width;
        imgHeight = params.height;
      }

      var elPattern = document.createElementNS(w.globals.SVGNS, 'pattern');
      Graphics.setAttrs(elPattern, {
        id: params.patternID,
        patternUnits: params.patternUnits ? params.patternUnits : 'userSpaceOnUse',
        width: imgWidth + 'px',
        height: imgHeight + 'px'
      });
      var elImage = document.createElementNS(w.globals.SVGNS, 'image');
      elPattern.appendChild(elImage);
      elImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', fillImg);
      Graphics.setAttrs(elImage, {
        x: 0,
        y: 0,
        preserveAspectRatio: 'none',
        width: imgWidth + 'px',
        height: imgHeight + 'px'
      });
      elImage.style.opacity = params.opacity;
      w.globals.dom.elDefs.node.appendChild(elPattern);
    }
  }, {
    key: "getSeriesIndex",
    value: function getSeriesIndex(opts) {
      var w = this.w;

      if (w.config.chart.type === 'bar' && w.config.plotOptions.bar.distributed || w.config.chart.type === 'heatmap') {
        this.seriesIndex = opts.seriesNumber;
      } else {
        this.seriesIndex = opts.seriesNumber % w.globals.series.length;
      }

      return this.seriesIndex;
    }
  }, {
    key: "fillPath",
    value: function fillPath(opts) {
      var w = this.w;
      this.opts = opts;
      var cnf = this.w.config;
      var pathFill;
      var patternFill, gradientFill;
      this.seriesIndex = this.getSeriesIndex(opts);
      var fillColors = this.getFillColors();
      var fillColor = fillColors[this.seriesIndex];
      var fillType = this.getFillType(this.seriesIndex);
      var fillOpacity = Array.isArray(cnf.fill.opacity) ? cnf.fill.opacity[this.seriesIndex] : cnf.fill.opacity;
      var defaultColor = fillColor;

      if (opts.color) {
        fillColor = opts.color;
      }

      if (fillColor.indexOf('rgb') === -1) {
        defaultColor = Utils.hexToRgba(fillColor, fillOpacity);
      } else {
        if (fillColor.indexOf('rgba') > -1) {
          fillOpacity = 0 + '.' + Utils.getOpacityFromRGBA(fillColors[this.seriesIndex]);
        }
      }

      if (fillType === 'pattern') {
        patternFill = this.handlePatternFill(patternFill, fillColor, fillOpacity, defaultColor);
      }

      if (fillType === 'gradient') {
        gradientFill = this.handleGradientFill(gradientFill, fillColor, fillOpacity, this.seriesIndex);
      }

      if (cnf.fill.image.src.length > 0 && fillType === 'image') {
        if (opts.seriesNumber < cnf.fill.image.src.length) {
          this.clippedImgArea({
            opacity: fillOpacity,
            image: cnf.fill.image.src[opts.seriesNumber],
            patternUnits: opts.patternUnits,
            patternID: "pattern".concat(w.globals.cuid).concat(opts.seriesNumber + 1)
          });
          pathFill = "url(#pattern".concat(w.globals.cuid).concat(opts.seriesNumber + 1, ")");
        } else {
          pathFill = defaultColor;
        }
      } else if (fillType === 'gradient') {
        pathFill = gradientFill;
      } else if (fillType === 'pattern') {
        pathFill = patternFill;
      } else {
        pathFill = defaultColor;
      } // override pattern/gradient if opts.solid is true


      if (opts.solid) {
        pathFill = defaultColor;
      }

      return pathFill;
    }
  }, {
    key: "getFillType",
    value: function getFillType(seriesIndex) {
      var w = this.w;

      if (Array.isArray(w.config.fill.type)) {
        return w.config.fill.type[seriesIndex];
      } else {
        return w.config.fill.type;
      }
    }
  }, {
    key: "getFillColors",
    value: function getFillColors() {
      var w = this.w;
      var cnf = w.config;
      var opts = this.opts;
      var fillColors = [];

      if (w.globals.comboCharts) {
        if (w.config.series[this.seriesIndex].type === 'line') {
          if (w.globals.stroke.colors instanceof Array) {
            fillColors = w.globals.stroke.colors;
          } else {
            fillColors.push(w.globals.stroke.colors);
          }
        } else {
          if (w.globals.fill.colors instanceof Array) {
            fillColors = w.globals.fill.colors;
          } else {
            fillColors.push(w.globals.fill.colors);
          }
        }
      } else {
        if (cnf.chart.type === 'line') {
          if (w.globals.stroke.colors instanceof Array) {
            fillColors = w.globals.stroke.colors;
          } else {
            fillColors.push(w.globals.stroke.colors);
          }
        } else {
          if (w.globals.fill.colors instanceof Array) {
            fillColors = w.globals.fill.colors;
          } else {
            fillColors.push(w.globals.fill.colors);
          }
        }
      } // colors passed in arguments


      if (typeof opts.fillColors !== 'undefined') {
        fillColors = [];

        if (opts.fillColors instanceof Array) {
          fillColors = opts.fillColors.slice();
        } else {
          fillColors.push(opts.fillColors);
        }
      }

      return fillColors;
    }
  }, {
    key: "handlePatternFill",
    value: function handlePatternFill(patternFill, fillColor, fillOpacity, defaultColor) {
      var cnf = this.w.config;
      var opts = this.opts;
      var graphics = new Graphics(this.ctx);
      var patternStrokeWidth = cnf.fill.pattern.strokeWidth === undefined ? Array.isArray(cnf.stroke.width) ? cnf.stroke.width[this.seriesIndex] : cnf.stroke.width : Array.isArray(cnf.fill.pattern.strokeWidth) ? cnf.fill.pattern.strokeWidth[this.seriesIndex] : cnf.fill.pattern.strokeWidth;
      var patternLineColor = fillColor;

      if (cnf.fill.pattern.style instanceof Array) {
        if (typeof cnf.fill.pattern.style[opts.seriesNumber] !== 'undefined') {
          var pf = graphics.drawPattern(cnf.fill.pattern.style[opts.seriesNumber], cnf.fill.pattern.width, cnf.fill.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);
          patternFill = pf;
        } else {
          patternFill = defaultColor;
        }
      } else {
        patternFill = graphics.drawPattern(cnf.fill.pattern.style, cnf.fill.pattern.width, cnf.fill.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);
      }

      return patternFill;
    }
  }, {
    key: "handleGradientFill",
    value: function handleGradientFill(gradientFill, fillColor, fillOpacity, i) {
      var cnf = this.w.config;
      var opts = this.opts;
      var graphics = new Graphics(this.ctx);
      var utils = new Utils();
      var type = cnf.fill.gradient.type;
      var gradientFrom, gradientTo;
      var opacityFrom = cnf.fill.gradient.opacityFrom === undefined ? fillOpacity : Array.isArray(cnf.fill.gradient.opacityFrom) ? cnf.fill.gradient.opacityFrom[i] : cnf.fill.gradient.opacityFrom;
      var opacityTo = cnf.fill.gradient.opacityTo === undefined ? fillOpacity : Array.isArray(cnf.fill.gradient.opacityTo) ? cnf.fill.gradient.opacityTo[i] : cnf.fill.gradient.opacityTo;
      gradientFrom = fillColor;

      if (cnf.fill.gradient.gradientToColors === undefined || cnf.fill.gradient.gradientToColors.length === 0) {
        if (cnf.fill.gradient.shade === 'dark') {
          gradientTo = utils.shadeColor(parseFloat(cnf.fill.gradient.shadeIntensity) * -1, fillColor);
        } else {
          gradientTo = utils.shadeColor(parseFloat(cnf.fill.gradient.shadeIntensity), fillColor);
        }
      } else {
        gradientTo = cnf.fill.gradient.gradientToColors[opts.seriesNumber];
      }

      if (cnf.fill.gradient.inverseColors) {
        var t = gradientFrom;
        gradientFrom = gradientTo;
        gradientTo = t;
      }

      gradientFill = graphics.drawGradient(type, gradientFrom, gradientTo, opacityFrom, opacityTo, opts.size, cnf.fill.gradient.stops, cnf.fill.gradient.colorStops, i);
      return gradientFill;
    }
  }]);

  return Fill;
}();

/**
 * ApexCharts Markers Class for drawing points on y values in axes charts.
 *
 * @module Markers
 **/

var Markers =
/*#__PURE__*/
function () {
  function Markers(ctx, opts) {
    _classCallCheck(this, Markers);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(Markers, [{
    key: "setGlobalMarkerSize",
    value: function setGlobalMarkerSize() {
      var w = this.w;
      w.globals.markers.size = Array.isArray(w.config.markers.size) ? w.config.markers.size : [w.config.markers.size];

      if (w.globals.markers.size.length > 0) {
        if (w.globals.markers.size.length < w.globals.series.length + 1) {
          for (var i = 0; i <= w.globals.series.length; i++) {
            if (typeof w.globals.markers.size[i] === 'undefined') {
              w.globals.markers.size.push(w.globals.markers.size[0]);
            }
          }
        }
      } else {
        w.globals.markers.size = w.config.series.map(function (s) {
          return w.config.markers.size;
        });
      }
    }
  }, {
    key: "plotChartMarkers",
    value: function plotChartMarkers(pointsPos, seriesIndex, j) {
      var _this = this;

      var w = this.w;
      var p = pointsPos;
      var elPointsWrap = null;
      var graphics = new Graphics(this.ctx);
      var point;

      if (w.globals.markers.size[seriesIndex] > 0) {
        elPointsWrap = graphics.group({
          class: 'apexcharts-series-markers'
        });
        elPointsWrap.attr('clip-path', "url(#gridRectMarkerMask".concat(w.globals.cuid, ")"));
      }

      if (p.x instanceof Array) {
        var _loop = function _loop(q) {
          var dataPointIndex = j; // a small hack as we have 2 points for the first val to connect it

          if (j === 1 && q === 0) dataPointIndex = 0;
          if (j === 1 && q === 1) dataPointIndex = 1;
          var PointClasses = 'apexcharts-marker';

          if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {
            PointClasses += ' no-pointer-events';
          }

          var shouldMarkerDraw = Array.isArray(w.config.markers.size) ? w.globals.markers.size[seriesIndex] > 0 : w.config.markers.size > 0;

          if (shouldMarkerDraw) {
            if (Utils.isNumber(p.y[q])) {
              PointClasses += " w".concat((Math.random() + 1).toString(36).substring(4));
            } else {
              PointClasses = 'apexcharts-nullpoint';
            }

            var opts = _this.getMarkerConfig(PointClasses, seriesIndex); // discrete markers is an option where user can specify a particular marker with different size and color


            w.config.markers.discrete.map(function (marker) {
              if (marker.seriesIndex === seriesIndex && marker.dataPointIndex === dataPointIndex) {
                opts.pointStrokeColor = marker.strokeColor;
                opts.pointFillColor = marker.fillColor;
                opts.pSize = marker.size;
              }
            });
            point = graphics.drawMarker(p.x[q], p.y[q], opts);
            point.attr('rel', dataPointIndex);
            point.attr('j', dataPointIndex);
            point.attr('index', seriesIndex);
            point.node.setAttribute('default-marker-size', opts.pSize);
            var filters = new Filters(_this.ctx);
            filters.setSelectionFilter(point, seriesIndex, dataPointIndex);

            _this.addEvents(point);

            if (elPointsWrap) {
              elPointsWrap.add(point);
            }
          } else {
            // dynamic array creation - multidimensional
            if (typeof w.globals.pointsArray[seriesIndex] === 'undefined') w.globals.pointsArray[seriesIndex] = [];
            w.globals.pointsArray[seriesIndex].push([p.x[q], p.y[q]]);
          }
        };

        for (var q = 0; q < p.x.length; q++) {
          _loop(q);
        }
      }

      return elPointsWrap;
    }
  }, {
    key: "getMarkerConfig",
    value: function getMarkerConfig(cssClass, seriesIndex) {
      var w = this.w;
      var pStyle = this.getMarkerStyle(seriesIndex);
      var pSize = w.globals.markers.size[seriesIndex];
      return {
        pSize: pSize,
        pRadius: w.config.markers.radius,
        pWidth: w.config.markers.strokeWidth,
        pointStrokeColor: pStyle.pointStrokeColor,
        pointFillColor: pStyle.pointFillColor,
        shape: w.config.markers.shape instanceof Array ? w.config.markers.shape[seriesIndex] : w.config.markers.shape,
        class: cssClass,
        pointStrokeOpacity: w.config.markers.strokeOpacity,
        pointFillOpacity: w.config.markers.fillOpacity,
        seriesIndex: seriesIndex
      };
    }
  }, {
    key: "addEvents",
    value: function addEvents(circle) {
      var graphics = new Graphics(this.ctx);
      circle.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this.ctx, circle));
      circle.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this.ctx, circle));
      circle.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this.ctx, circle));
      circle.node.addEventListener('touchstart', graphics.pathMouseDown.bind(this.ctx, circle), {
        passive: true
      });
    }
  }, {
    key: "getMarkerStyle",
    value: function getMarkerStyle(seriesIndex) {
      var w = this.w;
      var colors = w.globals.markers.colors;
      var strokeColors = w.config.markers.strokeColor || w.config.markers.strokeColors;
      var pointStrokeColor = strokeColors instanceof Array ? strokeColors[seriesIndex] : strokeColors;
      var pointFillColor = colors instanceof Array ? colors[seriesIndex] : colors;
      return {
        pointStrokeColor: pointStrokeColor,
        pointFillColor: pointFillColor
      };
    }
  }]);

  return Markers;
}();

/**
 * ApexCharts Scatter Class.
 * This Class also handles bubbles chart as currently there is no major difference in drawing them,
 * @module Scatter
 **/

var Scatter =
/*#__PURE__*/
function () {
  function Scatter(ctx) {
    _classCallCheck(this, Scatter);

    this.ctx = ctx;
    this.w = ctx.w;
    this.initialAnim = this.w.config.chart.animations.enabled;
    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled; // this array will help in centering the label in bubbles

    this.radiusSizes = [];
  }

  _createClass(Scatter, [{
    key: "draw",
    value: function draw(elSeries, j, opts) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var realIndex = opts.realIndex;
      var pointsPos = opts.pointsPos;
      var zRatio = opts.zRatio;
      var elPointsMain = opts.elParent;
      var elPointsWrap = graphics.group({
        class: "apexcharts-series-markers apexcharts-series-".concat(w.config.chart.type)
      });
      elPointsWrap.attr('clip-path', "url(#gridRectMarkerMask".concat(w.globals.cuid, ")"));

      if (pointsPos.x instanceof Array) {
        for (var q = 0; q < pointsPos.x.length; q++) {
          var dataPointIndex = j + 1;
          var shouldDraw = true; // a small hack as we have 2 points for the first val to connect it

          if (j === 0 && q === 0) dataPointIndex = 0;
          if (j === 0 && q === 1) dataPointIndex = 1;
          var radius = 0;
          var finishRadius = w.globals.markers.size[realIndex];

          if (zRatio !== Infinity) {
            // means we have a bubble
            finishRadius = w.globals.seriesZ[realIndex][dataPointIndex] / zRatio;

            if (typeof this.radiusSizes[realIndex] === 'undefined') {
              this.radiusSizes.push([]);
            }

            this.radiusSizes[realIndex].push(finishRadius);
          }

          if (!w.config.chart.animations.enabled) {
            radius = finishRadius;
          }

          var x = pointsPos.x[q];
          var y = pointsPos.y[q];
          radius = radius || 0;

          if (x === 0 && y === 0 || y === null || typeof w.globals.series[realIndex][dataPointIndex] === 'undefined') {
            shouldDraw = false;
          }

          if (shouldDraw) {
            var circle = this.drawPoint(x, y, radius, finishRadius, realIndex, dataPointIndex, j);
            elPointsWrap.add(circle);
          }

          elPointsMain.add(elPointsWrap);
        }
      }
    }
  }, {
    key: "drawPoint",
    value: function drawPoint(x, y, radius, finishRadius, realIndex, dataPointIndex, j) {
      var w = this.w;
      var anim = new Animations(this.ctx);
      var filters = new Filters(this.ctx);
      var fill = new Fill(this.ctx);
      var graphics = new Graphics(this.ctx);
      var pathFillCircle = fill.fillPath({
        seriesNumber: realIndex,
        patternUnits: 'objectBoundingBox'
      });
      var circle = graphics.drawCircle(radius);
      circle.attr({
        cx: x,
        cy: y,
        fill: pathFillCircle
      });

      if (w.config.chart.dropShadow.enabled) {
        filters.dropShadow(circle, {
          top: w.config.chart.dropShadow.top,
          left: w.config.chart.dropShadow.left,
          blur: w.config.chart.dropShadow.blur,
          color: w.config.chart.dropShadow.color,
          opacity: w.config.chart.dropShadow.opacity
        });
      }

      if (this.initialAnim && !w.globals.dataChanged) {
        var speed = 1;

        if (!w.globals.resized) {
          speed = w.config.chart.animations.speed;
        }

        anim.animateCircleRadius(circle, 0, finishRadius, speed, w.globals.easing);
      }

      if (w.globals.dataChanged) {
        if (this.dynamicAnim) {
          var _speed = w.config.chart.animations.dynamicAnimation.speed;
          var prevX, prevY, prevR;
          var prevPathJ = null;
          prevPathJ = w.globals.previousPaths[realIndex] && w.globals.previousPaths[realIndex][j];

          if (typeof prevPathJ !== 'undefined' && prevPathJ !== null) {
            // series containing less elements will ignore these values and revert to 0
            prevX = prevPathJ.x;
            prevY = prevPathJ.y;
            prevR = typeof prevPathJ.r !== 'undefined' ? prevPathJ.r : finishRadius;
          }

          for (var cs = 0; cs < w.globals.collapsedSeries.length; cs++) {
            if (w.globals.collapsedSeries[cs].index === realIndex) {
              _speed = 1;
              finishRadius = 0;
            }
          }

          if (x === 0 && y === 0) finishRadius = 0;
          anim.animateCircle(circle, {
            cx: prevX,
            cy: prevY,
            r: prevR
          }, {
            cx: x,
            cy: y,
            r: finishRadius
          }, _speed, w.globals.easing);
        } else {
          circle.attr({
            r: finishRadius
          });
        }
      }

      circle.attr({
        rel: dataPointIndex,
        j: dataPointIndex,
        index: realIndex,
        'default-marker-size': finishRadius
      });
      var markers = new Markers(this.ctx);
      filters.setSelectionFilter(circle, realIndex, dataPointIndex);
      markers.addEvents(circle);
      circle.node.classList.add('apexcharts-marker');
      return circle;
    }
  }, {
    key: "centerTextInBubble",
    value: function centerTextInBubble(y) {
      var w = this.w;
      y = y + parseInt(w.config.dataLabels.style.fontSize) / 4;
      return {
        y: y
      };
    }
  }]);

  return Scatter;
}();

/**
 * ApexCharts DataLabels Class for drawing dataLabels on Axes based Charts.
 *
 * @module DataLabels
 **/

var DataLabels =
/*#__PURE__*/
function () {
  function DataLabels(ctx) {
    _classCallCheck(this, DataLabels);

    this.ctx = ctx;
    this.w = ctx.w;
  } // When there are many datalabels to be printed, and some of them overlaps each other in the same series, this method will take care of that
  // Also, when datalabels exceeds the drawable area and get clipped off, we need to adjust and move some pixels to make them visible again


  _createClass(DataLabels, [{
    key: "dataLabelsCorrection",
    value: function dataLabelsCorrection(x, y, val, i, dataPointIndex, alwaysDrawDataLabel, fontSize) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var drawnextLabel = false; //

      var textRects = graphics.getTextRects(val, fontSize);
      var width = textRects.width;
      var height = textRects.height; // first value in series, so push an empty array

      if (typeof w.globals.dataLabelsRects[i] === 'undefined') w.globals.dataLabelsRects[i] = []; // then start pushing actual rects in that sub-array

      w.globals.dataLabelsRects[i].push({
        x: x,
        y: y,
        width: width,
        height: height
      });
      var len = w.globals.dataLabelsRects[i].length - 2;
      var lastDrawnIndex = typeof w.globals.lastDrawnDataLabelsIndexes[i] !== 'undefined' ? w.globals.lastDrawnDataLabelsIndexes[i][w.globals.lastDrawnDataLabelsIndexes[i].length - 1] : 0;

      if (typeof w.globals.dataLabelsRects[i][len] !== 'undefined') {
        var lastDataLabelRect = w.globals.dataLabelsRects[i][lastDrawnIndex];

        if ( // next label forward and x not intersecting
        x > lastDataLabelRect.x + lastDataLabelRect.width + 2 || y > lastDataLabelRect.y + lastDataLabelRect.height + 2 || x + width < lastDataLabelRect.x // next label is going to be drawn backwards
        ) {
            // the 2 indexes don't override, so OK to draw next label
            drawnextLabel = true;
          }
      }

      if (dataPointIndex === 0 || alwaysDrawDataLabel) {
        drawnextLabel = true;
      }

      return {
        x: x,
        y: y,
        drawnextLabel: drawnextLabel
      };
    }
  }, {
    key: "drawDataLabel",
    value: function drawDataLabel(pos, i, j) {
      // this method handles line, area, bubble, scatter charts as those charts contains markers/points which have pre-defined x/y positions
      // all other charts like bars / heatmaps will define their own drawDataLabel routine
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var dataLabelsConfig = w.config.dataLabels;
      var x = 0;
      var y = 0;
      var dataPointIndex = j;
      var elDataLabelsWrap = null;

      if (!dataLabelsConfig.enabled || pos.x instanceof Array !== true) {
        return elDataLabelsWrap;
      }

      elDataLabelsWrap = graphics.group({
        class: 'apexcharts-data-labels'
      });
      elDataLabelsWrap.attr('clip-path', "url(#gridRectMarkerMask".concat(w.globals.cuid, ")"));

      for (var q = 0; q < pos.x.length; q++) {
        x = pos.x[q] + dataLabelsConfig.offsetX;
        y = pos.y[q] + dataLabelsConfig.offsetY - w.globals.markers.size[i] - 5;

        if (!isNaN(x)) {
          // a small hack as we have 2 points for the first val to connect it
          if (j === 1 && q === 0) dataPointIndex = 0;
          if (j === 1 && q === 1) dataPointIndex = 1;
          var val = w.globals.series[i][dataPointIndex];
          var text = '';

          if (w.config.chart.type === 'bubble') {
            text = w.globals.seriesZ[i][dataPointIndex];
            y = pos.y[q] + w.config.dataLabels.offsetY;
            var scatter = new Scatter(this.ctx);
            var centerTextInBubbleCoords = scatter.centerTextInBubble(y, i, dataPointIndex);
            y = centerTextInBubbleCoords.y;
          } else {
            if (typeof val !== 'undefined') {
              text = w.config.dataLabels.formatter(val, {
                seriesIndex: i,
                dataPointIndex: dataPointIndex,
                w: w
              });
            }
          }

          this.plotDataLabelsText({
            x: x,
            y: y,
            text: text,
            i: i,
            j: dataPointIndex,
            parent: elDataLabelsWrap,
            offsetCorrection: true,
            dataLabelsConfig: w.config.dataLabels
          });
        }
      }

      return elDataLabelsWrap;
    }
  }, {
    key: "plotDataLabelsText",
    value: function plotDataLabelsText(opts) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var x = opts.x,
          y = opts.y,
          i = opts.i,
          j = opts.j,
          text = opts.text,
          textAnchor = opts.textAnchor,
          parent = opts.parent,
          dataLabelsConfig = opts.dataLabelsConfig,
          alwaysDrawDataLabel = opts.alwaysDrawDataLabel,
          offsetCorrection = opts.offsetCorrection;

      if (Array.isArray(w.config.dataLabels.enabledOnSeries)) {
        if (w.config.dataLabels.enabledOnSeries.indexOf(i) > -1) {
          return;
        }
      }

      var correctedLabels = {
        x: x,
        y: y,
        drawnextLabel: true
      };

      if (offsetCorrection) {
        correctedLabels = this.dataLabelsCorrection(x, y, text, i, j, alwaysDrawDataLabel, parseInt(dataLabelsConfig.style.fontSize));
      } // when zoomed, we don't need to correct labels offsets,
      // but if normally, labels get cropped, correct them


      if (!w.globals.zoomed) {
        x = correctedLabels.x;
        y = correctedLabels.y;
      }

      if (correctedLabels.drawnextLabel) {
        var dataLabelText = graphics.drawText({
          width: 100,
          height: parseInt(dataLabelsConfig.style.fontSize),
          x: x,
          y: y,
          foreColor: w.globals.dataLabels.style.colors[i],
          textAnchor: textAnchor || dataLabelsConfig.textAnchor,
          text: text,
          fontSize: dataLabelsConfig.style.fontSize,
          fontFamily: dataLabelsConfig.style.fontFamily
        });
        dataLabelText.attr({
          class: 'apexcharts-datalabel',
          cx: x,
          cy: y
        });

        if (dataLabelsConfig.dropShadow.enabled) {
          var textShadow = dataLabelsConfig.dropShadow;
          var filters = new Filters(this.ctx);
          filters.dropShadow(dataLabelText, textShadow);
        }

        parent.add(dataLabelText);

        if (typeof w.globals.lastDrawnDataLabelsIndexes[i] === 'undefined') {
          w.globals.lastDrawnDataLabelsIndexes[i] = [];
        }

        w.globals.lastDrawnDataLabelsIndexes[i].push(j);
      }
    }
  }]);

  return DataLabels;
}();

/**
 * ApexCharts Bar Class responsible for drawing both Columns and Bars.
 *
 * @module Bar
 **/

var DATA_LABELS_WARNING_THRESHOLD = 50;

var Bar =
/*#__PURE__*/
function () {
  function Bar(ctx, xyRatios) {
    _classCallCheck(this, Bar);

    this.ctx = ctx;
    this.w = ctx.w;
    var w = this.w;
    this.barOptions = w.config.plotOptions.bar;
    this.isHorizontal = this.barOptions.horizontal;
    this.strokeWidth = w.config.stroke.width;
    this.isNullValue = false;
    this.xyRatios = xyRatios;

    if (this.xyRatios !== null) {
      this.xRatio = xyRatios.xRatio;
      this.yRatio = xyRatios.yRatio;
      this.invertedXRatio = xyRatios.invertedXRatio;
      this.invertedYRatio = xyRatios.invertedYRatio;
      this.baseLineY = xyRatios.baseLineY;
      this.baseLineInvertedY = xyRatios.baseLineInvertedY;
    }

    this.minXDiff = Number.MAX_VALUE;
    this.yaxisIndex = 0;
    this.seriesLen = 0;
  }
  /** primary draw method which is called on bar object
   * @memberof Bar
   * @param {array} series - user supplied series values
   * @param {int} seriesIndex - the index by which series will be drawn on the svg
   * @return {node} element which is supplied to parent chart draw method for appending
   **/


  _createClass(Bar, [{
    key: "draw",
    value: function draw(series, seriesIndex) {
      var _this = this;

      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var fill = new Fill(this.ctx);
      var coreUtils = new CoreUtils(this.ctx, w);
      this.series = coreUtils.getLogSeries(series);
      series = this.series;
      this.yRatio = coreUtils.getLogYRatios(this.yRatio);
      this.initVariables(series);
      var ret = graphics.group({
        class: 'apexcharts-bar-series apexcharts-plot-series'
      });
      ret.attr('clip-path', "url(#gridRectMask".concat(w.globals.cuid, ")"));

      if (w.config.dataLabels.enabled) {
        if (this.totalItems > DATA_LABELS_WARNING_THRESHOLD) {
          console.warn('WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.');
        }
      }

      var _loop = function _loop(i, bc) {
        var pathTo = void 0,
            pathFrom = void 0;
        var x = void 0,
            y = void 0,
            xDivision = void 0,
            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)
        yDivision = void 0,
            // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)
        zeroH = void 0,
            // zeroH is the baseline where 0 meets y axis
        zeroW = void 0; // zeroW is the baseline where 0 meets x axis

        var yArrj = []; // hold y values of current iterating series

        var xArrj = []; // hold x values of current iterating series

        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn

        var elSeries = graphics.group({
          class: "apexcharts-series ".concat(Utils.escapeString(w.globals.seriesNames[realIndex])),
          rel: i + 1,
          'data:realIndex': realIndex
        });

        _this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);

        if (series[i].length > 0) {
          _this.visibleI = _this.visibleI + 1;
        }

        var strokeWidth = 0;
        var barHeight = 0;
        var barWidth = 0;

        if (_this.yRatio.length > 1) {
          _this.yaxisIndex = realIndex;
        }

        _this.isReversed = w.config.yaxis[_this.yaxisIndex] && w.config.yaxis[_this.yaxisIndex].reversed;

        var initPositions = _this.initialPositions();

        y = initPositions.y;
        barHeight = initPositions.barHeight;
        yDivision = initPositions.yDivision;
        zeroW = initPositions.zeroW;
        x = initPositions.x;
        barWidth = initPositions.barWidth;
        xDivision = initPositions.xDivision;
        zeroH = initPositions.zeroH;

        if (!_this.horizontal) {
          xArrj.push(x + barWidth / 2);
        } // eldatalabels


        var elDataLabelsWrap = graphics.group({
          class: 'apexcharts-datalabels'
        });

        var _loop2 = function _loop2(j, tj) {
          if (typeof _this.series[i][j] === 'undefined' || series[i][j] === null) {
            _this.isNullValue = true;
          } else {
            _this.isNullValue = false;
          }

          if (w.config.stroke.show) {
            if (_this.isNullValue) {
              strokeWidth = 0;
            } else {
              strokeWidth = Array.isArray(_this.strokeWidth) ? _this.strokeWidth[realIndex] : _this.strokeWidth;
            }
          }

          var paths = null;

          if (_this.isHorizontal) {
            paths = _this.drawBarPaths({
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                bc: bc
              },
              barHeight: barHeight,
              strokeWidth: strokeWidth,
              pathTo: pathTo,
              pathFrom: pathFrom,
              zeroW: zeroW,
              x: x,
              y: y,
              yDivision: yDivision,
              elSeries: elSeries
            });
          } else {
            paths = _this.drawColumnPaths({
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                bc: bc
              },
              x: x,
              y: y,
              xDivision: xDivision,
              pathTo: pathTo,
              pathFrom: pathFrom,
              barWidth: barWidth,
              zeroH: zeroH,
              strokeWidth: strokeWidth,
              elSeries: elSeries
            });
          }

          pathTo = paths.pathTo;
          pathFrom = paths.pathFrom;
          y = paths.y;
          x = paths.x; // push current X

          if (j > 0) {
            xArrj.push(x + barWidth / 2);
          }

          yArrj.push(y);
          var seriesNumber = _this.barOptions.distributed ? j : i;
          var fillColor = null;

          if (_this.barOptions.colors.ranges.length > 0) {
            var colorRange = _this.barOptions.colors.ranges;
            colorRange.map(function (range) {
              if (series[i][j] >= range.from && series[i][j] <= range.to) {
                fillColor = range.color;
              }
            });
          }

          var pathFill = fill.fillPath({
            seriesNumber: _this.barOptions.distributed ? seriesNumber : realIndex,
            color: fillColor
          });
          elSeries = _this.renderSeries({
            realIndex: realIndex,
            pathFill: pathFill,
            j: j,
            i: i,
            pathFrom: pathFrom,
            pathTo: pathTo,
            strokeWidth: strokeWidth,
            elSeries: elSeries,
            x: x,
            y: y,
            series: series,
            barHeight: barHeight,
            barWidth: barWidth,
            elDataLabelsWrap: elDataLabelsWrap,
            visibleSeries: _this.visibleI,
            type: 'bar'
          });
        };

        for (var j = 0, tj = w.globals.dataPoints; j < w.globals.dataPoints; j++, tj--) {
          _loop2(j, tj);
        } // push all x val arrays into main xArr


        w.globals.seriesXvalues[realIndex] = xArrj;
        w.globals.seriesYvalues[realIndex] = yArrj;
        ret.add(elSeries);
      };

      for (var i = 0, bc = 0; i < series.length; i++, bc++) {
        _loop(i, bc);
      }

      return ret;
    }
  }, {
    key: "renderSeries",
    value: function renderSeries(_ref) {
      var realIndex = _ref.realIndex,
          pathFill = _ref.pathFill,
          lineFill = _ref.lineFill,
          j = _ref.j,
          i = _ref.i,
          pathFrom = _ref.pathFrom,
          pathTo = _ref.pathTo,
          strokeWidth = _ref.strokeWidth,
          elSeries = _ref.elSeries,
          x = _ref.x,
          y = _ref.y,
          series = _ref.series,
          barHeight = _ref.barHeight,
          barWidth = _ref.barWidth,
          elDataLabelsWrap = _ref.elDataLabelsWrap,
          visibleSeries = _ref.visibleSeries,
          type = _ref.type;
      var w = this.w;
      var graphics = new Graphics(this.ctx);

      if (!lineFill) {
        /* fix apexcharts#341 */
        lineFill = this.barOptions.distributed ? w.globals.stroke.colors[j] : w.globals.stroke.colors[realIndex];
      }

      if (this.isNullValue) {
        pathFill = 'none';
      }

      var delay = j / w.config.chart.animations.animateGradually.delay * (w.config.chart.animations.speed / w.globals.dataPoints) / 2.4;
      var renderedPath = graphics.renderPaths({
        i: i,
        j: j,
        realIndex: realIndex,
        pathFrom: pathFrom,
        pathTo: pathTo,
        stroke: lineFill,
        strokeWidth: strokeWidth,
        strokeLineCap: w.config.stroke.lineCap,
        fill: pathFill,
        animationDelay: delay,
        initialSpeed: w.config.chart.animations.speed,
        dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,
        className: "apexcharts-".concat(type, "-area"),
        id: "apexcharts-".concat(type, "-area")
      });
      var filters = new Filters(this.ctx);
      filters.setSelectionFilter(renderedPath, realIndex, j);
      elSeries.add(renderedPath);
      var dataLabels = this.calculateDataLabelsPos({
        x: x,
        y: y,
        i: i,
        j: j,
        series: series,
        realIndex: realIndex,
        barHeight: barHeight,
        barWidth: barWidth,
        renderedPath: renderedPath,
        visibleSeries: visibleSeries
      });

      if (dataLabels !== null) {
        elDataLabelsWrap.add(dataLabels);
      }

      elSeries.add(elDataLabelsWrap);
      return elSeries;
    }
  }, {
    key: "initVariables",
    value: function initVariables(series) {
      var _this2 = this;

      var w = this.w;
      this.series = series;
      this.totalItems = 0;
      this.seriesLen = 0;
      this.visibleI = -1;
      this.visibleItems = 1; // number of visible bars after user zoomed in/out

      for (var sl = 0; sl < series.length; sl++) {
        if (series[sl].length > 0) {
          this.seriesLen = this.seriesLen + 1;
          this.totalItems += series[sl].length;
        }

        if (w.globals.isXNumeric) {
          // get the least x diff if numeric x axis is present
          w.globals.seriesX.forEach(function (sX, i) {
            sX.forEach(function (s, j) {
              if (j > 0) {
                var xDiff = s - w.globals.seriesX[i][j - 1];
                _this2.minXDiff = Math.min(xDiff, _this2.minXDiff);
              }
            });
          }); // get max visible items

          for (var j = 0; j < series[sl].length; j++) {
            if (w.globals.seriesX[sl][j] > w.globals.minX && w.globals.seriesX[sl][j] < w.globals.maxX) {
              this.visibleItems++;
            }
          }
        } else {
          this.visibleItems = w.globals.dataPoints;
        }
      }

      if (this.seriesLen === 0) {
        // A small adjustment when combo charts are used
        this.seriesLen = 1;
      }
    }
  }, {
    key: "initialPositions",
    value: function initialPositions() {
      var w = this.w;
      var x, y, yDivision, xDivision, barHeight, barWidth, zeroH, zeroW;

      if (this.isHorizontal) {
        // height divided into equal parts
        yDivision = w.globals.gridHeight / w.globals.dataPoints;
        barHeight = yDivision / this.seriesLen;

        if (w.globals.isXNumeric) {
          yDivision = w.globals.gridHeight / this.totalItems;
          barHeight = yDivision / this.seriesLen;
        }

        barHeight = barHeight * parseInt(this.barOptions.barHeight) / 100;
        zeroW = this.baseLineInvertedY + w.globals.padHorizontal + (this.isReversed ? w.globals.gridWidth : 0) - (this.isReversed ? this.baseLineInvertedY * 2 : 0);
        y = (yDivision - barHeight * this.seriesLen) / 2;
      } else {
        // width divided into equal parts
        xDivision = w.globals.gridWidth / this.visibleItems;
        barWidth = xDivision / this.seriesLen * parseInt(this.barOptions.columnWidth) / 100;

        if (w.globals.isXNumeric) {
          // max barwidth should be equal to minXDiff to avoid overlap
          if (this.minXDiff === Number.MAX_VALUE) {
            // possibly a single dataPoint (fixes react-apexcharts/issue#34)
            var len = w.globals.labels.length;

            if (w.globals.timelineLabels.length > 0) {
              len = w.globals.timelineLabels.length;
            }

            if (len < 3) {
              len = 3;
            }

            this.minXDiff = (w.globals.maxX - w.globals.minX) / len;
          }

          xDivision = this.minXDiff / this.xRatio;
          barWidth = xDivision / this.seriesLen * parseInt(this.barOptions.columnWidth) / 100;
        }

        zeroH = w.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? this.baseLineY[this.yaxisIndex] * 2 : 0);
        x = w.globals.padHorizontal + (xDivision - barWidth * this.seriesLen) / 2;
      }

      return {
        x: x,
        y: y,
        yDivision: yDivision,
        xDivision: xDivision,
        barHeight: barHeight,
        barWidth: barWidth,
        zeroH: zeroH,
        zeroW: zeroW
      };
    }
  }, {
    key: "drawBarPaths",
    value: function drawBarPaths(_ref2) {
      var indexes = _ref2.indexes,
          barHeight = _ref2.barHeight,
          strokeWidth = _ref2.strokeWidth,
          pathTo = _ref2.pathTo,
          pathFrom = _ref2.pathFrom,
          zeroW = _ref2.zeroW,
          x = _ref2.x,
          y = _ref2.y,
          yDivision = _ref2.yDivision,
          elSeries = _ref2.elSeries;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var i = indexes.i;
      var j = indexes.j;
      var realIndex = indexes.realIndex;
      var bc = indexes.bc;

      if (w.globals.isXNumeric) {
        y = (w.globals.seriesX[i][j] - w.globals.minX) / this.invertedXRatio - barHeight;
      }

      var barYPosition = y + barHeight * this.visibleI;
      pathTo = graphics.move(zeroW, barYPosition);
      pathFrom = graphics.move(zeroW, barYPosition);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.getPathFrom(realIndex, j);
      }

      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {
        x = zeroW;
      } else {
        x = zeroW + this.series[i][j] / this.invertedYRatio - (this.isReversed ? this.series[i][j] / this.invertedYRatio : 0) * 2;
      }

      pathTo = pathTo + graphics.line(x, barYPosition) + graphics.line(x, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition);
      pathFrom = pathFrom + graphics.line(zeroW, barYPosition) + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition + barHeight - strokeWidth) + graphics.line(zeroW, barYPosition);

      if (!w.globals.isXNumeric) {
        y = y + yDivision;
      }

      if (this.barOptions.colors.backgroundBarColors.length > 0 && i === 0) {
        if (bc >= this.barOptions.colors.backgroundBarColors.length) {
          bc = 0;
        }

        var bcolor = this.barOptions.colors.backgroundBarColors[bc];
        var rect = graphics.drawRect(0, barYPosition - barHeight * this.visibleI, w.globals.gridWidth, barHeight * this.seriesLen, 0, bcolor, this.barOptions.colors.backgroundBarOpacity);
        elSeries.add(rect);
        rect.node.classList.add('apexcharts-backgroundBar');
      }

      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        x: x,
        y: y,
        barYPosition: barYPosition
      };
    }
  }, {
    key: "drawColumnPaths",
    value: function drawColumnPaths(_ref3) {
      var indexes = _ref3.indexes,
          x = _ref3.x,
          y = _ref3.y,
          xDivision = _ref3.xDivision,
          pathTo = _ref3.pathTo,
          pathFrom = _ref3.pathFrom,
          barWidth = _ref3.barWidth,
          zeroH = _ref3.zeroH,
          strokeWidth = _ref3.strokeWidth,
          elSeries = _ref3.elSeries;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var i = indexes.i;
      var j = indexes.j;
      var realIndex = indexes.realIndex;
      var bc = indexes.bc;

      if (w.globals.isXNumeric) {
        x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;
      }

      var barXPosition = x + barWidth * this.visibleI;
      pathTo = graphics.move(barXPosition, zeroH);
      pathFrom = graphics.move(barXPosition, zeroH);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.getPathFrom(realIndex, j);
      }

      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {
        y = zeroH;
      } else {
        y = zeroH - this.series[i][j] / this.yRatio[this.yaxisIndex] + (this.isReversed ? this.series[i][j] / this.yRatio[this.yaxisIndex] : 0) * 2;
      }

      pathTo = pathTo + graphics.line(barXPosition, y) + graphics.line(barXPosition + barWidth - strokeWidth, y) + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition, zeroH);
      pathFrom = pathFrom + graphics.line(barXPosition, zeroH) + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition + barWidth - strokeWidth, zeroH) + graphics.line(barXPosition, zeroH);

      if (!w.globals.isXNumeric) {
        x = x + xDivision;
      }

      if (this.barOptions.colors.backgroundBarColors.length > 0 && i === 0) {
        if (bc >= this.barOptions.colors.backgroundBarColors.length) {
          bc = 0;
        }

        var bcolor = this.barOptions.colors.backgroundBarColors[bc];
        var rect = graphics.drawRect(barXPosition - barWidth * this.visibleI, 0, barWidth * this.seriesLen, w.globals.gridHeight, 0, bcolor, this.barOptions.colors.backgroundBarOpacity);
        elSeries.add(rect);
        rect.node.classList.add('apexcharts-backgroundBar');
      }

      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        x: x,
        y: y,
        barXPosition: barXPosition
      };
    }
    /** getPathFrom is a common function for bars/columns which is used to get previous paths when data changes.
     * @memberof Bar
     * @param {int} realIndex - current iterating i
     * @param {int} j - current iterating series's j index
     * @return {string} pathFrom is the string which will be appended in animations
     **/

  }, {
    key: "getPathFrom",
    value: function getPathFrom(realIndex, j) {
      var w = this.w;
      var pathFrom;

      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {
        var gpp = w.globals.previousPaths[pp];

        if (gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {
          if (typeof w.globals.previousPaths[pp].paths[j] !== 'undefined') {
            pathFrom = w.globals.previousPaths[pp].paths[j].d;
          }
        }
      }

      return pathFrom;
    }
    /** calculateBarDataLabels is used to calculate the positions for the data-labels
     * It also sets the element's data attr for bars and calls drawCalculatedBarDataLabels()
     * @memberof Bar
     * @param {object} {barProps} most of the bar properties used throughout the bar
     * drawing function
     * @return {object} dataLabels node-element which you can append later
     **/

  }, {
    key: "calculateDataLabelsPos",
    value: function calculateDataLabelsPos(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          i = _ref4.i,
          j = _ref4.j,
          realIndex = _ref4.realIndex,
          series = _ref4.series,
          barHeight = _ref4.barHeight,
          barWidth = _ref4.barWidth,
          visibleSeries = _ref4.visibleSeries,
          renderedPath = _ref4.renderedPath;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;
      var bcx = x + parseFloat(barWidth * visibleSeries);
      var bcy = y + parseFloat(barHeight * visibleSeries);

      if (w.globals.isXNumeric) {
        bcx = x + parseFloat(barWidth * (visibleSeries + 1)) - strokeWidth;
        bcy = y + parseFloat(barHeight * (visibleSeries + 1)) - strokeWidth;
      }

      var dataLabels = null;
      var dataLabelsX = x;
      var dataLabelsY = y;
      var dataLabelsPos = {};
      var dataLabelsConfig = w.config.dataLabels;
      var barDataLabelsConfig = this.barOptions.dataLabels;
      var offX = dataLabelsConfig.offsetX;
      var offY = dataLabelsConfig.offsetY;
      var textRects = {
        width: 0,
        height: 0
      };

      if (w.config.dataLabels.enabled) {
        textRects = graphics.getTextRects(w.globals.yLabelFormatters[0](w.globals.maxY), parseInt(dataLabelsConfig.style.fontSize));
      }

      if (this.isHorizontal) {
        dataLabelsPos = this.calculateBarsDataLabelsPosition({
          x: x,
          y: y,
          i: i,
          j: j,
          renderedPath: renderedPath,
          bcy: bcy,
          barHeight: barHeight,
          textRects: textRects,
          strokeWidth: strokeWidth,
          dataLabelsX: dataLabelsX,
          dataLabelsY: dataLabelsY,
          barDataLabelsConfig: barDataLabelsConfig,
          offX: offX,
          offY: offY
        });
      } else {
        dataLabelsPos = this.calculateColumnsDataLabelsPosition({
          x: x,
          y: y,
          i: i,
          j: j,
          renderedPath: renderedPath,
          realIndex: realIndex,
          bcx: bcx,
          bcy: bcy,
          barHeight: barHeight,
          barWidth: barWidth,
          textRects: textRects,
          strokeWidth: strokeWidth,
          dataLabelsY: dataLabelsY,
          barDataLabelsConfig: barDataLabelsConfig,
          offX: offX,
          offY: offY
        });
      }

      renderedPath.attr({
        cy: dataLabelsPos.bcy,
        cx: dataLabelsPos.bcx,
        j: j,
        val: series[i][j],
        barHeight: barHeight,
        barWidth: barWidth
      });
      dataLabels = this.drawCalculatedDataLabels({
        x: dataLabelsPos.dataLabelsX,
        y: dataLabelsPos.dataLabelsY,
        val: series[i][j],
        i: realIndex,
        j: j,
        dataLabelsConfig: dataLabelsConfig
      });
      return dataLabels;
    }
  }, {
    key: "calculateColumnsDataLabelsPosition",
    value: function calculateColumnsDataLabelsPosition(opts) {
      var w = this.w;
      var i = opts.i,
          j = opts.j,
          realIndex = opts.realIndex,
          y = opts.y,
          bcx = opts.bcx,
          barWidth = opts.barWidth,
          textRects = opts.textRects,
          dataLabelsY = opts.dataLabelsY,
          barDataLabelsConfig = opts.barDataLabelsConfig,
          strokeWidth = opts.strokeWidth,
          offX = opts.offX,
          offY = opts.offY;
      var dataLabelsX;
      var barHeight = this.series[i][j] / this.yRatio[this.yaxisIndex];
      var dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;
      bcx = bcx - strokeWidth / 2;

      if (w.globals.isXNumeric) {
        dataLabelsX = bcx - barWidth / 2 + offX;
      } else {
        dataLabelsX = bcx - dataPointsDividedWidth + barWidth / 2 + offX;
      }

      var valIsNegative = this.series[i][j] <= 0;

      if (w.config.yaxis[this.yaxisIndex].reversed) {
        y = y - barHeight;
      }

      switch (barDataLabelsConfig.position) {
        case 'center':
          if (valIsNegative) {
            dataLabelsY = y + barHeight / 2 + textRects.height / 2 + offY;
          } else {
            dataLabelsY = y + barHeight / 2 + textRects.height / 2 - offY;
          }

          break;

        case 'bottom':
          if (valIsNegative) {
            dataLabelsY = y + barHeight + textRects.height + strokeWidth + offY;
          } else {
            dataLabelsY = y + barHeight - textRects.height / 2 + strokeWidth - offY;
          }

          break;

        case 'top':
          if (valIsNegative) {
            dataLabelsY = y - textRects.height / 2 - offY;
          } else {
            dataLabelsY = y + textRects.height + offY;
          }

          break;
      }

      return {
        bcx: bcx,
        bcy: y,
        dataLabelsX: dataLabelsX,
        dataLabelsY: dataLabelsY
      };
    }
  }, {
    key: "calculateBarsDataLabelsPosition",
    value: function calculateBarsDataLabelsPosition(opts) {
      var w = this.w;
      var x = opts.x,
          i = opts.i,
          j = opts.j,
          bcy = opts.bcy,
          barHeight = opts.barHeight,
          textRects = opts.textRects,
          dataLabelsX = opts.dataLabelsX,
          strokeWidth = opts.strokeWidth,
          barDataLabelsConfig = opts.barDataLabelsConfig,
          offX = opts.offX,
          offY = opts.offY;
      var dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;
      var dataLabelsY = bcy - dataPointsDividedHeight + barHeight / 2 + textRects.height / 2 + offY - 3;
      var barWidth = this.series[i][j] / this.invertedYRatio;
      var valIsNegative = this.series[i][j] <= 0;

      if (w.config.yaxis[this.yaxisIndex].reversed) {
        x = x + barWidth;
      }

      switch (barDataLabelsConfig.position) {
        case 'center':
          if (valIsNegative) {
            dataLabelsX = x - barWidth / 2 - offX;
          } else {
            dataLabelsX = x - barWidth / 2 + offX;
          }

          break;

        case 'bottom':
          if (valIsNegative) {
            dataLabelsX = x - barWidth - strokeWidth - Math.round(textRects.width / 2) - offX;
          } else {
            dataLabelsX = x - barWidth + strokeWidth + Math.round(textRects.width / 2) + offX;
          }

          break;

        case 'top':
          if (valIsNegative) {
            dataLabelsX = x - strokeWidth + Math.round(textRects.width / 2) - offX;
          } else {
            dataLabelsX = x - strokeWidth - Math.round(textRects.width / 2) + offX;
          }

          break;
      }

      if (dataLabelsX < 0) {
        dataLabelsX = textRects.width + strokeWidth;
      } else if (dataLabelsX + textRects.width / 2 > w.globals.gridWidth) {
        dataLabelsX = dataLabelsX - textRects.width - strokeWidth;
      }

      return {
        bcx: x,
        bcy: bcy,
        dataLabelsX: dataLabelsX,
        dataLabelsY: dataLabelsY
      };
    }
  }, {
    key: "drawCalculatedDataLabels",
    value: function drawCalculatedDataLabels(_ref5) {
      var x = _ref5.x,
          y = _ref5.y,
          val = _ref5.val,
          i = _ref5.i,
          j = _ref5.j,
          dataLabelsConfig = _ref5.dataLabelsConfig;
      var w = this.w;
      var dataLabels = new DataLabels(this.ctx);
      var graphics = new Graphics(this.ctx);
      var formatter = dataLabelsConfig.formatter;
      var elDataLabelsWrap = null;
      var isSeriesNotCollapsed = w.globals.collapsedSeriesIndices.indexOf(i) > -1;

      if (dataLabelsConfig.enabled && !isSeriesNotCollapsed) {
        elDataLabelsWrap = graphics.group({
          class: 'apexcharts-data-labels'
        });
        var text = '';

        if (typeof val !== 'undefined' && val !== null) {
          text = formatter(val, {
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          });
        }

        dataLabels.plotDataLabelsText({
          x: x,
          y: y,
          text: text,
          i: i,
          j: j,
          parent: elDataLabelsWrap,
          dataLabelsConfig: dataLabelsConfig,
          alwaysDrawDataLabel: true,
          offsetCorrection: true
        });
      }

      return elDataLabelsWrap;
    }
  }]);

  return Bar;
}();

/**
 * ApexCharts BarStacked Class responsible for drawing both Stacked Columns and Bars.
 *
 * @module BarStacked
 * The whole calculation for stacked bar/column is different from normal bar/column,
 * hence it makes sense to derive a new class for it extending most of the props of Parent Bar
 **/

var BarStacked =
/*#__PURE__*/
function (_Bar) {
  _inherits(BarStacked, _Bar);

  function BarStacked() {
    _classCallCheck(this, BarStacked);

    return _possibleConstructorReturn(this, _getPrototypeOf(BarStacked).apply(this, arguments));
  }

  _createClass(BarStacked, [{
    key: "draw",
    value: function draw(series, seriesIndex) {
      var _this = this;

      var w = this.w;
      this.graphics = new Graphics(this.ctx);
      this.fill = new Fill(this.ctx);
      this.bar = new Bar(this.ctx, this.xyRatios);
      var coreUtils = new CoreUtils(this.ctx, w);
      this.series = coreUtils.getLogSeries(series);
      series = this.series;
      this.yRatio = coreUtils.getLogYRatios(this.yRatio);
      this.series = series;
      this.initVariables(series);

      if (w.config.chart.stackType === '100%') {
        this.series = w.globals.seriesPercent.slice();
        series = this.series;
      }

      this.totalItems = 0;
      this.prevY = []; // y position on chart

      this.prevX = []; // x position on chart

      this.prevYF = []; // y position including shapes on chart

      this.prevXF = []; // x position including shapes on chart

      this.prevYVal = []; // y values (series[i][j]) in columns

      this.prevXVal = []; // x values (series[i][j]) in bars

      this.xArrj = []; // xj indicates x position on graph in bars

      this.xArrjF = []; // xjF indicates bar's x position + endingshape's positions in bars

      this.xArrjVal = []; // x val means the actual series's y values in horizontal/bars

      this.yArrj = []; // yj indicates y position on graph in columns

      this.yArrjF = []; // yjF indicates bar's y position + endingshape's positions in columns

      this.yArrjVal = []; // y val means the actual series's y values in columns

      for (var sl = 0; sl < series.length; sl++) {
        if (series[sl].length > 0) {
          this.totalItems += series[sl].length;
        }
      }

      var ret = this.graphics.group({
        class: 'apexcharts-bar-series apexcharts-plot-series'
      });
      ret.attr('clip-path', "url(#gridRectMask".concat(w.globals.cuid, ")"));
      var x = 0;
      var y = 0;

      var _loop = function _loop(i, bc) {
        var pathTo = void 0,
            pathFrom = void 0;
        var xDivision = void 0; // xDivision is the GRIDWIDTH divided by number of datapoints (columns)

        var yDivision = void 0; // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)

        var zeroH = void 0; // zeroH is the baseline where 0 meets y axis

        var zeroW = void 0; // zeroW is the baseline where 0 meets x axis

        var xArrValues = [];
        var yArrValues = [];
        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;

        if (_this.yRatio.length > 1) {
          _this.yaxisIndex = realIndex;
        }

        _this.isReversed = w.config.yaxis[_this.yaxisIndex] && w.config.yaxis[_this.yaxisIndex].reversed; // el to which series will be drawn

        var elSeries = _this.graphics.group({
          class: "apexcharts-series ".concat(Utils.escapeString(w.globals.seriesNames[realIndex])),
          rel: i + 1,
          'data:realIndex': realIndex
        }); // eldatalabels


        var elDataLabelsWrap = _this.graphics.group({
          class: 'apexcharts-datalabels'
        });

        var strokeWidth = 0;
        var barHeight = 0;
        var barWidth = 0;

        var initPositions = _this.initialPositions(x, y, xDivision, yDivision, zeroH, zeroW);

        y = initPositions.y;
        barHeight = initPositions.barHeight;
        yDivision = initPositions.yDivision;
        zeroW = initPositions.zeroW;
        x = initPositions.x;
        barWidth = initPositions.barWidth;
        xDivision = initPositions.xDivision;
        zeroH = initPositions.zeroH;
        _this.yArrj = [];
        _this.yArrjF = [];
        _this.yArrjVal = [];
        _this.xArrj = [];
        _this.xArrjF = [];
        _this.xArrjVal = []; // if (!this.horizontal) {
        // this.xArrj.push(x + barWidth / 2)
        // }

        var _loop2 = function _loop2(j) {
          if (w.config.stroke.show) {
            if (_this.isNullValue) {
              strokeWidth = 0;
            } else {
              strokeWidth = Array.isArray(_this.strokeWidth) ? _this.strokeWidth[realIndex] : _this.strokeWidth;
            }
          }

          var paths = null;

          if (_this.isHorizontal) {
            paths = _this.drawBarPaths({
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                bc: bc
              },
              barHeight: barHeight,
              strokeWidth: strokeWidth,
              pathTo: pathTo,
              pathFrom: pathFrom,
              zeroW: zeroW,
              x: x,
              y: y,
              yDivision: yDivision,
              elSeries: elSeries
            });
          } else {
            paths = _this.drawColumnPaths({
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                bc: bc
              },
              x: x,
              y: y,
              xDivision: xDivision,
              pathTo: pathTo,
              pathFrom: pathFrom,
              barWidth: barWidth,
              zeroH: zeroH,
              strokeWidth: strokeWidth,
              elSeries: elSeries
            });
          }

          pathTo = paths.pathTo;
          pathFrom = paths.pathFrom;
          y = paths.y;
          x = paths.x;
          xArrValues.push(x);
          yArrValues.push(y);
          var seriesNumber = w.config.plotOptions.bar.distributed ? j : i;
          var fillColor = null;

          if (_this.barOptions.colors.ranges.length > 0) {
            var colorRange = _this.barOptions.colors.ranges;
            colorRange.map(function (range, index) {
              if (series[i][j] >= range.from && series[i][j] <= range.to) {
                fillColor = range.color;
              }
            });
          }

          var pathFill = _this.fill.fillPath({
            seriesNumber: _this.barOptions.distributed ? seriesNumber : realIndex,
            color: fillColor
          });

          elSeries = _this.renderSeries({
            realIndex: realIndex,
            pathFill: pathFill,
            j: j,
            i: i,
            pathFrom: pathFrom,
            pathTo: pathTo,
            strokeWidth: strokeWidth,
            elSeries: elSeries,
            x: x,
            y: y,
            series: series,
            barHeight: barHeight,
            barWidth: barWidth,
            elDataLabelsWrap: elDataLabelsWrap,
            type: 'bar',
            visibleSeries: 0
          });
        };

        for (var j = 0; j < w.globals.dataPoints; j++) {
          _loop2(j);
        } // push all x val arrays into main xArr


        w.globals.seriesXvalues[realIndex] = xArrValues;
        w.globals.seriesYvalues[realIndex] = yArrValues; // push all current y values array to main PrevY Array

        _this.prevY.push(_this.yArrj);

        _this.prevYF.push(_this.yArrjF);

        _this.prevYVal.push(_this.yArrjVal);

        _this.prevX.push(_this.xArrj);

        _this.prevXF.push(_this.xArrjF);

        _this.prevXVal.push(_this.xArrjVal);

        ret.add(elSeries);
      };

      for (var i = 0, bc = 0; i < series.length; i++, bc++) {
        _loop(i, bc);
      }

      return ret;
    }
  }, {
    key: "initialPositions",
    value: function initialPositions(x, y, xDivision, yDivision, zeroH, zeroW) {
      var w = this.w;
      var barHeight, barWidth;

      if (this.isHorizontal) {
        // height divided into equal parts
        yDivision = w.globals.gridHeight / w.globals.dataPoints;
        barHeight = yDivision;
        barHeight = barHeight * parseInt(w.config.plotOptions.bar.barHeight) / 100;
        zeroW = this.baseLineInvertedY + w.globals.padHorizontal + (this.isReversed ? w.globals.gridWidth : 0) - (this.isReversed ? this.baseLineInvertedY * 2 : 0); // initial y position is half of barHeight * half of number of Bars

        y = (yDivision - barHeight) / 2;
      } else {
        // width divided into equal parts
        xDivision = w.globals.gridWidth / w.globals.dataPoints;
        barWidth = xDivision;

        if (w.globals.isXNumeric) {
          // max barwidth should be equal to minXDiff to avoid overlap
          xDivision = this.minXDiff / this.xRatio;
          barWidth = xDivision * parseInt(this.barOptions.columnWidth) / 100;
        } else {
          barWidth = barWidth * parseInt(w.config.plotOptions.bar.columnWidth) / 100;
        }

        zeroH = this.baseLineY[this.yaxisIndex] + (this.isReversed ? w.globals.gridHeight : 0) - (this.isReversed ? this.baseLineY[this.yaxisIndex] * 2 : 0); // initial x position is one third of barWidth

        x = w.globals.padHorizontal + (xDivision - barWidth) / 2;
      }

      return {
        x: x,
        y: y,
        yDivision: yDivision,
        xDivision: xDivision,
        barHeight: barHeight,
        barWidth: barWidth,
        zeroH: zeroH,
        zeroW: zeroW
      };
    }
  }, {
    key: "drawBarPaths",
    value: function drawBarPaths(_ref) {
      var indexes = _ref.indexes,
          barHeight = _ref.barHeight,
          strokeWidth = _ref.strokeWidth,
          pathTo = _ref.pathTo,
          pathFrom = _ref.pathFrom,
          zeroW = _ref.zeroW,
          x = _ref.x,
          y = _ref.y,
          yDivision = _ref.yDivision,
          elSeries = _ref.elSeries;
      var w = this.w;
      var barYPosition = y;
      var barXPosition;
      var i = indexes.i;
      var j = indexes.j;
      var realIndex = indexes.realIndex;
      var bc = indexes.bc;
      var prevBarW = 0;

      for (var k = 0; k < this.prevXF.length; k++) {
        prevBarW = prevBarW + this.prevXF[k][j];
      }

      if (i > 0) {
        var bXP = zeroW;

        if (this.prevXVal[i - 1][j] < 0) {
          if (this.series[i][j] >= 0) {
            bXP = this.prevX[i - 1][j] + prevBarW - (this.isReversed ? prevBarW : 0) * 2;
          } else {
            bXP = this.prevX[i - 1][j];
          }
        } else if (this.prevXVal[i - 1][j] >= 0) {
          if (this.series[i][j] >= 0) {
            bXP = this.prevX[i - 1][j];
          } else {
            bXP = this.prevX[i - 1][j] - prevBarW + (this.isReversed ? prevBarW : 0) * 2;
          }
        }

        barXPosition = bXP;
      } else {
        // the first series will not have prevX values
        barXPosition = zeroW;
      }

      if (this.series[i][j] === null) {
        x = barXPosition;
      } else {
        x = barXPosition + this.series[i][j] / this.invertedYRatio - (this.isReversed ? this.series[i][j] / this.invertedYRatio : 0) * 2;
      }

      this.xArrj.push(x);
      this.xArrjF.push(Math.abs(barXPosition - x));
      this.xArrjVal.push(this.series[i][j]);
      pathTo = this.graphics.move(barXPosition, barYPosition);
      pathFrom = this.graphics.move(barXPosition, barYPosition);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.bar.getPathFrom(realIndex, j, false);
      }

      pathTo = pathTo + this.graphics.line(x, barYPosition) + this.graphics.line(x, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition);
      pathFrom = pathFrom + this.graphics.line(barXPosition, barYPosition) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition + barHeight - strokeWidth) + this.graphics.line(barXPosition, barYPosition);

      if (w.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && i === 0) {
        if (bc >= w.config.plotOptions.bar.colors.backgroundBarColors.length) {
          bc = 0;
        }

        var bcolor = w.config.plotOptions.bar.colors.backgroundBarColors[bc];
        var rect = this.graphics.drawRect(0, barYPosition, w.globals.gridWidth, barHeight, 0, bcolor, w.config.plotOptions.bar.colors.backgroundBarOpacity);
        elSeries.add(rect);
        rect.node.classList.add('apexcharts-backgroundBar');
      }

      y = y + yDivision;
      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        x: x,
        y: y
      };
    }
  }, {
    key: "drawColumnPaths",
    value: function drawColumnPaths(_ref2) {
      var indexes = _ref2.indexes,
          x = _ref2.x,
          y = _ref2.y,
          xDivision = _ref2.xDivision,
          pathTo = _ref2.pathTo,
          pathFrom = _ref2.pathFrom,
          barWidth = _ref2.barWidth,
          zeroH = _ref2.zeroH,
          strokeWidth = _ref2.strokeWidth,
          elSeries = _ref2.elSeries;
      var w = this.w;
      var i = indexes.i;
      var j = indexes.j;
      var realIndex = indexes.realIndex;
      var bc = indexes.bc;

      if (w.globals.isXNumeric) {
        var seriesVal = w.globals.seriesX[i][j];
        if (!seriesVal) seriesVal = 0;
        x = (seriesVal - w.globals.minX) / this.xRatio - barWidth / 2;
      }

      var barXPosition = x;
      var barYPosition;
      var prevBarH = 0;

      for (var k = 0; k < this.prevYF.length; k++) {
        prevBarH = prevBarH + this.prevYF[k][j];
      }

      if (i > 0 && !w.globals.isXNumeric || i > 0 && w.globals.isXNumeric && w.globals.seriesX[i - 1][j] === w.globals.seriesX[i][j]) {
        var bYP;
        var prevYValue = this.prevY[i - 1][j];

        if (this.prevYVal[i - 1][j] < 0) {
          if (this.series[i][j] >= 0) {
            bYP = prevYValue - prevBarH + (this.isReversed ? prevBarH : 0) * 2;
          } else {
            bYP = prevYValue;
          }
        } else {
          if (this.series[i][j] >= 0) {
            bYP = prevYValue;
          } else {
            bYP = prevYValue + prevBarH - (this.isReversed ? prevBarH : 0) * 2;
          }
        }

        barYPosition = bYP;
      } else {
        // the first series will not have prevY values, also if the prev index's series X doesn't matches the current index's series X, then start from zero
        barYPosition = w.globals.gridHeight - zeroH;
      }

      y = barYPosition - this.series[i][j] / this.yRatio[this.yaxisIndex] + (this.isReversed ? this.series[i][j] / this.yRatio[this.yaxisIndex] : 0) * 2;
      this.yArrj.push(y);
      this.yArrjF.push(Math.abs(barYPosition - y));
      this.yArrjVal.push(this.series[i][j]);
      pathTo = this.graphics.move(barXPosition, barYPosition);
      pathFrom = this.graphics.move(barXPosition, barYPosition);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.bar.getPathFrom(realIndex, j, false);
      }

      pathTo = pathTo + this.graphics.line(barXPosition, y) + this.graphics.line(barXPosition + barWidth - strokeWidth, y) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition, barYPosition);
      pathFrom = pathFrom + this.graphics.line(barXPosition, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition + barWidth - strokeWidth, barYPosition) + this.graphics.line(barXPosition, barYPosition);

      if (w.config.plotOptions.bar.colors.backgroundBarColors.length > 0 && i === 0) {
        if (bc >= w.config.plotOptions.bar.colors.backgroundBarColors.length) {
          bc = 0;
        }

        var bcolor = w.config.plotOptions.bar.colors.backgroundBarColors[bc];
        var rect = this.graphics.drawRect(barXPosition, 0, barWidth, w.globals.gridHeight, 0, bcolor, w.config.plotOptions.bar.colors.backgroundBarOpacity);
        elSeries.add(rect);
        rect.node.classList.add('apexcharts-backgroundBar');
      }

      x = x + xDivision;
      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        x: w.globals.isXNumeric ? x - xDivision : x,
        y: y
      };
    }
  }]);

  return BarStacked;
}(Bar);

/**
 * ApexCharts CandleStick Class responsible for drawing both Stacked Columns and Bars.
 *
 * @module CandleStick
 * The whole calculation for stacked bar/column is different from normal bar/column,
 * hence it makes sense to derive a new class for it extending most of the props of Parent Bar
 **/

var CandleStick =
/*#__PURE__*/
function (_Bar) {
  _inherits(CandleStick, _Bar);

  function CandleStick() {
    _classCallCheck(this, CandleStick);

    return _possibleConstructorReturn(this, _getPrototypeOf(CandleStick).apply(this, arguments));
  }

  _createClass(CandleStick, [{
    key: "draw",
    value: function draw(series, seriesIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var fill = new Fill(this.ctx);
      this.candlestickOptions = this.w.config.plotOptions.candlestick;
      var coreUtils = new CoreUtils(this.ctx, w);
      this.series = coreUtils.getLogSeries(series);
      series = this.series;
      this.yRatio = coreUtils.getLogYRatios(this.yRatio);
      this.initVariables(series);
      var ret = graphics.group({
        class: 'apexcharts-candlestick-series apexcharts-plot-series'
      });
      ret.attr('clip-path', "url(#gridRectMask".concat(w.globals.cuid, ")"));

      for (var i = 0, bc = 0; i < series.length; i++, bc++) {
        var pathTo = void 0,
            pathFrom = void 0;
        var x = void 0,
            y = void 0,
            xDivision = void 0,
            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)
        zeroH = void 0; // zeroH is the baseline where 0 meets y axis

        var yArrj = []; // hold y values of current iterating series

        var xArrj = []; // hold x values of current iterating series

        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i; // el to which series will be drawn

        var elSeries = graphics.group({
          class: "apexcharts-series ".concat(Utils.escapeString(w.globals.seriesNames[realIndex])),
          rel: i + 1,
          'data:realIndex': realIndex
        });

        if (series[i].length > 0) {
          this.visibleI = this.visibleI + 1;
        }

        var strokeWidth = 0;
        var barHeight = 0;
        var barWidth = 0;

        if (this.yRatio.length > 1) {
          this.yaxisIndex = realIndex;
        }

        var initPositions = this.initialPositions();
        y = initPositions.y;
        barHeight = initPositions.barHeight;
        x = initPositions.x;
        barWidth = initPositions.barWidth;
        xDivision = initPositions.xDivision;
        zeroH = initPositions.zeroH;
        xArrj.push(x + barWidth / 2); // eldatalabels

        var elDataLabelsWrap = graphics.group({
          class: 'apexcharts-datalabels'
        });

        for (var j = 0, tj = w.globals.dataPoints; j < w.globals.dataPoints; j++, tj--) {
          if (typeof this.series[i][j] === 'undefined' || series[i][j] === null) {
            this.isNullValue = true;
          } else {
            this.isNullValue = false;
          }

          if (w.config.stroke.show) {
            if (this.isNullValue) {
              strokeWidth = 0;
            } else {
              strokeWidth = Array.isArray(this.strokeWidth) ? this.strokeWidth[realIndex] : this.strokeWidth;
            }
          }

          var color = void 0;
          var paths = this.drawCandleStickPaths({
            indexes: {
              i: i,
              j: j,
              realIndex: realIndex,
              bc: bc
            },
            x: x,
            y: y,
            xDivision: xDivision,
            pathTo: pathTo,
            pathFrom: pathFrom,
            barWidth: barWidth,
            zeroH: zeroH,
            strokeWidth: strokeWidth,
            elSeries: elSeries
          });
          pathTo = paths.pathTo;
          pathFrom = paths.pathFrom;
          y = paths.y;
          x = paths.x;
          color = paths.color; // push current X

          if (j > 0) {
            xArrj.push(x + barWidth / 2);
          }

          yArrj.push(y);
          var pathFill = fill.fillPath({
            seriesNumber: realIndex,
            color: color
          });
          var lineFill = this.candlestickOptions.wick.useFillColor ? color : undefined;
          elSeries = this.renderSeries({
            realIndex: realIndex,
            pathFill: pathFill,
            lineFill: lineFill,
            j: j,
            i: i,
            pathFrom: pathFrom,
            pathTo: pathTo,
            strokeWidth: strokeWidth,
            elSeries: elSeries,
            x: x,
            y: y,
            series: series,
            barHeight: barHeight,
            barWidth: barWidth,
            elDataLabelsWrap: elDataLabelsWrap,
            visibleSeries: this.visibleI,
            type: 'candlestick'
          });
        } // push all x val arrays into main xArr


        w.globals.seriesXvalues[realIndex] = xArrj;
        w.globals.seriesYvalues[realIndex] = yArrj;
        ret.add(elSeries);
      }

      return ret;
    }
  }, {
    key: "drawCandleStickPaths",
    value: function drawCandleStickPaths(_ref) {
      var indexes = _ref.indexes,
          x = _ref.x,
          y = _ref.y,
          xDivision = _ref.xDivision,
          pathTo = _ref.pathTo,
          pathFrom = _ref.pathFrom,
          barWidth = _ref.barWidth,
          zeroH = _ref.zeroH,
          strokeWidth = _ref.strokeWidth;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var i = indexes.i;
      var j = indexes.j;
      var isPositive = true;
      var colorPos = w.config.plotOptions.candlestick.colors.upward;
      var colorNeg = w.config.plotOptions.candlestick.colors.downward;
      var yRatio = this.yRatio[this.yaxisIndex];
      var realIndex = indexes.realIndex;
      var ohlc = this.getOHLCValue(realIndex, j);
      var l1 = zeroH;
      var l2 = zeroH;

      if (ohlc.o > ohlc.c) {
        isPositive = false;
      }

      var y1 = Math.min(ohlc.o, ohlc.c);
      var y2 = Math.max(ohlc.o, ohlc.c);

      if (w.globals.isXNumeric) {
        x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;
      }

      var barXPosition = x + barWidth * this.visibleI;
      pathTo = graphics.move(barXPosition, zeroH);
      pathFrom = graphics.move(barXPosition, zeroH);

      if (w.globals.previousPaths.length > 0) {
        pathFrom = this.getPathFrom(realIndex, j, true);
      }

      if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {
        y1 = zeroH;
      } else {
        y1 = zeroH - y1 / yRatio;
        y2 = zeroH - y2 / yRatio;
        l1 = zeroH - ohlc.h / yRatio;
        l2 = zeroH - ohlc.l / yRatio;
      }

      pathTo = graphics.move(barXPosition, y2) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth / 2, l1) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth, y2) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition + barWidth / 2, l2) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition, y1) + graphics.line(barXPosition, y2 - strokeWidth / 2);

      if (!w.globals.isXNumeric) {
        x = x + xDivision;
      }

      return {
        pathTo: pathTo,
        pathFrom: pathFrom,
        x: x,
        y: y2,
        barXPosition: barXPosition,
        color: isPositive ? colorPos : colorNeg
      };
    }
  }, {
    key: "getOHLCValue",
    value: function getOHLCValue(i, j) {
      var w = this.w;
      return {
        o: w.globals.seriesCandleO[i][j],
        h: w.globals.seriesCandleH[i][j],
        l: w.globals.seriesCandleL[i][j],
        c: w.globals.seriesCandleC[i][j]
      };
    }
  }]);

  return CandleStick;
}(Bar);

var Crosshairs =
/*#__PURE__*/
function () {
  function Crosshairs(ctx) {
    _classCallCheck(this, Crosshairs);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(Crosshairs, [{
    key: "drawXCrosshairs",
    value: function drawXCrosshairs() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var filters = new Filters(this.ctx);
      var crosshairGradient = w.config.xaxis.crosshairs.fill.gradient;
      var crosshairShadow = w.config.xaxis.crosshairs.dropShadow;
      var fillType = w.config.xaxis.crosshairs.fill.type;
      var gradientFrom = crosshairGradient.colorFrom;
      var gradientTo = crosshairGradient.colorTo;
      var opacityFrom = crosshairGradient.opacityFrom;
      var opacityTo = crosshairGradient.opacityTo;
      var stops = crosshairGradient.stops;
      var shadow = 'none';
      var dropShadow = crosshairShadow.enabled;
      var shadowLeft = crosshairShadow.left;
      var shadowTop = crosshairShadow.top;
      var shadowBlur = crosshairShadow.blur;
      var shadowColor = crosshairShadow.color;
      var shadowOpacity = crosshairShadow.opacity;
      var xcrosshairsFill = w.config.xaxis.crosshairs.fill.color;

      if (w.config.xaxis.crosshairs.show) {
        if (fillType === 'gradient') {
          xcrosshairsFill = graphics.drawGradient('vertical', gradientFrom, gradientTo, opacityFrom, opacityTo, null, stops, null);
        }

        var xcrosshairs = graphics.drawRect();

        if (w.config.xaxis.crosshairs.width === 1) {
          // to prevent drawing 2 lines, convert rect to line
          xcrosshairs = graphics.drawLine();
        }

        xcrosshairs.attr({
          class: 'apexcharts-xcrosshairs',
          x: 0,
          y: 0,
          y2: w.globals.gridHeight,
          width: Utils.isNumber(w.config.xaxis.crosshairs.width) ? w.config.xaxis.crosshairs.width : 0,
          height: w.globals.gridHeight,
          fill: xcrosshairsFill,
          filter: shadow,
          'fill-opacity': w.config.xaxis.crosshairs.opacity,
          stroke: w.config.xaxis.crosshairs.stroke.color,
          'stroke-width': w.config.xaxis.crosshairs.stroke.width,
          'stroke-dasharray': w.config.xaxis.crosshairs.stroke.dashArray
        });

        if (dropShadow) {
          xcrosshairs = filters.dropShadow(xcrosshairs, {
            left: shadowLeft,
            top: shadowTop,
            blur: shadowBlur,
            color: shadowColor,
            opacity: shadowOpacity
          });
        }

        w.globals.dom.elGraphical.add(xcrosshairs);
      }
    }
  }, {
    key: "drawYCrosshairs",
    value: function drawYCrosshairs() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var crosshair = w.config.yaxis[0].crosshairs;

      if (w.config.yaxis[0].crosshairs.show) {
        var ycrosshairs = graphics.drawLine(0, 0, w.globals.gridWidth, 0, crosshair.stroke.color, crosshair.stroke.dashArray, crosshair.stroke.width);
        ycrosshairs.attr({
          class: 'apexcharts-ycrosshairs'
        });
        w.globals.dom.elGraphical.add(ycrosshairs);
      } // draw an invisible crosshair to help in positioning the yaxis tooltip


      var ycrosshairsHidden = graphics.drawLine(0, 0, w.globals.gridWidth, 0, crosshair.stroke.color, 0, 0);
      ycrosshairsHidden.attr({
        class: 'apexcharts-ycrosshairs-hidden'
      });
      w.globals.dom.elGraphical.add(ycrosshairsHidden);
    }
  }]);

  return Crosshairs;
}();

/**
 * DateTime Class to manipulate datetime values.
 *
 * @module DateTime
 **/

var DateTime =
/*#__PURE__*/
function () {
  function DateTime(ctx) {
    _classCallCheck(this, DateTime);

    this.ctx = ctx;
    this.w = ctx.w;
    this.months31 = [1, 3, 5, 7, 8, 10, 12];
    this.months30 = [2, 4, 6, 9, 11];
    this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }

  _createClass(DateTime, [{
    key: "isValidDate",
    value: function isValidDate(date) {
      return !isNaN(this.parseDate(date));
    }
  }, {
    key: "getUTCTimeStamp",
    value: function getUTCTimeStamp(dateStr) {
      if (!Date.parse(dateStr)) {
        return dateStr;
      }

      return new Date(new Date(dateStr).toISOString().substr(0, 25)).getTime();
    }
  }, {
    key: "parseDate",
    value: function parseDate(dateStr) {
      var parsed = Date.parse(dateStr);

      if (!isNaN(parsed)) {
        return this.getUTCTimeStamp(dateStr);
      }

      var output = Date.parse(dateStr.replace(/-/g, '/').replace(/[a-z]+/gi, ' '));
      output = this.getUTCTimeStamp(output);
      return output;
    } // https://stackoverflow.com/a/11252167/6495043

  }, {
    key: "treatAsUtc",
    value: function treatAsUtc(dateStr) {
      var result = new Date(dateStr);
      result.setMinutes(result.getMinutes() - result.getTimezoneOffset());
      return result;
    } // http://stackoverflow.com/questions/14638018/current-time-formatting-with-javascript#answer-14638191

  }, {
    key: "formatDate",
    value: function formatDate(date, format) {
      var utc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var convertToUTC = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var locale = this.w.globals.locale;
      var MMMM = ['\x00'].concat(_toConsumableArray(locale.months));
      var MMM = ['\x01'].concat(_toConsumableArray(locale.shortMonths));
      var dddd = ['\x02'].concat(_toConsumableArray(locale.days));
      var ddd = ['\x03'].concat(_toConsumableArray(locale.shortDays));

      function ii(i, len) {
        var s = i + '';
        len = len || 2;

        while (s.length < len) {
          s = '0' + s;
        }

        return s;
      }

      if (convertToUTC) {
        date = this.treatAsUtc(date);
      }

      var y = utc ? date.getUTCFullYear() : date.getFullYear();
      format = format.replace(/(^|[^\\])yyyy+/g, '$1' + y);
      format = format.replace(/(^|[^\\])yy/g, '$1' + y.toString().substr(2, 2));
      format = format.replace(/(^|[^\\])y/g, '$1' + y);
      var M = (utc ? date.getUTCMonth() : date.getMonth()) + 1;
      format = format.replace(/(^|[^\\])MMMM+/g, '$1' + MMMM[0]);
      format = format.replace(/(^|[^\\])MMM/g, '$1' + MMM[0]);
      format = format.replace(/(^|[^\\])MM/g, '$1' + ii(M));
      format = format.replace(/(^|[^\\])M/g, '$1' + M);
      var d = utc ? date.getUTCDate() : date.getDate();
      format = format.replace(/(^|[^\\])dddd+/g, '$1' + dddd[0]);
      format = format.replace(/(^|[^\\])ddd/g, '$1' + ddd[0]);
      format = format.replace(/(^|[^\\])dd/g, '$1' + ii(d));
      format = format.replace(/(^|[^\\])d/g, '$1' + d);
      var H = utc ? date.getUTCHours() : date.getHours();
      format = format.replace(/(^|[^\\])HH+/g, '$1' + ii(H));
      format = format.replace(/(^|[^\\])H/g, '$1' + H);
      var h = H > 12 ? H - 12 : H === 0 ? 12 : H;
      format = format.replace(/(^|[^\\])hh+/g, '$1' + ii(h));
      format = format.replace(/(^|[^\\])h/g, '$1' + h);
      var m = utc ? date.getUTCMinutes() : date.getMinutes();
      format = format.replace(/(^|[^\\])mm+/g, '$1' + ii(m));
      format = format.replace(/(^|[^\\])m/g, '$1' + m);
      var s = utc ? date.getUTCSeconds() : date.getSeconds();
      format = format.replace(/(^|[^\\])ss+/g, '$1' + ii(s));
      format = format.replace(/(^|[^\\])s/g, '$1' + s);
      var f = utc ? date.getUTCMilliseconds() : date.getMilliseconds();
      format = format.replace(/(^|[^\\])fff+/g, '$1' + ii(f, 3));
      f = Math.round(f / 10);
      format = format.replace(/(^|[^\\])ff/g, '$1' + ii(f));
      f = Math.round(f / 10);
      format = format.replace(/(^|[^\\])f/g, '$1' + f);
      var T = H < 12 ? 'AM' : 'PM';
      format = format.replace(/(^|[^\\])TT+/g, '$1' + T);
      format = format.replace(/(^|[^\\])T/g, '$1' + T.charAt(0));
      var t = T.toLowerCase();
      format = format.replace(/(^|[^\\])tt+/g, '$1' + t);
      format = format.replace(/(^|[^\\])t/g, '$1' + t.charAt(0));
      var tz = -date.getTimezoneOffset();
      var K = utc || !tz ? 'Z' : tz > 0 ? '+' : '-';

      if (!utc) {
        tz = Math.abs(tz);
        var tzHrs = Math.floor(tz / 60);
        var tzMin = tz % 60;
        K += ii(tzHrs) + ':' + ii(tzMin);
      }

      format = format.replace(/(^|[^\\])K/g, '$1' + K);
      var day = (utc ? date.getUTCDay() : date.getDay()) + 1;
      format = format.replace(new RegExp(dddd[0], 'g'), dddd[day]);
      format = format.replace(new RegExp(ddd[0], 'g'), ddd[day]);
      format = format.replace(new RegExp(MMMM[0], 'g'), MMMM[M]);
      format = format.replace(new RegExp(MMM[0], 'g'), MMM[M]);
      format = format.replace(/\\(.)/g, '$1');
      return format;
    }
  }, {
    key: "getTimeUnitsfromTimestamp",
    value: function getTimeUnitsfromTimestamp(minX, maxX) {
      var w = this.w;

      if (w.config.xaxis.min !== undefined) {
        minX = w.config.xaxis.min;
      }

      if (w.config.xaxis.max !== undefined) {
        maxX = w.config.xaxis.max;
      }

      var minYear = new Date(minX).getFullYear();
      var maxYear = new Date(maxX).getFullYear();
      var minMonth = new Date(minX).getMonth();
      var maxMonth = new Date(maxX).getMonth();
      var minDate = new Date(minX).getDate();
      var maxDate = new Date(maxX).getDate();
      var minHour = new Date(minX).getHours();
      var maxHour = new Date(maxX).getHours();
      var minMinute = new Date(minX).getMinutes();
      var maxMinute = new Date(maxX).getMinutes();
      return {
        minMinute: minMinute,
        maxMinute: maxMinute,
        minHour: minHour,
        maxHour: maxHour,
        minDate: minDate,
        maxDate: maxDate,
        minMonth: minMonth,
        maxMonth: maxMonth,
        minYear: minYear,
        maxYear: maxYear
      };
    }
  }, {
    key: "isLeapYear",
    value: function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
  }, {
    key: "calculcateLastDaysOfMonth",
    value: function calculcateLastDaysOfMonth(month, year, subtract) {
      var days = this.determineDaysOfMonths(month, year); // whatever days we get, subtract the number of days asked

      return days - subtract;
    }
  }, {
    key: "determineDaysOfYear",
    value: function determineDaysOfYear(year) {
      var days = 365;

      if (this.isLeapYear(year)) {
        days = 366;
      }

      return days;
    }
  }, {
    key: "determineRemainingDaysOfYear",
    value: function determineRemainingDaysOfYear(year, month, date) {
      var dayOfYear = this.daysCntOfYear[month] + date;
      if (month > 1 && this.isLeapYear()) dayOfYear++;
      return dayOfYear;
    }
  }, {
    key: "determineDaysOfMonths",
    value: function determineDaysOfMonths(month, year) {
      var days = 30;
      month = Utils.monthMod(month);

      switch (true) {
        case this.months30.indexOf(month) > -1:
          if (month === 2) {
            if (this.isLeapYear(year)) {
              days = 29;
            } else {
              days = 28;
            }
          }

          break;

        case this.months31.indexOf(month) > -1:
          days = 31;
          break;

        default:
          days = 31;
          break;
      }

      return days;
    }
  }]);

  return DateTime;
}();

/**
 * ApexCharts HeatMap Class.
 * @module HeatMap
 **/

var HeatMap =
/*#__PURE__*/
function () {
  function HeatMap(ctx, xyRatios) {
    _classCallCheck(this, HeatMap);

    this.ctx = ctx;
    this.w = ctx.w;
    this.xRatio = xyRatios.xRatio;
    this.yRatio = xyRatios.yRatio;
    this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation;
    this.rectRadius = this.w.config.plotOptions.heatmap.radius;
    this.strokeWidth = this.w.config.stroke.width;
  }

  _createClass(HeatMap, [{
    key: "draw",
    value: function draw(series) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var ret = graphics.group({
        class: 'apexcharts-heatmap'
      });
      ret.attr('clip-path', "url(#gridRectMask".concat(w.globals.cuid, ")")); // width divided into equal parts

      var xDivision = w.globals.gridWidth / w.globals.dataPoints;
      var yDivision = w.globals.gridHeight / w.globals.series.length;
      var y1 = 0;
      var rev = false;
      var heatSeries = series.slice();

      if (w.config.yaxis[0].reversed) {
        rev = true;
        heatSeries.reverse();
      }

      for (var i = rev ? 0 : heatSeries.length - 1; rev ? i < heatSeries.length : i >= 0; rev ? i++ : i--) {
        // el to which series will be drawn
        var elSeries = graphics.group({
          class: "apexcharts-series apexcharts-heatmap-series ".concat(Utils.escapeString(w.globals.seriesNames[i])),
          rel: i + 1,
          'data:realIndex': i
        });

        if (w.config.chart.dropShadow.enabled) {
          var shadow = w.config.chart.dropShadow;
          var filters = new Filters(this.ctx);
          filters.dropShadow(elSeries, shadow);
        }

        var x1 = 0;

        for (var j = 0; j < heatSeries[i].length; j++) {
          var colorShadePercent = 1;
          var heatColorProps = this.determineHeatColor(i, j);

          if (w.globals.hasNegs) {
            var shadeIntensity = w.config.plotOptions.heatmap.shadeIntensity;

            if (heatColorProps.percent < 0) {
              colorShadePercent = 1 - (1 + heatColorProps.percent / 100) * shadeIntensity;
            } else {
              colorShadePercent = (1 - heatColorProps.percent / 100) * shadeIntensity;
            }
          } else {
            colorShadePercent = 1 - heatColorProps.percent / 100;
          }

          var color = heatColorProps.color;

          if (w.config.plotOptions.heatmap.enableShades) {
            var utils = new Utils();
            color = Utils.hexToRgba(utils.shadeColor(colorShadePercent, heatColorProps.color), w.config.fill.opacity);
          }

          var radius = this.rectRadius;
          var rect = graphics.drawRect(x1, y1, xDivision, yDivision, radius);
          rect.attr({
            cx: x1,
            cy: y1
          });
          rect.node.classList.add('apexcharts-heatmap-rect');
          elSeries.add(rect);
          rect.attr({
            fill: color,
            i: i,
            index: i,
            j: j,
            val: heatSeries[i][j],
            'stroke-width': this.strokeWidth,
            stroke: w.globals.stroke.colors[0],
            color: color
          });
          rect.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, rect));
          rect.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, rect));
          rect.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, rect));

          if (w.config.chart.animations.enabled && !w.globals.dataChanged) {
            var speed = 1;

            if (!w.globals.resized) {
              speed = w.config.chart.animations.speed;
            }

            this.animateHeatMap(rect, x1, y1, xDivision, yDivision, speed);
          }

          if (w.globals.dataChanged) {
            var _speed = 1;

            if (this.dynamicAnim.enabled && w.globals.shouldAnimate) {
              _speed = this.dynamicAnim.speed;
              var colorFrom = w.globals.previousPaths[i] && w.globals.previousPaths[i][j] && w.globals.previousPaths[i][j].color;
              if (!colorFrom) colorFrom = 'rgba(255, 255, 255, 0)';
              this.animateHeatColor(rect, Utils.isColorHex(colorFrom) ? colorFrom : Utils.rgb2hex(colorFrom), Utils.isColorHex(color) ? color : Utils.rgb2hex(color), _speed);
            }
          }

          var dataLabels = this.calculateHeatmapDataLabels({
            x: x1,
            y: y1,
            i: i,
            j: j,
            series: heatSeries,
            rectHeight: yDivision,
            rectWidth: xDivision
          });

          if (dataLabels !== null) {
            elSeries.add(dataLabels);
          }

          x1 = x1 + xDivision;
        }

        y1 = y1 + yDivision;
        ret.add(elSeries);
      } // adjust yaxis labels for heatmap


      var yAxisScale = w.globals.yAxisScale[0].result.slice();

      if (w.config.yaxis[0].reversed) {
        yAxisScale.unshift('');
      } else {
        yAxisScale.push('');
      }

      w.globals.yAxisScale[0].result = yAxisScale;
      var divisor = w.globals.gridHeight / w.globals.series.length;
      w.config.yaxis[0].labels.offsetY = -(divisor / 2);
      return ret;
    }
  }, {
    key: "determineHeatColor",
    value: function determineHeatColor(i, j) {
      var w = this.w;
      var val = w.globals.series[i][j];
      var heatmap = w.config.plotOptions.heatmap;
      var seriesNumber = heatmap.colorScale.inverse ? j : i;
      var color = w.globals.colors[seriesNumber];
      var min = Math.min.apply(Math, _toConsumableArray(w.globals.series[i]));
      var max = Math.max.apply(Math, _toConsumableArray(w.globals.series[i]));

      if (!heatmap.distributed) {
        min = w.globals.minY;
        max = w.globals.maxY;
      }

      if (typeof heatmap.colorScale.min !== 'undefined') {
        min = heatmap.colorScale.min < w.globals.minY ? heatmap.colorScale.min : w.globals.minY;
        max = heatmap.colorScale.max > w.globals.maxY ? heatmap.colorScale.max : w.globals.maxY;
      }

      var total = Math.abs(max) + Math.abs(min);
      var percent = 100 * val / (total === 0 ? total - 0.000001 : total);

      if (heatmap.colorScale.ranges.length > 0) {
        var colorRange = heatmap.colorScale.ranges;
        colorRange.map(function (range, index) {
          if (val >= range.from && val <= range.to) {
            color = range.color;
            min = range.from;
            max = range.to;
            total = Math.abs(max) + Math.abs(min);
            percent = 100 * val / total;
          }
        });
      }

      return {
        color: color,
        percent: percent
      };
    }
  }, {
    key: "calculateHeatmapDataLabels",
    value: function calculateHeatmapDataLabels(_ref) {
      var x = _ref.x,
          y = _ref.y,
          i = _ref.i,
          j = _ref.j,
          series = _ref.series,
          rectHeight = _ref.rectHeight,
          rectWidth = _ref.rectWidth;
      var w = this.w; // let graphics = new Graphics(this.ctx)

      var dataLabelsConfig = w.config.dataLabels;
      var graphics = new Graphics(this.ctx);
      var dataLabels = new DataLabels(this.ctx);
      var formatter = dataLabelsConfig.formatter;
      var elDataLabelsWrap = null;

      if (dataLabelsConfig.enabled) {
        elDataLabelsWrap = graphics.group({
          class: 'apexcharts-data-labels'
        });
        var offX = dataLabelsConfig.offsetX;
        var offY = dataLabelsConfig.offsetY;
        var dataLabelsX = x + rectWidth / 2 + offX;
        var dataLabelsY = y + rectHeight / 2 + parseInt(dataLabelsConfig.style.fontSize) / 3 + offY;
        var text = formatter(w.globals.series[i][j], {
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        });
        dataLabels.plotDataLabelsText({
          x: dataLabelsX,
          y: dataLabelsY,
          text: text,
          i: i,
          j: j,
          parent: elDataLabelsWrap,
          dataLabelsConfig: dataLabelsConfig
        });
      }

      return elDataLabelsWrap;
    }
  }, {
    key: "animateHeatMap",
    value: function animateHeatMap(el, x, y, width, height, speed) {
      var _this = this;

      var animations = new Animations(this.ctx);
      animations.animateRect(el, {
        x: x + width / 2,
        y: y + height / 2,
        width: 0,
        height: 0
      }, {
        x: x,
        y: y,
        width: width,
        height: height
      }, speed, function () {
        _this.w.globals.animationEnded = true;
      });
    }
  }, {
    key: "animateHeatColor",
    value: function animateHeatColor(el, colorFrom, colorTo, speed) {
      el.attr({
        fill: colorFrom
      }).animate(speed).attr({
        fill: colorTo
      });
    }
  }]);

  return HeatMap;
}();

/**
 * ApexCharts Pie Class for drawing Pie / Donut Charts.
 * @module Pie
 **/

var Pie =
/*#__PURE__*/
function () {
  function Pie(ctx) {
    _classCallCheck(this, Pie);

    this.ctx = ctx;
    this.w = ctx.w;
    this.chartType = this.w.config.chart.type;
    this.initialAnim = this.w.config.chart.animations.enabled;
    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    this.animBeginArr = [0];
    this.animDur = 0;
    this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels;
    var w = this.w;
    this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;
    this.defaultSize = w.globals.svgHeight < w.globals.svgWidth ? w.globals.svgHeight - 35 : w.globals.gridWidth;
    this.centerY = this.defaultSize / 2;
    this.centerX = w.globals.gridWidth / 2;
    this.fullAngle = 360;
    this.size = 0;
    this.donutSize = 0;
    this.sliceLabels = [];
    this.prevSectorAngleArr = []; // for dynamic animations
  }

  _createClass(Pie, [{
    key: "draw",
    value: function draw(series) {
      var self = this;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var ret = graphics.group({
        class: 'apexcharts-pie'
      });
      var total = 0;

      for (var k = 0; k < series.length; k++) {
        // CALCULATE THE TOTAL
        total += Utils.negToZero(series[k]);
      }

      var sectorAngleArr = []; // el to which series will be drawn

      var elSeries = graphics.group(); // prevent division by zero error if there is no data

      if (total === 0) {
        total = 0.00001;
      }

      for (var i = 0; i < series.length; i++) {
        // CALCULATE THE ANGLES
        var angle = this.fullAngle * Utils.negToZero(series[i]) / total;
        sectorAngleArr.push(angle);
      }

      if (w.globals.dataChanged) {
        var prevTotal = 0;

        for (var _k = 0; _k < w.globals.previousPaths.length; _k++) {
          // CALCULATE THE PREV TOTAL
          prevTotal += Utils.negToZero(w.globals.previousPaths[_k]);
        }

        var previousAngle;

        for (var _i = 0; _i < w.globals.previousPaths.length; _i++) {
          // CALCULATE THE PREVIOUS ANGLES
          previousAngle = this.fullAngle * Utils.negToZero(w.globals.previousPaths[_i]) / prevTotal;
          this.prevSectorAngleArr.push(previousAngle);
        }
      }

      this.size = this.defaultSize / 2.05 - w.config.stroke.width - w.config.chart.dropShadow.blur;

      if (w.config.plotOptions.pie.size !== undefined) {
        this.size = w.config.plotOptions.pie.size;
      }

      this.donutSize = this.size * parseInt(w.config.plotOptions.pie.donut.size) / 100;
      var scaleSize = w.config.plotOptions.pie.customScale;
      var halfW = w.globals.gridWidth / 2;
      var halfH = w.globals.gridHeight / 2;
      var translateX = halfW - w.globals.gridWidth / 2 * scaleSize;
      var translateY = halfH - w.globals.gridHeight / 2 * scaleSize;

      if (this.donutDataLabels.show) {
        var dataLabels = this.renderInnerDataLabels(this.donutDataLabels, {
          hollowSize: this.donutSize,
          centerX: this.centerX,
          centerY: this.centerY,
          opacity: this.donutDataLabels.show,
          translateX: translateX,
          translateY: translateY
        });
        ret.add(dataLabels);
      }

      if (w.config.chart.type === 'donut') {
        // draw the inner circle and add some text to it
        var circle = graphics.drawCircle(this.donutSize);
        circle.attr({
          cx: this.centerX,
          cy: this.centerY,
          fill: w.config.plotOptions.pie.donut.background
        });
        elSeries.add(circle);
      }

      var elG = self.drawArcs(sectorAngleArr, series); // add slice dataLabels at the end

      this.sliceLabels.forEach(function (s) {
        elG.add(s);
      });
      elSeries.attr({
        transform: "translate(".concat(translateX, ", ").concat(translateY - 5, ") scale(").concat(scaleSize, ")")
      });
      ret.attr({
        'data:innerTranslateX': translateX,
        'data:innerTranslateY': translateY - 25
      });
      elSeries.add(elG);
      ret.add(elSeries);
      return ret;
    } // core function for drawing pie arcs

  }, {
    key: "drawArcs",
    value: function drawArcs(sectorAngleArr, series) {
      var w = this.w;
      var filters = new Filters(this.ctx);
      var graphics = new Graphics(this.ctx);
      var fill = new Fill(this.ctx);
      var g = graphics.group();
      var startAngle = 0;
      var prevStartAngle = 0;
      var endAngle = 0;
      var prevEndAngle = 0;
      this.strokeWidth = w.config.stroke.show ? w.config.stroke.width : 0;

      for (var i = 0; i < sectorAngleArr.length; i++) {
        // if(sectorAngleArr[i]>0) {
        var elPieArc = graphics.group({
          class: "apexcharts-series apexcharts-pie-series ".concat(Utils.escapeString(w.globals.seriesNames[i])),
          id: 'apexcharts-series-' + i,
          rel: i + 1
        });
        g.add(elPieArc);
        startAngle = endAngle;
        prevStartAngle = prevEndAngle;
        endAngle = startAngle + sectorAngleArr[i];
        prevEndAngle = prevStartAngle + this.prevSectorAngleArr[i];
        var angle = endAngle - startAngle;
        var pathFill = fill.fillPath({
          seriesNumber: i,
          size: this.size
        }); // additionaly, pass size for gradient drawing in the fillPath function

        var path = this.getChangedPath(prevStartAngle, prevEndAngle);
        var elPath = graphics.drawPath({
          d: path,
          stroke: this.lineColorArr instanceof Array ? this.lineColorArr[i] : this.lineColorArr,
          strokeWidth: this.strokeWidth,
          fill: pathFill,
          fillOpacity: w.config.fill.opacity,
          classes: 'apexcharts-pie-area'
        });
        elPath.attr({
          id: "apexcharts-".concat(w.config.chart.type, "-slice-").concat(i),
          index: 0,
          j: i
        });

        if (w.config.chart.dropShadow.enabled) {
          var shadow = w.config.chart.dropShadow;
          filters.dropShadow(elPath, shadow);
        }

        this.addListeners(elPath, this.donutDataLabels);
        Graphics.setAttrs(elPath.node, {
          'data:angle': angle,
          'data:startAngle': startAngle,
          'data:strokeWidth': this.strokeWidth,
          'data:value': series[i]
        });
        var labelPosition = {
          x: 0,
          y: 0
        };

        if (w.config.chart.type === 'pie') {
          labelPosition = Utils.polarToCartesian(this.centerX, this.centerY, this.size / 1.25 + w.config.plotOptions.pie.dataLabels.offset, startAngle + (endAngle - startAngle) / 2);
        } else if (w.config.chart.type === 'donut') {
          labelPosition = Utils.polarToCartesian(this.centerX, this.centerY, (this.size + this.donutSize) / 2 + w.config.plotOptions.pie.dataLabels.offset, startAngle + (endAngle - startAngle) / 2);
        }

        elPieArc.add(elPath); // Animation code starts

        var dur = 0;

        if (this.initialAnim && !w.globals.resized && !w.globals.dataChanged) {
          dur = (endAngle - startAngle) / this.fullAngle * w.config.chart.animations.speed;
          this.animDur = dur + this.animDur;
          this.animBeginArr.push(this.animDur);
        } else {
          this.animBeginArr.push(0);
        }

        if (this.dynamicAnim && w.globals.dataChanged) {
          this.animatePaths(elPath, {
            endAngle: endAngle,
            startAngle: startAngle,
            prevStartAngle: prevStartAngle,
            prevEndAngle: prevEndAngle,
            animateStartingPos: true,
            i: i,
            animBeginArr: this.animBeginArr,
            dur: w.config.chart.animations.dynamicAnimation.speed
          });
        } else {
          this.animatePaths(elPath, {
            endAngle: endAngle,
            startAngle: startAngle,
            i: i,
            totalItems: sectorAngleArr.length - 1,
            animBeginArr: this.animBeginArr,
            dur: dur
          });
        } // animation code ends


        if (w.config.plotOptions.pie.expandOnClick) {
          elPath.click(this.pieClicked.bind(this, i));
        }

        if (w.config.dataLabels.enabled) {
          var xPos = labelPosition.x;
          var yPos = labelPosition.y;
          var text = 100 * (endAngle - startAngle) / 360 + '%';

          if (angle !== 0) {
            var formatter = w.config.dataLabels.formatter;

            if (formatter !== undefined) {
              text = formatter(w.globals.seriesPercent[i][0], {
                seriesIndex: i,
                w: w
              });
            }

            var foreColor = w.globals.dataLabels.style.colors[i];
            var elPieLabel = graphics.drawText({
              x: xPos,
              y: yPos,
              text: text,
              textAnchor: 'middle',
              fontSize: w.config.dataLabels.style.fontSize,
              fontFamily: w.config.dataLabels.style.fontFamily,
              foreColor: foreColor
            });

            if (w.config.dataLabels.dropShadow.enabled) {
              var textShadow = w.config.dataLabels.dropShadow;

              var _filters = new Filters(this.ctx);

              _filters.dropShadow(elPieLabel, textShadow);
            }

            elPieLabel.node.classList.add('apexcharts-pie-label');

            if (w.config.chart.animations.animate && w.globals.resized === false) {
              elPieLabel.node.classList.add('apexcharts-pie-label-delay');
              elPieLabel.node.style.animationDelay = w.config.chart.animations.speed / 940 + 's';
            }

            this.sliceLabels.push(elPieLabel);
          }
        } // }

      }

      return g;
    }
  }, {
    key: "addListeners",
    value: function addListeners(elPath, dataLabels) {
      var graphics = new Graphics(this.ctx); // append filters on mouseenter and mouseleave

      elPath.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, elPath));
      elPath.node.addEventListener('mouseenter', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));
      elPath.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, elPath));
      elPath.node.addEventListener('mouseleave', this.revertDataLabelsInner.bind(this, elPath.node, dataLabels));
      elPath.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, elPath));
      elPath.node.addEventListener('mousedown', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));
    } // This function can be used for other circle charts too

  }, {
    key: "animatePaths",
    value: function animatePaths(el, opts) {
      var w = this.w;
      var me = this;
      var angle = opts.endAngle - opts.startAngle;
      var prevAngle = angle;
      var fromStartAngle = opts.startAngle;
      var toStartAngle = opts.startAngle;

      if (opts.prevStartAngle !== undefined && opts.prevEndAngle !== undefined) {
        fromStartAngle = opts.prevEndAngle;
        prevAngle = opts.prevEndAngle - opts.prevStartAngle;
      }

      if (opts.i === w.config.series.length - 1) {
        // some adjustments for the last overlapping paths
        if (angle + toStartAngle > this.fullAngle) {
          opts.endAngle = opts.endAngle - (angle + toStartAngle);
        } else if (angle + toStartAngle < this.fullAngle) {
          opts.endAngle = opts.endAngle + (this.fullAngle - (angle + toStartAngle));
        }
      }

      if (angle === this.fullAngle) angle = this.fullAngle - 0.01;
      me.animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts);
    }
  }, {
    key: "animateArc",
    value: function animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts) {
      var me = this;
      var w = this.w;
      var size = me.size;

      if (!size) {
        size = opts.size;
      }

      var path;

      if (isNaN(fromStartAngle) || isNaN(prevAngle)) {
        fromStartAngle = toStartAngle;
        prevAngle = angle;
        opts.dur = 0;
      }

      var currAngle = angle;
      var startAngle = toStartAngle;
      var fromAngle = fromStartAngle - toStartAngle;

      if (w.globals.dataChanged && opts.shouldSetPrevPaths) {
        // to avoid flickering, set prev path first and then we will animate from there
        path = me.getPiePath({
          me: me,
          startAngle: startAngle,
          angle: prevAngle,
          size: size
        });
        el.attr({
          d: path
        });
      }

      if (opts.dur !== 0) {
        el.animate(opts.dur, w.globals.easing, opts.animBeginArr[opts.i]).afterAll(function () {
          if (w.config.chart.type === 'pie' || w.config.chart.type === 'donut') {
            this.animate(300).attr({
              'stroke-width': w.config.stroke.width
            });
          }

          w.globals.animationEnded = true;
        }).during(function (pos) {
          currAngle = fromAngle + (angle - fromAngle) * pos;

          if (opts.animateStartingPos) {
            currAngle = prevAngle + (angle - prevAngle) * pos;
            startAngle = fromStartAngle - prevAngle + (toStartAngle - (fromStartAngle - prevAngle)) * pos;
          }

          path = me.getPiePath({
            me: me,
            startAngle: startAngle,
            angle: currAngle,
            size: size
          });
          el.node.setAttribute('data:pathOrig', path);
          el.attr({
            d: path
          });
        });
      } else {
        path = me.getPiePath({
          me: me,
          startAngle: startAngle,
          angle: angle,
          size: size
        });

        if (!opts.isTrack) {
          w.globals.animationEnded = true;
        }

        el.node.setAttribute('data:pathOrig', path);
        el.attr({
          d: path
        });
      }
    }
  }, {
    key: "pieClicked",
    value: function pieClicked(i) {
      var w = this.w;
      var me = this;
      var path;
      var size = me.size + 4;
      var elPath = w.globals.dom.Paper.select("#apexcharts-".concat(w.config.chart.type.toLowerCase(), "-slice-").concat(i)).members[0];
      var pathFrom = elPath.attr('d');

      if (elPath.attr('data:pieClicked') === 'true') {
        elPath.attr({
          'data:pieClicked': 'false'
        });
        var origPath = elPath.attr('data:pathOrig');
        elPath.attr({
          d: origPath
        });
        return;
      } else {
        // reset all elems
        var allEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-pie-area');
        Array.prototype.forEach.call(allEls, function (pieSlice) {
          pieSlice.setAttribute('data:pieClicked', 'false');
          var origPath = pieSlice.getAttribute('data:pathOrig');
          pieSlice.setAttribute('d', origPath);
        });
        elPath.attr('data:pieClicked', 'true');
      }

      var startAngle = parseInt(elPath.attr('data:startAngle'));
      var angle = parseInt(elPath.attr('data:angle'));
      path = me.getPiePath({
        me: me,
        startAngle: startAngle,
        angle: angle,
        size: size
      });
      if (angle === 360) return;
      elPath.plot(path).animate(1).plot(pathFrom).animate(100).plot(path);
    }
  }, {
    key: "getChangedPath",
    value: function getChangedPath(prevStartAngle, prevEndAngle) {
      var path = '';

      if (this.dynamicAnim && this.w.globals.dataChanged) {
        path = this.getPiePath({
          me: this,
          startAngle: prevStartAngle,
          angle: prevEndAngle - prevStartAngle,
          size: this.size
        });
      }

      return path;
    }
  }, {
    key: "getPiePath",
    value: function getPiePath(_ref) {
      var me = _ref.me,
          startAngle = _ref.startAngle,
          angle = _ref.angle,
          size = _ref.size;
      var w = this.w;
      var path;
      var startDeg = startAngle;
      var startRadians = Math.PI * (startDeg - 90) / 180;
      var endDeg = angle + startAngle;
      if (Math.ceil(endDeg) >= 360) endDeg = 359.99;
      var endRadians = Math.PI * (endDeg - 90) / 180;
      var x1 = me.centerX + size * Math.cos(startRadians);
      var y1 = me.centerY + size * Math.sin(startRadians);
      var x2 = me.centerX + size * Math.cos(endRadians);
      var y2 = me.centerY + size * Math.sin(endRadians);
      var startInner = Utils.polarToCartesian(me.centerX, me.centerY, me.donutSize, endDeg);
      var endInner = Utils.polarToCartesian(me.centerX, me.centerY, me.donutSize, startDeg);
      var largeArc = angle > 180 ? 1 : 0;

      if (w.config.chart.type === 'donut') {
        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2, 'L', startInner.x, startInner.y, 'A', me.donutSize, me.donutSize, 0, largeArc, 0, endInner.x, endInner.y, 'L', x1, y1, 'z'].join(' ');
      } else if (w.config.chart.type === 'pie') {
        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2, 'L', me.centerX, me.centerY, 'L', x1, y1].join(' ');
      } else {
        path = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2].join(' ');
      }

      return path;
    }
  }, {
    key: "renderInnerDataLabels",
    value: function renderInnerDataLabels(dataLabelsConfig, opts) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var g = graphics.group({
        class: 'apexcharts-datalabels-group',
        transform: "translate(".concat(opts.translateX ? opts.translateX : 0, ", ").concat(opts.translateY ? opts.translateY : 0, ")")
      });
      var showTotal = dataLabelsConfig.total.show;
      g.node.style.opacity = opts.opacity;
      var x = opts.centerX;
      var y = opts.centerY;
      var labelColor, valueColor;

      if (dataLabelsConfig.name.color === undefined) {
        labelColor = w.globals.colors[0];
      } else {
        labelColor = dataLabelsConfig.name.color;
      }

      if (dataLabelsConfig.value.color === undefined) {
        valueColor = w.config.chart.foreColor;
      } else {
        valueColor = dataLabelsConfig.value.color;
      }

      var lbFormatter = dataLabelsConfig.value.formatter;
      var val = '';
      var name = '';

      if (showTotal) {
        labelColor = dataLabelsConfig.total.color;
        name = dataLabelsConfig.total.label;
        val = dataLabelsConfig.total.formatter(w);
      } else {
        if (w.globals.series.length === 1) {
          val = lbFormatter(w.globals.series[0], w);
          name = w.globals.seriesNames[0];
        }
      }

      if (dataLabelsConfig.name.show) {
        var elLabel = graphics.drawText({
          x: x,
          y: y + parseInt(dataLabelsConfig.name.offsetY),
          text: name,
          textAnchor: 'middle',
          foreColor: labelColor,
          fontSize: dataLabelsConfig.name.fontSize,
          fontFamily: dataLabelsConfig.name.fontFamily
        });
        elLabel.node.classList.add('apexcharts-datalabel-label');
        g.add(elLabel);
      }

      if (dataLabelsConfig.value.show) {
        var valOffset = dataLabelsConfig.name.show ? parseInt(dataLabelsConfig.value.offsetY) + 16 : dataLabelsConfig.value.offsetY;
        var elValue = graphics.drawText({
          x: x,
          y: y + valOffset,
          text: val,
          textAnchor: 'middle',
          foreColor: valueColor,
          fontSize: dataLabelsConfig.value.fontSize,
          fontFamily: dataLabelsConfig.value.fontFamily
        });
        elValue.node.classList.add('apexcharts-datalabel-value');
        g.add(elValue);
      } // for a multi-series circle chart, we need to show total value instead of first series labels


      return g;
    }
    /**
     *
     * @param {string} name - The name of the series
     * @param {string} val - The value of that series
     * @param {object} el - Optional el (indicates which series was hovered/clicked). If this param is not present, means we need to show total
     */

  }, {
    key: "printInnerLabels",
    value: function printInnerLabels(labelsConfig, name, val, el) {
      var w = this.w;
      var labelColor;

      if (el) {
        if (labelsConfig.name.color === undefined) {
          labelColor = w.globals.colors[parseInt(el.parentNode.getAttribute('rel')) - 1];
        } else {
          labelColor = labelsConfig.name.color;
        }
      } else {
        if (w.globals.series.length > 1 && labelsConfig.total.show) {
          labelColor = labelsConfig.total.color;
        }
      }

      var elLabel = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-label');
      var elValue = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-value');
      var lbFormatter = labelsConfig.value.formatter;
      val = lbFormatter(val, w); // we need to show Total Val - so get the formatter of it

      if (!el && typeof labelsConfig.total.formatter === 'function') {
        val = labelsConfig.total.formatter(w);
      }

      if (elLabel !== null) {
        elLabel.textContent = name;
      }

      if (elValue !== null) {
        elValue.textContent = val;
      }

      if (elLabel !== null) {
        elLabel.style.fill = labelColor;
      }
    }
  }, {
    key: "printDataLabelsInner",
    value: function printDataLabelsInner(el, dataLabelsConfig) {
      var w = this.w;
      var val = el.getAttribute('data:value');
      var name = w.globals.seriesNames[parseInt(el.parentNode.getAttribute('rel')) - 1];

      if (w.globals.series.length > 1) {
        this.printInnerLabels(dataLabelsConfig, name, val, el);
      }

      var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');

      if (dataLabelsGroup !== null) {
        dataLabelsGroup.style.opacity = 1;
      }
    }
  }, {
    key: "revertDataLabelsInner",
    value: function revertDataLabelsInner(el, dataLabelsConfig) {
      var w = this.w;
      var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');

      if (dataLabelsConfig.total.show && w.globals.series.length > 1) {
        var pie = new Pie(this.ctx);
        pie.printInnerLabels(dataLabelsConfig, dataLabelsConfig.total.label, dataLabelsConfig.total.formatter(w));
      } else {
        if (w.globals.selectedDataPoints.length && w.globals.series.length > 1) {
          if (w.globals.selectedDataPoints[0].length > 0) {
            var index = w.globals.selectedDataPoints[0];

            var _el = w.globals.dom.baseEl.querySelector("#apexcharts-".concat(w.config.chart.type.toLowerCase(), "-slice-").concat(index));

            this.printDataLabelsInner(_el, dataLabelsConfig);
          } else if (w.globals.selectedDataPoints.length && w.globals.selectedDataPoints[0].length === 0) {
            dataLabelsGroup.style.opacity = 0;
          }
        } else {
          if (dataLabelsGroup !== null && w.globals.series.length > 1) {
            dataLabelsGroup.style.opacity = 0;
          }
        }
      }
    }
  }]);

  return Pie;
}();

/**
 * ApexCharts Radar Class for Spider/Radar Charts.
 * @module Radar
 **/

var Radar =
/*#__PURE__*/
function () {
  function Radar(ctx) {
    _classCallCheck(this, Radar);

    this.ctx = ctx;
    this.w = ctx.w;
    this.chartType = this.w.config.chart.type;
    this.initialAnim = this.w.config.chart.animations.enabled;
    this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    this.animDur = 0;
    var w = this.w;
    this.graphics = new Graphics(this.ctx);
    this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;
    this.defaultSize = w.globals.svgHeight < w.globals.svgWidth ? w.globals.svgHeight - 35 : w.globals.gridWidth;
    this.maxValue = this.w.globals.maxY;
    this.polygons = w.config.plotOptions.radar.polygons;
    this.maxLabelWidth = 20;
    var longestLabel = w.globals.labels.slice().sort(function (a, b) {
      return b.length - a.length;
    })[0];
    var labelWidth = this.graphics.getTextRects(longestLabel, w.config.dataLabels.style.fontSize);
    this.size = this.defaultSize / 2.1 - w.config.stroke.width - w.config.chart.dropShadow.blur - labelWidth.width / 1.75;

    if (w.config.plotOptions.radar.size !== undefined) {
      this.size = w.config.plotOptions.radar.size;
    }

    this.dataRadiusOfPercent = [];
    this.dataRadius = [];
    this.angleArr = [];
    this.yaxisLabelsTextsPos = [];
  }

  _createClass(Radar, [{
    key: "draw",
    value: function draw(series) {
      var _this = this;

      var w = this.w;
      var fill = new Fill(this.ctx);
      var allSeries = [];
      this.dataPointsLen = series[w.globals.maxValsInArrayIndex].length;
      this.disAngle = Math.PI * 2 / this.dataPointsLen;
      var halfW = w.globals.gridWidth / 2;
      var halfH = w.globals.gridHeight / 2;
      var translateX = halfW;
      var translateY = halfH;
      var ret = this.graphics.group({
        class: 'apexcharts-radar-series',
        'data:innerTranslateX': translateX,
        'data:innerTranslateY': translateY - 25,
        transform: "translate(".concat(translateX || 0, ", ").concat(translateY || 0, ")")
      });
      var dataPointsPos = [];
      var elPointsMain = null;
      this.yaxisLabels = this.graphics.group({
        class: 'apexcharts-yaxis'
      });
      series.forEach(function (s, i) {
        // el to which series will be drawn
        var elSeries = _this.graphics.group().attr({
          class: "apexcharts-series ".concat(Utils.escapeString(w.globals.seriesNames[i])),
          rel: i + 1,
          'data:realIndex': i
        });

        _this.dataRadiusOfPercent[i] = [];
        _this.dataRadius[i] = [];
        _this.angleArr[i] = [];
        s.forEach(function (dv, j) {
          _this.dataRadiusOfPercent[i][j] = dv / _this.maxValue;
          _this.dataRadius[i][j] = _this.dataRadiusOfPercent[i][j] * _this.size;
          _this.angleArr[i][j] = j * _this.disAngle;
        });
        dataPointsPos = _this.getDataPointsPos(_this.dataRadius[i], _this.angleArr[i]);

        var paths = _this.createPaths(dataPointsPos, {
          x: 0,
          y: 0
        }); // points


        elPointsMain = _this.graphics.group({
          class: 'apexcharts-series-markers-wrap hidden'
        });
        w.globals.delayedElements.push({
          el: elPointsMain.node,
          index: i
        });
        var defaultRenderedPathOptions = {
          i: i,
          realIndex: i,
          animationDelay: i,
          initialSpeed: w.config.chart.animations.speed,
          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,
          className: "apexcharts-radar",
          id: "apexcharts-radar",
          shouldClipToGrid: false,
          bindEventsOnPaths: false,
          stroke: w.globals.stroke.colors[i],
          strokeLineCap: w.config.stroke.lineCap
        };
        var pathFrom = null;

        if (w.globals.previousPaths.length > 0) {
          pathFrom = _this.getPathFrom(i);
        }

        for (var p = 0; p < paths.linePathsTo.length; p++) {
          var renderedLinePath = _this.graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {
            pathFrom: pathFrom === null ? paths.linePathsFrom[p] : pathFrom,
            pathTo: paths.linePathsTo[p],
            strokeWidth: Array.isArray(w.config.stroke.width) ? w.config.stroke.width[i] : w.config.stroke.width,
            fill: 'none'
          }));

          elSeries.add(renderedLinePath);
          var pathFill = fill.fillPath({
            seriesNumber: i
          });

          var renderedAreaPath = _this.graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {
            pathFrom: pathFrom === null ? paths.areaPathsFrom[p] : pathFrom,
            pathTo: paths.areaPathsTo[p],
            strokeWidth: 0,
            fill: pathFill
          }));

          if (w.config.chart.dropShadow.enabled) {
            var filters = new Filters(_this.ctx);
            var shadow = w.config.chart.dropShadow;
            filters.dropShadow(renderedAreaPath, _objectSpread({}, shadow, {
              noUserSpaceOnUse: true
            }));
          }

          elSeries.add(renderedAreaPath);
        }

        s.forEach(function (sj, j) {
          var markers = new Markers(_this.ctx);
          var opts = markers.getMarkerConfig('apexcharts-marker', i);

          var point = _this.graphics.drawMarker(dataPointsPos[j].x, dataPointsPos[j].y, opts);

          point.attr('rel', j);
          point.attr('j', j);
          point.attr('index', i);
          point.node.setAttribute('default-marker-size', opts.pSize);

          var elPointsWrap = _this.graphics.group({
            class: 'apexcharts-series-markers'
          });

          if (elPointsWrap) {
            elPointsWrap.add(point);
          }

          elPointsMain.add(elPointsWrap);
          elSeries.add(elPointsMain);
        });
        allSeries.push(elSeries);
      });
      this.drawPolygons({
        parent: ret
      });

      if (w.config.dataLabels.enabled) {
        var dataLabels = this.drawLabels();
        ret.add(dataLabels);
      }

      ret.add(this.yaxisLabels);
      allSeries.forEach(function (elS) {
        ret.add(elS);
      });
      return ret;
    }
  }, {
    key: "drawPolygons",
    value: function drawPolygons(opts) {
      var _this2 = this;

      var w = this.w;
      var parent = opts.parent;
      var yaxisTexts = w.globals.yAxisScale[0].result.reverse();
      var layers = yaxisTexts.length;
      var radiusSizes = [];
      var layerDis = this.size / (layers - 1);

      for (var i = 0; i < layers; i++) {
        radiusSizes[i] = layerDis * i;
      }

      radiusSizes.reverse();
      var polygonStrings = [];
      var lines = [];
      radiusSizes.forEach(function (radiusSize, r) {
        var polygon = _this2.getPolygonPos(radiusSize);

        var string = '';
        polygon.forEach(function (p, i) {
          if (r === 0) {
            var line = _this2.graphics.drawLine(p.x, p.y, 0, 0, Array.isArray(_this2.polygons.connectorColors) ? _this2.polygons.connectorColors[i] : _this2.polygons.connectorColors);

            lines.push(line);
          }

          if (i === 0) {
            _this2.yaxisLabelsTextsPos.push({
              x: p.x,
              y: p.y
            });
          }

          string += p.x + ',' + p.y + ' ';
        });
        polygonStrings.push(string);
      });
      polygonStrings.forEach(function (p, i) {
        var strokeColors = _this2.polygons.strokeColors;

        var polygon = _this2.graphics.drawPolygon(p, Array.isArray(strokeColors) ? strokeColors[i] : strokeColors, w.globals.radarPolygons.fill.colors[i]);

        parent.add(polygon);
      });
      lines.forEach(function (l) {
        parent.add(l);
      });

      if (w.config.yaxis[0].show) {
        this.yaxisLabelsTextsPos.forEach(function (p, i) {
          var yText = _this2.drawYAxisText(p.x, p.y, i, yaxisTexts[i]);

          _this2.yaxisLabels.add(yText);
        });
      }
    }
  }, {
    key: "drawYAxisText",
    value: function drawYAxisText(x, y, i, text) {
      var w = this.w;
      var yaxisConfig = w.config.yaxis[0];
      var formatter = w.globals.yLabelFormatters[0];
      var yaxisLabel = this.graphics.drawText({
        x: x + yaxisConfig.labels.offsetX,
        y: y + yaxisConfig.labels.offsetY,
        text: formatter(text, i),
        textAnchor: 'middle',
        fontSize: yaxisConfig.labels.style.fontSize,
        fontFamily: yaxisConfig.labels.style.fontFamily,
        foreColor: yaxisConfig.labels.style.color
      });
      return yaxisLabel;
    }
  }, {
    key: "drawLabels",
    value: function drawLabels() {
      var _this3 = this;

      var w = this.w;
      var limit = 10;
      var textAnchor = 'middle';
      var dataLabelsConfig = w.config.dataLabels;
      var elDataLabelsWrap = this.graphics.group({
        class: 'apexcharts-datalabels'
      });
      var polygonPos = this.getPolygonPos(this.size);
      var currPosX = 0;
      var currPosY = 0;
      w.globals.labels.forEach(function (label, i) {
        var formatter = dataLabelsConfig.formatter;
        var dataLabels = new DataLabels(_this3.ctx);

        if (polygonPos[i]) {
          currPosX = polygonPos[i].x;
          currPosY = polygonPos[i].y;

          if (Math.abs(polygonPos[i].x) >= limit) {
            if (polygonPos[i].x > 0) {
              textAnchor = 'start';
              currPosX += 10;
            } else if (polygonPos[i].x < 0) {
              textAnchor = 'end';
              currPosX -= 10;
            }
          } else {
            textAnchor = 'middle';
          }

          if (Math.abs(polygonPos[i].y) >= _this3.size - limit) {
            if (polygonPos[i].y < 0) {
              currPosY -= 10;
            } else if (polygonPos[i].y > 0) {
              currPosY += 10;
            }
          }

          var text = formatter(label, {
            seriesIndex: -1,
            dataPointIndex: i,
            w: w
          });
          dataLabels.plotDataLabelsText({
            x: currPosX,
            y: currPosY,
            text: text,
            textAnchor: textAnchor,
            i: i,
            j: i,
            parent: elDataLabelsWrap,
            dataLabelsConfig: dataLabelsConfig,
            offsetCorrection: false
          });
        }
      });
      return elDataLabelsWrap;
    }
  }, {
    key: "createPaths",
    value: function createPaths(pos, origin) {
      var _this4 = this;

      var linePathsTo = [];
      var linePathsFrom = [];
      var areaPathsTo = [];
      var areaPathsFrom = [];

      if (pos.length) {
        linePathsFrom = [this.graphics.move(origin.x, origin.y)];
        areaPathsFrom = [this.graphics.move(origin.x, origin.y)];
        var linePathTo = this.graphics.move(pos[0].x, pos[0].y);
        var areaPathTo = this.graphics.move(pos[0].x, pos[0].y);
        pos.forEach(function (p, i) {
          linePathTo += _this4.graphics.line(p.x, p.y);
          areaPathTo += _this4.graphics.line(p.x, p.y);

          if (i === pos.length - 1) {
            linePathTo += 'Z';
            areaPathTo += 'Z';
          }
        });
        linePathsTo.push(linePathTo);
        areaPathsTo.push(areaPathTo);
      }

      return {
        linePathsFrom: linePathsFrom,
        linePathsTo: linePathsTo,
        areaPathsFrom: areaPathsFrom,
        areaPathsTo: areaPathsTo
      };
    }
  }, {
    key: "getPathFrom",
    value: function getPathFrom(realIndex) {
      var w = this.w;
      var pathFrom = null;

      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {
        var gpp = w.globals.previousPaths[pp];

        if (gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {
          if (typeof w.globals.previousPaths[pp].paths[0] !== 'undefined') {
            pathFrom = w.globals.previousPaths[pp].paths[0].d;
          }
        }
      }

      return pathFrom;
    }
  }, {
    key: "getDataPointsPos",
    value: function getDataPointsPos(dataRadiusArr, angleArr) {
      var dataPointsLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dataPointsLen;
      dataRadiusArr = dataRadiusArr || [];
      angleArr = angleArr || [];
      var dataPointsPosArray = [];

      for (var j = 0; j < dataPointsLen; j++) {
        var curPointPos = {};
        curPointPos.x = dataRadiusArr[j] * Math.sin(angleArr[j]);
        curPointPos.y = -dataRadiusArr[j] * Math.cos(angleArr[j]);
        dataPointsPosArray.push(curPointPos);
      }

      return dataPointsPosArray;
    }
  }, {
    key: "getPolygonPos",
    value: function getPolygonPos(size) {
      var dotsArray = [];
      var angle = Math.PI * 2 / this.dataPointsLen;

      for (var i = 0; i < this.dataPointsLen; i++) {
        var curPos = {};
        curPos.x = size * Math.sin(i * angle);
        curPos.y = -size * Math.cos(i * angle);
        dotsArray.push(curPos);
      }

      return dotsArray;
    }
  }]);

  return Radar;
}();

/**
 * ApexCharts Radial Class for drawing Circle / Semi Circle Charts.
 * @module Radial
 **/

var Radial =
/*#__PURE__*/
function (_Pie) {
  _inherits(Radial, _Pie);

  function Radial(ctx) {
    var _this;

    _classCallCheck(this, Radial);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Radial).call(this, ctx));
    _this.ctx = ctx;
    _this.w = ctx.w;
    _this.animBeginArr = [0];
    _this.animDur = 0;
    var w = _this.w;
    _this.startAngle = w.config.plotOptions.radialBar.startAngle;
    _this.endAngle = w.config.plotOptions.radialBar.endAngle;
    _this.trackStartAngle = w.config.plotOptions.radialBar.track.startAngle;
    _this.trackEndAngle = w.config.plotOptions.radialBar.track.endAngle;
    _this.radialDataLabels = w.config.plotOptions.radialBar.dataLabels;
    if (!_this.trackStartAngle) _this.trackStartAngle = _this.startAngle;
    if (!_this.trackEndAngle) _this.trackEndAngle = _this.endAngle;
    if (_this.endAngle === 360) _this.endAngle = 359.99;
    _this.fullAngle = 360 - w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle;
    _this.margin = parseInt(w.config.plotOptions.radialBar.track.margin);
    return _this;
  }

  _createClass(Radial, [{
    key: "draw",
    value: function draw(series) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var ret = graphics.group({
        class: 'apexcharts-radialbar'
      });
      var elSeries = graphics.group();
      var centerY = this.defaultSize / 2;
      var centerX = w.globals.gridWidth / 2;
      var size = this.defaultSize / 2.05 - w.config.stroke.width - w.config.chart.dropShadow.blur;

      if (w.config.plotOptions.radialBar.size !== undefined) {
        size = w.config.plotOptions.radialBar.size;
      }

      var colorArr = w.globals.fill.colors;

      if (w.config.plotOptions.radialBar.track.show) {
        var elTracks = this.drawTracks({
          size: size,
          centerX: centerX,
          centerY: centerY,
          colorArr: colorArr,
          series: series
        });
        elSeries.add(elTracks);
      }

      var elG = this.drawArcs({
        size: size,
        centerX: centerX,
        centerY: centerY,
        colorArr: colorArr,
        series: series
      });
      elSeries.add(elG.g);

      if (w.config.plotOptions.radialBar.hollow.position === 'front') {
        elG.g.add(elG.elHollow);

        if (elG.dataLabels) {
          elG.g.add(elG.dataLabels);
        }
      }

      ret.add(elSeries);
      return ret;
    }
  }, {
    key: "drawTracks",
    value: function drawTracks(opts) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var g = graphics.group();
      var filters = new Filters(this.ctx);
      var fill = new Fill(this.ctx);
      var strokeWidth = this.getStrokeWidth(opts);
      opts.size = opts.size - strokeWidth / 2;

      for (var i = 0; i < opts.series.length; i++) {
        var elRadialBarTrack = graphics.group({
          class: 'apexcharts-radialbar-track apexcharts-track'
        });
        g.add(elRadialBarTrack);
        elRadialBarTrack.attr({
          id: 'apexcharts-track-' + i,
          rel: i + 1
        });
        opts.size = opts.size - strokeWidth - this.margin;
        var trackConfig = w.config.plotOptions.radialBar.track;
        var pathFill = fill.fillPath({
          seriesNumber: 0,
          size: opts.size,
          fillColors: Array.isArray(trackConfig.background) ? trackConfig.background[i] : trackConfig.background,
          solid: true
        });
        var startAngle = this.trackStartAngle;
        var endAngle = this.trackEndAngle;
        if (Math.abs(endAngle) + Math.abs(startAngle) >= 360) endAngle = 360 - Math.abs(this.startAngle) - 0.1;
        var elPath = graphics.drawPath({
          d: '',
          stroke: pathFill,
          strokeWidth: strokeWidth * parseInt(trackConfig.strokeWidth) / 100,
          fill: 'none',
          strokeOpacity: trackConfig.opacity,
          classes: 'apexcharts-radialbar-area'
        });

        if (trackConfig.dropShadow.enabled) {
          var shadow = trackConfig.dropShadow;
          filters.dropShadow(elPath, shadow);
        }

        elRadialBarTrack.add(elPath);
        elPath.attr('id', 'apexcharts-radialbarTrack-' + i);
        var pie = new Pie(this.ctx);
        pie.animatePaths(elPath, {
          centerX: opts.centerX,
          centerY: opts.centerY,
          endAngle: endAngle,
          startAngle: startAngle,
          size: opts.size,
          i: i,
          totalItems: 2,
          animBeginArr: 0,
          dur: 0,
          isTrack: true,
          easing: w.globals.easing
        });
      }

      return g;
    }
  }, {
    key: "drawArcs",
    value: function drawArcs(opts) {
      var w = this.w; // size, donutSize, centerX, centerY, colorArr, lineColorArr, sectorAngleArr, series

      var graphics = new Graphics(this.ctx);
      var fill = new Fill(this.ctx);
      var filters = new Filters(this.ctx);
      var g = graphics.group();
      var strokeWidth = this.getStrokeWidth(opts);
      opts.size = opts.size - strokeWidth / 2;
      var hollowFillID = w.config.plotOptions.radialBar.hollow.background;
      var hollowSize = opts.size - strokeWidth * opts.series.length - this.margin * opts.series.length - strokeWidth * parseInt(w.config.plotOptions.radialBar.track.strokeWidth) / 100 / 2;
      var hollowRadius = hollowSize - w.config.plotOptions.radialBar.hollow.margin;

      if (w.config.plotOptions.radialBar.hollow.image !== undefined) {
        hollowFillID = this.drawHollowImage(opts, g, hollowSize, hollowFillID);
      }

      var elHollow = this.drawHollow({
        size: hollowRadius,
        centerX: opts.centerX,
        centerY: opts.centerY,
        fill: hollowFillID
      });

      if (w.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
        var shadow = w.config.plotOptions.radialBar.hollow.dropShadow;
        filters.dropShadow(elHollow, shadow);
      }

      var shown = 1;

      if (!this.radialDataLabels.total.show && w.globals.series.length > 1) {
        shown = 0;
      }

      var pie = new Pie(this.ctx);
      var dataLabels = null;

      if (this.radialDataLabels.show) {
        dataLabels = pie.renderInnerDataLabels(this.radialDataLabels, {
          hollowSize: hollowSize,
          centerX: opts.centerX,
          centerY: opts.centerY,
          opacity: shown
        });
      }

      if (w.config.plotOptions.radialBar.hollow.position === 'back') {
        g.add(elHollow);

        if (dataLabels) {
          g.add(dataLabels);
        }
      }

      var reverseLoop = false;

      if (w.config.plotOptions.radialBar.inverseOrder) {
        reverseLoop = true;
      }

      for (var i = reverseLoop ? opts.series.length - 1 : 0; reverseLoop ? i >= 0 : i < opts.series.length; reverseLoop ? i-- : i++) {
        var elRadialBarArc = graphics.group({
          class: "apexcharts-series apexcharts-radial-series ".concat(Utils.escapeString(w.globals.seriesNames[i]))
        });
        g.add(elRadialBarArc);
        elRadialBarArc.attr({
          id: 'apexcharts-series-' + i,
          rel: i + 1
        });
        this.ctx.series.addCollapsedClassToSeries(elRadialBarArc, i);
        opts.size = opts.size - strokeWidth - this.margin;
        var pathFill = fill.fillPath({
          seriesNumber: i,
          size: opts.size
        });
        var startAngle = this.startAngle;
        var prevStartAngle = void 0;
        var totalAngle = Math.abs(w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle); // if data exceeds 100, make it 100

        var dataValue = Utils.negToZero(opts.series[i] > 100 ? 100 : opts.series[i]) / 100;
        var endAngle = Math.round(totalAngle * dataValue) + this.startAngle;
        var prevEndAngle = void 0;

        if (w.globals.dataChanged) {
          prevStartAngle = this.startAngle;
          prevEndAngle = Math.round(totalAngle * Utils.negToZero(w.globals.previousPaths[i]) / 100) + prevStartAngle;
        }

        var currFullAngle = Math.abs(endAngle) + Math.abs(startAngle);

        if (currFullAngle >= 360) {
          endAngle = endAngle - 0.01;
        }

        var prevFullAngle = Math.abs(prevEndAngle) + Math.abs(prevStartAngle);

        if (prevFullAngle >= 360) {
          prevEndAngle = prevEndAngle - 0.01;
        }

        var angle = endAngle - startAngle;
        var dashArray = Array.isArray(w.config.stroke.dashArray) ? w.config.stroke.dashArray[i] : w.config.stroke.dashArray;
        var elPath = graphics.drawPath({
          d: '',
          stroke: pathFill,
          strokeWidth: strokeWidth,
          fill: 'none',
          fillOpacity: w.config.fill.opacity,
          classes: 'apexcharts-radialbar-area',
          strokeDashArray: dashArray
        });
        Graphics.setAttrs(elPath.node, {
          'data:angle': angle,
          'data:value': opts.series[i]
        });

        if (w.config.chart.dropShadow.enabled) {
          var _shadow = w.config.chart.dropShadow;
          filters.dropShadow(elPath, _shadow);
        }

        this.addListeners(elPath, this.radialDataLabels);

        var _pie = new Pie(this.ctx);

        elRadialBarArc.add(elPath);
        elPath.attr({
          id: 'apexcharts-radialbar-slice-' + i,
          index: 0,
          j: i
        });
        var dur = 0;

        if (_pie.initialAnim && !w.globals.resized && !w.globals.dataChanged) {
          dur = (endAngle - startAngle) / 360 * w.config.chart.animations.speed;
          this.animDur = dur / (opts.series.length * 1.2) + this.animDur;
          this.animBeginArr.push(this.animDur);
        }

        if (w.globals.dataChanged) {
          dur = (endAngle - startAngle) / 360 * w.config.chart.animations.dynamicAnimation.speed;
          this.animDur = dur / (opts.series.length * 1.2) + this.animDur;
          this.animBeginArr.push(this.animDur);
        }

        _pie.animatePaths(elPath, {
          centerX: opts.centerX,
          centerY: opts.centerY,
          endAngle: endAngle,
          startAngle: startAngle,
          prevEndAngle: prevEndAngle,
          prevStartAngle: prevStartAngle,
          size: opts.size,
          i: i,
          totalItems: 2,
          animBeginArr: this.animBeginArr,
          dur: dur,
          shouldSetPrevPaths: true,
          easing: w.globals.easing
        });
      }

      return {
        g: g,
        elHollow: elHollow,
        dataLabels: dataLabels
      };
    }
  }, {
    key: "drawHollow",
    value: function drawHollow(opts) {
      var graphics = new Graphics(this.ctx);
      var circle = graphics.drawCircle(opts.size * 2);
      circle.attr({
        class: 'apexcharts-radialbar-hollow',
        cx: opts.centerX,
        cy: opts.centerY,
        r: opts.size,
        fill: opts.fill
      });
      return circle;
    }
  }, {
    key: "drawHollowImage",
    value: function drawHollowImage(opts, g, hollowSize, hollowFillID) {
      var w = this.w;
      var fill = new Fill(this.ctx);
      var randID = (Math.random() + 1).toString(36).substring(4);
      var hollowFillImg = w.config.plotOptions.radialBar.hollow.image;

      if (w.config.plotOptions.radialBar.hollow.imageClipped) {
        fill.clippedImgArea({
          width: hollowSize,
          height: hollowSize,
          image: hollowFillImg,
          patternID: "pattern".concat(w.globals.cuid).concat(randID)
        });
        hollowFillID = "url(#pattern".concat(w.globals.cuid).concat(randID, ")");
      } else {
        var imgWidth = w.config.plotOptions.radialBar.hollow.imageWidth;
        var imgHeight = w.config.plotOptions.radialBar.hollow.imageHeight;

        if (imgWidth === undefined && imgHeight === undefined) {
          var image = w.globals.dom.Paper.image(hollowFillImg).loaded(function (loader) {
            this.move(opts.centerX - loader.width / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - loader.height / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);
          });
          g.add(image);
        } else {
          var _image = w.globals.dom.Paper.image(hollowFillImg).loaded(function (loader) {
            this.move(opts.centerX - imgWidth / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - imgHeight / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);
            this.size(imgWidth, imgHeight);
          });

          g.add(_image);
        }
      }

      return hollowFillID;
    }
  }, {
    key: "getStrokeWidth",
    value: function getStrokeWidth(opts) {
      var w = this.w;
      return opts.size * (100 - parseInt(w.config.plotOptions.radialBar.hollow.size)) / 100 / (opts.series.length + 1) - this.margin;
    }
  }]);

  return Radial;
}(Pie);

/**
 * ApexCharts Line Class responsible for drawing Line / Area Charts.
 * This class is also responsible for generating values for Bubble/Scatter charts, so need to rename it to Axis Charts to avoid confusions
 * @module Line
 **/

var Line =
/*#__PURE__*/
function () {
  function Line(ctx, xyRatios, isPointsChart) {
    _classCallCheck(this, Line);

    this.ctx = ctx;
    this.w = ctx.w;
    this.xyRatios = xyRatios;
    this.pointsChart = !(this.w.config.chart.type !== 'bubble' && this.w.config.chart.type !== 'scatter') || isPointsChart;
    this.scatter = new Scatter(this.ctx);
    this.noNegatives = this.w.globals.minX === Number.MAX_VALUE;
    this.yaxisIndex = 0;
  }

  _createClass(Line, [{
    key: "draw",
    value: function draw(series, ptype, seriesIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var fill = new Fill(this.ctx);
      var type = w.globals.comboCharts ? ptype : w.config.chart.type;
      var ret = graphics.group({
        class: "apexcharts-".concat(type, "-series apexcharts-plot-series")
      });
      var coreUtils = new CoreUtils(this.ctx, w);
      series = coreUtils.getLogSeries(series);
      var yRatio = this.xyRatios.yRatio;
      yRatio = coreUtils.getLogYRatios(yRatio);
      var zRatio = this.xyRatios.zRatio;
      var xRatio = this.xyRatios.xRatio;
      var baseLineY = this.xyRatios.baseLineY; // push all series in an array, so we can draw in reverse order (for stacked charts)

      var allSeries = [];
      var prevSeriesY = [];
      var categoryAxisCorrection = 0;

      for (var i = 0; i < series.length; i++) {
        // width divided into equal parts
        if (type === 'line' && (w.config.fill.type === 'gradient' || w.config.fill.type[i] === 'gradient')) {
          // a small adjustment to allow gradient line to draw correctly for all same values

          /* #fix https://github.com/apexcharts/apexcharts.js/issues/358 */
          if (coreUtils.seriesHaveSameValues(i)) {
            var gSeries = series[i].slice();
            gSeries[gSeries.length - 1] = gSeries[gSeries.length - 1] + 0.000001;
            series[i] = gSeries;
          }
        }

        var xDivision = w.globals.gridWidth / w.globals.dataPoints;
        var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;

        if (yRatio.length > 1) {
          this.yaxisIndex = realIndex;
        }

        this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed;
        var yArrj = []; // hold y values of current iterating series

        var xArrj = []; // hold x values of current iterating series
        // zeroY is the 0 value in y series which can be used in negative charts

        var zeroY = w.globals.gridHeight - baseLineY[this.yaxisIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? baseLineY[this.yaxisIndex] * 2 : 0);
        var areaBottomY = zeroY;

        if (zeroY > w.globals.gridHeight) {
          areaBottomY = w.globals.gridHeight;
        }

        categoryAxisCorrection = xDivision / 2;
        var x = w.globals.padHorizontal + categoryAxisCorrection;
        var y = 1;

        if (w.globals.isXNumeric) {
          x = (w.globals.seriesX[realIndex][0] - w.globals.minX) / xRatio;
        }

        xArrj.push(x);
        var linePath = void 0,
            areaPath = void 0,
            pathFromLine = void 0,
            pathFromArea = void 0;
        var linePaths = [];
        var areaPaths = []; // el to which series will be drawn

        var elSeries = graphics.group({
          class: "apexcharts-series ".concat(Utils.escapeString(w.globals.seriesNames[realIndex]))
        }); // points

        var elPointsMain = graphics.group({
          class: 'apexcharts-series-markers-wrap'
        }); // eldatalabels

        var elDataLabelsWrap = graphics.group({
          class: 'apexcharts-datalabels'
        });
        this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);
        var longestSeries = series[i].length === w.globals.dataPoints;
        elSeries.attr({
          'data:longestSeries': longestSeries,
          rel: i + 1,
          'data:realIndex': realIndex
        });
        this.appendPathFrom = true;
        var pX = x;
        var pY = void 0;
        var prevX = pX;
        var prevY = zeroY; // w.globals.svgHeight;

        var lineYPosition = 0; // the first value in the current series is not null or undefined

        var firstPrevY = this.determineFirstPrevY({
          i: i,
          series: series,
          yRatio: yRatio[this.yaxisIndex],
          zeroY: zeroY,
          prevY: prevY,
          prevSeriesY: prevSeriesY,
          lineYPosition: lineYPosition
        });
        prevY = firstPrevY.prevY;
        yArrj.push(prevY);
        pY = prevY;

        if (series[i][0] === null) {
          // when the first value itself is null, we need to move the pointer to a location where a null value is not found
          for (var s = 0; s < series[i].length; s++) {
            if (series[i][s] !== null) {
              prevX = xDivision * s;
              prevY = zeroY - series[i][s] / yRatio[this.yaxisIndex];
              linePath = graphics.move(prevX, prevY);
              areaPath = graphics.move(prevX, areaBottomY);
              break;
            }
          }
        } else {
          linePath = graphics.move(prevX, prevY);
          areaPath = graphics.move(prevX, areaBottomY) + graphics.line(prevX, prevY);
        }

        pathFromLine = graphics.move(-1, zeroY) + graphics.line(-1, zeroY);
        pathFromArea = graphics.move(-1, zeroY) + graphics.line(-1, zeroY);

        if (w.globals.previousPaths.length > 0) {
          var pathFrom = this.checkPreviousPaths({
            pathFromLine: pathFromLine,
            pathFromArea: pathFromArea,
            realIndex: realIndex
          });
          pathFromLine = pathFrom.pathFromLine;
          pathFromArea = pathFrom.pathFromArea;
        }

        var iterations = w.globals.dataPoints > 1 ? w.globals.dataPoints - 1 : w.globals.dataPoints;

        for (var j = 0; j < iterations; j++) {
          if (w.globals.isXNumeric) {
            var sX = w.globals.seriesX[realIndex][j + 1];

            if (typeof w.globals.seriesX[realIndex][j + 1] === 'undefined') {
              /* fix #374 */
              sX = w.globals.seriesX[realIndex][iterations - 1];
            }

            x = (sX - w.globals.minX) / xRatio;
          } else {
            x = x + xDivision;
          }

          var minY = Utils.isNumber(w.globals.minYArr[realIndex]) ? w.globals.minYArr[realIndex] : w.globals.minY;

          if (w.config.chart.stacked) {
            if (i > 0 && w.globals.collapsedSeries.length < w.config.series.length - 1) {
              lineYPosition = prevSeriesY[i - 1][j + 1];
            } else {
              // the first series will not have prevY values
              lineYPosition = zeroY;
            }

            if (typeof series[i][j + 1] === 'undefined' || series[i][j + 1] === null) {
              y = lineYPosition - minY / yRatio[this.yaxisIndex] + (this.isReversed ? minY / yRatio[this.yaxisIndex] : 0) * 2;
            } else {
              y = lineYPosition - series[i][j + 1] / yRatio[this.yaxisIndex] + (this.isReversed ? series[i][j + 1] / yRatio[this.yaxisIndex] : 0) * 2;
            }
          } else {
            if (typeof series[i][j + 1] === 'undefined' || series[i][j + 1] === null) {
              y = zeroY - minY / yRatio[this.yaxisIndex] + (this.isReversed ? minY / yRatio[this.yaxisIndex] : 0) * 2;
            } else {
              y = zeroY - series[i][j + 1] / yRatio[this.yaxisIndex] + (this.isReversed ? series[i][j + 1] / yRatio[this.yaxisIndex] : 0) * 2;
            }
          } // push current X


          xArrj.push(x); // push current Y that will be used as next series's bottom position

          yArrj.push(y);
          var calculatedPaths = this.createPaths({
            series: series,
            i: i,
            j: j,
            x: x,
            y: y,
            xDivision: xDivision,
            pX: pX,
            pY: pY,
            areaBottomY: areaBottomY,
            linePath: linePath,
            areaPath: areaPath,
            linePaths: linePaths,
            areaPaths: areaPaths
          });
          areaPaths = calculatedPaths.areaPaths;
          linePaths = calculatedPaths.linePaths;
          pX = calculatedPaths.pX;
          pY = calculatedPaths.pY;
          areaPath = calculatedPaths.areaPath;
          linePath = calculatedPaths.linePath;

          if (this.appendPathFrom) {
            pathFromLine = pathFromLine + graphics.line(x, zeroY);
            pathFromArea = pathFromArea + graphics.line(x, zeroY);
          }

          var pointsPos = this.calculatePoints({
            series: series,
            x: x,
            y: y,
            realIndex: realIndex,
            i: i,
            j: j,
            prevY: prevY,
            categoryAxisCorrection: categoryAxisCorrection,
            xRatio: xRatio
          });

          if (!this.pointsChart) {
            var markers = new Markers(this.ctx);

            if (w.globals.dataPoints > 1) {
              elPointsMain.node.classList.add('hidden');
            }

            var elPointsWrap = markers.plotChartMarkers(pointsPos, realIndex, j + 1);

            if (elPointsWrap !== null) {
              elPointsMain.add(elPointsWrap);
            }
          } else {
            // scatter / bubble chart points creation
            this.scatter.draw(elSeries, j, {
              realIndex: realIndex,
              pointsPos: pointsPos,
              zRatio: zRatio,
              elParent: elPointsMain
            });
          }

          var dataLabels = new DataLabels(this.ctx);
          var drawnLabels = dataLabels.drawDataLabel(pointsPos, realIndex, j + 1);

          if (drawnLabels !== null) {
            elDataLabelsWrap.add(drawnLabels);
          }
        } // push all current y values array to main PrevY Array


        prevSeriesY.push(yArrj); // push all x val arrays into main xArr

        w.globals.seriesXvalues[realIndex] = xArrj;
        w.globals.seriesYvalues[realIndex] = yArrj; // these elements will be shown after area path animation completes

        if (!this.pointsChart) {
          w.globals.delayedElements.push({
            el: elPointsMain.node,
            index: realIndex
          });
        }

        var defaultRenderedPathOptions = {
          i: i,
          realIndex: realIndex,
          animationDelay: i,
          initialSpeed: w.config.chart.animations.speed,
          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,
          className: "apexcharts-".concat(type),
          id: "apexcharts-".concat(type)
        };

        if (type === 'area') {
          var pathFill = fill.fillPath({
            seriesNumber: realIndex
          });

          for (var p = 0; p < areaPaths.length; p++) {
            var renderedPath = graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {
              pathFrom: pathFromArea,
              pathTo: areaPaths[p],
              stroke: 'none',
              strokeWidth: 0,
              strokeLineCap: null,
              fill: pathFill
            }));
            elSeries.add(renderedPath);
          }
        }

        if (w.config.stroke.show && !this.pointsChart) {
          var lineFill = null;

          if (type === 'line') {
            // fillable lines only for lineChart
            lineFill = fill.fillPath({
              seriesNumber: realIndex,
              i: i
            });
          } else {
            lineFill = w.globals.stroke.colors[realIndex];
          }

          for (var _p = 0; _p < linePaths.length; _p++) {
            var _renderedPath = graphics.renderPaths(_objectSpread({}, defaultRenderedPathOptions, {
              pathFrom: pathFromLine,
              pathTo: linePaths[_p],
              stroke: lineFill,
              strokeWidth: Array.isArray(w.config.stroke.width) ? w.config.stroke.width[realIndex] : w.config.stroke.width,
              strokeLineCap: w.config.stroke.lineCap,
              fill: 'none'
            }));

            elSeries.add(_renderedPath);
          }
        }

        elSeries.add(elPointsMain);
        elSeries.add(elDataLabelsWrap);
        allSeries.push(elSeries);
      }

      for (var _s = allSeries.length; _s > 0; _s--) {
        ret.add(allSeries[_s - 1]);
      }

      return ret;
    }
  }, {
    key: "createPaths",
    value: function createPaths(_ref) {
      var series = _ref.series,
          i = _ref.i,
          j = _ref.j,
          x = _ref.x,
          y = _ref.y,
          pX = _ref.pX,
          pY = _ref.pY,
          xDivision = _ref.xDivision,
          areaBottomY = _ref.areaBottomY,
          linePath = _ref.linePath,
          areaPath = _ref.areaPath,
          linePaths = _ref.linePaths,
          areaPaths = _ref.areaPaths;
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var curve = Array.isArray(w.config.stroke.curve) ? w.config.stroke.curve[i] : w.config.stroke.curve; // logic of smooth curve derived from chartist
      // CREDITS: https://gionkunz.github.io/chartist-js/

      if (curve === 'smooth') {
        var length = (x - pX) * 0.35;

        if (w.globals.hasNullValues) {
          if (series[i][j] !== null) {
            if (series[i][j + 1] !== null) {
              linePath = graphics.move(pX, pY) + graphics.curve(pX + length, pY, x - length, y, x + 1, y);
              areaPath = graphics.move(pX + 1, pY) + graphics.curve(pX + length, pY, x - length, y, x + 1, y) + graphics.line(x, areaBottomY) + graphics.line(pX, areaBottomY) + 'z';
            } else {
              linePath = graphics.move(pX, pY);
              areaPath = graphics.move(pX, pY) + 'z';
            }
          }

          linePaths.push(linePath);
          areaPaths.push(areaPath);
        } else {
          linePath = linePath + graphics.curve(pX + length, pY, x - length, y, x, y);
          areaPath = areaPath + graphics.curve(pX + length, pY, x - length, y, x, y);
        }

        pX = x;
        pY = y;

        if (j === series[i].length - 2) {
          // last loop, close path
          areaPath = areaPath + graphics.curve(pX, pY, x, y, x, areaBottomY) + graphics.move(x, y) + 'z';

          if (!w.globals.hasNullValues) {
            linePaths.push(linePath);
            areaPaths.push(areaPath);
          }
        }
      } else {
        if (series[i][j + 1] === null) {
          linePath = linePath + graphics.move(x, y);
          areaPath = areaPath + graphics.line(x - xDivision, areaBottomY) + graphics.move(x, y);
        }

        if (series[i][j] === null) {
          linePath = linePath + graphics.move(x, y);
          areaPath = areaPath + graphics.move(x, areaBottomY);
        }

        if (curve === 'stepline') {
          linePath = linePath + graphics.line(x, null, 'H') + graphics.line(null, y, 'V');
          areaPath = areaPath + graphics.line(x, null, 'H') + graphics.line(null, y, 'V');
        } else if (curve === 'straight') {
          linePath = linePath + graphics.line(x, y);
          areaPath = areaPath + graphics.line(x, y);
        }

        if (j === series[i].length - 2) {
          // last loop, close path
          areaPath = areaPath + graphics.line(x, areaBottomY) + graphics.move(x, y) + 'z';
          linePaths.push(linePath);
          areaPaths.push(areaPath);
        }
      }

      return {
        linePaths: linePaths,
        areaPaths: areaPaths,
        pX: pX,
        pY: pY,
        linePath: linePath,
        areaPath: areaPath
      };
    }
  }, {
    key: "calculatePoints",
    value: function calculatePoints(_ref2) {
      var series = _ref2.series,
          realIndex = _ref2.realIndex,
          x = _ref2.x,
          y = _ref2.y,
          i = _ref2.i,
          j = _ref2.j,
          prevY = _ref2.prevY,
          categoryAxisCorrection = _ref2.categoryAxisCorrection,
          xRatio = _ref2.xRatio;
      var w = this.w;
      var ptX = [];
      var ptY = [];

      if (j === 0) {
        var xPT1st = categoryAxisCorrection + w.config.markers.offsetX; // the first point for line series
        // we need to check whether it's not a time series, because a time series may
        // start from the middle of the x axis

        if (w.globals.isXNumeric) {
          xPT1st = (w.globals.seriesX[realIndex][0] - w.globals.minX) / xRatio + w.config.markers.offsetX;
        } // push 2 points for the first data values


        ptX.push(xPT1st);
        ptY.push(Utils.isNumber(series[i][0]) ? prevY + w.config.markers.offsetY : null);
        ptX.push(x + w.config.markers.offsetX);
        ptY.push(Utils.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);
      } else {
        ptX.push(x + w.config.markers.offsetX);
        ptY.push(Utils.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);
      }

      var pointsPos = {
        x: ptX,
        y: ptY
      };
      return pointsPos;
    }
  }, {
    key: "checkPreviousPaths",
    value: function checkPreviousPaths(_ref3) {
      var pathFromLine = _ref3.pathFromLine,
          pathFromArea = _ref3.pathFromArea,
          realIndex = _ref3.realIndex;
      var w = this.w;

      for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {
        var gpp = w.globals.previousPaths[pp];

        if ((gpp.type === 'line' || gpp.type === 'area') && gpp.paths.length > 0 && parseInt(gpp.realIndex) === parseInt(realIndex)) {
          if (gpp.type === 'line') {
            this.appendPathFrom = false;
            pathFromLine = w.globals.previousPaths[pp].paths[0].d;
          } else if (gpp.type === 'area') {
            this.appendPathFrom = false;
            pathFromArea = w.globals.previousPaths[pp].paths[0].d;

            if (w.config.stroke.show) {
              pathFromLine = w.globals.previousPaths[pp].paths[1].d;
            }
          }
        }
      }

      return {
        pathFromLine: pathFromLine,
        pathFromArea: pathFromArea
      };
    }
  }, {
    key: "determineFirstPrevY",
    value: function determineFirstPrevY(_ref4) {
      var i = _ref4.i,
          series = _ref4.series,
          yRatio = _ref4.yRatio,
          zeroY = _ref4.zeroY,
          prevY = _ref4.prevY,
          prevSeriesY = _ref4.prevSeriesY,
          lineYPosition = _ref4.lineYPosition;
      var w = this.w;

      if (typeof series[i][0] !== 'undefined') {
        if (w.config.chart.stacked) {
          if (i > 0) {
            // 1st y value of previous series
            lineYPosition = prevSeriesY[i - 1][0];
          } else {
            // the first series will not have prevY values
            lineYPosition = zeroY;
          }

          prevY = lineYPosition - series[i][0] / yRatio + (this.isReversed ? series[i][0] / yRatio : 0) * 2;
        } else {
          prevY = zeroY - series[i][0] / yRatio + (this.isReversed ? series[i][0] / yRatio : 0) * 2;
        }
      } else {
        // the first value in the current series is null
        if (w.config.chart.stacked && i > 0 && typeof series[i][0] === 'undefined') {
          // check for undefined value (undefined value will occur when we clear the series while user clicks on legend to hide serieses)
          for (var s = i - 1; s >= 0; s--) {
            // for loop to get to 1st previous value until we get it
            if (series[s][0] !== null && typeof series[s][0] !== 'undefined') {
              lineYPosition = prevSeriesY[s][0];
              prevY = lineYPosition;
              break;
            }
          }
        }
      }

      return {
        prevY: prevY,
        lineYPosition: lineYPosition
      };
    }
  }]);

  return Line;
}();

/**
 * ApexCharts YAxis Class for drawing Y-Axis.
 *
 * @module YAxis
 **/

var YAxis =
/*#__PURE__*/
function () {
  function YAxis(ctx) {
    _classCallCheck(this, YAxis);

    this.ctx = ctx;
    this.w = ctx.w;
    this.xaxisFontSize = this.w.config.xaxis.labels.style.fontSize;
    this.axisFontFamily = this.w.config.xaxis.labels.style.fontFamily;
    this.isBarHorizontal = !!(this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.horizontal);
    this.xaxisForeColors = this.w.config.xaxis.labels.style.colors;
    this.xAxisoffX = 0;

    if (this.w.config.xaxis.position === 'bottom') {
      this.xAxisoffX = this.w.globals.gridHeight;
    }
  }

  _createClass(YAxis, [{
    key: "drawYaxis",
    value: function drawYaxis(realIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var yaxisFontSize = w.config.yaxis[realIndex].labels.style.fontSize;
      var yaxisFontFamily = w.config.yaxis[realIndex].labels.style.fontFamily;
      var elYaxis = graphics.group({
        class: 'apexcharts-yaxis',
        rel: realIndex,
        transform: 'translate(' + w.globals.translateYAxisX[realIndex] + ', 0)'
      });

      if (!w.config.yaxis[realIndex].show) {
        return elYaxis;
      }

      var elYaxisTexts = graphics.group({
        class: 'apexcharts-yaxis-texts-g'
      });
      elYaxis.add(elYaxisTexts);
      var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1; // labelsDivider is simply svg height/number of ticks

      var labelsDivider = w.globals.gridHeight / tickAmount + 0.1; // initial label position = 0;

      var l = w.globals.translateY;
      var lbFormatter = w.globals.yLabelFormatters[realIndex];
      var labels = w.globals.yAxisScale[realIndex].result.slice();

      if (w.config.yaxis[realIndex].reversed) {
        labels.reverse();
      }

      if (w.config.yaxis[realIndex].labels.show) {
        for (var i = tickAmount; i >= 0; i--) {
          var val = labels[i];
          val = lbFormatter(val, i);
          var xPad = w.config.yaxis[realIndex].labels.padding;

          if (w.config.yaxis[realIndex].opposite && w.config.yaxis.length !== 0) {
            xPad = xPad * -1;
          }

          var label = graphics.drawText({
            x: xPad,
            y: l + tickAmount / 10 + w.config.yaxis[realIndex].labels.offsetY + 1,
            text: val,
            textAnchor: w.config.yaxis[realIndex].opposite ? 'start' : 'end',
            fontSize: yaxisFontSize,
            fontFamily: yaxisFontFamily,
            foreColor: w.config.yaxis[realIndex].labels.style.color,
            cssClass: 'apexcharts-yaxis-label ' + w.config.yaxis[realIndex].labels.style.cssClass
          });
          elYaxisTexts.add(label);
          var labelRotatingCenter = graphics.rotateAroundCenter(label.node);

          if (w.config.yaxis[realIndex].labels.rotate !== 0) {
            label.node.setAttribute('transform', "rotate(".concat(w.config.yaxis[realIndex].labels.rotate, " ").concat(labelRotatingCenter.x, " ").concat(labelRotatingCenter.y, ")"));
          }

          l = l + labelsDivider;
        }
      }

      if (w.config.yaxis[realIndex].title.text !== undefined) {
        var elYaxisTitle = graphics.group({
          class: 'apexcharts-yaxis-title'
        });
        var x = 0;

        if (w.config.yaxis[realIndex].opposite) {
          x = w.globals.translateYAxisX[realIndex];
        }

        var elYAxisTitleText = graphics.drawText({
          x: x,
          y: w.globals.gridHeight / 2 + w.globals.translateY,
          text: w.config.yaxis[realIndex].title.text,
          textAnchor: 'end',
          foreColor: w.config.yaxis[realIndex].title.style.color,
          fontSize: w.config.yaxis[realIndex].title.style.fontSize,
          fontFamily: w.config.yaxis[realIndex].title.style.fontFamily,
          cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[realIndex].title.style.cssClass
        });
        elYaxisTitle.add(elYAxisTitleText);
        elYaxis.add(elYaxisTitle);
      }

      var axisBorder = w.config.yaxis[realIndex].axisBorder;

      if (axisBorder.show) {
        var _x = 31 + axisBorder.offsetX;

        if (w.config.yaxis[realIndex].opposite) {
          _x = -31 - axisBorder.offsetX;
        }

        var elVerticalLine = graphics.drawLine(_x, w.globals.translateY + axisBorder.offsetY - 2, _x, w.globals.gridHeight + w.globals.translateY + axisBorder.offsetY + 2, axisBorder.color);
        elYaxis.add(elVerticalLine);
        this.drawAxisTicks(_x, tickAmount, axisBorder, w.config.yaxis[realIndex].axisTicks, realIndex, labelsDivider, elYaxis);
      }

      return elYaxis;
    } // This actually becomes horizonal axis (for bar charts)

  }, {
    key: "drawYaxisInversed",
    value: function drawYaxisInversed(realIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var elXaxis = graphics.group({
        class: 'apexcharts-xaxis apexcharts-yaxis-inversed'
      });
      var elXaxisTexts = graphics.group({
        class: 'apexcharts-xaxis-texts-g',
        transform: "translate(".concat(w.globals.translateXAxisX, ", ").concat(w.globals.translateXAxisY, ")")
      });
      elXaxis.add(elXaxisTexts);
      var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1; // labelsDivider is simply svg width/number of ticks

      var labelsDivider = w.globals.gridWidth / tickAmount + 0.1; // initial label position;

      var l = labelsDivider + w.config.xaxis.labels.offsetX;
      var lbFormatter = w.globals.xLabelFormatter;
      var labels = w.globals.yAxisScale[realIndex].result.slice();

      if (w.config.yaxis[realIndex].reversed) {
        labels.reverse();
      }

      if (w.config.xaxis.labels.show) {
        for (var i = tickAmount; i >= 0; i--) {
          var val = labels[i];
          val = lbFormatter(val, i);
          var elTick = graphics.drawText({
            x: w.globals.gridWidth + w.globals.padHorizontal - (l - labelsDivider + w.config.xaxis.labels.offsetX),
            y: this.xAxisoffX + w.config.xaxis.labels.offsetY + 30,
            text: '',
            textAnchor: 'middle',
            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[realIndex] : this.xaxisForeColors,
            fontSize: this.xaxisFontSize,
            fontFamily: this.xaxisFontFamily,
            cssClass: 'apexcharts-xaxis-label ' + w.config.xaxis.labels.style.cssClass
          });
          elXaxisTexts.add(elTick);
          elTick.tspan(val);
          var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');
          elTooltipTitle.textContent = val;
          elTick.node.appendChild(elTooltipTitle);
          l = l + labelsDivider;
        }
      }

      if (w.config.xaxis.title.text !== undefined) {
        var elYaxisTitle = graphics.group({
          class: 'apexcharts-xaxis-title apexcharts-yaxis-title-inversed'
        });
        var elYAxisTitleText = graphics.drawText({
          x: w.globals.gridWidth / 2,
          y: this.xAxisoffX + parseInt(this.xaxisFontSize) + parseInt(w.config.xaxis.title.style.fontSize) + 20,
          text: w.config.xaxis.title.text,
          textAnchor: 'middle',
          fontSize: w.config.xaxis.title.style.fontSize,
          fontFamily: w.config.xaxis.title.style.fontFamily,
          cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass
        });
        elYaxisTitle.add(elYAxisTitleText);
        elXaxis.add(elYaxisTitle);
      }

      var axisBorder = w.config.yaxis[realIndex].axisBorder;

      if (axisBorder.show) {
        var elVerticalLine = graphics.drawLine(w.globals.padHorizontal + axisBorder.offsetX, 1 + axisBorder.offsetY, w.globals.padHorizontal + axisBorder.offsetX, w.globals.gridHeight + axisBorder.offsetY, axisBorder.color);
        elXaxis.add(elVerticalLine);
      }

      return elXaxis;
    }
  }, {
    key: "drawAxisTicks",
    value: function drawAxisTicks(x, tickAmount, axisBorder, axisTicks, realIndex, labelsDivider, elYaxis) {
      var w = this.w;
      var graphics = new Graphics(this.ctx); // initial label position = 0;

      var t = w.globals.translateY;

      if (axisTicks.show) {
        if (w.config.yaxis[realIndex].opposite === true) x = x + axisTicks.width;

        for (var i = tickAmount; i >= 0; i--) {
          var tY = t + tickAmount / 10 + w.config.yaxis[realIndex].labels.offsetY - 1;

          if (this.isBarHorizontal) {
            tY = labelsDivider * i;
          }

          var elTick = graphics.drawLine(x + axisBorder.offsetX - axisTicks.width + axisTicks.offsetX, tY + axisTicks.offsetY, x + axisBorder.offsetX + axisTicks.offsetX, tY + axisTicks.offsetY, axisBorder.color);
          elYaxis.add(elTick);
          t = t + labelsDivider;
        }
      }
    }
  }, {
    key: "yAxisTitleRotate",
    value: function yAxisTitleRotate(realIndex, yAxisOpposite) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var yAxisLabelsCoord = {
        width: 0,
        height: 0
      };
      var yAxisTitleCoord = {
        width: 0,
        height: 0
      };
      var elYAxisLabelsWrap = w.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(realIndex, "'] .apexcharts-yaxis-texts-g"));

      if (elYAxisLabelsWrap !== null) {
        yAxisLabelsCoord = elYAxisLabelsWrap.getBoundingClientRect();
      }

      var yAxisTitle = w.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(realIndex, "'] .apexcharts-yaxis-title text"));

      if (yAxisTitle !== null) {
        yAxisTitleCoord = yAxisTitle.getBoundingClientRect();
      }

      if (yAxisTitle !== null) {
        var x = this.xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite);
        yAxisTitle.setAttribute('x', x.xPos - (yAxisOpposite ? 10 : 0));
      }

      if (yAxisTitle !== null) {
        var titleRotatingCenter = graphics.rotateAroundCenter(yAxisTitle);

        if (!yAxisOpposite) {
          yAxisTitle.setAttribute('transform', "rotate(-".concat(w.config.yaxis[realIndex].title.rotate, " ").concat(titleRotatingCenter.x, " ").concat(titleRotatingCenter.y, ")"));
        } else {
          yAxisTitle.setAttribute('transform', "rotate(".concat(w.config.yaxis[realIndex].title.rotate, " ").concat(titleRotatingCenter.x, " ").concat(titleRotatingCenter.y, ")"));
        }
      }
    }
  }, {
    key: "xPaddingForYAxisTitle",
    value: function xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite) {
      var w = this.w;
      var oppositeAxisCount = 0;
      var x = 0;
      var padd = 10;

      if (w.config.yaxis[realIndex].title.text === undefined || realIndex < 0) {
        return {
          xPos: x,
          padd: 0
        };
      }

      if (yAxisOpposite) {
        x = yAxisLabelsCoord.width + w.config.yaxis[realIndex].title.offsetX + yAxisTitleCoord.width / 2 + padd / 2;
        oppositeAxisCount += 1;

        if (oppositeAxisCount === 0) {
          x = x - padd / 2;
        }
      } else {
        x = yAxisLabelsCoord.width * -1 + w.config.yaxis[realIndex].title.offsetX + padd / 2 + yAxisTitleCoord.width / 2;

        if (this.isBarHorizontal) {
          padd = 25;
          x = yAxisLabelsCoord.width * -1 - w.config.yaxis[realIndex].title.offsetX - padd;
        }
      }

      return {
        xPos: x,
        padd: padd
      };
    } // sets the x position of the y-axis by counting the labels width, title width and any offset

  }, {
    key: "setYAxisXPosition",
    value: function setYAxisXPosition(yaxisLabelCoords, yTitleCoords) {
      var _this = this;

      var w = this.w;
      var xLeft = 0;
      var xRight = 0;
      var leftOffsetX = 21;
      var rightOffsetX = 1;

      if (w.config.yaxis.length > 1) {
        this.multipleYs = true;
      }

      w.config.yaxis.map(function (yaxe, index) {
        var shouldNotDrawAxis = w.globals.ignoreYAxisIndexes.indexOf(index) > -1 || !yaxe.show || yaxe.floating || yaxisLabelCoords[index].width === 0;
        var axisWidth = yaxisLabelCoords[index].width + yTitleCoords[index].width;

        if (!yaxe.opposite) {
          xLeft = w.globals.translateX - leftOffsetX;

          if (!shouldNotDrawAxis) {
            leftOffsetX = leftOffsetX + axisWidth + 20;
          }

          w.globals.translateYAxisX[index] = xLeft + yaxe.labels.offsetX;
        } else {
          if (_this.isBarHorizontal) {
            xRight = w.globals.gridWidth + w.globals.translateX - 1;
            w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX;
          } else {
            xRight = w.globals.gridWidth + w.globals.translateX + rightOffsetX;

            if (!shouldNotDrawAxis) {
              rightOffsetX = rightOffsetX + axisWidth + 20;
            }

            w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX + 20;
          }
        }
      });
    }
  }]);

  return YAxis;
}();

/**
 * ApexCharts Formatter Class for setting value formatters for axes as well as tooltips.
 *
 * @module Formatters
 **/

var Formatters =
/*#__PURE__*/
function () {
  function Formatters(ctx) {
    _classCallCheck(this, Formatters);

    this.ctx = ctx;
    this.w = ctx.w;
    this.tooltipKeyFormat = 'dd MMM';
  }

  _createClass(Formatters, [{
    key: "xLabelFormat",
    value: function xLabelFormat(fn, val) {
      var w = this.w;

      if (w.config.xaxis.type === 'datetime') {
        // if user has not specified a custom formatter, use the default tooltip.x.format
        if (w.config.tooltip.x.formatter === undefined) {
          var datetimeObj = new DateTime(this.ctx);
          return datetimeObj.formatDate(new Date(val), w.config.tooltip.x.format, true, true);
        }
      }

      return fn(val);
    }
  }, {
    key: "setLabelFormatters",
    value: function setLabelFormatters() {
      var w = this.w;

      w.globals.xLabelFormatter = function (val) {
        return val;
      };

      w.globals.xaxisTooltipFormatter = function (val) {
        return val;
      };

      w.globals.ttKeyFormatter = function (val) {
        return val;
      };

      w.globals.ttZFormatter = function (val) {
        return val;
      };

      w.globals.legendFormatter = function (val) {
        return val;
      };

      if (typeof w.config.tooltip.x.formatter === 'function') {
        w.globals.ttKeyFormatter = w.config.tooltip.x.formatter;
      }

      if (typeof w.config.xaxis.tooltip.formatter === 'function') {
        w.globals.xaxisTooltipFormatter = w.config.xaxis.tooltip.formatter;
      }

      if (Array.isArray(w.config.tooltip.y)) {
        w.globals.ttVal = w.config.tooltip.y;
      } else {
        if (w.config.tooltip.y.formatter !== undefined) {
          w.globals.ttVal = w.config.tooltip.y;
        }
      }

      if (w.config.tooltip.z.formatter !== undefined) {
        w.globals.ttZFormatter = w.config.tooltip.z.formatter;
      } // legend formatter - if user wants to append any global values of series to legend text


      if (w.config.legend.formatter !== undefined) {
        w.globals.legendFormatter = w.config.legend.formatter;
      } // formatter function will always overwrite format property


      if (w.config.xaxis.labels.formatter !== undefined) {
        w.globals.xLabelFormatter = w.config.xaxis.labels.formatter;
      } else {
        w.globals.xLabelFormatter = function (val) {
          if (Utils.isNumber(val)) {
            // numeric xaxis may have smaller range, so defaulting to 1 decimal
            if (w.config.xaxis.type === 'numeric' && w.globals.dataPoints < 50) {
              return val.toFixed(1);
            }

            return val.toFixed(0);
          }

          return val;
        };
      } // formatter function will always overwrite format property


      w.config.yaxis.forEach(function (yaxe, i) {
        if (yaxe.labels.formatter !== undefined) {
          w.globals.yLabelFormatters[i] = yaxe.labels.formatter;
        } else {
          w.globals.yLabelFormatters[i] = function (val) {
            if (Utils.isNumber(val)) {
              if (w.globals.yValueDecimal !== 0 || w.globals.maxY - w.globals.minY < 3) {
                return val.toFixed(yaxe.decimalsInFloat);
              } else {
                return val.toFixed(0);
              }
            }

            return val;
          };
        }
      });
      return w.globals;
    }
  }, {
    key: "heatmapLabelFormatters",
    value: function heatmapLabelFormatters() {
      var w = this.w;

      if (w.config.chart.type === 'heatmap') {
        w.globals.yAxisScale[0].result = w.globals.seriesNames.slice(); //  get the longest string from the labels array and also apply label formatter to it

        var longest = w.globals.seriesNames.reduce(function (a, b) {
          return a.length > b.length ? a : b;
        }, 0);
        w.globals.yAxisScale[0].niceMax = longest;
        w.globals.yAxisScale[0].niceMin = longest;
      }
    }
  }]);

  return Formatters;
}();

/**
 * ApexCharts XAxis Class for drawing X-Axis.
 *
 * @module XAxis
 **/

var XAxis =
/*#__PURE__*/
function () {
  function XAxis(ctx) {
    _classCallCheck(this, XAxis);

    this.ctx = ctx;
    this.w = ctx.w;
    var w = this.w;
    this.xaxisLabels = w.globals.labels.slice();

    if (w.globals.timelineLabels.length > 0) {
      //  timeline labels are there
      this.xaxisLabels = w.globals.timelineLabels.slice();
    }

    this.drawnLabels = [];

    if (w.config.xaxis.position === 'top') {
      this.offY = 0;
    } else {
      this.offY = w.globals.gridHeight + 1;
    }

    this.offY = this.offY + w.config.xaxis.axisBorder.offsetY;
    this.xaxisFontSize = w.config.xaxis.labels.style.fontSize;
    this.xaxisFontFamily = w.config.xaxis.labels.style.fontFamily;
    this.xaxisForeColors = w.config.xaxis.labels.style.colors;
    this.xaxisBorderWidth = w.config.xaxis.axisBorder.width;

    if (this.xaxisBorderWidth.indexOf('%') > -1) {
      this.xaxisBorderWidth = w.globals.gridWidth * parseInt(this.xaxisBorderWidth) / 100;
    } else {
      this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth);
    }

    this.xaxisBorderHeight = w.config.xaxis.axisBorder.height; // For bars, we will only consider single y xais,
    // as we are not providing multiple yaxis for bar charts

    this.yaxis = w.config.yaxis[0];
  }

  _createClass(XAxis, [{
    key: "drawXaxis",
    value: function drawXaxis() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var elXaxis = graphics.group({
        class: 'apexcharts-xaxis',
        transform: "translate(".concat(w.config.xaxis.offsetX, ", ").concat(w.config.xaxis.offsetY, ")")
      });
      var elXaxisTexts = graphics.group({
        class: 'apexcharts-xaxis-texts-g',
        transform: "translate(".concat(w.globals.translateXAxisX, ", ").concat(w.globals.translateXAxisY, ")")
      });
      elXaxis.add(elXaxisTexts);
      var colWidth; // initial x Position (keep adding column width in the loop)

      var xPos = w.globals.padHorizontal;
      var labels = [];

      for (var i = 0; i < this.xaxisLabels.length; i++) {
        labels.push(this.xaxisLabels[i]);
      }

      if (w.globals.isXNumeric) {
        colWidth = w.globals.gridWidth / (labels.length - 1);
        xPos = xPos + colWidth / 2 + w.config.xaxis.labels.offsetX;
      } else {
        colWidth = w.globals.gridWidth / labels.length;
        xPos = xPos + colWidth + w.config.xaxis.labels.offsetX;
      }

      var xlbFormatter = w.globals.xLabelFormatter;
      var customFormatter = w.config.xaxis.labels.formatter;
      var labelsLen = labels.length;

      if (w.config.xaxis.labels.show) {
        for (var _i = 0; _i <= labelsLen - 1; _i++) {
          var rawLabel = typeof labels[_i] === 'undefined' ? '' : labels[_i];
          var label = void 0;
          var xFormat = new Formatters(this.ctx);
          label = xFormat.xLabelFormat(xlbFormatter, rawLabel);

          if (customFormatter !== undefined) {
            label = customFormatter(rawLabel, this.xaxisLabels[_i], _i);
          }

          var x = xPos - colWidth / 2 + w.config.xaxis.labels.offsetX;

          if (w.globals.timelineLabels.length > 0) {
            x = w.globals.timelineLabels[_i].position;
            label = w.globals.timelineLabels[_i].value;
          } else {
            if (w.config.xaxis.type === 'datetime' && customFormatter === undefined) {
              label = '';
            }
          }

          if (typeof label === 'undefined') label = '';
          label = label.toString();

          if (label.indexOf('NaN') === 0 || label.toLowerCase().indexOf('invalid') === 0 || label.toLowerCase().indexOf('infinity') >= 0 || this.drawnLabels.indexOf(label) >= 0 && !w.config.xaxis.labels.showDuplicates) {
            label = '';
          }

          this.drawnLabels.push(label);
          var offsetYCorrection = 28;

          if (w.globals.rotateXLabels) {
            offsetYCorrection = 22;
          }

          var elTick = graphics.drawText({
            x: x,
            y: this.offY + w.config.xaxis.labels.offsetY + offsetYCorrection,
            text: '',
            textAnchor: 'middle',
            fontSize: this.xaxisFontSize,
            fontFamily: this.xaxisFontFamily,
            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[_i] : this.xaxisForeColors,
            cssClass: 'apexcharts-xaxis-label ' + w.config.xaxis.labels.style.cssClass
          });
          elXaxisTexts.add(elTick);
          graphics.addTspan(elTick, label, this.xaxisFontFamily);
          var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');
          elTooltipTitle.textContent = label;
          elTick.node.appendChild(elTooltipTitle);
          xPos = xPos + colWidth;
        }
      }

      if (w.config.xaxis.title.text !== undefined) {
        var elXaxisTitle = graphics.group({
          class: 'apexcharts-xaxis-title'
        });
        var elXAxisTitleText = graphics.drawText({
          x: w.globals.gridWidth / 2 + w.config.xaxis.title.offsetX,
          y: this.offY - parseInt(this.xaxisFontSize) + w.globals.xAxisLabelsHeight + w.config.xaxis.title.offsetY,
          text: w.config.xaxis.title.text,
          textAnchor: 'middle',
          fontSize: w.config.xaxis.title.style.fontSize,
          fontFamily: w.config.xaxis.title.style.fontFamily,
          foreColor: w.config.xaxis.title.style.color,
          cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass
        });
        elXaxisTitle.add(elXAxisTitleText);
        elXaxis.add(elXaxisTitle);
      }

      if (w.config.xaxis.axisBorder.show) {
        var lineCorrection = 0;

        if (w.config.chart.type === 'bar' && w.globals.isXNumeric) {
          lineCorrection = lineCorrection - 15;
        }

        var elHorzLine = graphics.drawLine(w.globals.padHorizontal + lineCorrection + w.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, w.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        elXaxis.add(elHorzLine);
      }

      return elXaxis;
    } // this actually becomes the vertical axis (for bar charts)

  }, {
    key: "drawXaxisInversed",
    value: function drawXaxisInversed(realIndex) {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var translateYAxisX = w.config.yaxis[0].opposite ? w.globals.translateYAxisX[realIndex] : 0;
      var elYaxis = graphics.group({
        class: 'apexcharts-yaxis apexcharts-xaxis-inversed',
        rel: realIndex
      });
      var elYaxisTexts = graphics.group({
        class: 'apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g',
        transform: 'translate(' + translateYAxisX + ', 0)'
      });
      elYaxis.add(elYaxisTexts);
      var colHeight; // initial x Position (keep adding column width in the loop)

      var yPos;
      var labels = [];

      for (var i = 0; i < this.xaxisLabels.length; i++) {
        labels.push(this.xaxisLabels[i]);
      }

      colHeight = w.globals.gridHeight / labels.length;
      yPos = -(colHeight / 2.2);
      var lbFormatter = w.globals.yLabelFormatters[0];
      var ylabels = w.config.yaxis[0].labels;

      if (ylabels.show) {
        for (var _i2 = 0; _i2 <= labels.length - 1; _i2++) {
          var label = typeof labels[_i2] === 'undefined' ? '' : labels[_i2];
          label = lbFormatter(label);
          var elLabel = graphics.drawText({
            x: ylabels.offsetX - 15,
            y: yPos + colHeight + ylabels.offsetY,
            text: label,
            textAnchor: this.yaxis.opposite ? 'start' : 'end',
            foreColor: ylabels.style.color ? ylabels.style.color : ylabels.style.colors[_i2],
            fontSize: ylabels.style.fontSize,
            fontFamily: ylabels.style.fontFamily,
            cssClass: 'apexcharts-yaxis-label ' + ylabels.style.cssClass
          }); // let labelRotatingCenter = graphics.rotateAroundCenter(elLabel.node)
          // if (ylabels.rotate !== 0) {
          //   elLabel.node.setAttribute(
          //     'transform',
          //     `rotate(${ylabels.rotate} ${labelRotatingCenter.x} ${labelRotatingCenter.y})`
          //   )
          // }

          elYaxisTexts.add(elLabel);
          yPos = yPos + colHeight;
        }
      }

      if (w.config.yaxis[0].title.text !== undefined) {
        var elXaxisTitle = graphics.group({
          class: 'apexcharts-yaxis-title apexcharts-xaxis-title-inversed',
          transform: 'translate(' + translateYAxisX + ', 0)'
        });
        var elXAxisTitleText = graphics.drawText({
          x: 0,
          y: w.globals.gridHeight / 2,
          text: w.config.yaxis[0].title.text,
          textAnchor: 'middle',
          foreColor: w.config.yaxis[0].title.style.color,
          fontSize: w.config.yaxis[0].title.style.fontSize,
          fontFamily: w.config.yaxis[0].title.style.fontFamily,
          cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[0].title.style.cssClass
        });
        elXaxisTitle.add(elXAxisTitleText);
        elYaxis.add(elXaxisTitle);
      }

      if (w.config.xaxis.axisBorder.show) {
        var elHorzLine = graphics.drawLine(w.globals.padHorizontal + w.config.xaxis.axisBorder.offsetX, this.offY, this.xaxisBorderWidth, this.offY, this.yaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        elYaxis.add(elHorzLine); // let x = w.globals.yAxisWidths[0] / 2
        // if (w.config.yaxis[0].opposite) {
        //   x = -w.globals.yAxisWidths[0] / 2
        // }

        var yaxis = new YAxis(this.ctx);
        yaxis.drawAxisTicks(0, labels.length, w.config.yaxis[0].axisBorder, w.config.yaxis[0].axisTicks, 0, colHeight, elYaxis);
      }

      return elYaxis;
    }
  }, {
    key: "drawXaxisTicks",
    value: function drawXaxisTicks(x1, appendToElement) {
      var w = this.w;
      var x2 = x1;
      if (x1 < 0 || x1 > w.globals.gridWidth) return;
      var y1 = this.offY + w.config.xaxis.axisTicks.offsetY;
      var y2 = y1 + w.config.xaxis.axisTicks.height;

      if (w.config.xaxis.axisTicks.show) {
        var graphics = new Graphics(this.ctx);
        var line = graphics.drawLine(x1 + w.config.xaxis.axisTicks.offsetX, y1 + w.config.xaxis.offsetY, x2 + w.config.xaxis.axisTicks.offsetX, y2 + w.config.xaxis.offsetY, w.config.xaxis.axisTicks.color); // we are not returning anything, but appending directly to the element pased in param

        appendToElement.add(line);
        line.node.classList.add('apexcharts-xaxis-tick');
      }
    }
  }, {
    key: "getXAxisTicksPositions",
    value: function getXAxisTicksPositions() {
      var w = this.w;
      var xAxisTicksPositions = [];
      var xCount = this.xaxisLabels.length;
      var x1 = w.globals.padHorizontal;

      if (w.globals.timelineLabels.length > 0) {
        for (var i = 0; i < xCount; i++) {
          x1 = this.xaxisLabels[i].position;
          xAxisTicksPositions.push(x1);
        }
      } else {
        var xCountForCategoryCharts = xCount;

        for (var _i3 = 0; _i3 < xCountForCategoryCharts; _i3++) {
          var x1Count = xCountForCategoryCharts;

          if (w.globals.isXNumeric && w.config.chart.type !== 'bar') {
            x1Count -= 1;
          }

          x1 = x1 + w.globals.gridWidth / x1Count;
          xAxisTicksPositions.push(x1);
        }
      }

      return xAxisTicksPositions;
    } // to rotate x-axis labels or to put ... for longer text in xaxis

  }, {
    key: "xAxisLabelCorrections",
    value: function xAxisLabelCorrections() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var xAxis = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g');
      var xAxisTexts = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-texts-g text');
      var yAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-inversed text');
      var xAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-inversed-texts-g text');

      if (w.globals.rotateXLabels || w.config.xaxis.labels.rotateAlways) {
        for (var xat = 0; xat < xAxisTexts.length; xat++) {
          var textRotatingCenter = graphics.rotateAroundCenter(xAxisTexts[xat]);
          textRotatingCenter.y = textRotatingCenter.y - 1; // + tickWidth/4;

          textRotatingCenter.x = textRotatingCenter.x + 1;
          xAxisTexts[xat].setAttribute('transform', "rotate(".concat(w.config.xaxis.labels.rotate, " ").concat(textRotatingCenter.x, " ").concat(textRotatingCenter.y, ")"));
          xAxisTexts[xat].setAttribute('text-anchor', "end");
          var offsetHeight = 10;
          xAxis.setAttribute('transform', "translate(0, ".concat(-offsetHeight, ")"));
          var tSpan = xAxisTexts[xat].childNodes;

          if (w.config.xaxis.labels.trim) {
            graphics.placeTextWithEllipsis(tSpan[0], tSpan[0].textContent, w.config.xaxis.labels.maxHeight - 40);
          }
        }
      } else {
        var width = w.globals.gridWidth / w.globals.labels.length;

        for (var _xat = 0; _xat < xAxisTexts.length; _xat++) {
          var _tSpan = xAxisTexts[_xat].childNodes;

          if (w.config.xaxis.labels.trim && w.config.chart.type !== 'bar' && w.config.plotOptions.bar.horizontal) {
            graphics.placeTextWithEllipsis(_tSpan[0], _tSpan[0].textContent, width);
          }
        }
      }

      if (yAxisTextsInversed.length > 0) {
        // truncate rotated y axis in bar chart (x axis)
        var firstLabelPosX = yAxisTextsInversed[yAxisTextsInversed.length - 1].getBBox();
        var lastLabelPosX = yAxisTextsInversed[0].getBBox();

        if (firstLabelPosX.x < -20) {
          yAxisTextsInversed[yAxisTextsInversed.length - 1].parentNode.removeChild(yAxisTextsInversed[yAxisTextsInversed.length - 1]);
        }

        if (lastLabelPosX.x + lastLabelPosX.width > w.globals.gridWidth) {
          yAxisTextsInversed[0].parentNode.removeChild(yAxisTextsInversed[0]);
        } // truncate rotated x axis in bar chart (y axis)


        for (var _xat2 = 0; _xat2 < xAxisTextsInversed.length; _xat2++) {
          graphics.placeTextWithEllipsis(xAxisTextsInversed[_xat2], xAxisTextsInversed[_xat2].textContent, w.config.yaxis[0].labels.maxWidth - parseInt(w.config.yaxis[0].title.style.fontSize) * 2 - 20);
        }
      }
    } // renderXAxisBands() {
    //   let w = this.w;
    //   let plotBand = document.createElementNS(w.globals.SVGNS, 'rect')
    //   w.globals.dom.elGraphical.add(plotBand)
    // }

  }]);

  return XAxis;
}();

var Range =
/*#__PURE__*/
function () {
  function Range(ctx) {
    _classCallCheck(this, Range);

    this.ctx = ctx;
    this.w = ctx.w;
    this.isBarHorizontal = !!(this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.horizontal);
  } // http://stackoverflow.com/questions/326679/choosing-an-attractive-linear-scale-for-a-graphs-y-axiss
  // This routine creates the Y axis values for a graph.


  _createClass(Range, [{
    key: "niceScale",
    value: function niceScale(yMin, yMax) {
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var ticks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;

      if (yMin === Number.MIN_VALUE && yMax === 0 || !Utils.isNumber(yMin) && !Utils.isNumber(yMax) || yMin === Number.MIN_VALUE && yMax === -Number.MAX_VALUE) {
        // when all values are 0
        yMin = 0;
        yMax = ticks;
        var linearScale = this.linearScale(yMin, yMax, ticks);
        return linearScale;
      }

      if (yMin > yMax) {
        // if somehow due to some wrong config, user sent max less than min,
        // adjust the min/max again
        console.warn('yaxis.min cannot be greater than yaxis.max');
        yMax = yMin + 0.1;
      } else if (yMin === yMax) {
        // If yMin and yMax are identical, then
        // adjust the yMin and yMax values to actually
        // make a graph. Also avoids division by zero errors.
        yMin = yMin === 0 ? 0 : yMin - 0.1; // some small value

        yMax = yMax === 0 ? 2 : yMax + 0.1; // some small value
      } // Calculate Min amd Max graphical labels and graph
      // increments.  The number of ticks defaults to
      // 10 which is the SUGGESTED value.  Any tick value
      // entered is used as a suggested value which is
      // adjusted to be a 'pretty' value.
      //
      // Output will be an array of the Y axis values that
      // encompass the Y values.


      var result = []; // Determine Range

      var range = yMax - yMin;
      var tiks = ticks + 1; // Adjust ticks if needed

      if (tiks < 2) {
        tiks = 2;
      } else if (tiks > 2) {
        tiks -= 2;
      } // Get raw step value


      var tempStep = range / tiks; // Calculate pretty step value

      var mag = Math.floor(Utils.log10(tempStep));
      var magPow = Math.pow(10, mag);
      var magMsd = parseInt(tempStep / magPow);
      var stepSize = magMsd * magPow; // build Y label array.
      // Lower and upper bounds calculations

      var lb = stepSize * Math.floor(yMin / stepSize);
      var ub = stepSize * Math.ceil(yMax / stepSize); // Build array

      var val = lb;

      while (1) {
        result.push(val);
        val += stepSize;

        if (val > ub) {
          break;
        }
      } // TODO: need to remove this condition below which makes this function tightly coupled with w.


      if (this.w.config.yaxis[index].max === undefined && this.w.config.yaxis[index].min === undefined || this.w.config.yaxis[index].forceNiceScale) {
        return {
          result: result,
          niceMin: result[0],
          niceMax: result[result.length - 1]
        };
      } else {
        result = [];
        var v = yMin;
        result.push(v);
        var valuesDivider = Math.abs(yMax - yMin) / ticks;

        for (var i = 0; i <= ticks - 1; i++) {
          v = v + valuesDivider;
          result.push(v);
        }

        return {
          result: result,
          niceMin: result[0],
          niceMax: result[result.length - 1]
        };
      }
    }
  }, {
    key: "linearScale",
    value: function linearScale(yMin, yMax) {
      var ticks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
      var range = Math.abs(yMax - yMin);
      var step = range / ticks;

      if (ticks === Number.MAX_VALUE) {
        ticks = 10;
        step = 1;
      }

      var result = [];
      var v = yMin;

      while (ticks >= 0) {
        result.push(v);
        v = v + step;
        ticks -= 1;
      }

      return {
        result: result,
        niceMin: result[0],
        niceMax: result[result.length - 1]
      };
    }
  }, {
    key: "logarithmicScale",
    value: function logarithmicScale(index, yMin, yMax, ticks) {
      if (yMin < 0 || yMin === Number.MIN_VALUE) yMin = 0.01;
      var base = 10;
      var min = Math.log(yMin) / Math.log(base);
      var max = Math.log(yMax) / Math.log(base);
      var range = Math.abs(yMax - yMin);
      var step = range / ticks;
      var result = [];
      var v = yMin;

      while (ticks >= 0) {
        result.push(v);
        v = v + step;
        ticks -= 1;
      }

      var logs = result.map(function (niceNumber, i) {
        if (niceNumber <= 0) {
          niceNumber = 0.01;
        } // calculate adjustment factor


        var scale = (max - min) / (yMax - yMin);
        var logVal = Math.pow(base, min + scale * (niceNumber - min));
        return Math.round(logVal / Utils.roundToBase(logVal, base)) * Utils.roundToBase(logVal, base);
      }); // Math.floor may have rounded the value to 0, revert back to 1

      if (logs[0] === 0) logs[0] = 1;
      return {
        result: logs,
        niceMin: logs[0],
        niceMax: logs[logs.length - 1]
      };
    }
  }, {
    key: "setYScaleForIndex",
    value: function setYScaleForIndex(index, minY, maxY) {
      var gl = this.w.globals;
      var cnf = this.w.config;
      var y = this.isBarHorizontal ? cnf.xaxis : cnf.yaxis[index];

      if (typeof gl.yAxisScale[index] === 'undefined') {
        gl.yAxisScale[index] = [];
      }

      if (y.logarithmic) {
        gl.allSeriesCollapsed = false;
        gl.yAxisScale[index] = this.logarithmicScale(index, minY, maxY, y.tickAmount ? y.tickAmount : Math.floor(Math.log10(maxY)));
      } else {
        if (maxY === -Number.MAX_VALUE || !Utils.isNumber(maxY)) {
          // no data in the chart. Either all series collapsed or user passed a blank array
          gl.yAxisScale[index] = this.linearScale(0, 5, 5);
        } else {
          // there is some data. Turn off the allSeriesCollapsed flag
          gl.allSeriesCollapsed = false;
          gl.yAxisScale[index] = this.niceScale(minY, maxY, index, // fix https://github.com/apexcharts/apexcharts.js/issues/397
          y.tickAmount ? y.tickAmount : maxY < 5 && maxY > 1 ? maxY + 1 : 5); //
        }
      }
    }
  }, {
    key: "setMultipleYScales",
    value: function setMultipleYScales() {
      var _this = this;

      var gl = this.w.globals;
      var cnf = this.w.config;
      var minYArr = gl.minYArr.concat([]);
      var maxYArr = gl.maxYArr.concat([]);
      var scalesIndices = []; // here, we loop through the yaxis array and find the item which has "seriesName" property

      cnf.yaxis.forEach(function (yaxe, i) {
        var index = i;
        cnf.series.forEach(function (s, si) {
          // if seriesName matches and that series is not collapsed, we use that scale
          if (s.name === yaxe.seriesName && gl.collapsedSeriesIndices.indexOf(si) === -1) {
            index = si;

            if (i !== si) {
              scalesIndices.push({
                index: si,
                similarIndex: i,
                alreadyExists: true
              });
            } else {
              scalesIndices.push({
                index: si
              });
            }
          }
        });
        var minY = minYArr[index];
        var maxY = maxYArr[index];

        _this.setYScaleForIndex(i, minY, maxY);
      });
      this.sameScaleInMultipleAxes(minYArr, maxYArr, scalesIndices);
    }
  }, {
    key: "sameScaleInMultipleAxes",
    value: function sameScaleInMultipleAxes(minYArr, maxYArr, scalesIndices) {
      var _this2 = this;

      var cnf = this.w.config;
      var gl = this.w.globals; // we got the scalesIndices array in the above code, but we need to filter out the items which doesn't have same scales

      var similarIndices = [];
      scalesIndices.forEach(function (scale) {
        if (scale.alreadyExists) {
          if (typeof similarIndices[scale.index] === 'undefined') {
            similarIndices[scale.index] = [];
          }

          similarIndices[scale.index].push(scale.index);
          similarIndices[scale.index].push(scale.similarIndex);
        }
      });

      function intersect(a, b) {
        return a.filter(function (value) {
          return b.indexOf(value) !== -1;
        });
      }

      similarIndices.forEach(function (si, i) {
        similarIndices.forEach(function (sj, j) {
          if (i !== j) {
            if (intersect(si, sj).length > 0) {
              similarIndices[i] = similarIndices[i].concat(similarIndices[j]);
            }
          }
        });
      }); // then, we remove duplicates from the similarScale array

      var uniqueSimilarIndices = similarIndices.map(function (item) {
        return item.filter(function (i, pos) {
          return item.indexOf(i) === pos;
        });
      }); // sort further to remove whole duplicate arrays later

      var sortedIndices = uniqueSimilarIndices.map(function (s) {
        return s.sort();
      }); // remove undefined items

      similarIndices = similarIndices.filter(function (s) {
        return !!s;
      });
      var indices = sortedIndices.slice();
      var stringIndices = indices.map(function (ind) {
        return JSON.stringify(ind);
      });
      indices = indices.filter(function (ind, p) {
        return stringIndices.indexOf(JSON.stringify(ind)) === p;
      });
      var sameScaleMinYArr = [];
      var sameScaleMaxYArr = [];
      minYArr.forEach(function (minYValue, yi) {
        indices.forEach(function (scale, i) {
          // we compare only the yIndex which exists in the indices array
          if (scale.indexOf(yi) > -1) {
            if (typeof sameScaleMinYArr[i] === 'undefined') {
              sameScaleMinYArr[i] = [];
              sameScaleMaxYArr[i] = [];
            }

            sameScaleMinYArr[i].push({
              key: yi,
              value: minYValue
            });
            sameScaleMaxYArr[i].push({
              key: yi,
              value: maxYArr[yi]
            });
          }
        });
      });
      var sameScaleMin = Array.apply(null, Array(indices.length)).map(Number.prototype.valueOf, Number.MIN_VALUE);
      var sameScaleMax = Array.apply(null, Array(indices.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
      sameScaleMinYArr.forEach(function (s, i) {
        s.forEach(function (sc, j) {
          sameScaleMin[i] = Math.min(sc.value, sameScaleMin[i]);
        });
      });
      sameScaleMaxYArr.forEach(function (s, i) {
        s.forEach(function (sc, j) {
          sameScaleMax[i] = Math.max(sc.value, sameScaleMax[i]);
        });
      });
      minYArr.forEach(function (min, i) {
        sameScaleMaxYArr.forEach(function (s, si) {
          var minY = sameScaleMin[si];
          var maxY = sameScaleMax[si];
          s.forEach(function (ind, k) {
            if (s[k].key === i) {
              if (cnf.yaxis[i].min !== undefined) {
                if (typeof cnf.yaxis[i].min === 'function') {
                  minY = cnf.yaxis[i].min(gl.minY);
                } else {
                  minY = cnf.yaxis[i].min;
                }
              }

              if (cnf.yaxis[i].max !== undefined) {
                if (typeof cnf.yaxis[i].max === 'function') {
                  maxY = cnf.yaxis[i].max(gl.maxY);
                } else {
                  maxY = cnf.yaxis[i].max;
                }
              }

              _this2.setYScaleForIndex(i, minY, maxY);
            }
          });
        });
      });
    }
  }, {
    key: "autoScaleY",
    value: function autoScaleY(ctx, e) {
      if (!ctx) {
        ctx = this;
      }

      var ret = [];
      ctx.w.config.series.forEach(function (serie) {
        var min, max;
        var first = serie.data.find(function (x) {
          return x[0] >= e.xaxis.min;
        });
        var firstValue = first[1];
        max = min = firstValue;
        serie.data.forEach(function (data) {
          if (data[0] <= e.xaxis.max && data[0] >= e.xaxis.min) {
            if (data[1] > max && data[1] !== null) max = data[1];
            if (data[1] < min && data[1] !== null) min = data[1];
          }
        });
        min *= 0.95;
        max *= 1.05;
        ret.push({
          min: min,
          max: max
        });
      });
      return ret;
    }
  }]);

  return Range;
}();

/**
 * Range is used to generates values between min and max.
 *
 * @module Range
 **/

var Range$1 =
/*#__PURE__*/
function () {
  function Range$$1(ctx) {
    _classCallCheck(this, Range$$1);

    this.ctx = ctx;
    this.w = ctx.w;
    this.isBarHorizontal = !!(this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.horizontal);
    this.scales = new Range(ctx);
  }

  _createClass(Range$$1, [{
    key: "init",
    value: function init() {
      this.setYRange();
      this.setXRange();
      this.setZRange();
    }
  }, {
    key: "getMinYMaxY",
    value: function getMinYMaxY(startingIndex) {
      var lowestY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
      var highestY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Number.MAX_VALUE;
      var len = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var gl = this.w.globals;
      var maxY = -Number.MAX_VALUE;
      var minY = Number.MIN_VALUE;

      if (len === null) {
        len = startingIndex + 1;
      }

      var series = gl.series;
      var seriesMin = series;
      var seriesMax = series;

      if (this.w.config.chart.type === 'candlestick') {
        seriesMin = gl.seriesCandleL;
        seriesMax = gl.seriesCandleH;
      }

      for (var i = startingIndex; i < len; i++) {
        gl.dataPoints = Math.max(gl.dataPoints, series[i].length);

        for (var j = 0; j < gl.series[i].length; j++) {
          if (series[i][j] !== null && Utils.isNumber(series[i][j])) {
            maxY = Math.max(maxY, seriesMax[i][j]);
            lowestY = Math.min(lowestY, seriesMin[i][j]);
            highestY = Math.max(highestY, seriesMin[i][j]);

            if (Utils.isFloat(series[i][j])) {
              gl.yValueDecimal = Math.max(gl.yValueDecimal, series[i][j].toString().split('.')[1].length);
            }

            if (minY > seriesMin[i][j] && seriesMin[i][j] < 0) {
              minY = seriesMin[i][j];
            }
          } else {
            gl.hasNullValues = true;
          }
        }
      }

      return {
        minY: minY,
        maxY: maxY,
        lowestY: lowestY,
        highestY: highestY
      };
    }
  }, {
    key: "setYRange",
    value: function setYRange() {
      var gl = this.w.globals;
      var cnf = this.w.config;
      gl.maxY = -Number.MAX_VALUE;
      gl.minY = Number.MIN_VALUE;
      var lowestYInAllSeries = Number.MAX_VALUE;

      if (gl.isMultipleYAxis) {
        // we need to get minY and maxY for multiple y axis
        for (var i = 0; i < gl.series.length; i++) {
          var minYMaxYArr = this.getMinYMaxY(i, lowestYInAllSeries, null, i + 1);
          gl.minYArr.push(minYMaxYArr.minY);
          gl.maxYArr.push(minYMaxYArr.maxY);
          lowestYInAllSeries = minYMaxYArr.lowestY;
        }
      } // and then, get the minY and maxY from all series


      var minYMaxY = this.getMinYMaxY(0, lowestYInAllSeries, null, gl.series.length);
      gl.minY = minYMaxY.minY;
      gl.maxY = minYMaxY.maxY;
      lowestYInAllSeries = minYMaxY.lowestY;

      if (cnf.chart.stacked) {
        // for stacked charts, we calculate each series's parallel values. i.e, series[0][j] + series[1][j] .... [series[i.length][j]] and get the max out of it
        var stackedPoss = [];
        var stackedNegs = [];

        for (var j = 0; j < gl.series[gl.maxValsInArrayIndex].length; j++) {
          var poss = 0;
          var negs = 0;

          for (var _i = 0; _i < gl.series.length; _i++) {
            if (gl.series[_i][j] !== null && Utils.isNumber(gl.series[_i][j])) {
              if (gl.series[_i][j] > 0) {
                // 0.0001 fixes #185 when values are very small
                poss = poss + parseFloat(gl.series[_i][j]) + 0.0001;
              } else {
                negs = negs + parseFloat(gl.series[_i][j]);
              }
            }

            if (_i === gl.series.length - 1) {
              // push all the totals to the array for future use
              stackedPoss.push(poss);
              stackedNegs.push(negs);
            }
          }
        } // get the max/min out of the added parallel values


        for (var z = 0; z < stackedPoss.length; z++) {
          gl.maxY = Math.max(gl.maxY, stackedPoss[z]);
          gl.minY = Math.min(gl.minY, stackedNegs[z]);
        }
      } // if the numbers are too big, reduce the range
      // for eg, if number is between 100000-110000, putting 0 as the lowest value is not so good idea. So change the gl.minY for line/area/candlesticks


      if (cnf.chart.type === 'line' || cnf.chart.type === 'area' || cnf.chart.type === 'candlestick') {
        if (gl.minY === Number.MIN_VALUE && lowestYInAllSeries !== -Number.MAX_VALUE) {
          var diff = gl.maxY - lowestYInAllSeries;

          if (lowestYInAllSeries >= 0 && lowestYInAllSeries <= 10) {
            // if minY is already 0/low value, we don't want to go negatives here - so this check is essential.
            diff = 0;
          }

          gl.minY = lowestYInAllSeries - diff * 5 / 100;
          gl.maxY = gl.maxY + diff * 5 / 100 + 0.05;
        }
      }

      cnf.yaxis.map(function (yaxe, index) {
        // override all min/max values by user defined values (y axis)
        if (yaxe.max !== undefined) {
          if (typeof yaxe.max === 'number') {
            gl.maxYArr[index] = yaxe.max;
          } else if (typeof yaxe.max === 'function') {
            gl.maxYArr[index] = yaxe.max(gl.maxY);
          } // gl.maxY is for single y-axis chart, it will be ignored in multi-yaxis


          gl.maxY = gl.maxYArr[index];
        }

        if (yaxe.min !== undefined) {
          if (typeof yaxe.min === 'number') {
            gl.minYArr[index] = yaxe.min;
          } else if (typeof yaxe.min === 'function') {
            gl.minYArr[index] = yaxe.min(gl.minY);
          } // gl.minY is for single y-axis chart, it will be ignored in multi-yaxis


          gl.minY = gl.minYArr[index];
        }
      }); // for horizontal bar charts, we need to check xaxis min/max as user may have specified there

      if (this.isBarHorizontal) {
        if (cnf.xaxis.min !== undefined && typeof cnf.xaxis.min === 'number') {
          gl.minY = cnf.xaxis.min;
        }

        if (cnf.xaxis.max !== undefined && typeof cnf.xaxis.max === 'number') {
          gl.maxY = cnf.xaxis.max;
        }
      } // for multi y-axis we need different scales for each


      if (gl.isMultipleYAxis) {
        this.scales.setMultipleYScales();
        gl.minY = lowestYInAllSeries;
        gl.yAxisScale.forEach(function (scale, i) {
          gl.minYArr[i] = scale.niceMin;
          gl.maxYArr[i] = scale.niceMax;
        });
      } else {
        this.scales.setYScaleForIndex(0, gl.minY, gl.maxY);
        gl.minY = gl.yAxisScale[0].niceMin;
        gl.maxY = gl.yAxisScale[0].niceMax;
        gl.minYArr[0] = gl.yAxisScale[0].niceMin;
        gl.maxYArr[0] = gl.yAxisScale[0].niceMax;
      }
    }
  }, {
    key: "setXRange",
    value: function setXRange() {
      var gl = this.w.globals;
      var cnf = this.w.config;
      var isXNumeric = cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'datetime' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided; // minX maxX starts here

      if (gl.isXNumeric) {
        for (var i = 0; i < gl.series.length; i++) {
          if (gl.labels[i]) {
            for (var j = 0; j < gl.labels[i].length; j++) {
              if (gl.labels[i][j] !== null && Utils.isNumber(gl.labels[i][j])) {
                gl.maxX = Math.max(gl.maxX, gl.labels[i][j]);
                gl.initialmaxX = Math.max(gl.maxX, gl.labels[i][j]);
                gl.minX = Math.min(gl.minX, gl.labels[i][j]);
                gl.initialminX = Math.min(gl.minX, gl.labels[i][j]);
              }
            }
          }
        }
      }

      if (gl.noLabelsProvided) {
        if (cnf.xaxis.categories.length === 0) {
          gl.maxX = gl.labels[gl.labels.length - 1];
          gl.initialmaxX = gl.labels[gl.labels.length - 1];
          gl.minX = 1;
          gl.initialminX = 1;
        }
      } // for numeric xaxis, we need to adjust some padding left and right for bar charts


      if (gl.comboChartsHasBars || cnf.chart.type === 'candlestick' || cnf.chart.type === 'bar' && cnf.xaxis.type !== 'category') {
        if (cnf.xaxis.type !== 'category') {
          var minX = gl.minX - gl.svgWidth / gl.dataPoints * (Math.abs(gl.maxX - gl.minX) / gl.svgWidth) / 2;
          gl.minX = minX;
          gl.initialminX = minX;
          var maxX = gl.maxX + gl.svgWidth / gl.dataPoints * (Math.abs(gl.maxX - gl.minX) / gl.svgWidth) / 2;
          gl.maxX = maxX;
          gl.initialmaxX = maxX;
        }
      }

      if (gl.isXNumeric || gl.noLabelsProvided) {
        var ticks;

        if (cnf.xaxis.tickAmount === undefined) {
          ticks = Math.round(gl.svgWidth / 150); // no labels provided and total number of dataPoints is less than 20

          if (cnf.xaxis.type === 'numeric' && gl.dataPoints < 20) {
            ticks = gl.dataPoints - 1;
          } // this check is for when ticks exceeds total datapoints and that would result in duplicate labels


          if (ticks > gl.dataPoints && gl.dataPoints !== 0) {
            ticks = gl.dataPoints - 1;
          }
        } else if (cnf.xaxis.tickAmount === 'dataPoints') {
          ticks = gl.series[gl.maxValsInArrayIndex].length - 1;
        } else {
          ticks = cnf.xaxis.tickAmount;
        } // override all min/max values by user defined values (x axis)


        if (cnf.xaxis.max !== undefined && typeof cnf.xaxis.max === 'number') {
          gl.maxX = cnf.xaxis.max;
        }

        if (cnf.xaxis.min !== undefined && typeof cnf.xaxis.min === 'number') {
          gl.minX = cnf.xaxis.min;
        } // if range is provided, adjust the new minX


        if (cnf.xaxis.range !== undefined) {
          gl.minX = gl.maxX - cnf.xaxis.range;
        }

        if (gl.minX !== Number.MAX_VALUE && gl.maxX !== -Number.MAX_VALUE) {
          gl.xAxisScale = this.scales.linearScale(gl.minX, gl.maxX, ticks);
        } else {
          gl.xAxisScale = this.scales.linearScale(1, ticks, ticks);

          if (gl.noLabelsProvided && gl.labels.length > 0) {
            gl.xAxisScale = this.scales.linearScale(1, gl.labels.length, ticks - 1);
            gl.seriesX = gl.labels.slice();
          }
        } // we will still store these labels as the count for this will be different (to draw grid and labels placement)


        if (isXNumeric) {
          gl.labels = gl.xAxisScale.result.slice();
        }
      }

      if (gl.minX === gl.maxX) {
        // single dataPoint
        if (cnf.xaxis.type === 'datetime') {
          var newMinX = new Date(gl.minX);
          newMinX.setDate(newMinX.getDate() - 2);
          gl.minX = new Date(newMinX).getTime();
          var newMaxX = new Date(gl.maxX);
          newMaxX.setDate(newMaxX.getDate() + 2);
          gl.maxX = new Date(newMaxX).getTime();
        } else if (cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided) {
          gl.minX = gl.minX - 2;
          gl.maxX = gl.maxX + 2;
        }
      }
    }
  }, {
    key: "setZRange",
    value: function setZRange() {
      var gl = this.w.globals; // minZ, maxZ starts here

      if (gl.isDataXYZ) {
        for (var i = 0; i < gl.series.length; i++) {
          if (typeof gl.seriesZ[i] !== 'undefined') {
            for (var j = 0; j < gl.seriesZ[i].length; j++) {
              if (gl.seriesZ[i][j] !== null && Utils.isNumber(gl.seriesZ[i][j])) {
                gl.maxZ = Math.max(gl.maxZ, gl.seriesZ[i][j]);
                gl.minZ = Math.min(gl.minZ, gl.seriesZ[i][j]);
              }
            }
          }
        }
      }
    }
  }]);

  return Range$$1;
}();

/**
 * ApexCharts Series Class for interation with the Series of the chart.
 *
 * @module Series
 **/

var Series =
/*#__PURE__*/
function () {
  function Series(ctx) {
    _classCallCheck(this, Series);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(Series, [{
    key: "getAllSeriesEls",
    value: function getAllSeriesEls() {
      return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
    }
  }, {
    key: "getSeriesByName",
    value: function getSeriesByName(seriesName) {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-series.".concat(Utils.escapeString(seriesName)));
    }
  }, {
    key: "addCollapsedClassToSeries",
    value: function addCollapsedClassToSeries(elSeries, index) {
      var w = this.w;

      for (var cs = 0; cs < w.globals.collapsedSeries.length; cs++) {
        if (w.globals.collapsedSeries[cs].index === index) {
          elSeries.node.classList.add('apexcharts-series-collapsed');
        }
      }
    }
  }, {
    key: "toggleSeriesOnHover",
    value: function toggleSeriesOnHover(e, targetElement) {
      var w = this.w;
      var allSeriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-series");

      if (e.type === 'mousemove') {
        var seriesCnt = parseInt(targetElement.getAttribute('rel')) - 1;
        var seriesEl = null;

        if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {
          if (w.globals.axisCharts) {
            seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(seriesCnt, "']"));
          } else {
            seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(seriesCnt + 1, "']"));
          }
        } else {
          seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(seriesCnt + 1, "'] path"));
        }

        for (var se = 0; se < allSeriesEls.length; se++) {
          allSeriesEls[se].classList.add('legend-mouseover-inactive');
        }

        if (seriesEl !== null) {
          if (!w.globals.axisCharts) {
            seriesEl.parentNode.classList.remove('legend-mouseover-inactive');
          }

          seriesEl.classList.remove('legend-mouseover-inactive');
        }
      } else if (e.type === 'mouseout') {
        for (var _se = 0; _se < allSeriesEls.length; _se++) {
          allSeriesEls[_se].classList.remove('legend-mouseover-inactive');
        }
      }
    }
  }, {
    key: "highlightRangeInSeries",
    value: function highlightRangeInSeries(e, targetElement) {
      var w = this.w;
      var allHeatMapElements = w.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap-rect');

      var allActive = function allActive() {
        for (var i = 0; i < allHeatMapElements.length; i++) {
          allHeatMapElements[i].classList.remove('legend-mouseover-inactive');
        }
      };

      var allInactive = function allInactive() {
        for (var i = 0; i < allHeatMapElements.length; i++) {
          allHeatMapElements[i].classList.add('legend-mouseover-inactive');
        }
      };

      var selectedActive = function selectedActive(range) {
        for (var i = 0; i < allHeatMapElements.length; i++) {
          var val = parseInt(allHeatMapElements[i].getAttribute('val'));

          if (val >= range.from && val <= range.to) {
            allHeatMapElements[i].classList.remove('legend-mouseover-inactive');
          }
        }
      };

      if (e.type === 'mousemove') {
        var seriesCnt = parseInt(targetElement.getAttribute('rel')) - 1;
        allActive();
        allInactive();
        var range = w.config.plotOptions.heatmap.colorScale.ranges[seriesCnt];
        selectedActive(range);
      } else if (e.type === 'mouseout') {
        allActive();
      }
    }
  }, {
    key: "getActiveSeriesIndex",
    value: function getActiveSeriesIndex() {
      var w = this.w;
      var activeIndex = 0;

      if (w.globals.series.length > 1) {
        // active series flag is required to know if user has not deactivated via legend click
        var firstActiveSeriesIndex = w.globals.series.map(function (series, index) {
          if (series.length > 0 && w.config.series[index].type !== 'bar' && w.config.series[index].type !== 'column') {
            return index;
          } else {
            return -1;
          }
        });

        for (var a = 0; a < firstActiveSeriesIndex.length; a++) {
          if (firstActiveSeriesIndex[a] !== -1) {
            activeIndex = firstActiveSeriesIndex[a];
            break;
          }
        }
      }

      return activeIndex;
    }
  }, {
    key: "getActiveConfigSeriesIndex",
    value: function getActiveConfigSeriesIndex() {
      var w = this.w;
      var activeIndex = 0;

      if (w.config.series.length > 1) {
        // active series flag is required to know if user has not deactivated via legend click
        var firstActiveSeriesIndex = w.config.series.map(function (series, index) {
          if (series.data && series.data.length > 0) {
            return index;
          } else {
            return -1;
          }
        });

        for (var a = 0; a < firstActiveSeriesIndex.length; a++) {
          if (firstActiveSeriesIndex[a] !== -1) {
            activeIndex = firstActiveSeriesIndex[a];
            break;
          }
        }
      }

      return activeIndex;
    }
  }, {
    key: "getPreviousPaths",
    value: function getPreviousPaths() {
      var w = this.w;
      w.globals.previousPaths = [];

      function pushPaths(seriesEls, i, type) {
        var paths = seriesEls[i].childNodes;
        var dArr = {
          type: type,
          paths: [],
          realIndex: seriesEls[i].getAttribute('data:realIndex')
        };

        for (var j = 0; j < paths.length; j++) {
          if (paths[j].hasAttribute('pathTo')) {
            var d = paths[j].getAttribute('pathTo');
            dArr.paths.push({
              d: d
            });
          }
        }

        w.globals.previousPaths.push(dArr);
      }

      var linePaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-series');

      if (linePaths.length > 0) {
        for (var p = linePaths.length - 1; p >= 0; p--) {
          pushPaths(linePaths, p, 'line');
        }
      }

      var areapaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-area-series .apexcharts-series');

      if (areapaths.length > 0) {
        for (var i = areapaths.length - 1; i >= 0; i--) {
          pushPaths(areapaths, i, 'area');
        }
      }

      var barPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series .apexcharts-series');

      if (barPaths.length > 0) {
        for (var _p = 0; _p < barPaths.length; _p++) {
          pushPaths(barPaths, _p, 'bar');
        }
      }

      var candlestickPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-candlestick-series .apexcharts-series');

      if (candlestickPaths.length > 0) {
        for (var _p2 = 0; _p2 < candlestickPaths.length; _p2++) {
          pushPaths(candlestickPaths, _p2, 'candlestick');
        }
      }

      var radarPaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-radar-series .apexcharts-series');

      if (radarPaths.length > 0) {
        for (var _p3 = 0; _p3 < radarPaths.length; _p3++) {
          pushPaths(radarPaths, _p3, 'radar');
        }
      }

      var bubblepaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bubble-series .apexcharts-series');

      if (bubblepaths.length > 0) {
        for (var s = 0; s < bubblepaths.length; s++) {
          var seriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-bubble-series .apexcharts-series[data\\:realIndex='".concat(s, "'] circle"));
          var dArr = [];

          for (var _i = 0; _i < seriesEls.length; _i++) {
            dArr.push({
              x: seriesEls[_i].getAttribute('cx'),
              y: seriesEls[_i].getAttribute('cy'),
              r: seriesEls[_i].getAttribute('r')
            });
          }

          w.globals.previousPaths.push(dArr);
        }
      }

      var scatterpaths = w.globals.dom.baseEl.querySelectorAll('.apexcharts-scatter-series .apexcharts-series');

      if (scatterpaths.length > 0) {
        for (var _s = 0; _s < scatterpaths.length; _s++) {
          var _seriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-scatter-series .apexcharts-series[data\\:realIndex='".concat(_s, "'] circle"));

          var _dArr = [];

          for (var _i2 = 0; _i2 < _seriesEls.length; _i2++) {
            _dArr.push({
              x: _seriesEls[_i2].getAttribute('cx'),
              y: _seriesEls[_i2].getAttribute('cy'),
              r: _seriesEls[_i2].getAttribute('r')
            });
          }

          w.globals.previousPaths.push(_dArr);
        }
      }

      var heatmapColors = w.globals.dom.baseEl.querySelectorAll('.apexcharts-heatmap .apexcharts-series');

      if (heatmapColors.length > 0) {
        for (var h = 0; h < heatmapColors.length; h++) {
          var _seriesEls2 = w.globals.dom.baseEl.querySelectorAll(".apexcharts-heatmap .apexcharts-series[data\\:realIndex='".concat(h, "'] rect"));

          var _dArr2 = [];

          for (var _i3 = 0; _i3 < _seriesEls2.length; _i3++) {
            _dArr2.push({
              color: _seriesEls2[_i3].getAttribute('color')
            });
          }

          w.globals.previousPaths.push(_dArr2);
        }
      }

      if (!w.globals.axisCharts) {
        // for non-axis charts (i.e., circular charts, pathFrom is not usable. We need whole series)
        w.globals.previousPaths = w.globals.series;
      }
    }
  }, {
    key: "handleNoData",
    value: function handleNoData() {
      var w = this.w;
      var me = this;
      var noDataOpts = w.config.noData;
      var graphics = new Graphics(me.ctx);
      var x = w.globals.svgWidth / 2;
      var y = w.globals.svgHeight / 2;
      var textAnchor = 'middle';
      w.globals.noData = true;
      w.globals.animationEnded = true;

      if (noDataOpts.align === 'left') {
        x = 10;
        textAnchor = 'start';
      } else if (noDataOpts.align === 'right') {
        x = w.globals.svgWidth - 10;
        textAnchor = 'end';
      }

      if (noDataOpts.verticalAlign === 'top') {
        y = 50;
      } else if (noDataOpts.verticalAlign === 'bottom') {
        y = w.globals.svgHeight - 50;
      }

      x = x + noDataOpts.offsetX;
      y = y + parseInt(noDataOpts.style.fontSize) + 2;

      if (noDataOpts.text !== undefined && noDataOpts.text !== '') {
        var titleText = graphics.drawText({
          x: x,
          y: y,
          text: noDataOpts.text,
          textAnchor: textAnchor,
          fontSize: noDataOpts.style.fontSize,
          fontFamily: noDataOpts.style.fontFamily,
          foreColor: noDataOpts.style.color,
          opacity: 1,
          class: 'apexcharts-text-nodata'
        });
        titleText.node.setAttribute('class', 'apexcharts-title-text');
        w.globals.dom.Paper.add(titleText);
      }
    } // When user clicks on legends, the collapsed series is filled with [0,0,0,...,0]
    // This is because we don't want to alter the series' length as it is used at many places

  }, {
    key: "setNullSeriesToZeroValues",
    value: function setNullSeriesToZeroValues(series) {
      var w = this.w;

      for (var sl = 0; sl < series.length; sl++) {
        if (series[sl].length === 0) {
          for (var j = 0; j < series[w.globals.maxValsInArrayIndex].length; j++) {
            series[sl].push(0);
          }
        }
      }

      return series;
    }
  }, {
    key: "hasAllSeriesEqualX",
    value: function hasAllSeriesEqualX() {
      var equalLen = true;
      var w = this.w;
      var filteredSerX = this.filteredSeriesX();

      for (var i = 0; i < filteredSerX.length - 1; i++) {
        if (filteredSerX[i][0] !== filteredSerX[i + 1][0]) {
          equalLen = false;
          break;
        }
      }

      w.globals.allSeriesHasEqualX = equalLen;
      return equalLen;
    }
  }, {
    key: "filteredSeriesX",
    value: function filteredSeriesX() {
      var w = this.w;
      var filteredSeriesX = w.globals.seriesX.map(function (ser, index) {
        if (ser.length > 0) {
          return ser;
        } else {
          return [];
        }
      });
      return filteredSeriesX;
    }
  }]);

  return Series;
}();

/**
 * ApexCharts Dimensions Class for calculating rects of all elements that are drawn and will be drawn.
 *
 * @module Dimensions
 **/

var Dimensions =
/*#__PURE__*/
function () {
  function Dimensions(ctx) {
    _classCallCheck(this, Dimensions);

    this.ctx = ctx;
    this.w = ctx.w;
    this.lgRect = {};
    this.yAxisWidth = 0;
    this.xAxisHeight = 0;
    this.isSparkline = this.w.config.chart.sparkline.enabled;
    this.xPadRight = 0;
    this.xPadLeft = 0;
    this.isBarHorizontal = !!(this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.horizontal);
  }
  /**
   * @memberof Dimensions
   * @param {object} w - chart context
   **/


  _createClass(Dimensions, [{
    key: "plotCoords",
    value: function plotCoords() {
      var w = this.w;
      var gl = w.globals;
      var lgRect = this.getLegendsRect();

      if (gl.axisCharts) {
        // for line / area / scatter / column
        this.setGridCoordsForAxisCharts(lgRect);
      } else {
        // for pie / donuts / circle
        this.setGridCoordsForNonAxisCharts(lgRect);
      }

      this.titleSubtitleOffset(); // after calculating everything, apply padding set by user

      gl.gridHeight = gl.gridHeight - w.config.grid.padding.top - w.config.grid.padding.bottom;
      gl.gridWidth = gl.gridWidth - w.config.grid.padding.left - w.config.grid.padding.right - this.xPadRight - this.xPadLeft;
      gl.translateX = gl.translateX + w.config.grid.padding.left + this.xPadLeft;
      gl.translateY = gl.translateY + w.config.grid.padding.top;
    }
  }, {
    key: "conditionalChecksForAxisCoords",
    value: function conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords) {
      var w = this.w;
      this.xAxisHeight = (xaxisLabelCoords.height + xtitleCoords.height) * w.globals.LINE_HEIGHT_RATIO + 15;
      this.xAxisWidth = xaxisLabelCoords.width;

      if (this.xAxisHeight - xtitleCoords.height > w.config.xaxis.labels.maxHeight) {
        this.xAxisHeight = w.config.xaxis.labels.maxHeight;
      }

      if (w.config.xaxis.labels.minHeight && this.xAxisHeight < w.config.xaxis.labels.minHeight) {
        this.xAxisHeight = w.config.xaxis.labels.minHeight;
      }

      if (w.config.xaxis.floating) {
        this.xAxisHeight = 0;
      }

      if (!this.isBarHorizontal) {
        this.yAxisWidth = this.getTotalYAxisWidth();
      } else {
        this.yAxisWidth = w.globals.yLabelsCoords[0].width + w.globals.yTitleCoords[0].width + 15;
      }

      if (!w.globals.isMultipleYAxis) {
        if (this.yAxisWidth < w.config.yaxis[0].labels.minWidth) {
          this.yAxisWidth = w.config.yaxis[0].labels.minWidth;
        }

        if (this.yAxisWidth > w.config.yaxis[0].labels.maxWidth) {
          this.yAxisWidth = w.config.yaxis[0].labels.maxWidth;
        }
      }
    }
  }, {
    key: "setGridCoordsForAxisCharts",
    value: function setGridCoordsForAxisCharts(lgRect) {
      var w = this.w;
      var gl = w.globals;
      var yaxisLabelCoords = this.getyAxisLabelsCoords();
      var xaxisLabelCoords = this.getxAxisLabelsCoords();
      var yTitleCoords = this.getyAxisTitleCoords();
      var xtitleCoords = this.getxAxisTitleCoords();
      w.globals.yLabelsCoords = [];
      w.globals.yTitleCoords = [];
      w.config.yaxis.map(function (yaxe, index) {
        // store the labels and titles coords in global vars
        w.globals.yLabelsCoords.push({
          width: yaxisLabelCoords[index].width,
          index: index
        });
        w.globals.yTitleCoords.push({
          width: yTitleCoords[index].width,
          index: index
        });
      });
      this.conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords);
      gl.translateXAxisY = w.globals.rotateXLabels ? this.xAxisHeight / 8 : -4;
      gl.translateXAxisX = w.globals.rotateXLabels && w.globals.isXNumeric && w.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0;

      if (this.isBarHorizontal) {
        gl.rotateXLabels = false;
        gl.translateXAxisY = -1 * (parseInt(w.config.xaxis.labels.style.fontSize) / 1.5);
      }

      gl.translateXAxisY = gl.translateXAxisY + w.config.xaxis.labels.offsetY;
      gl.translateXAxisX = gl.translateXAxisX + w.config.xaxis.labels.offsetX;
      var yAxisWidth = this.yAxisWidth;
      var xAxisHeight = this.xAxisHeight;
      gl.xAxisLabelsHeight = this.xAxisHeight;
      gl.xAxisHeight = this.xAxisHeight;
      var translateY = 10;

      if (!w.config.grid.show || w.config.chart.type === 'radar') {
        yAxisWidth = 0;
        xAxisHeight = 35;
      }

      if (this.isSparkline) {
        lgRect = {
          height: 0,
          width: 0
        };
        xAxisHeight = 0;
        yAxisWidth = 0;
        translateY = 0;
      }

      this.additionalPaddingXLabels(xaxisLabelCoords);

      switch (w.config.legend.position) {
        case 'bottom':
          gl.translateY = translateY;
          gl.translateX = yAxisWidth;
          gl.gridHeight = gl.svgHeight - lgRect.height - xAxisHeight - (!this.isSparkline ? w.globals.rotateXLabels ? 10 : 15 : 0);
          gl.gridWidth = gl.svgWidth - yAxisWidth;
          break;

        case 'top':
          gl.translateY = lgRect.height + translateY;
          gl.translateX = yAxisWidth;
          gl.gridHeight = gl.svgHeight - lgRect.height - xAxisHeight - (!this.isSparkline ? w.globals.rotateXLabels ? 10 : 15 : 0);
          gl.gridWidth = gl.svgWidth - yAxisWidth;
          break;

        case 'left':
          gl.translateY = translateY;
          gl.translateX = lgRect.width + yAxisWidth;
          gl.gridHeight = gl.svgHeight - xAxisHeight - 12;
          gl.gridWidth = gl.svgWidth - lgRect.width - yAxisWidth;
          break;

        case 'right':
          gl.translateY = translateY;
          gl.translateX = yAxisWidth;
          gl.gridHeight = gl.svgHeight - xAxisHeight - 12;
          gl.gridWidth = gl.svgWidth - lgRect.width - yAxisWidth - 5;
          break;

        default:
          throw new Error('Legend position not supported');
      }

      this.setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords); // after drawing everything, set the Y axis positions

      var objyAxis = new YAxis(this.ctx);
      objyAxis.setYAxisXPosition(yaxisLabelCoords, yTitleCoords);
    }
  }, {
    key: "setGridCoordsForNonAxisCharts",
    value: function setGridCoordsForNonAxisCharts(lgRect) {
      var w = this.w;
      var gl = w.globals;
      var xPad = 0;

      if (w.config.legend.show && !w.config.legend.floating) {
        xPad = 20;
      }

      var offY = 10;
      var offX = 0;

      if (w.config.chart.type === 'pie' || w.config.chart.type === 'donut') {
        offY = offY + w.config.plotOptions.pie.offsetY;
        offX = offX + w.config.plotOptions.pie.offsetX;
      } else if (w.config.chart.type === 'radialBar') {
        offY = offY + w.config.plotOptions.radialBar.offsetY;
        offX = offX + w.config.plotOptions.radialBar.offsetX;
      }

      if (!w.config.legend.show) {
        gl.gridHeight = gl.svgHeight - 35;
        gl.gridWidth = gl.gridHeight;
        gl.translateY = offY - 10;
        gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;
        return;
      }

      switch (w.config.legend.position) {
        case 'bottom':
          gl.gridHeight = gl.svgHeight - lgRect.height - 35;
          gl.gridWidth = gl.gridHeight;
          gl.translateY = offY - 20;
          gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;
          break;

        case 'top':
          gl.gridHeight = gl.svgHeight - lgRect.height - 35;
          gl.gridWidth = gl.gridHeight;
          gl.translateY = lgRect.height + offY;
          gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;
          break;

        case 'left':
          gl.gridWidth = gl.svgWidth - lgRect.width - xPad;
          gl.gridHeight = gl.gridWidth;
          gl.translateY = offY;
          gl.translateX = offX + lgRect.width + xPad;
          break;

        case 'right':
          gl.gridWidth = gl.svgWidth - lgRect.width - xPad - 5;
          gl.gridHeight = gl.gridWidth;
          gl.translateY = offY;
          gl.translateX = offX + 10;
          break;

        default:
          throw new Error('Legend position not supported');
      }
    }
  }, {
    key: "setGridXPosForDualYAxis",
    value: function setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords) {
      var w = this.w;
      w.config.yaxis.map(function (yaxe, index) {
        if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1 && !w.config.yaxis[index].floating && w.config.yaxis[index].show) {
          if (yaxe.opposite) {
            w.globals.translateX = w.globals.translateX - (yaxisLabelCoords[index].width + yTitleCoords[index].width) - parseInt(w.config.yaxis[index].labels.style.fontSize) / 1.2 - 12;
          }
        }
      });
    } // Sometimes, the last labels gets cropped in category/numeric xaxis.
    // Hence, we add some additional padding based on the label length to avoid the last label being cropped.
    // NOTE: datetime x-axis won't have any effect with this as we don't know the label length there due to many constraints.

  }, {
    key: "additionalPaddingXLabels",
    value: function additionalPaddingXLabels(xaxisLabelCoords) {
      var _this = this;

      var w = this.w;

      if (w.config.xaxis.type === 'category' && this.isBarHorizontal || w.config.xaxis.type === 'numeric') {
        var rightPad = function rightPad(labels) {
          if (w.config.grid.padding.right < labels.width) {
            _this.xPadRight = labels.width / 2 + 1;
          }
        };

        var leftPad = function leftPad(labels) {
          if (w.config.grid.padding.left < labels.width) {
            _this.xPadLeft = labels.width / 2 + 1;
          }
        };

        var lineArea = w.config.chart.type === 'line' || w.config.chart.type === 'area';
        w.config.yaxis.forEach(function (yaxe, i) {
          var shouldPad = !yaxe.show || yaxe.floating || w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || lineArea || yaxe.opposite && _this.isBarHorizontal;

          if (shouldPad) {
            if (lineArea && w.globals.isMultipleYAxis && w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || _this.isBarHorizontal && yaxe.opposite) {
              leftPad(xaxisLabelCoords);
            }

            if (!_this.isBarHorizontal && yaxe.opposite && w.globals.collapsedSeriesIndices.indexOf(i) !== -1 || lineArea && !w.globals.isMultipleYAxis) {
              rightPad(xaxisLabelCoords);
            }
          }
        });
      }
    }
  }, {
    key: "titleSubtitleOffset",
    value: function titleSubtitleOffset() {
      var w = this.w;
      var gl = w.globals;
      var gridShrinkOffset = this.isSparkline ? 0 : 10;

      if (w.config.title.text !== undefined) {
        gridShrinkOffset += w.config.title.margin;
      } else {
        gridShrinkOffset += this.isSparkline ? 0 : 5;
      }

      if (w.config.subtitle.text !== undefined) {
        gridShrinkOffset += w.config.subtitle.margin;
      } else {
        gridShrinkOffset += this.isSparkline ? 0 : 5;
      }

      if (w.config.legend.show && w.config.legend.position === 'bottom' && !w.config.legend.floating && w.config.series.length > 1) {
        gridShrinkOffset += 10;
      }

      var titleCoords = this.getTitleSubtitleCoords('title');
      var subtitleCoords = this.getTitleSubtitleCoords('subtitle');
      gl.gridHeight = gl.gridHeight - titleCoords.height - subtitleCoords.height - gridShrinkOffset;
      gl.translateY = gl.translateY + titleCoords.height + subtitleCoords.height + gridShrinkOffset;
    }
  }, {
    key: "getTotalYAxisWidth",
    value: function getTotalYAxisWidth() {
      var w = this.w;
      var yAxisWidth = 0;
      var padding = 10;

      var isHiddenYAxis = function isHiddenYAxis(index) {
        return w.globals.ignoreYAxisIndexes.indexOf(index) > -1;
      };

      w.globals.yLabelsCoords.map(function (yLabelCoord, index) {
        var floating = w.config.yaxis[index].floating;

        if (yLabelCoord.width > 0 && !floating) {
          yAxisWidth = yAxisWidth + yLabelCoord.width + padding;

          if (isHiddenYAxis(index)) {
            yAxisWidth = yAxisWidth - yLabelCoord.width - padding;
          }
        } else {
          yAxisWidth = yAxisWidth + (floating || !w.config.yaxis[index].show ? 0 : 5);
        }
      });
      w.globals.yTitleCoords.map(function (yTitleCoord, index) {
        var floating = w.config.yaxis[index].floating;
        padding = parseInt(w.config.yaxis[index].title.style.fontSize);

        if (yTitleCoord.width > 0 && !floating) {
          yAxisWidth = yAxisWidth + yTitleCoord.width + padding;

          if (isHiddenYAxis(index)) {
            yAxisWidth = yAxisWidth - yTitleCoord.width - padding;
          }
        } else {
          yAxisWidth = yAxisWidth + (floating || !w.config.yaxis[index].show ? 0 : 5);
        }
      });
      return yAxisWidth;
    }
  }, {
    key: "getxAxisTimeScaleLabelsCoords",
    value: function getxAxisTimeScaleLabelsCoords() {
      var w = this.w;
      var rect;
      var timescaleLabels = w.globals.timelineLabels.slice();
      var labels = timescaleLabels.map(function (label) {
        return label.value;
      }); //  get the longest string from the labels array and also apply label formatter to it

      var val = labels.reduce(function (a, b) {
        // if undefined, maybe user didn't pass the datetime(x) values
        if (typeof a === 'undefined') {
          console.error('You have possibly supplied invalid Date format. Please supply a valid JavaScript Date');
          return 0;
        } else {
          return a.length > b.length ? a : b;
        }
      }, 0);
      var graphics = new Graphics(this.ctx);
      rect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);
      var totalWidthRotated = rect.width * 1.05 * labels.length;

      if (totalWidthRotated > w.globals.gridWidth && w.config.xaxis.labels.rotate !== 0) {
        w.globals.overlappingXLabels = true;
      }

      return rect;
    }
    /**
     * Get X Axis Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/

  }, {
    key: "getxAxisLabelsCoords",
    value: function getxAxisLabelsCoords() {
      var w = this.w;
      var xaxisLabels = w.globals.labels.slice();
      var rect;

      if (w.globals.timelineLabels.length > 0) {
        var coords = this.getxAxisTimeScaleLabelsCoords();
        rect = {
          width: coords.width,
          height: coords.height
        };
      } else {
        var lgWidthForSideLegends = w.config.legend.position === 'left' && w.config.legend.position === 'right' && !w.config.legend.floating ? this.lgRect.width : 0; //  get the longest string from the labels array and also apply label formatter to it

        var val = xaxisLabels.reduce(function (a, b) {
          return a.length > b.length ? a : b;
        }, 0); // the labels gets changed for bar charts

        if (this.isBarHorizontal) {
          val = w.globals.yAxisScale[0].result.reduce(function (a, b) {
            return a.length > b.length ? a : b;
          }, 0);
        }

        var xlbFormatter = w.globals.xLabelFormatter;
        var xFormat = new Formatters(this.ctx);
        val = xFormat.xLabelFormat(xlbFormatter, val);
        var graphics = new Graphics(this.ctx);
        var xLabelrect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);
        rect = {
          width: xLabelrect.width,
          height: xLabelrect.height
        };

        if (rect.width * xaxisLabels.length > w.globals.svgWidth - lgWidthForSideLegends - this.yAxisWidth && w.config.xaxis.labels.rotate !== 0) {
          if (!this.isBarHorizontal) {
            w.globals.rotateXLabels = true;
            xLabelrect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize, w.config.xaxis.labels.style.fontFamily, "rotate(".concat(w.config.xaxis.labels.rotate, " 0 0)"), false);
            rect.height = xLabelrect.height / 1.66;
          }
        } else {
          w.globals.rotateXLabels = false;
        }
      }

      if (!w.config.xaxis.labels.show) {
        rect = {
          width: 0,
          height: 0
        };
      }

      return {
        width: rect.width,
        height: rect.height
      };
    }
    /**
     * Get Y Axis Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/

  }, {
    key: "getyAxisLabelsCoords",
    value: function getyAxisLabelsCoords() {
      var _this2 = this;

      var w = this.w;
      var width = 0;
      var height = 0;
      var ret = [];
      var labelPad = 10;
      w.config.yaxis.map(function (yaxe, index) {
        if (yaxe.show && yaxe.labels.show && w.globals.yAxisScale[index].result.length) {
          var lbFormatter = w.globals.yLabelFormatters[index]; // the second parameter -1 is the index of tick which user can use in the formatter

          var val = lbFormatter(w.globals.yAxisScale[index].niceMax, -1); // if user has specified a custom formatter, and the result is null or empty, we need to discard the formatter and take the value as it is.

          if (typeof val === 'undefined' || val.length === 0) {
            val = w.globals.yAxisScale[index].niceMax;
          }

          if (_this2.isBarHorizontal) {
            labelPad = 0;
            var barYaxisLabels = w.globals.labels.slice(); //  get the longest string from the labels array and also apply label formatter to it

            val = barYaxisLabels.reduce(function (a, b) {
              return a.length > b.length ? a : b;
            }, 0);
            val = lbFormatter(val, -1);
          }

          var graphics = new Graphics(_this2.ctx);
          var rect = graphics.getTextRects(val, yaxe.labels.style.fontSize);
          ret.push({
            width: rect.width + labelPad,
            height: rect.height
          });
        } else {
          ret.push({
            width: width,
            height: height
          });
        }
      });
      return ret;
    }
    /**
     * Get X Axis Title Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/

  }, {
    key: "getxAxisTitleCoords",
    value: function getxAxisTitleCoords() {
      var w = this.w;
      var width = 0;
      var height = 0;

      if (w.config.xaxis.title.text !== undefined) {
        var graphics = new Graphics(this.ctx);
        var rect = graphics.getTextRects(w.config.xaxis.title.text, w.config.xaxis.title.style.fontSize);
        width = rect.width;
        height = rect.height;
      }

      return {
        width: width,
        height: height
      };
    }
    /**
     * Get Y Axis Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/

  }, {
    key: "getyAxisTitleCoords",
    value: function getyAxisTitleCoords() {
      var _this3 = this;

      var w = this.w;
      var ret = [];
      w.config.yaxis.map(function (yaxe, index) {
        if (yaxe.show && yaxe.title.text !== undefined) {
          var graphics = new Graphics(_this3.ctx);
          var rect = graphics.getTextRects(yaxe.title.text, yaxe.title.style.fontSize, yaxe.title.style.fontFamily, 'rotate(-90 0 0)', false);
          ret.push({
            width: rect.width,
            height: rect.height
          });
        } else {
          ret.push({
            width: 0,
            height: 0
          });
        }
      });
      return ret;
    }
    /**
     * Get Chart Title/Subtitle Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/

  }, {
    key: "getTitleSubtitleCoords",
    value: function getTitleSubtitleCoords(type) {
      var w = this.w;
      var width = 0;
      var height = 0;
      var floating = type === 'title' ? w.config.title.floating : w.config.subtitle.floating;
      var el = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-text"));

      if (el !== null && !floating) {
        var coord = el.getBoundingClientRect();
        width = coord.width;
        height = w.globals.axisCharts ? coord.height + 5 : coord.height;
      }

      return {
        width: width,
        height: height
      };
    }
  }, {
    key: "getLegendsRect",
    value: function getLegendsRect() {
      var w = this.w;
      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');
      var lgRect = Object.assign({}, Utils.getBoundingClientRect(elLegendWrap));

      if (elLegendWrap !== null && !w.config.legend.floating && w.config.legend.show) {
        this.lgRect = {
          x: lgRect.x,
          y: lgRect.y,
          height: lgRect.height,
          width: lgRect.height === 0 ? 0 : lgRect.width
        };
      } else {
        this.lgRect = {
          x: 0,
          y: 0,
          height: 0,
          width: 0
        };
      }

      return this.lgRect;
    }
  }]);

  return Dimensions;
}();

/**
 * ApexCharts TimeScale Class for generating time ticks for x-axis.
 *
 * @module TimeScale
 **/

var TimeScale =
/*#__PURE__*/
function () {
  function TimeScale(ctx) {
    _classCallCheck(this, TimeScale);

    this.ctx = ctx;
    this.w = ctx.w;
    this.timeScaleArray = [];
  }

  _createClass(TimeScale, [{
    key: "calculateTimeScaleTicks",
    value: function calculateTimeScaleTicks(minX, maxX) {
      var _this = this;

      var w = this.w; // null check when no series to show

      if (w.globals.allSeriesCollapsed) {
        w.globals.labels = [];
        w.globals.timelineLabels = [];
        return [];
      }

      var dt = new DateTime(this.ctx);
      var daysDiff = (maxX - minX) / (1000 * 60 * 60 * 24);
      this.determineInterval(daysDiff);
      w.globals.disableZoomIn = false;
      w.globals.disableZoomOut = false;

      if (daysDiff < 0.005) {
        w.globals.disableZoomIn = true;
      } else if (daysDiff > 50000) {
        w.globals.disableZoomOut = true;
      }

      var timeIntervals = dt.getTimeUnitsfromTimestamp(minX, maxX);
      var daysWidthOnXAxis = w.globals.gridWidth / daysDiff;
      var hoursWidthOnXAxis = daysWidthOnXAxis / 24;
      var minutesWidthOnXAxis = hoursWidthOnXAxis / 60;
      var numberOfHours = Math.floor(daysDiff * 24);
      var numberOfMinutes = Math.floor(daysDiff * 24 * 60);
      var numberOfDays = Math.floor(daysDiff);
      var numberOfMonths = Math.floor(daysDiff / 30);
      var numberOfYears = Math.floor(daysDiff / 365);
      var firstVal = {
        minMinute: timeIntervals.minMinute,
        minHour: timeIntervals.minHour,
        minDate: timeIntervals.minDate,
        minMonth: timeIntervals.minMonth,
        minYear: timeIntervals.minYear
      };
      var currentMinute = firstVal.minMinute;
      var currentHour = firstVal.minHour;
      var currentMonthDate = firstVal.minDate;
      var currentDate = firstVal.minDate;
      var currentMonth = firstVal.minMonth;
      var currentYear = firstVal.minYear;
      var params = {
        firstVal: firstVal,
        currentMinute: currentMinute,
        currentHour: currentHour,
        currentMonthDate: currentMonthDate,
        currentDate: currentDate,
        currentMonth: currentMonth,
        currentYear: currentYear,
        daysWidthOnXAxis: daysWidthOnXAxis,
        hoursWidthOnXAxis: hoursWidthOnXAxis,
        minutesWidthOnXAxis: minutesWidthOnXAxis,
        numberOfMinutes: numberOfMinutes,
        numberOfHours: numberOfHours,
        numberOfDays: numberOfDays,
        numberOfMonths: numberOfMonths,
        numberOfYears: numberOfYears
      };

      switch (this.tickInterval) {
        case 'years':
          {
            this.generateYearScale(params);
            break;
          }

        case 'months':
        case 'half_year':
          {
            this.generateMonthScale(params);
            break;
          }

        case 'months_days':
        case 'months_fortnight':
        case 'days':
        case 'week_days':
          {
            this.generateDayScale(params);
            break;
          }

        case 'hours':
          {
            this.generateHourScale(params);
            break;
          }

        case 'minutes':
          this.generateMinuteScale(params);
          break;
      } // first, we will adjust the month values index
      // as in the upper function, it is starting from 0
      // we will start them from 1


      var adjustedMonthInTimeScaleArray = this.timeScaleArray.map(function (ts) {
        var defaultReturn = {
          position: ts.position,
          unit: ts.unit,
          year: ts.year,
          day: ts.day ? ts.day : 1,
          hour: ts.hour ? ts.hour : 0,
          month: ts.month + 1
        };

        if (ts.unit === 'month') {
          return _objectSpread({}, defaultReturn, {
            value: ts.value + 1
          });
        } else if (ts.unit === 'day' || ts.unit === 'hour') {
          return _objectSpread({}, defaultReturn, {
            value: ts.value
          });
        } else if (ts.unit === 'minute') {
          return _objectSpread({}, defaultReturn, {
            value: ts.value,
            minute: ts.value
          });
        }

        return ts;
      });
      var filteredTimeScale = adjustedMonthInTimeScaleArray.filter(function (ts) {
        var modulo = 1;
        var ticks = Math.ceil(w.globals.gridWidth / 120);
        var value = ts.value;

        if (w.config.xaxis.tickAmount !== undefined) {
          ticks = w.config.xaxis.tickAmount;
        }

        if (adjustedMonthInTimeScaleArray.length > ticks) {
          modulo = Math.floor(adjustedMonthInTimeScaleArray.length / ticks);
        }

        var shouldNotSkipUnit = false; // there is a big change in unit i.e days to months

        var shouldNotPrint = false; // should skip these values

        switch (_this.tickInterval) {
          case 'half_year':
            modulo = 7;

            if (ts.unit === 'year') {
              shouldNotSkipUnit = true;
            }

            break;

          case 'months':
            modulo = 1;

            if (ts.unit === 'year') {
              shouldNotSkipUnit = true;
            }

            break;

          case 'months_fortnight':
            modulo = 15;

            if (ts.unit === 'year' || ts.unit === 'month') {
              shouldNotSkipUnit = true;
            }

            if (value === 30) {
              shouldNotPrint = true;
            }

            break;

          case 'months_days':
            modulo = 10;

            if (ts.unit === 'month') {
              shouldNotSkipUnit = true;
            }

            if (value === 30) {
              shouldNotPrint = true;
            }

            break;

          case 'week_days':
            modulo = 8;

            if (ts.unit === 'month') {
              shouldNotSkipUnit = true;
            }

            break;

          case 'days':
            modulo = 1;

            if (ts.unit === 'month') {
              shouldNotSkipUnit = true;
            }

            break;

          case 'hours':
            if (ts.unit === 'day') {
              shouldNotSkipUnit = true;
            }

            break;

          case 'minutes':
            if (value % 5 !== 0) {
              shouldNotPrint = true;
            }

            break;
        }

        if (_this.tickInterval === 'minutes' || _this.tickInterval === 'hours') {
          if (!shouldNotPrint) {
            return true;
          }
        } else {
          if ((value % modulo === 0 || shouldNotSkipUnit) && !shouldNotPrint) {
            return true;
          }
        }
      });
      return filteredTimeScale;
    }
  }, {
    key: "recalcDimensionsBasedOnFormat",
    value: function recalcDimensionsBasedOnFormat(filteredTimeScale) {
      var w = this.w;
      var reformattedTimescaleArray = this.formatDates(filteredTimeScale);
      var removedOverlappingTS = this.removeOverlappingTS(reformattedTimescaleArray);
      w.globals.timelineLabels = removedOverlappingTS.slice(); // at this stage, we need to re-calculate coords of the grid as timeline labels may have altered the xaxis labels coords
      // The reason we can't do this prior to this stage is because timeline labels depends on gridWidth, and as the ticks are calculated based on available gridWidth, there can be unknown number of ticks generated for different minX and maxX
      // Dependency on Dimensions(), need to refactor correctly
      // TODO - find an alternate way to avoid calling this Heavy method twice

      var dimensions = new Dimensions(this.ctx);
      dimensions.plotCoords();
    }
  }, {
    key: "determineInterval",
    value: function determineInterval(daysDiff) {
      switch (true) {
        case daysDiff > 1825:
          // difference is more than 5 years
          this.tickInterval = 'years';
          break;

        case daysDiff > 800 && daysDiff <= 1825:
          this.tickInterval = 'half_year';
          break;

        case daysDiff > 180 && daysDiff <= 800:
          this.tickInterval = 'months';
          break;

        case daysDiff > 90 && daysDiff <= 180:
          this.tickInterval = 'months_fortnight';
          break;

        case daysDiff > 60 && daysDiff <= 90:
          this.tickInterval = 'months_days';
          break;

        case daysDiff > 30 && daysDiff <= 60:
          this.tickInterval = 'week_days';
          break;

        case daysDiff > 2 && daysDiff <= 30:
          this.tickInterval = 'days';
          break;

        case daysDiff > 0.1 && daysDiff <= 2:
          // less than  2 days
          this.tickInterval = 'hours';
          break;

        case daysDiff < 0.1:
          this.tickInterval = 'minutes';
          break;

        default:
          this.tickInterval = 'days';
          break;
      }
    }
  }, {
    key: "generateYearScale",
    value: function generateYearScale(params) {
      var firstVal = params.firstVal,
          currentMonth = params.currentMonth,
          currentYear = params.currentYear,
          daysWidthOnXAxis = params.daysWidthOnXAxis,
          numberOfYears = params.numberOfYears;
      var firstTickValue = firstVal.minYear;
      var firstTickPosition = 0;
      var dt = new DateTime(this.ctx);
      var unit = 'year';

      if (firstVal.minDate > 1 && firstVal.minMonth > 0) {
        var remainingDays = dt.determineRemainingDaysOfYear(firstVal.minYear, firstVal.minMonth, firstVal.minDate); // remainingDaysofFirstMonth is used to reacht the 2nd tick position

        var remainingDaysOfFirstYear = dt.determineDaysOfYear(firstVal.minYear) - remainingDays + 1; // calculate the first tick position

        firstTickPosition = remainingDaysOfFirstYear * daysWidthOnXAxis;
        firstTickValue = firstVal.minYear + 1; // push the first tick in the array

        this.timeScaleArray.push({
          position: firstTickPosition,
          value: firstTickValue,
          unit: unit,
          year: firstTickValue,
          month: Utils.monthMod(currentMonth + 1)
        });
      } else if (firstVal.minDate === 1 && firstVal.minMonth === 0) {
        // push the first tick in the array
        this.timeScaleArray.push({
          position: firstTickPosition,
          value: firstTickValue,
          unit: unit,
          year: currentYear,
          month: Utils.monthMod(currentMonth + 1)
        });
      }

      var year = firstTickValue;
      var pos = firstTickPosition; // keep drawing rest of the ticks

      for (var i = 0; i < numberOfYears; i++) {
        year++;
        pos = dt.determineDaysOfYear(year - 1) * daysWidthOnXAxis + pos;
        this.timeScaleArray.push({
          position: pos,
          value: year,
          unit: unit,
          year: year,
          month: 1
        });
      }
    }
  }, {
    key: "generateMonthScale",
    value: function generateMonthScale(params) {
      var firstVal = params.firstVal,
          currentMonthDate = params.currentMonthDate,
          currentMonth = params.currentMonth,
          currentYear = params.currentYear,
          daysWidthOnXAxis = params.daysWidthOnXAxis,
          numberOfMonths = params.numberOfMonths;
      var firstTickValue = currentMonth;
      var firstTickPosition = 0;
      var dt = new DateTime(this.ctx);
      var unit = 'month';
      var yrCounter = 0;

      if (firstVal.minDate > 1) {
        // remainingDaysofFirstMonth is used to reacht the 2nd tick position
        var remainingDaysOfFirstMonth = dt.determineDaysOfMonths(currentMonth + 1, firstVal.minYear) - currentMonthDate + 1; // calculate the first tick position

        firstTickPosition = remainingDaysOfFirstMonth * daysWidthOnXAxis;
        firstTickValue = Utils.monthMod(currentMonth + 1);
        var year = currentYear + yrCounter;

        var _month = Utils.monthMod(firstTickValue);

        var value = firstTickValue; // it's Jan, so update the year

        if (firstTickValue === 0) {
          unit = 'year';
          value = year;
          _month = 1;
          yrCounter += 1;
          year = year + yrCounter;
        } // push the first tick in the array


        this.timeScaleArray.push({
          position: firstTickPosition,
          value: value,
          unit: unit,
          year: year,
          month: _month
        });
      } else {
        // push the first tick in the array
        this.timeScaleArray.push({
          position: firstTickPosition,
          value: firstTickValue,
          unit: unit,
          year: currentYear,
          month: Utils.monthMod(currentMonth)
        });
      }

      var month = firstTickValue + 1;
      var pos = firstTickPosition; // keep drawing rest of the ticks

      for (var i = 0, j = 1; i < numberOfMonths; i++, j++) {
        month = Utils.monthMod(month);

        if (month === 0) {
          unit = 'year';
          yrCounter += 1;
        } else {
          unit = 'month';
        }

        var _year = currentYear + Math.floor(month / 12) + yrCounter;

        pos = dt.determineDaysOfMonths(month, _year) * daysWidthOnXAxis + pos;
        var monthVal = month === 0 ? _year : month;
        this.timeScaleArray.push({
          position: pos,
          value: monthVal,
          unit: unit,
          year: _year,
          month: month === 0 ? 1 : month
        });
        month++;
      }
    }
  }, {
    key: "generateDayScale",
    value: function generateDayScale(params) {
      var firstVal = params.firstVal,
          currentMonth = params.currentMonth,
          currentYear = params.currentYear,
          hoursWidthOnXAxis = params.hoursWidthOnXAxis,
          numberOfDays = params.numberOfDays;
      var dt = new DateTime(this.ctx);
      var unit = 'day';
      var remainingHours = 24 - firstVal.minHour;
      var yrCounter = 0; // calculate the first tick position

      var firstTickPosition = remainingHours * hoursWidthOnXAxis;
      var firstTickValue = firstVal.minDate + 1;
      var val = firstTickValue;

      var changeMonth = function changeMonth(dateVal, month, year) {
        var monthdays = dt.determineDaysOfMonths(month + 1, year);

        if (dateVal > monthdays) {
          month = month + 1;
          date = 1;
          unit = 'month';
          val = month;
          return month;
        }

        return month;
      };

      var date = firstTickValue;
      var month = changeMonth(date, currentMonth, currentYear); // push the first tick in the array

      this.timeScaleArray.push({
        position: firstTickPosition,
        value: val,
        unit: unit,
        year: currentYear,
        month: Utils.monthMod(month),
        day: date
      });
      var pos = firstTickPosition; // keep drawing rest of the ticks

      for (var i = 0; i < numberOfDays; i++) {
        date += 1;
        unit = 'day';
        month = changeMonth(date, month, currentYear + Math.floor(month / 12) + yrCounter);
        var year = currentYear + Math.floor(month / 12) + yrCounter;
        pos = 24 * hoursWidthOnXAxis + pos;

        var _val = date === 1 ? Utils.monthMod(month) : date;

        this.timeScaleArray.push({
          position: pos,
          value: _val,
          unit: unit,
          year: year,
          month: Utils.monthMod(month),
          day: _val
        });
      }
    }
  }, {
    key: "generateHourScale",
    value: function generateHourScale(params) {
      var firstVal = params.firstVal,
          currentDate = params.currentDate,
          currentMonth = params.currentMonth,
          currentYear = params.currentYear,
          minutesWidthOnXAxis = params.minutesWidthOnXAxis,
          numberOfHours = params.numberOfHours;
      var dt = new DateTime(this.ctx);
      var yrCounter = 0;
      var unit = 'hour';

      var changeDate = function changeDate(dateVal, month) {
        var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);

        if (dateVal > monthdays) {
          date = 1;
          month = month + 1;
        }

        return {
          month: month,
          date: date
        };
      };

      var changeMonth = function changeMonth(dateVal, month) {
        var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);

        if (dateVal > monthdays) {
          month = month + 1;
          return month;
        }

        return month;
      };

      var remainingMins = 60 - firstVal.minMinute;
      var firstTickPosition = remainingMins * minutesWidthOnXAxis;
      var firstTickValue = firstVal.minHour + 1;
      var hour = firstTickValue + 1;

      if (remainingMins === 60) {
        firstTickPosition = 0;
        firstTickValue = firstVal.minHour;
        hour = firstTickValue + 1;
      }

      var date = currentDate;
      var month = changeMonth(date, currentMonth); // push the first tick in the array

      this.timeScaleArray.push({
        position: firstTickPosition,
        value: firstTickValue,
        unit: unit,
        day: date,
        hour: hour,
        year: currentYear,
        month: Utils.monthMod(month)
      });
      var pos = firstTickPosition; // keep drawing rest of the ticks

      for (var i = 0; i < numberOfHours; i++) {
        unit = 'hour';

        if (hour >= 24) {
          hour = 0;
          date += 1;
          unit = 'day';
          var checkNextMonth = changeDate(date, month);
          month = checkNextMonth.month;
          month = changeMonth(date, month);
        }

        var year = currentYear + Math.floor(month / 12) + yrCounter;
        pos = hour === 0 && i === 0 ? remainingMins * minutesWidthOnXAxis : 60 * minutesWidthOnXAxis + pos;
        var val = hour === 0 ? date : hour;
        this.timeScaleArray.push({
          position: pos,
          value: val,
          unit: unit,
          hour: hour,
          day: date,
          year: year,
          month: Utils.monthMod(month)
        });
        hour++;
      }
    }
  }, {
    key: "generateMinuteScale",
    value: function generateMinuteScale(params) {
      var firstVal = params.firstVal,
          currentMinute = params.currentMinute,
          currentHour = params.currentHour,
          currentDate = params.currentDate,
          currentMonth = params.currentMonth,
          currentYear = params.currentYear,
          minutesWidthOnXAxis = params.minutesWidthOnXAxis,
          numberOfMinutes = params.numberOfMinutes;
      var yrCounter = 0;
      var unit = 'minute';
      var remainingMins = currentMinute - firstVal.minMinute;
      var firstTickPosition = minutesWidthOnXAxis - remainingMins;
      var firstTickValue = firstVal.minMinute + 1;
      var minute = firstTickValue + 1;
      var date = currentDate;
      var month = currentMonth;
      var year = currentYear;
      var hour = currentHour; // push the first tick in the array

      this.timeScaleArray.push({
        position: firstTickPosition,
        value: firstTickValue,
        unit: unit,
        day: date,
        hour: hour,
        minute: minute,
        year: year,
        month: Utils.monthMod(month)
      });
      var pos = firstTickPosition; // keep drawing rest of the ticks

      for (var i = 0; i < numberOfMinutes; i++) {
        if (minute >= 60) {
          minute = 0;
          hour += 1;

          if (hour === 24) {
            hour = 0;
          }
        }

        var _year2 = currentYear + Math.floor(month / 12) + yrCounter;

        pos = minutesWidthOnXAxis + pos;
        var val = minute;
        this.timeScaleArray.push({
          position: pos,
          value: val,
          unit: unit,
          hour: hour,
          minute: minute,
          day: date,
          year: _year2,
          month: Utils.monthMod(month)
        });
        minute++;
      }
    }
  }, {
    key: "createRawDateString",
    value: function createRawDateString(ts, value) {
      var raw = ts.year;
      raw += '-' + ('0' + ts.month.toString()).slice(-2); // unit is day

      if (ts.unit === 'day') {
        raw += ts.unit === 'day' ? '-' + ('0' + value).slice(-2) : '-01';
      } else {
        raw += '-' + ('0' + (ts.day ? ts.day : '1')).slice(-2);
      } // unit is hour


      if (ts.unit === 'hour') {
        raw += ts.unit === 'hour' ? 'T' + ('0' + value).slice(-2) : 'T00';
      } else {
        raw += 'T' + ('0' + (ts.hour ? ts.hour : '0')).slice(-2);
      } // unit is minute


      raw += ts.unit === 'minute' ? ':' + ('0' + value).slice(-2) + ':00.000Z' : ':00:00.000Z';
      return raw;
    }
  }, {
    key: "formatDates",
    value: function formatDates(filteredTimeScale) {
      var _this2 = this;

      var w = this.w;
      var reformattedTimescaleArray = filteredTimeScale.map(function (ts) {
        var value = ts.value.toString();
        var dt = new DateTime(_this2.ctx);

        var raw = _this2.createRawDateString(ts, value); // parse the whole ISO datestring


        var dateString = new Date(Date.parse(raw));

        if (w.config.xaxis.labels.format === undefined) {
          var customFormat = 'dd MMM';
          var dtFormatter = w.config.xaxis.labels.datetimeFormatter;
          if (ts.unit === 'year') customFormat = dtFormatter.year;
          if (ts.unit === 'month') customFormat = dtFormatter.month;
          if (ts.unit === 'day') customFormat = dtFormatter.day;
          if (ts.unit === 'hour') customFormat = dtFormatter.hour;
          if (ts.unit === 'minute') customFormat = dtFormatter.minute;
          value = dt.formatDate(dateString, customFormat, true, false);
        } else {
          value = dt.formatDate(dateString, w.config.xaxis.labels.format);
        }

        return {
          dateString: raw,
          position: ts.position,
          value: value,
          unit: ts.unit,
          year: ts.year,
          month: ts.month
        };
      });
      return reformattedTimescaleArray;
    }
  }, {
    key: "removeOverlappingTS",
    value: function removeOverlappingTS(arr) {
      var _this3 = this;

      var graphics = new Graphics(this.ctx);
      var lastDrawnIndex = 0;
      var filteredArray = arr.map(function (item, index) {
        if (index > 0 && _this3.w.config.xaxis.labels.hideOverlappingLabels) {
          var prevLabelWidth = graphics.getTextRects(arr[lastDrawnIndex].value).width;
          var prevPos = arr[lastDrawnIndex].position;
          var pos = item.position;

          if (pos > prevPos + prevLabelWidth + 10) {
            lastDrawnIndex = index;
            return item;
          } else {
            return null;
          }
        } else {
          return item;
        }
      });
      filteredArray = filteredArray.filter(function (f) {
        return f !== null;
      });
      return filteredArray;
    }
  }]);

  return TimeScale;
}();

/**
 * ApexCharts Core Class responsible for major calculations and creating elements.
 *
 * @module Core
 **/

var Core =
/*#__PURE__*/
function () {
  function Core(el, ctx) {
    _classCallCheck(this, Core);

    this.ctx = ctx;
    this.w = ctx.w;
    this.el = el;
    this.coreUtils = new CoreUtils(this.ctx);
    this.twoDSeries = [];
    this.threeDSeries = [];
    this.twoDSeriesX = [];
  } // get data and store into appropriate vars


  _createClass(Core, [{
    key: "setupElements",
    value: function setupElements() {
      var gl = this.w.globals;
      var cnf = this.w.config; // const graphics = new Graphics(this.ctx)

      var ct = cnf.chart.type;
      var axisChartsArrTypes = ['line', 'area', 'bar', 'candlestick', 'radar', 'scatter', 'bubble', 'heatmap'];
      var xyChartsArrTypes = ['line', 'area', 'bar', 'candlestick', 'scatter', 'bubble'];
      gl.axisCharts = axisChartsArrTypes.indexOf(ct) > -1;
      gl.xyCharts = xyChartsArrTypes.indexOf(ct) > -1;
      gl.chartClass = '.apexcharts' + gl.cuid;
      gl.dom.baseEl = this.el;
      gl.dom.elWrap = document.createElement('div');
      Graphics.setAttrs(gl.dom.elWrap, {
        id: gl.chartClass.substring(1),
        class: 'apexcharts-canvas ' + gl.chartClass.substring(1)
      });
      this.el.appendChild(gl.dom.elWrap);
      gl.dom.Paper = new window.SVG.Doc(gl.dom.elWrap);
      gl.dom.Paper.attr({
        class: 'apexcharts-svg',
        'xmlns:data': 'ApexChartsNS',
        transform: "translate(".concat(cnf.chart.offsetX, ", ").concat(cnf.chart.offsetY, ")")
      });
      gl.dom.Paper.node.style.background = cnf.chart.background;
      this.setSVGDimensions();
      gl.dom.elGraphical = gl.dom.Paper.group().attr({
        class: 'apexcharts-inner apexcharts-graphical'
      });
      gl.dom.elDefs = gl.dom.Paper.defs();
      gl.dom.elLegendWrap = document.createElement('div');
      gl.dom.elLegendWrap.classList.add('apexcharts-legend');
      gl.dom.elWrap.appendChild(gl.dom.elLegendWrap); // gl.dom.Paper.add(gl.dom.elLegendWrap)

      gl.dom.Paper.add(gl.dom.elGraphical);
      gl.dom.elGraphical.add(gl.dom.elDefs);
    }
  }, {
    key: "plotChartType",
    value: function plotChartType(ser, xyRatios) {
      var w = this.w;
      var cnf = w.config;
      var gl = w.globals;
      var lineSeries = {
        series: [],
        i: []
      };
      var areaSeries = {
        series: [],
        i: []
      };
      var scatterSeries = {
        series: [],
        i: []
      };
      var columnSeries = {
        series: [],
        i: []
      };
      var candlestickSeries = {
        series: [],
        i: []
      };
      gl.series.map(function (series, st) {
        // if user has specified a particular type for particular series
        if (typeof ser[st].type !== 'undefined') {
          if (ser[st].type === 'column' || ser[st].type === 'bar') {
            w.config.plotOptions.bar.horizontal = false; // bar not supported in mixed charts

            columnSeries.series.push(series);
            columnSeries.i.push(st);
          } else if (ser[st].type === 'area') {
            areaSeries.series.push(series);
            areaSeries.i.push(st);
          } else if (ser[st].type === 'line') {
            lineSeries.series.push(series);
            lineSeries.i.push(st);
          } else if (ser[st].type === 'scatter') {
            scatterSeries.series.push(series);
            scatterSeries.i.push(st);
          } else if (ser[st].type === 'bubble') ; else if (ser[st].type === 'candlestick') {
            candlestickSeries.series.push(series);
            candlestickSeries.i.push(st);
          } else {
            // user has specified type, but it is not valid (other than line/area/column)
            console.warn('You have specified an unrecognized chart type. Available types for this propery are line/area/column/bar/scatter/bubble');
          }

          gl.comboCharts = true;
        } else {
          lineSeries.series.push(series);
          lineSeries.i.push(st);
        }
      });
      var line = new Line(this.ctx, xyRatios);
      var candlestick = new CandleStick(this.ctx, xyRatios);
      var pie = new Pie(this.ctx);
      var radialBar = new Radial(this.ctx);
      var radar = new Radar(this.ctx);
      var elGraph = [];

      if (gl.comboCharts) {
        if (areaSeries.series.length > 0) {
          elGraph.push(line.draw(areaSeries.series, 'area', areaSeries.i));
        }

        if (columnSeries.series.length > 0) {
          if (w.config.chart.stacked) {
            var barStacked = new BarStacked(this.ctx, xyRatios);
            elGraph.push(barStacked.draw(columnSeries.series, columnSeries.i));
          } else {
            var bar = new Bar(this.ctx, xyRatios);
            elGraph.push(bar.draw(columnSeries.series, columnSeries.i));
          }
        }

        if (lineSeries.series.length > 0) {
          elGraph.push(line.draw(lineSeries.series, 'line', lineSeries.i));
        }

        if (candlestickSeries.series.length > 0) {
          elGraph.push(candlestick.draw(candlestickSeries.series, candlestickSeries.i));
        }

        if (scatterSeries.series.length > 0) {
          var scatterLine = new Line(this.ctx, xyRatios, true);
          elGraph.push(scatterLine.draw(scatterSeries.series, 'scatter', scatterSeries.i));
        } // TODO: allow bubble series in a combo chart
        // if (bubbleSeries.series.length > 0) {
        //   const bubbleLine = new Line(this.ctx, xyRatios, true)
        //   elGraph.push(
        //     bubbleLine.draw(bubbleSeries.series, 'bubble', bubbleSeries.i)
        //   )
        // }

      } else {
        switch (cnf.chart.type) {
          case 'line':
            elGraph = line.draw(gl.series, 'line');
            break;

          case 'area':
            elGraph = line.draw(gl.series, 'area');
            break;

          case 'bar':
            if (cnf.chart.stacked) {
              var _barStacked = new BarStacked(this.ctx, xyRatios);

              elGraph = _barStacked.draw(gl.series);
            } else {
              var _bar = new Bar(this.ctx, xyRatios);

              elGraph = _bar.draw(gl.series);
            }

            break;

          case 'candlestick':
            var candleStick = new CandleStick(this.ctx, xyRatios);
            elGraph = candleStick.draw(gl.series);
            break;

          case 'heatmap':
            var heatmap = new HeatMap(this.ctx, xyRatios);
            elGraph = heatmap.draw(gl.series);
            break;

          case 'pie':
          case 'donut':
            elGraph = pie.draw(gl.series);
            break;

          case 'radialBar':
            elGraph = radialBar.draw(gl.series);
            break;

          case 'radar':
            elGraph = radar.draw(gl.series);
            break;

          default:
            elGraph = line.draw(gl.series);
        }
      }

      return elGraph;
    }
  }, {
    key: "setSVGDimensions",
    value: function setSVGDimensions() {
      var gl = this.w.globals;
      var cnf = this.w.config;
      gl.svgWidth = cnf.chart.width;
      gl.svgHeight = cnf.chart.height;
      var elDim = Utils.getDimensions(this.el);
      var widthUnit = cnf.chart.width.toString().split(/[0-9]+/g).pop();

      if (widthUnit === '%') {
        if (Utils.isNumber(elDim[0])) {
          if (elDim[0].width === 0) {
            elDim = Utils.getDimensions(this.el.parentNode);
          }

          gl.svgWidth = elDim[0] * parseInt(cnf.chart.width) / 100;
        }
      } else if (widthUnit === 'px' || widthUnit === '') {
        gl.svgWidth = parseInt(cnf.chart.width);
      }

      if (gl.svgHeight !== 'auto' && gl.svgHeight !== '') {
        var heightUnit = cnf.chart.height.toString().split(/[0-9]+/g).pop();

        if (heightUnit === '%') {
          var elParentDim = Utils.getDimensions(this.el.parentNode);
          gl.svgHeight = elParentDim[1] * parseInt(cnf.chart.height) / 100;
        } else {
          gl.svgHeight = parseInt(cnf.chart.height);
        }
      } else {
        if (gl.axisCharts) {
          gl.svgHeight = gl.svgWidth / 1.61;
        } else {
          gl.svgHeight = gl.svgWidth;
        }
      }

      Graphics.setAttrs(gl.dom.Paper.node, {
        width: gl.svgWidth,
        height: gl.svgHeight
      }); // gl.dom.Paper.node.parentNode.parentNode.style.minWidth = gl.svgWidth + "px";

      var offsetY = cnf.chart.sparkline.enabled ? 0 : gl.axisCharts ? 14 : 5;
      gl.dom.Paper.node.parentNode.parentNode.style.minHeight = gl.svgHeight + offsetY + 'px';
      gl.dom.elWrap.style.width = gl.svgWidth + 'px';
      gl.dom.elWrap.style.height = gl.svgHeight + 'px';
    }
  }, {
    key: "shiftGraphPosition",
    value: function shiftGraphPosition() {
      var gl = this.w.globals;
      var tY = gl.translateY;
      var tX = gl.translateX;
      var scalingAttrs = {
        transform: 'translate(' + tX + ', ' + tY + ')'
      };
      Graphics.setAttrs(gl.dom.elGraphical.node, scalingAttrs);
    }
    /*
     ** All the calculations for setting range in charts will be done here
     */

  }, {
    key: "coreCalculations",
    value: function coreCalculations() {
      var range = new Range$1(this.ctx);
      range.init();
    }
  }, {
    key: "resetGlobals",
    value: function resetGlobals() {
      var _this = this;

      var gl = this.w.globals;
      gl.series = [];
      gl.seriesCandleO = [];
      gl.seriesCandleH = [];
      gl.seriesCandleL = [];
      gl.seriesCandleC = [];
      gl.seriesPercent = [];
      gl.seriesX = [];
      gl.seriesZ = [];
      gl.seriesNames = [];
      gl.seriesTotals = [];
      gl.stackedSeriesTotals = [];
      gl.labels = [];
      gl.timelineLabels = [];
      gl.noLabelsProvided = false;
      gl.timescaleTicks = [];
      gl.resizeTimer = null;
      gl.selectionResizeTimer = null;

      gl.seriesXvalues = function () {
        return _this.w.config.series.map(function (s) {
          return [];
        });
      }();

      gl.seriesYvalues = function () {
        return _this.w.config.series.map(function (s) {
          return [];
        });
      }();

      gl.delayedElements = [];
      gl.pointsArray = [];
      gl.dataLabelsRects = [];
      gl.isXNumeric = false;
      gl.isDataXYZ = false;
      gl.maxY = -Number.MAX_VALUE;
      gl.minY = Number.MIN_VALUE;
      gl.minYArr = [];
      gl.maxYArr = [];
      gl.maxX = -Number.MAX_VALUE;
      gl.minX = Number.MAX_VALUE;
      gl.initialmaxX = -Number.MAX_VALUE;
      gl.initialminX = Number.MAX_VALUE;
      gl.maxDate = 0;
      gl.minDate = Number.MAX_VALUE;
      gl.minZ = Number.MAX_VALUE;
      gl.maxZ = -Number.MAX_VALUE;
      gl.yAxisScale = [];
      gl.xAxisScale = null;
      gl.xAxisTicksPositions = [];
      gl.yLabelsCoords = [];
      gl.yTitleCoords = [];
      gl.xRange = 0;
      gl.yRange = [];
      gl.zRange = 0;
      gl.dataPoints = 0;
    }
  }, {
    key: "isMultipleY",
    value: function isMultipleY() {
      // user has supplied an array in yaxis property. So, turn on multipleYAxis flag
      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) {
        // first, turn off stacking if multiple y axis
        this.w.config.chart.stacked = false;
        this.w.globals.isMultipleYAxis = true;
        return true;
      }
    }
  }, {
    key: "excludeCollapsedSeriesInYAxis",
    value: function excludeCollapsedSeriesInYAxis() {
      var _this2 = this;

      var w = this.w;
      w.globals.ignoreYAxisIndexes = w.globals.collapsedSeries.map(function (collapsed, i) {
        if (_this2.w.globals.isMultipleYAxis) {
          return collapsed.index;
        }
      });
    }
  }, {
    key: "isMultiFormat",
    value: function isMultiFormat() {
      return this.isFormatXY() || this.isFormat2DArray();
    } // given format is [{x, y}, {x, y}]

  }, {
    key: "isFormatXY",
    value: function isFormatXY() {
      var series = this.w.config.series.slice();
      var sr = new Series(this.ctx);
      this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();

      if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && series[this.activeSeriesIndex].data[0] !== null && typeof series[this.activeSeriesIndex].data[0].x !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null) {
        return true;
      }
    } // given format is [[x, y], [x, y]]

  }, {
    key: "isFormat2DArray",
    value: function isFormat2DArray() {
      var series = this.w.config.series.slice();
      var sr = new Series(this.ctx);
      this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();

      if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && typeof series[this.activeSeriesIndex].data[0] !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null && series[this.activeSeriesIndex].data[0].constructor === Array) {
        return true;
      }
    }
  }, {
    key: "handleFormat2DArray",
    value: function handleFormat2DArray(ser, i) {
      var cnf = this.w.config;
      var gl = this.w.globals;

      for (var j = 0; j < ser[i].data.length; j++) {
        if (typeof ser[i].data[j][1] !== 'undefined') {
          if (Array.isArray(ser[i].data[j][1]) && ser[i].data[j][1].length === 4) {
            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j][1][3]));
          } else {
            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j][1]));
          }
        }

        if (cnf.xaxis.type === 'datetime') {
          // if timestamps are provided and xaxis type is datettime,
          var ts = new Date(ser[i].data[j][0]);
          ts = new Date(ts).getTime();
          this.twoDSeriesX.push(ts);
        } else {
          this.twoDSeriesX.push(ser[i].data[j][0]);
        }
      }

      for (var _j = 0; _j < ser[i].data.length; _j++) {
        if (typeof ser[i].data[_j][2] !== 'undefined') {
          this.threeDSeries.push(ser[i].data[_j][2]);
          gl.isDataXYZ = true;
        }
      }
    }
  }, {
    key: "handleFormatXY",
    value: function handleFormatXY(ser, i) {
      var cnf = this.w.config;
      var gl = this.w.globals;
      var dt = new DateTime(this.ctx);
      var activeI = i;

      if (gl.collapsedSeriesIndices.indexOf(i) > -1) {
        // fix #368
        activeI = this.activeSeriesIndex;
      } // get series


      for (var j = 0; j < ser[i].data.length; j++) {
        if (typeof ser[i].data[j].y !== 'undefined') {
          if (Array.isArray(ser[i].data[j].y) && ser[i].data[j].y.length === 4) {
            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j].y[3]));
          } else {
            this.twoDSeries.push(Utils.parseNumber(ser[i].data[j].y));
          }
        }
      } // get seriesX


      for (var _j2 = 0; _j2 < ser[activeI].data.length; _j2++) {
        var isXString = typeof ser[activeI].data[_j2].x === 'string';
        var isXDate = !!dt.isValidDate(ser[activeI].data[_j2].x.toString());

        if (isXString || isXDate) {
          // user supplied '01/01/2017' or a date string (a JS date object is not supported)
          if (isXString) {
            if (cnf.xaxis.type === 'datetime') {
              this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x));
            } else {
              // a category and not a numeric x value
              this.fallbackToCategory = true;
              this.twoDSeriesX.push(ser[activeI].data[_j2].x);
            }
          } else {
            if (cnf.xaxis.type === 'datetime') {
              this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x.toString()));
            } else {
              this.twoDSeriesX.push(parseFloat(ser[activeI].data[_j2].x));
            }
          }
        } else {
          // a numeric value in x property
          this.twoDSeriesX.push(ser[activeI].data[_j2].x);
        }
      }

      if (ser[i].data[0] && typeof ser[i].data[0].z !== 'undefined') {
        for (var t = 0; t < ser[i].data.length; t++) {
          this.threeDSeries.push(ser[i].data[t].z);
        }

        gl.isDataXYZ = true;
      }
    }
  }, {
    key: "handleCandleStickData",
    value: function handleCandleStickData(ser, i) {
      var gl = this.w.globals;
      var ohlc = {};

      if (this.isFormat2DArray()) {
        ohlc = this.handleCandleStickDataFormat('array', ser, i);
      } else if (this.isFormatXY()) {
        ohlc = this.handleCandleStickDataFormat('xy', ser, i);
      }

      gl.seriesCandleO.push(ohlc.o);
      gl.seriesCandleH.push(ohlc.h);
      gl.seriesCandleL.push(ohlc.l);
      gl.seriesCandleC.push(ohlc.c);
      return ohlc;
    }
  }, {
    key: "handleCandleStickDataFormat",
    value: function handleCandleStickDataFormat(format, ser, i) {
      var serO = [];
      var serH = [];
      var serL = [];
      var serC = [];
      var err = 'Please provide [Open, High, Low and Close] values in valid format. Read more https://apexcharts.com/docs/series/#candlestick';

      if (format === 'array') {
        if (ser[i].data[0][1].length !== 4) {
          throw new Error(err);
        }

        for (var j = 0; j < ser[i].data.length; j++) {
          serO.push(ser[i].data[j][1][0]);
          serH.push(ser[i].data[j][1][1]);
          serL.push(ser[i].data[j][1][2]);
          serC.push(ser[i].data[j][1][3]);
        }
      } else if (format === 'xy') {
        if (ser[i].data[0].y.length !== 4) {
          throw new Error(err);
        }

        for (var _j3 = 0; _j3 < ser[i].data.length; _j3++) {
          serO.push(ser[i].data[_j3].y[0]);
          serH.push(ser[i].data[_j3].y[1]);
          serL.push(ser[i].data[_j3].y[2]);
          serC.push(ser[i].data[_j3].y[3]);
        }
      }

      return {
        o: serO,
        h: serH,
        l: serL,
        c: serC
      };
    }
  }, {
    key: "parseDataAxisCharts",
    value: function parseDataAxisCharts(ser) {
      var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.ctx;
      var cnf = this.w.config;
      var gl = this.w.globals;
      var dt = new DateTime(ctx);

      for (var i = 0; i < ser.length; i++) {
        this.twoDSeries = [];
        this.twoDSeriesX = [];
        this.threeDSeries = [];

        if (typeof ser[i].data === 'undefined') {
          console.error("It is a possibility that you may have not included 'data' property in series.");
          return;
        }

        if (this.isMultiFormat()) {
          if (this.isFormat2DArray()) {
            this.handleFormat2DArray(ser, i);
          } else if (this.isFormatXY()) {
            this.handleFormatXY(ser, i);
          }

          if (cnf.chart.type === 'candlestick' || ser[i].type === 'candlestick') {
            this.handleCandleStickData(ser, i);
          }

          gl.series.push(this.twoDSeries);
          gl.labels.push(this.twoDSeriesX);
          gl.seriesX.push(this.twoDSeriesX);

          if (!this.fallbackToCategory) {
            gl.isXNumeric = true;
          }
        } else {
          if (cnf.xaxis.type === 'datetime') {
            // user didn't supplied [{x,y}] or [[x,y]], but single array in data.
            // Also labels/categories were supplied differently
            gl.isXNumeric = true;
            var dates = cnf.labels.length > 0 ? cnf.labels.slice() : cnf.xaxis.categories.slice();

            for (var j = 0; j < dates.length; j++) {
              if (typeof dates[j] === 'string') {
                var isDate = dt.isValidDate(dates[j]);

                if (isDate) {
                  this.twoDSeriesX.push(dt.parseDate(dates[j]));
                } else {
                  throw new Error('You have provided invalid Date format. Please provide a valid JavaScript Date');
                }
              }
            }

            gl.seriesX.push(this.twoDSeriesX);
          } else if (cnf.xaxis.type === 'numeric') {
            gl.isXNumeric = true;
            var x = cnf.labels.length > 0 ? cnf.labels.slice() : cnf.xaxis.categories.slice();

            if (x.length > 0) {
              this.twoDSeriesX = x;
              gl.seriesX.push(this.twoDSeriesX);
            }
          }

          gl.labels.push(this.twoDSeriesX);
          var singleArray = ser[i].data.map(function (d) {
            return Utils.parseNumber(d);
          });
          gl.series.push(singleArray);
        }

        gl.seriesZ.push(this.threeDSeries);

        if (ser[i].name !== undefined) {
          gl.seriesNames.push(ser[i].name);
        } else {
          gl.seriesNames.push('series-' + parseInt(i + 1));
        }
      }

      return this.w;
    }
  }, {
    key: "parseDataNonAxisCharts",
    value: function parseDataNonAxisCharts(ser) {
      var gl = this.w.globals;
      var cnf = this.w.config;
      gl.series = ser.slice();
      gl.seriesNames = cnf.labels.slice();

      for (var i = 0; i < gl.series.length; i++) {
        if (gl.seriesNames[i] === undefined) {
          gl.seriesNames.push('series-' + (i + 1));
        }
      }

      return this.w;
    }
  }, {
    key: "handleExternalLabelsData",
    value: function handleExternalLabelsData(ser) {
      var cnf = this.w.config;
      var gl = this.w.globals; // user provided labels in category axis

      if (cnf.xaxis.categories.length > 0) {
        gl.labels = cnf.xaxis.categories;
      } else if (cnf.labels.length > 0) {
        gl.labels = cnf.labels.slice();
      } else if (this.fallbackToCategory) {
        gl.labels = gl.labels[0];
      } else {
        // user didn't provided labels, fallback to 1-2-3-4-5
        var labelArr = [];

        if (gl.axisCharts) {
          for (var i = 0; i < gl.series[gl.maxValsInArrayIndex].length; i++) {
            labelArr.push(i + 1);
          }

          for (var _i = 0; _i < ser.length; _i++) {
            gl.seriesX.push(labelArr);
          }

          gl.isXNumeric = true;
        } // no series to pull labels from, put a 0-10 series


        if (labelArr.length === 0) {
          labelArr = [0, 10];

          for (var _i2 = 0; _i2 < ser.length; _i2++) {
            gl.seriesX.push(labelArr);
          }
        }

        gl.labels = labelArr;
        gl.noLabelsProvided = true;

        if (cnf.xaxis.type === 'category') {
          gl.isXNumeric = false;
        }
      }
    } // Segregate user provided data into appropriate vars

  }, {
    key: "parseData",
    value: function parseData(ser) {
      var w = this.w;
      var cnf = w.config;
      var gl = w.globals;
      this.excludeCollapsedSeriesInYAxis();
      this.fallbackToCategory = false;
      this.resetGlobals();
      this.isMultipleY();

      if (gl.axisCharts) {
        this.parseDataAxisCharts(ser);
      } else {
        this.parseDataNonAxisCharts(ser);
      }

      this.coreUtils.getLargestSeries(); // set Null values to 0 in all series when user hides/shows some series

      if (cnf.chart.type === 'bar' && cnf.chart.stacked) {
        var series = new Series(this.ctx);
        gl.series = series.setNullSeriesToZeroValues(gl.series);
      }

      this.coreUtils.getSeriesTotals();

      if (gl.axisCharts) {
        this.coreUtils.getStackedSeriesTotals();
      }

      this.coreUtils.getPercentSeries(); // user didn't provide a [[x,y],[x,y]] series, but a named series

      if (!gl.isXNumeric || cnf.xaxis.type === 'numeric' && cnf.labels.length === 0 && cnf.xaxis.categories.length === 0) {
        this.handleExternalLabelsData(ser);
      }
    }
  }, {
    key: "xySettings",
    value: function xySettings() {
      var xyRatios = null;
      var w = this.w;

      if (w.globals.axisCharts) {
        if (w.config.xaxis.crosshairs.position === 'back') {
          var crosshairs = new Crosshairs(this.ctx);
          crosshairs.drawXCrosshairs();
        }

        if (w.config.yaxis[0].crosshairs.position === 'back') {
          var _crosshairs = new Crosshairs(this.ctx);

          _crosshairs.drawYCrosshairs();
        }

        xyRatios = this.coreUtils.getCalculatedRatios();

        if (w.config.xaxis.type === 'datetime' && w.config.xaxis.labels.formatter === undefined && isFinite(w.globals.minX) && isFinite(w.globals.maxX)) {
          var ts = new TimeScale(this.ctx);
          var formattedTimeScale = ts.calculateTimeScaleTicks(w.globals.minX, w.globals.maxX);
          ts.recalcDimensionsBasedOnFormat(formattedTimeScale);
        }
      }

      return xyRatios;
    }
  }, {
    key: "drawAxis",
    value: function drawAxis(type, xyRatios) {
      var gl = this.w.globals;
      var cnf = this.w.config;
      var xAxis = new XAxis(this.ctx);
      var yAxis = new YAxis(this.ctx);

      if (gl.axisCharts && type !== 'radar') {
        var elXaxis, elYaxis;

        if (type === 'bar' && cnf.plotOptions.bar.horizontal) {
          elYaxis = yAxis.drawYaxisInversed(0);
          elXaxis = xAxis.drawXaxisInversed(0);
          gl.dom.elGraphical.add(elXaxis);
          gl.dom.elGraphical.add(elYaxis);
        } else {
          elXaxis = xAxis.drawXaxis();
          gl.dom.elGraphical.add(elXaxis);
          cnf.yaxis.map(function (yaxe, index) {
            if (gl.ignoreYAxisIndexes.indexOf(index) === -1) {
              elYaxis = yAxis.drawYaxis(index);
              gl.dom.Paper.add(elYaxis);
            }
          });
        }
      }

      cnf.yaxis.map(function (yaxe, index) {
        if (gl.ignoreYAxisIndexes.indexOf(index) === -1) {
          yAxis.yAxisTitleRotate(index, yaxe.opposite);
        }
      });
    }
  }, {
    key: "setupBrushHandler",
    value: function setupBrushHandler() {
      var _this3 = this;

      var w = this.w; // only for brush charts

      if (!w.config.chart.brush.enabled) {
        return;
      } // if user has not defined a custom function for selection - we handle the brush chart
      // otherwise we leave it to the user to define the functionality for selection


      if (typeof w.config.chart.events.selection !== 'function') {
        var targets = w.config.chart.brush.targets || [w.config.chart.brush.target]; // retro compatibility with single target option

        targets.forEach(function (target) {
          var targetChart = ApexCharts.getChartByID(target);
          targetChart.w.globals.brushSource = _this3.ctx;

          var updateSourceChart = function updateSourceChart() {
            _this3.ctx._updateOptions({
              chart: {
                selection: {
                  xaxis: {
                    min: targetChart.w.globals.minX,
                    max: targetChart.w.globals.maxX
                  }
                }
              }
            }, false, false);
          };

          if (typeof targetChart.w.config.chart.events.zoomed !== 'function') {
            targetChart.w.config.chart.events.zoomed = function () {
              updateSourceChart();
            };
          }

          if (typeof targetChart.w.config.chart.events.scrolled !== 'function') {
            targetChart.w.config.chart.events.scrolled = function () {
              updateSourceChart();
            };
          }

          w.config.chart.events.selection = function (chart, e) {
            var yaxis = Utils.clone(w.config.yaxis);

            if (w.config.chart.brush.autoScaleYaxis) {
              var scale = new Range(targetChart);
              yaxis = scale.autoScaleY(targetChart, e);
            }

            targetChart._updateOptions({
              xaxis: {
                min: e.xaxis.min,
                max: e.xaxis.max
              },
              yaxis: yaxis
            }, false, false, false);
          };
        });
      }
    }
  }]);

  return Core;
}();

/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      return constructor.resolve(callback()).then(function() {
        return constructor.reject(reason);
      });
    }
  );
}

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise$1(fn) {
  if (!(this instanceof Promise$1))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise$1._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise$1._immediateFn(function() {
      if (!self._handled) {
        Promise$1._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise$1.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise$1.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise$1.prototype['finally'] = finallyConstructor;

Promise$1.all = function(arr) {
  return new Promise$1(function(resolve, reject) {
    if (!arr || typeof arr.length === 'undefined')
      throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise$1.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise$1) {
    return value;
  }

  return new Promise$1(function(resolve) {
    resolve(value);
  });
};

Promise$1.reject = function(value) {
  return new Promise$1(function(resolve, reject) {
    reject(value);
  });
};

Promise$1.race = function(values) {
  return new Promise$1(function(resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise$1._immediateFn =
  (typeof setImmediate === 'function' &&
    function(fn) {
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

var Exports =
/*#__PURE__*/
function () {
  function Exports(ctx) {
    _classCallCheck(this, Exports);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(Exports, [{
    key: "getSvgString",
    value: function getSvgString() {
      return this.w.globals.dom.Paper.svg();
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      var w = this.w; // hide some elements to avoid printing them on exported svg

      var xcrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs');
      var ycrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs');

      if (xcrosshairs) {
        xcrosshairs.setAttribute('x', -500);
      }

      if (ycrosshairs) {
        ycrosshairs.setAttribute('y1', -100);
        ycrosshairs.setAttribute('y2', -100);
      }
    }
  }, {
    key: "svgUrl",
    value: function svgUrl() {
      this.cleanup();
      var svgData = this.getSvgString();
      var svgBlob = new Blob([svgData], {
        type: 'image/svg+xml;charset=utf-8'
      });
      return URL.createObjectURL(svgBlob);
    }
  }, {
    key: "dataURI",
    value: function dataURI() {
      var _this = this;

      return new Promise$1(function (resolve) {
        var w = _this.w;

        _this.cleanup();

        var canvas = document.createElement('canvas');
        canvas.width = w.globals.svgWidth;
        canvas.height = w.globals.svgHeight;
        var canvasBg = w.config.chart.background === 'transparent' ? '#fff' : w.config.chart.background;
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = canvasBg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        var DOMURL = window.URL || window.webkitURL || window;
        var img = new Image();
        img.crossOrigin = 'anonymous';

        var svgData = _this.getSvgString();

        var svgUrl = 'data:image/svg+xml,' + encodeURIComponent(svgData);

        img.onload = function () {
          ctx.drawImage(img, 0, 0);
          DOMURL.revokeObjectURL(svgUrl);
          var imgURI = canvas.toDataURL('image/png');
          resolve(imgURI);
        };

        img.src = svgUrl;
      });
    }
  }, {
    key: "exportToSVG",
    value: function exportToSVG() {
      this.triggerDownload(this.svgUrl(), '.svg');
    }
  }, {
    key: "exportToPng",
    value: function exportToPng() {
      var _this2 = this;

      this.dataURI().then(function (imgURI) {
        _this2.triggerDownload(imgURI, '.png');
      });
    }
  }, {
    key: "triggerDownload",
    value: function triggerDownload(href, ext) {
      var downloadLink = document.createElement('a');
      downloadLink.href = href;
      downloadLink.download = this.w.globals.chartID + ext;
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    }
  }]);

  return Exports;
}();

/**
 * ApexCharts Grid Class for drawing Cartesian Grid.
 *
 * @module Grid
 **/

var Grid =
/*#__PURE__*/
function () {
  function Grid(ctx) {
    _classCallCheck(this, Grid);

    this.ctx = ctx;
    this.w = ctx.w;
    var w = this.w;
    this.anim = new Animations(this.ctx);
    this.xaxisLabels = w.globals.labels.slice();
    this.animX = w.config.grid.xaxis.lines.animate && w.config.chart.animations.enabled;
    this.animY = w.config.grid.yaxis.lines.animate && w.config.chart.animations.enabled;

    if (w.globals.timelineLabels.length > 0) {
      //  timeline labels are there
      this.xaxisLabels = w.globals.timelineLabels.slice();
    }
  } // .when using sparklines or when showing no grid, we need to have a grid area which is reused at many places for other calculations as well


  _createClass(Grid, [{
    key: "drawGridArea",
    value: function drawGridArea() {
      var elGrid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var w = this.w;
      var graphics = new Graphics(this.ctx);

      if (elGrid === null) {
        elGrid = graphics.group({
          class: 'apexcharts-grid'
        });
      }

      var elVerticalLine = graphics.drawLine(w.globals.padHorizontal, 1, w.globals.padHorizontal, w.globals.gridHeight, 'transparent');
      var elHorzLine = graphics.drawLine(w.globals.padHorizontal, w.globals.gridHeight, w.globals.gridWidth, w.globals.gridHeight, 'transparent');
      elGrid.add(elHorzLine);
      elGrid.add(elVerticalLine);
      return elGrid;
    }
  }, {
    key: "drawGrid",
    value: function drawGrid() {
      var w = this.w;
      var xAxis = new XAxis(this.ctx);
      var gl = this.w.globals;
      var elgrid = null;

      if (gl.axisCharts) {
        if (w.config.grid.show) {
          // grid is drawn after xaxis and yaxis are drawn
          elgrid = this.renderGrid();
          gl.dom.elGraphical.add(elgrid.el);
          this.drawGridArea(elgrid.el);
        } else {
          var elgridArea = this.drawGridArea();
          gl.dom.elGraphical.add(elgridArea);
        }

        if (elgrid !== null) {
          xAxis.xAxisLabelCorrections(elgrid.xAxisTickWidth);
        }
      }
    } // This mask will clip off overflowing graphics from the drawable area

  }, {
    key: "createGridMask",
    value: function createGridMask() {
      var w = this.w;
      var gl = w.globals;
      var graphics = new Graphics(this.ctx);
      var strokeSize = Array.isArray(w.config.stroke.width) ? 0 : w.config.stroke.width;

      if (Array.isArray(w.config.stroke.width)) {
        var strokeMaxSize = 0;
        w.config.stroke.width.forEach(function (m) {
          strokeMaxSize = Math.max(strokeMaxSize, m);
        });
        strokeSize = strokeMaxSize;
      }

      gl.dom.elGridRectMask = document.createElementNS(gl.SVGNS, 'clipPath');
      gl.dom.elGridRectMask.setAttribute('id', "gridRectMask".concat(gl.cuid));
      gl.dom.elGridRectMarkerMask = document.createElementNS(gl.SVGNS, 'clipPath');
      gl.dom.elGridRectMarkerMask.setAttribute('id', "gridRectMarkerMask".concat(gl.cuid));
      gl.dom.elGridRect = graphics.drawRect(-strokeSize / 2, -strokeSize / 2, gl.gridWidth + strokeSize, gl.gridHeight + strokeSize, 0, '#fff');
      var coreUtils = new CoreUtils(this);
      coreUtils.getLargestMarkerSize();
      var markerSize = w.globals.markers.largestSize + w.config.markers.hover.sizeOffset + 1;
      gl.dom.elGridRectMarker = graphics.drawRect(-markerSize, -markerSize, gl.gridWidth + markerSize * 2, gl.gridHeight + markerSize * 2, 0, '#fff');
      gl.dom.elGridRectMask.appendChild(gl.dom.elGridRect.node);
      gl.dom.elGridRectMarkerMask.appendChild(gl.dom.elGridRectMarker.node);
      var defs = gl.dom.baseEl.querySelector('defs');
      defs.appendChild(gl.dom.elGridRectMask);
      defs.appendChild(gl.dom.elGridRectMarkerMask);
    } // actual grid rendering

  }, {
    key: "renderGrid",
    value: function renderGrid() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var strokeDashArray = w.config.grid.strokeDashArray;
      var elg = graphics.group({
        class: 'apexcharts-grid'
      });
      var tickAmount = 8;

      for (var i = 0; i < w.globals.series.length; i++) {
        if (typeof w.globals.yAxisScale[i] !== 'undefined') {
          tickAmount = w.globals.yAxisScale[i].result.length - 1;
        }

        if (tickAmount > 2) break;
      }

      var xCount;
      var inversedGrid = !!(w.config.plotOptions.bar.horizontal && w.config.chart.type === 'bar');

      if (!inversedGrid) {
        xCount = this.xaxisLabels.length; // draw vertical lines

        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {
          var x1 = w.globals.padHorizontal;
          var y1 = 0;
          var x2;
          var y2 = w.globals.gridHeight;

          if (w.globals.timelineLabels.length > 0) {
            for (var _i = 0; _i < xCount; _i++) {
              x1 = this.xaxisLabels[_i].position;
              x2 = this.xaxisLabels[_i].position;

              if (w.config.grid.xaxis.lines.show && x1 > 0 && x1 < w.globals.gridWidth) {
                var line = graphics.drawLine(x1, y1, x2, y2, w.config.grid.borderColor, strokeDashArray);
                line.node.classList.add('apexcharts-gridline');
                elg.add(line);

                if (this.animX) {
                  this.animateLine(line, {
                    x1: 0,
                    x2: 0
                  }, {
                    x1: x1,
                    x2: x2
                  });
                }
              }

              var xAxis = new XAxis(this.ctx);
              xAxis.drawXaxisTicks(x1, elg);
            }
          } else {
            var xCountForCategoryCharts = xCount;

            for (var _i2 = 0; _i2 < xCountForCategoryCharts; _i2++) {
              var x1Count = xCountForCategoryCharts;

              if (w.globals.isXNumeric && w.config.chart.type !== 'bar') {
                x1Count -= 1;
              }

              x1 = x1 + w.globals.gridWidth / x1Count;
              x2 = x1; // skip the last line

              if (_i2 === x1Count - 1) break;

              if (w.config.grid.xaxis.lines.show) {
                var _line = graphics.drawLine(x1, y1, x2, y2, w.config.grid.borderColor, strokeDashArray);

                _line.node.classList.add('apexcharts-gridline');

                elg.add(_line);

                if (this.animX) {
                  this.animateLine(_line, {
                    x1: 0,
                    x2: 0
                  }, {
                    x1: x1,
                    x2: x2
                  });
                }
              }

              var _xAxis = new XAxis(this.ctx);

              _xAxis.drawXaxisTicks(x1, elg);
            }
          }
        } // draw horizontal lines


        if (w.config.grid.yaxis.lines.show) {
          var _x = 0;
          var _y = 0;
          var _y2 = 0;
          var _x2 = w.globals.gridWidth;

          for (var _i3 = 0; _i3 < tickAmount + 1; _i3++) {
            var _line2 = graphics.drawLine(_x, _y, _x2, _y2, w.config.grid.borderColor, strokeDashArray);

            elg.add(_line2);

            _line2.node.classList.add('apexcharts-gridline');

            if (this.animY) {
              this.animateLine(_line2, {
                y1: _y + 20,
                y2: _y2 + 20
              }, {
                y1: _y,
                y2: _y2
              });
            }

            _y = _y + w.globals.gridHeight / tickAmount;
            _y2 = _y;
          }
        }
      } else {
        xCount = tickAmount; // draw vertical lines

        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {
          var _x3 = w.globals.padHorizontal;
          var _y3 = 0;

          var _x4;

          var _y4 = w.globals.gridHeight;

          for (var _i4 = 0; _i4 < xCount + 1; _i4++) {
            _x3 = _x3 + w.globals.gridWidth / xCount + 0.3;
            _x4 = _x3; // skip the last vertical line

            if (_i4 === xCount - 1) break;

            if (w.config.grid.xaxis.lines.show) {
              var _line3 = graphics.drawLine(_x3, _y3, _x4, _y4, w.config.grid.borderColor, strokeDashArray);

              _line3.node.classList.add('apexcharts-gridline');

              elg.add(_line3);

              if (this.animX) {
                this.animateLine(_line3, {
                  x1: 0,
                  x2: 0
                }, {
                  x1: _x3,
                  x2: _x4
                });
              }
            } // skip the first vertical line


            var _xAxis2 = new XAxis(this.ctx);

            _xAxis2.drawXaxisTicks(_x3, elg);
          }
        } // draw horizontal lines


        if (w.config.grid.yaxis.lines.show) {
          var _x5 = 0;
          var _y5 = 0;
          var _y6 = 0;
          var _x6 = w.globals.gridWidth;

          for (var _i5 = 0; _i5 < w.globals.dataPoints + 1; _i5++) {
            var _line4 = graphics.drawLine(_x5, _y5, _x6, _y6, w.config.grid.borderColor, strokeDashArray);

            elg.add(_line4);

            _line4.node.classList.add('apexcharts-gridline');

            if (this.animY) {
              this.animateLine(_line4, {
                y1: _y5 + 20,
                y2: _y6 + 20
              }, {
                y1: _y5,
                y2: _y6
              });
            }

            _y5 = _y5 + w.globals.gridHeight / w.globals.dataPoints;
            _y6 = _y5;
          }
        }
      }

      this.drawGridBands(elg, xCount, tickAmount);
      return {
        el: elg,
        xAxisTickWidth: w.globals.gridWidth / xCount
      };
    }
  }, {
    key: "drawGridBands",
    value: function drawGridBands(elg, xCount, tickAmount) {
      var w = this.w;
      var graphics = new Graphics(this.ctx); // rows background bands

      if (w.config.grid.row.colors !== undefined && w.config.grid.row.colors.length > 0) {
        var x1 = 0;
        var y1 = 0;
        var y2 = w.globals.gridHeight / tickAmount;
        var x2 = w.globals.gridWidth;

        for (var i = 0, c = 0; i < tickAmount; i++, c++) {
          if (c >= w.config.grid.row.colors.length) {
            c = 0;
          }

          var color = w.config.grid.row.colors[c];
          var rect = graphics.drawRect(x1, y1, x2, y2, 0, color, w.config.grid.row.opacity);
          elg.add(rect);
          rect.node.classList.add('apexcharts-gridRow');
          y1 = y1 + w.globals.gridHeight / tickAmount;
        }
      } // columns background bands


      if (w.config.grid.column.colors !== undefined && w.config.grid.column.colors.length > 0) {
        var _x7 = w.globals.padHorizontal;
        var _y7 = 0;

        var _x8 = w.globals.padHorizontal + w.globals.gridWidth / xCount;

        var _y8 = w.globals.gridHeight;

        for (var _i6 = 0, _c = 0; _i6 < xCount; _i6++, _c++) {
          if (_c >= w.config.grid.column.colors.length) {
            _c = 0;
          }

          var _color = w.config.grid.column.colors[_c];

          var _rect = graphics.drawRect(_x7, _y7, _x8, _y8, 0, _color, w.config.grid.column.opacity);

          _rect.node.classList.add('apexcharts-gridColumn');

          elg.add(_rect);
          _x7 = _x7 + w.globals.gridWidth / xCount;
        }
      }
    }
  }, {
    key: "animateLine",
    value: function animateLine(line, from, to) {
      var w = this.w;
      var initialAnim = w.config.chart.animations;

      if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {
        var speed = initialAnim.speed;
        this.anim.animateLine(line, from, to, speed);
      }
    }
  }]);

  return Grid;
}();

/**
 * ApexCharts Legend Class to draw legend.
 *
 * @module Legend
 **/

var Legend =
/*#__PURE__*/
function () {
  function Legend(ctx, opts) {
    _classCallCheck(this, Legend);

    this.ctx = ctx;
    this.w = ctx.w;
    this.onLegendClick = this.onLegendClick.bind(this);
    this.onLegendHovered = this.onLegendHovered.bind(this);
  }

  _createClass(Legend, [{
    key: "init",
    value: function init() {
      var w = this.w;
      var gl = w.globals;
      var cnf = w.config;
      var showLegendAlways = cnf.legend.showForSingleSeries && gl.series.length === 1 || gl.series.length > 1;

      if ((showLegendAlways || !gl.axisCharts) && cnf.legend.show) {
        while (gl.dom.elLegendWrap.firstChild) {
          gl.dom.elLegendWrap.removeChild(gl.dom.elLegendWrap.firstChild);
        }

        this.drawLegends();

        if (!Utils.isIE11()) {
          this.appendToForeignObject();
        } else {
          // IE11 doesn't supports foreignObject, hence append it to <head>
          document.getElementsByTagName('head')[0].appendChild(this.getLegendStyles());
        }

        if (cnf.legend.position === 'bottom' || cnf.legend.position === 'top') {
          this.legendAlignHorizontal();
        } else if (cnf.legend.position === 'right' || cnf.legend.position === 'left') {
          this.legendAlignVertical();
        }
      }
    }
  }, {
    key: "appendToForeignObject",
    value: function appendToForeignObject() {
      var gl = this.w.globals;
      var elForeign = document.createElementNS(gl.SVGNS, 'foreignObject');
      elForeign.setAttribute('x', 0);
      elForeign.setAttribute('y', 0);
      elForeign.setAttribute('width', gl.svgWidth);
      elForeign.setAttribute('height', gl.svgHeight);
      gl.dom.elLegendWrap.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
      elForeign.appendChild(gl.dom.elLegendWrap);
      elForeign.appendChild(this.getLegendStyles());
      gl.dom.Paper.node.insertBefore(elForeign, gl.dom.elGraphical.node);
    }
  }, {
    key: "drawLegends",
    value: function drawLegends() {
      var self = this;
      var w = this.w;
      var fontFamily = w.config.legend.fontFamily;
      var legendNames = w.globals.seriesNames;
      var fillcolor = w.globals.colors.slice();

      if (w.config.chart.type === 'heatmap') {
        var ranges = w.config.plotOptions.heatmap.colorScale.ranges;
        legendNames = ranges.map(function (colorScale) {
          return colorScale.name ? colorScale.name : colorScale.from + ' - ' + colorScale.to;
        });
        fillcolor = ranges.map(function (color) {
          return color.color;
        });
      }

      var legendFormatter = w.globals.legendFormatter;

      for (var i = 0; i <= legendNames.length - 1; i++) {
        var text = legendFormatter(legendNames[i], {
          seriesIndex: i,
          w: w
        });
        var collapsedSeries = false;
        var ancillaryCollapsedSeries = false;

        if (w.globals.collapsedSeries.length > 0) {
          for (var c = 0; c < w.globals.collapsedSeries.length; c++) {
            if (w.globals.collapsedSeries[c].index === i) {
              collapsedSeries = true;
            }
          }
        }

        if (w.globals.ancillaryCollapsedSeriesIndices.length > 0) {
          for (var _c = 0; _c < w.globals.ancillaryCollapsedSeriesIndices.length; _c++) {
            if (w.globals.ancillaryCollapsedSeriesIndices[_c] === i) {
              ancillaryCollapsedSeries = true;
            }
          }
        }

        var elMarker = document.createElement('span');
        elMarker.classList.add('apexcharts-legend-marker');
        var mOffsetX = w.config.legend.markers.offsetX;
        var mOffsetY = w.config.legend.markers.offsetY;
        var mHeight = w.config.legend.markers.height;
        var mWidth = w.config.legend.markers.width;
        var mBorderWidth = w.config.legend.markers.strokeWidth;
        var mBorderColor = w.config.legend.markers.strokeColor;
        var mBorderRadius = w.config.legend.markers.radius;
        var mStyle = elMarker.style;
        mStyle.background = fillcolor[i];
        mStyle.color = fillcolor[i];
        mStyle.height = Array.isArray(mHeight) ? parseFloat(mHeight[i]) + 'px' : parseFloat(mHeight) + 'px';
        mStyle.width = Array.isArray(mWidth) ? parseFloat(mWidth[i]) + 'px' : parseFloat(mWidth) + 'px';
        mStyle.left = Array.isArray(mOffsetX) ? mOffsetX[i] : mOffsetX;
        mStyle.top = Array.isArray(mOffsetY) ? mOffsetY[i] : mOffsetY;
        mStyle.borderWidth = Array.isArray(mBorderWidth) ? mBorderWidth[i] : mBorderWidth;
        mStyle.borderColor = Array.isArray(mBorderColor) ? mBorderColor[i] : mBorderColor;
        mStyle.borderRadius = Array.isArray(mBorderRadius) ? parseFloat(mBorderRadius[i]) + 'px' : parseFloat(mBorderRadius) + 'px';

        if (w.config.legend.markers.customHTML) {
          if (Array.isArray(w.config.legend.markers.customHTML)) {
            elMarker.innerHTML = w.config.legend.markers.customHTML[i]();
          } else {
            elMarker.innerHTML = w.config.legend.markers.customHTML();
          }
        }

        Graphics.setAttrs(elMarker, {
          rel: i + 1,
          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries
        });

        if (collapsedSeries || ancillaryCollapsedSeries) {
          elMarker.classList.add('inactive-legend');
        }

        var elLegend = document.createElement('div');
        var elLegendText = document.createElement('span');
        elLegendText.classList.add('apexcharts-legend-text');
        elLegendText.innerHTML = text;
        var textColor = w.config.legend.labels.useSeriesColors ? w.globals.colors[i] : w.config.legend.labels.colors;

        if (!textColor) {
          textColor = w.config.chart.foreColor;
        }

        elLegendText.style.color = textColor;
        elLegendText.style.fontSize = parseFloat(w.config.legend.fontSize) + 'px';
        elLegendText.style.fontFamily = fontFamily || w.config.chart.fontFamily;
        Graphics.setAttrs(elLegendText, {
          rel: i + 1,
          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries
        });
        elLegend.appendChild(elMarker);
        elLegend.appendChild(elLegendText);
        var coreUtils = new CoreUtils(this.ctx);

        if (!w.config.legend.showForZeroSeries) {
          var total = coreUtils.getSeriesTotalByIndex(i);

          if (total === 0 && coreUtils.seriesHaveSameValues(i) && !coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {
            elLegend.classList.add('apexcharts-hidden-zero-series');
          }
        }

        if (!w.config.legend.showForNullSeries) {
          if (coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {
            elLegend.classList.add('apexcharts-hidden-null-series');
          }
        }

        w.globals.dom.elLegendWrap.appendChild(elLegend);
        w.globals.dom.elLegendWrap.classList.add(w.config.legend.horizontalAlign); // w.globals.dom.elLegendWrap.classList.add(w.config.legend.verticalAlign)

        w.globals.dom.elLegendWrap.classList.add('position-' + w.config.legend.position);
        elLegend.classList.add('apexcharts-legend-series');
        elLegend.style.margin = "".concat(w.config.legend.itemMargin.horizontal, "px ").concat(w.config.legend.itemMargin.vertical, "px");
        w.globals.dom.elLegendWrap.style.width = w.config.legend.width ? w.config.legend.width + 'px' : '';
        w.globals.dom.elLegendWrap.style.height = w.config.legend.height ? w.config.legend.height + 'px' : '';
        Graphics.setAttrs(elLegend, {
          rel: i + 1,
          'data:collapsed': collapsedSeries || ancillaryCollapsedSeries
        });

        if (collapsedSeries || ancillaryCollapsedSeries) {
          elLegend.classList.add('inactive-legend');
        }

        if (!w.config.legend.onItemClick.toggleDataSeries) {
          elLegend.classList.add('no-click');
        }
      } // for now - just prevent click on heatmap legend - and allow hover only


      var clickAllowed = w.config.chart.type !== 'heatmap';

      if (clickAllowed && w.config.legend.onItemClick.toggleDataSeries) {
        w.globals.dom.elWrap.addEventListener('click', self.onLegendClick, true);
      }

      if (w.config.legend.onItemHover.highlightDataSeries) {
        w.globals.dom.elWrap.addEventListener('mousemove', self.onLegendHovered, true);
        w.globals.dom.elWrap.addEventListener('mouseout', self.onLegendHovered, true);
      }
    }
  }, {
    key: "getLegendBBox",
    value: function getLegendBBox() {
      var w = this.w;
      var currLegendsWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');
      var currLegendsWrapRect = currLegendsWrap.getBoundingClientRect();
      var currLegendsWrapWidth = currLegendsWrapRect.width;
      var currLegendsWrapHeight = currLegendsWrapRect.height;
      return {
        clwh: currLegendsWrapHeight,
        clww: currLegendsWrapWidth
      };
    }
  }, {
    key: "setLegendWrapXY",
    value: function setLegendWrapXY(offsetX, offsetY) {
      var w = this.w;
      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');
      var legendRect = elLegendWrap.getBoundingClientRect();
      var x = 0;
      var y = 0;

      if (w.config.legend.position === 'bottom') {
        y = y + (w.globals.svgHeight - legendRect.height / 2);
      } else if (w.config.legend.position === 'top') {
        var dim = new Dimensions(this.ctx);
        var titleH = dim.getTitleSubtitleCoords('title').height;
        var subtitleH = dim.getTitleSubtitleCoords('subtitle').height;
        y = y + (titleH > 0 ? titleH - 10 : 0) + (subtitleH > 0 ? subtitleH - 10 : 0);
      }

      elLegendWrap.style.position = 'absolute';
      x = x + offsetX + w.config.legend.offsetX;
      y = y + offsetY + w.config.legend.offsetY;
      elLegendWrap.style.left = x + 'px';
      elLegendWrap.style.top = y + 'px';

      if (w.config.legend.position === 'bottom') {
        elLegendWrap.style.top = 'auto';
        elLegendWrap.style.bottom = 10 + w.config.legend.offsetY + 'px';
      } else if (w.config.legend.position === 'right') {
        elLegendWrap.style.left = 'auto';
        elLegendWrap.style.right = 25 + w.config.legend.offsetX + 'px';
      }

      if (elLegendWrap.style.width) {
        elLegendWrap.style.width = parseInt(w.config.legend.width) + 'px';
      }

      if (elLegendWrap.style.height) {
        elLegendWrap.style.height = parseInt(w.config.legend.height) + 'px';
      }
    }
  }, {
    key: "legendAlignHorizontal",
    value: function legendAlignHorizontal() {
      var w = this.w;
      var elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');
      elLegendWrap.style.right = 0;
      var lRect = this.getLegendBBox();
      var dimensions = new Dimensions(this.ctx);
      var titleRect = dimensions.getTitleSubtitleCoords('title');
      var subtitleRect = dimensions.getTitleSubtitleCoords('subtitle');
      var offsetX = 20;
      var offsetY = 0; // the whole legend box is set to bottom

      if (w.config.legend.position === 'bottom') {
        offsetY = -lRect.clwh / 1.8;
      } else if (w.config.legend.position === 'top') {
        offsetY = titleRect.height + subtitleRect.height + w.config.title.margin + w.config.subtitle.margin - 15;
      }

      this.setLegendWrapXY(offsetX, offsetY);
    }
  }, {
    key: "legendAlignVertical",
    value: function legendAlignVertical() {
      var w = this.w;
      var lRect = this.getLegendBBox();
      var offsetY = 20;
      var offsetX = 0;

      if (w.config.legend.position === 'left') {
        offsetX = 20;
      }

      if (w.config.legend.position === 'right') {
        offsetX = w.globals.svgWidth - lRect.clww - 10;
      }

      this.setLegendWrapXY(offsetX, offsetY);
    }
  }, {
    key: "onLegendHovered",
    value: function onLegendHovered(e) {
      var w = this.w;
      var hoverOverLegend = e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker');

      if (w.config.chart.type !== 'heatmap') {
        if (!e.target.classList.contains('inactive-legend') && hoverOverLegend) {
          var series = new Series(this.ctx);
          series.toggleSeriesOnHover(e, e.target);
        }
      } else {
        // for heatmap handling
        if (hoverOverLegend) {
          var seriesCnt = parseInt(e.target.getAttribute('rel')) - 1;
          this.ctx.fireEvent('legendHover', [this.ctx, seriesCnt, this.w]);

          var _series = new Series(this.ctx);

          _series.highlightRangeInSeries(e, e.target);
        }
      }
    }
  }, {
    key: "onLegendClick",
    value: function onLegendClick(e) {
      if (e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker')) {
        var seriesCnt = parseInt(e.target.getAttribute('rel')) - 1;
        var isHidden = e.target.getAttribute('data:collapsed') === 'true';
        var legendClick = this.w.config.chart.events.legendClick;

        if (typeof legendClick === 'function') {
          legendClick(this.ctx, seriesCnt, this.w);
        }

        this.ctx.fireEvent('legendClick', [this.ctx, seriesCnt, this.w]);
        var markerClick = this.w.config.legend.markers.onClick;

        if (typeof markerClick === 'function' && e.target.classList.contains('apexcharts-legend-marker')) {
          markerClick(this.ctx, seriesCnt, this.w);
          this.ctx.fireEvent('legendMarkerClick', [this.ctx, seriesCnt, this.w]);
        }

        this.toggleDataSeries(seriesCnt, isHidden);
      }
    }
  }, {
    key: "getLegendStyles",
    value: function getLegendStyles() {
      var stylesheet = document.createElement('style');
      stylesheet.setAttribute('type', 'text/css');
      var text = "\n    \n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n\n      .apexcharts-legend.position-bottom.left, .apexcharts-legend.position-top.left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\n        justify-content: flex-start;\n      }\n\n      .apexcharts-legend.position-bottom.center, .apexcharts-legend.position-top.center {\n        justify-content: center;  \n      }\n\n      .apexcharts-legend.position-bottom.right, .apexcharts-legend.position-top.right {\n        justify-content: flex-end;\n      }\n\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n      }\n\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\n        display: flex;\n        align-items: center;\n      }\n\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n\n      .apexcharts-legend-marker {\n        position: relative;\n        display: inline-block;\n        cursor: pointer;\n        margin-right: 3px;\n      }\n      \n      .apexcharts-legend.right .apexcharts-legend-series, .apexcharts-legend.left .apexcharts-legend-series{\n        display: inline-block;\n      }\n\n      .apexcharts-legend-series.no-click {\n        cursor: auto;\n      }\n\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n\n      .inactive-legend {\n        opacity: 0.45;\n      }";
      var rules = document.createTextNode(text);
      stylesheet.appendChild(rules);
      return stylesheet;
    }
  }, {
    key: "resetToggleDataSeries",
    value: function resetToggleDataSeries() {
      var w = this.w;
      var seriesEls = null;
      var realIndexes = [];

      if (w.globals.axisCharts) {
        seriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex]");
        seriesEls.forEach(function (v) {
          realIndexes.push(parseInt(v.getAttribute('data:realIndex')));
        });
      } else {
        seriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[rel]");
        seriesEls.forEach(function (v) {
          realIndexes.push(parseInt(v.getAttribute('rel')) - 1);
        });
      }

      realIndexes.sort();

      if (w.globals.collapsedSeries.length > 0) {
        var risingSeries = w.globals.risingSeries.slice();
        var series = w.config.series.slice();

        for (var c = 0; c < w.globals.collapsedSeries.length; c++) {
          var index = realIndexes.indexOf(w.globals.collapsedSeries[c].index);

          if (index !== -1) {
            if (w.globals.axisCharts) {
              series[index].data = w.globals.collapsedSeries.slice()[c].data.slice();
            } else {
              series[index] = w.globals.collapsedSeries.slice()[c].data;
            }

            risingSeries.push(index);
          }
        }

        w.globals.collapsedSeries = [];
        w.globals.ancillaryCollapsedSeries = [];
        w.globals.collapsedSeriesIndices = [];
        w.globals.ancillaryCollapsedSeriesIndices = [];
        w.globals.risingSeries = risingSeries;
        w.config.series = series;

        this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);
      }
    }
  }, {
    key: "toggleDataSeries",
    value: function toggleDataSeries(seriesCnt, isHidden) {
      var w = this.w;

      if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {
        w.globals.resized = true; // we don't want initial animations again

        var seriesEl = null;
        var realIndex = null; // yes, make it null. 1 series will rise at a time

        w.globals.risingSeries = [];

        if (w.globals.axisCharts) {
          seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(seriesCnt, "']"));
          realIndex = parseInt(seriesEl.getAttribute('data:realIndex'));
        } else {
          seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(seriesCnt + 1, "']"));
          realIndex = parseInt(seriesEl.getAttribute('rel')) - 1;
        }

        if (isHidden) {
          this.riseCollapsedSeries(w.globals.collapsedSeries, w.globals.collapsedSeriesIndices, realIndex);
          this.riseCollapsedSeries(w.globals.ancillaryCollapsedSeries, w.globals.ancillaryCollapsedSeriesIndices, realIndex);
        } else {
          if (w.globals.axisCharts) {
            var shouldNotHideYAxis = false;

            if (w.config.yaxis[realIndex] && w.config.yaxis[realIndex].show && w.config.yaxis[realIndex].showAlways) {
              shouldNotHideYAxis = true;

              if (w.globals.ancillaryCollapsedSeriesIndices.indexOf(realIndex) < 0) {
                w.globals.ancillaryCollapsedSeries.push({
                  index: realIndex,
                  data: w.config.series[realIndex].data.slice(),
                  type: seriesEl.parentNode.className.baseVal.split('-')[1]
                });
                w.globals.ancillaryCollapsedSeriesIndices.push(realIndex);
              }
            }

            if (!shouldNotHideYAxis) {
              w.globals.collapsedSeries.push({
                index: realIndex,
                data: w.config.series[realIndex].data.slice(),
                type: seriesEl.parentNode.className.baseVal.split('-')[1]
              });
              w.globals.collapsedSeriesIndices.push(realIndex);
              var removeIndexOfRising = w.globals.risingSeries.indexOf(realIndex);
              w.globals.risingSeries.splice(removeIndexOfRising, 1);
            } // TODO: AVOID mutating the user's config object below


            w.config.series[realIndex].data = [];
          } else {
            w.globals.collapsedSeries.push({
              index: realIndex,
              data: w.config.series[realIndex]
            });
            w.globals.collapsedSeriesIndices.push(realIndex);
            w.config.series[realIndex] = 0;
          }

          var seriesChildren = seriesEl.childNodes;

          for (var sc = 0; sc < seriesChildren.length; sc++) {
            if (seriesChildren[sc].classList.contains('apexcharts-series-markers-wrap')) {
              if (seriesChildren[sc].classList.contains('apexcharts-hide')) {
                seriesChildren[sc].classList.remove('apexcharts-hide');
              } else {
                seriesChildren[sc].classList.add('apexcharts-hide');
              }
            }
          }

          w.globals.allSeriesCollapsed = w.globals.collapsedSeries.length === w.globals.series.length;

          this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);
        }
      } else {
        // for non-axis charts i.e pie / donuts
        var _seriesEl = w.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(seriesCnt + 1, "'] path"));

        _seriesEl.fire('click');
      }
    }
  }, {
    key: "riseCollapsedSeries",
    value: function riseCollapsedSeries(series, seriesIndices, realIndex) {
      var w = this.w;

      if (series.length > 0) {
        for (var c = 0; c < series.length; c++) {
          if (series[c].index === realIndex) {
            if (w.globals.axisCharts) {
              w.config.series[realIndex].data = series[c].data.slice();
              series.splice(c, 1);
              seriesIndices.splice(c, 1);
              w.globals.risingSeries.push(realIndex);
            } else {
              w.config.series[realIndex] = series[c].data;
              series.splice(c, 1);
              seriesIndices.splice(c, 1);
              w.globals.risingSeries.push(realIndex);
            }

            this.ctx._updateSeries(w.config.series, w.config.chart.animations.dynamicAnimation.enabled);
          }
        }
      }
    }
  }]);

  return Legend;
}();

/**
 * ApexCharts Responsive Class to override options for different screen sizes.
 *
 * @module Responsive
 **/

var Responsive =
/*#__PURE__*/
function () {
  function Responsive(ctx) {
    _classCallCheck(this, Responsive);

    this.ctx = ctx;
    this.w = ctx.w;
  } // the opts parameter if not null has to be set overriding everything
  // as the opts is set by user externally


  _createClass(Responsive, [{
    key: "checkResponsiveConfig",
    value: function checkResponsiveConfig(opts) {
      var _this = this;

      var w = this.w;
      var cnf = w.config; // check if responsive config exists

      if (cnf.responsive.length === 0) return;
      var res = cnf.responsive.slice();
      res.sort(function (a, b) {
        return a.breakpoint > b.breakpoint ? 1 : b.breakpoint > a.breakpoint ? -1 : 0;
      }).reverse();
      var config = new Config({});

      var iterateResponsiveOptions = function iterateResponsiveOptions() {
        var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var largestBreakpoint = res[0].breakpoint;
        var width = window.innerWidth > 0 ? window.innerWidth : screen.width;

        if (width > largestBreakpoint) {
          var options = CoreUtils.extendArrayProps(config, w.globals.initialConfig);
          newOptions = Utils.extend(options, newOptions);
          newOptions = Utils.extend(w.config, newOptions);

          _this.overrideResponsiveOptions(newOptions);
        } else {
          for (var i = 0; i < res.length; i++) {
            if (width < res[i].breakpoint) {
              newOptions = Utils.extend(config, newOptions);
              newOptions = CoreUtils.extendArrayProps(newOptions, res[i].options);
              newOptions = Utils.extend(w.config, newOptions);

              _this.overrideResponsiveOptions(newOptions);
            }
          }
        }
      };

      if (opts) {
        var options = CoreUtils.extendArrayProps(config, opts);
        options = Utils.extend(w.config, options);
        options = Utils.extend(options, opts);
        iterateResponsiveOptions(options);
      } else {
        iterateResponsiveOptions({});
      }
    }
  }, {
    key: "overrideResponsiveOptions",
    value: function overrideResponsiveOptions(newOptions) {
      var newConfig = new Config(newOptions).init();
      this.w.config = newConfig;
    }
  }]);

  return Responsive;
}();

/**
 * ApexCharts Theme Class for setting the colors and palettes.
 *
 * @module Theme
 **/

var Theme =
/*#__PURE__*/
function () {
  function Theme(ctx) {
    _classCallCheck(this, Theme);

    this.ctx = ctx;
    this.w = ctx.w;
    this.colors = [];
  }

  _createClass(Theme, [{
    key: "init",
    value: function init() {
      this.setDefaultColors();
    }
  }, {
    key: "setDefaultColors",
    value: function setDefaultColors() {
      var w = this.w;
      var utils = new Utils();

      if (w.config.colors === undefined) {
        w.globals.colors = this.predefined();
      } else {
        w.globals.colors = w.config.colors;
      }

      if (w.config.theme.monochrome.enabled) {
        var monoArr = [];
        var glsCnt = w.globals.series.length;

        if (w.config.plotOptions.bar.distributed && w.config.chart.type === 'bar') {
          glsCnt = w.globals.series[0].length * w.globals.series.length;
        }

        var mainColor = w.config.theme.monochrome.color;
        var part = 1 / (glsCnt / w.config.theme.monochrome.shadeIntensity);
        var shade = w.config.theme.monochrome.shadeTo;
        var percent = 0;

        for (var gsl = 0; gsl < glsCnt; gsl++) {
          var newColor = void 0;

          if (shade === 'dark') {
            newColor = utils.shadeColor(percent * -1, mainColor);
            percent = percent + part;
          } else {
            newColor = utils.shadeColor(percent, mainColor);
            percent = percent + part;
          }

          monoArr.push(newColor);
        }

        w.globals.colors = monoArr.slice();
      }

      var defaultColors = w.globals.colors.slice(); // if user specfied less colors than no. of series, push the same colors again

      this.pushExtraColors(w.globals.colors); // The Border colors

      if (w.config.stroke.colors === undefined) {
        w.globals.stroke.colors = defaultColors;
      } else {
        w.globals.stroke.colors = w.config.stroke.colors;
      }

      this.pushExtraColors(w.globals.stroke.colors); // The FILL colors

      if (w.config.fill.colors === undefined) {
        w.globals.fill.colors = defaultColors;
      } else {
        w.globals.fill.colors = w.config.fill.colors;
      }

      this.pushExtraColors(w.globals.fill.colors);

      if (w.config.dataLabels.style.colors === undefined) {
        w.globals.dataLabels.style.colors = defaultColors;
      } else {
        w.globals.dataLabels.style.colors = w.config.dataLabels.style.colors;
      }

      this.pushExtraColors(w.globals.dataLabels.style.colors, 50);

      if (w.config.plotOptions.radar.polygons.fill.colors === undefined) {
        w.globals.radarPolygons.fill.colors = ['#fff'];
      } else {
        w.globals.radarPolygons.fill.colors = w.config.plotOptions.radar.polygons.fill.colors;
      }

      this.pushExtraColors(w.globals.radarPolygons.fill.colors, 20); // The point colors

      if (w.config.markers.colors === undefined) {
        w.globals.markers.colors = defaultColors;
      } else {
        w.globals.markers.colors = w.config.markers.colors;
      }

      this.pushExtraColors(w.globals.markers.colors);
    } // When the number of colors provided is less than the number of series, this method
    // will push same colors to the list
    // params:
    // distributed is only valid for distributed column/bar charts

  }, {
    key: "pushExtraColors",
    value: function pushExtraColors(colorSeries, length) {
      var distributed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var w = this.w;
      var len = length || w.globals.series.length;

      if (distributed === null) {
        distributed = w.config.chart.type === 'bar' && w.config.plotOptions.bar.distributed || w.config.chart.type === 'heatmap' && w.config.plotOptions.heatmap.colorScale.inverse;
      }

      if (distributed) {
        len = w.globals.series[0].length * w.globals.series.length;
      }

      if (colorSeries.length < len) {
        var diff = len - colorSeries.length;

        for (var i = 0; i < diff; i++) {
          colorSeries.push(colorSeries[i]);
        }
      }
    }
  }, {
    key: "predefined",
    value: function predefined() {
      var palette = this.w.config.theme.palette; // D6E3F8, FCEFEF, DCE0D9, A5978B, EDDDD4, D6E3F8, FEF5EF

      switch (palette) {
        case 'palette1':
          this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'];
          break;

        case 'palette2':
          this.colors = ['#3f51b5', '#03a9f4', '#4caf50', '#f9ce1d', '#FF9800'];
          break;

        case 'palette3':
          this.colors = ['#33b2df', '#546E7A', '#d4526e', '#13d8aa', '#A5978B'];
          break;

        case 'palette4':
          this.colors = ['#546E7A', '#4ecdc4', '#c7f464', '#81D4FA', '#fd6a6a'];
          break;

        case 'palette5':
          this.colors = ['#2b908f', '#f9a3a4', '#90ee7e', '#fa4443', '#69d2e7'];
          break;

        case 'palette6':
          this.colors = ['#449DD1', '#F86624', '#EA3546', '#662E9B', '#C5D86D'];
          break;

        case 'palette7':
          this.colors = ['#D7263D', '#1B998B', '#2E294E', '#F46036', '#E2C044'];
          break;

        case 'palette8':
          this.colors = ['#662E9B', '#F86624', '#F9C80E', '#EA3546', '#43BCCD'];
          break;

        case 'palette9':
          this.colors = ['#5C4742', '#A5978B', '#8D5B4C', '#5A2A27', '#C4BBAF'];
          break;

        case 'palette10':
          this.colors = ['#A300D6', '#7D02EB', '#5653FE', '#2983FF', '#00B1F2'];
          break;

        default:
          this.colors = ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'];
          break;
      }

      return this.colors;
    }
  }]);

  return Theme;
}();

var Utils$1 =
/*#__PURE__*/
function () {
  function Utils(tooltipContext) {
    _classCallCheck(this, Utils);

    this.w = tooltipContext.w;
    this.ttCtx = tooltipContext;
    this.ctx = tooltipContext.ctx;
  }
  /**
   ** When hovering over series, you need to capture which series is being hovered on.
   ** This function will return both capturedseries index as well as inner index of that series
   * @memberof Utils
   * @param {object}
   * - hoverArea = the rect on which user hovers
   * - elGrid = dimensions of the hover rect (it can be different than hoverarea)
   */


  _createClass(Utils, [{
    key: "getNearestValues",
    value: function getNearestValues(_ref) {
      var hoverArea = _ref.hoverArea,
          elGrid = _ref.elGrid,
          clientX = _ref.clientX,
          clientY = _ref.clientY,
          hasBars = _ref.hasBars;
      var w = this.w;
      var hoverWidth = w.globals.gridWidth;
      var xDivisor = hoverWidth / (w.globals.dataPoints - 1);
      var seriesBound = elGrid.getBoundingClientRect();

      if (hasBars && w.globals.comboCharts || hasBars) {
        xDivisor = hoverWidth / w.globals.dataPoints;
      }

      var hoverX = clientX - seriesBound.left;
      var hoverY = clientY - seriesBound.top;
      var inRect = hoverX < 0 || hoverY < 0 || hoverX > w.globals.gridWidth || hoverY > w.globals.gridHeight;

      if (inRect) {
        hoverArea.classList.remove('hovering-zoom');
        hoverArea.classList.remove('hovering-pan');
      } else {
        if (w.globals.zoomEnabled) {
          hoverArea.classList.remove('hovering-pan');
          hoverArea.classList.add('hovering-zoom');
        } else if (w.globals.panEnabled) {
          hoverArea.classList.remove('hovering-zoom');
          hoverArea.classList.add('hovering-pan');
        }
      }

      var j = Math.round(hoverX / xDivisor);

      if (hasBars) {
        j = Math.ceil(hoverX / xDivisor);
        j = j - 1;
      }

      var capturedSeries = null;
      var closest = null;
      var seriesXValArr = [];
      var seriesYValArr = [];

      for (var s = 0; s < w.globals.seriesXvalues.length; s++) {
        seriesXValArr.push([w.globals.seriesXvalues[s][0] - 0.000001].concat(w.globals.seriesXvalues[s]));
      }

      seriesXValArr = seriesXValArr.map(function (seriesXVal) {
        return seriesXVal.filter(function (s) {
          return s;
        });
      });
      seriesYValArr = w.globals.seriesYvalues.map(function (seriesYVal) {
        return seriesYVal.filter(function (s) {
          return s;
        });
      }); // if X axis type is not category and tooltip is not shared, then we need to find the cursor position and get the nearest value

      if (w.globals.isXNumeric) {
        closest = this.closestInMultiArray(hoverX, hoverY, seriesXValArr, seriesYValArr);
        capturedSeries = closest.index;
        j = closest.j;

        if (capturedSeries !== null) {
          // initial push, it should be a little smaller than the 1st val
          seriesXValArr = w.globals.seriesXvalues[capturedSeries];
          closest = this.closestInArray(hoverX, seriesXValArr);
          j = closest.index;
        }
      }

      if (!j || j < 1) j = 0;
      return {
        capturedSeries: capturedSeries,
        j: j,
        hoverX: hoverX,
        hoverY: hoverY
      };
    }
  }, {
    key: "closestInMultiArray",
    value: function closestInMultiArray(hoverX, hoverY, Xarrays, Yarrays) {
      var w = this.w;
      var activeIndex = 0;
      var currIndex = null;
      var j = -1;

      if (w.globals.series.length > 1) {
        activeIndex = this.getFirstActiveXArray(Xarrays);
      } else {
        currIndex = 0;
      }

      var currY = Yarrays[activeIndex][0];
      var currX = Xarrays[activeIndex][0];
      var diffX = Math.abs(hoverX - currX);
      var diffY = Math.abs(hoverY - currY);
      var diff = diffY + diffX;
      Yarrays.map(function (arrY, arrIndex) {
        arrY.map(function (y, innerKey) {
          var newdiffY = Math.abs(hoverY - Yarrays[arrIndex][innerKey]);
          var newdiffX = Math.abs(hoverX - Xarrays[arrIndex][innerKey]);
          var newdiff = newdiffX + newdiffY;

          if (newdiff < diff) {
            diff = newdiff;
            diffX = newdiffX;
            diffY = newdiffY;
            currIndex = arrIndex;
            j = innerKey;
          }
        });
      });
      return {
        index: currIndex,
        j: j
      };
    }
  }, {
    key: "getFirstActiveXArray",
    value: function getFirstActiveXArray(Xarrays) {
      var activeIndex = 0;
      var coreUtils = new CoreUtils(this.ctx);
      var firstActiveSeriesIndex = Xarrays.map(function (xarr, index) {
        if (xarr.length > 0) {
          return index;
        } else {
          return -1;
        }
      });

      for (var a = 0; a < firstActiveSeriesIndex.length; a++) {
        var total = coreUtils.getSeriesTotalByIndex(a);

        if (firstActiveSeriesIndex[a] !== -1 && total !== 0 && !coreUtils.seriesHaveSameValues(a)) {
          activeIndex = firstActiveSeriesIndex[a];
          break;
        }
      }

      return activeIndex;
    }
  }, {
    key: "closestInArray",
    value: function closestInArray(val, arr) {
      var curr = arr[0];
      var currIndex = null;
      var diff = Math.abs(val - curr);

      for (var i = 0; i < arr.length; i++) {
        var newdiff = Math.abs(val - arr[i]);

        if (newdiff < diff) {
          diff = newdiff;
          curr = arr[i];
          currIndex = i;
        }
      }

      return {
        index: currIndex
      };
    }
    /**
     * When there are multiple series, it is possible to have different x values for each series.
     * But it may be possible in those multiple series, that there is same x value for 2 or more
     * series.
     * @memberof Utils
     * @param {int}
     * - j = is the inner index of series -> (series[i][j])
     * @return {bool}
     */

  }, {
    key: "isXoverlap",
    value: function isXoverlap(j) {
      var w = this.w;
      var xSameForAllSeriesJArr = [];
      var seriesX = w.globals.seriesX.filter(function (s) {
        return typeof s[0] !== 'undefined';
      });

      if (seriesX.length > 0) {
        for (var i = 0; i < seriesX.length - 1; i++) {
          if (typeof seriesX[i][j] !== 'undefined' && typeof seriesX[i + 1][j] !== 'undefined') {
            if (seriesX[i][j] !== seriesX[i + 1][j]) {
              xSameForAllSeriesJArr.push('unEqual');
            }
          }
        }
      }

      if (xSameForAllSeriesJArr.length === 0) {
        return true;
      }

      return false;
    }
  }, {
    key: "isinitialSeriesSameLen",
    value: function isinitialSeriesSameLen() {
      var sameLen = true;
      var initialSeries = this.w.globals.initialSeries;

      for (var i = 0; i < initialSeries.length - 1; i++) {
        if (initialSeries[i].data.length !== initialSeries[i + 1].data.length) {
          sameLen = false;
          break;
        }
      }

      return sameLen;
    }
  }, {
    key: "getBarsHeight",
    value: function getBarsHeight(allbars) {
      var bars = _toConsumableArray(allbars);

      var totalHeight = bars.reduce(function (acc, bar) {
        return acc + bar.getBBox().height;
      }, 0);
      return totalHeight;
    }
  }, {
    key: "toggleAllTooltipSeriesGroups",
    value: function toggleAllTooltipSeriesGroups(state) {
      var w = this.w;
      var ttCtx = this.ttCtx;

      if (ttCtx.allTooltipSeriesGroups.length === 0) {
        ttCtx.allTooltipSeriesGroups = w.globals.dom.baseEl.querySelectorAll('.apexcharts-tooltip-series-group');
      }

      var allTooltipSeriesGroups = ttCtx.allTooltipSeriesGroups;

      for (var i = 0; i < allTooltipSeriesGroups.length; i++) {
        if (state === 'enable') {
          allTooltipSeriesGroups[i].classList.add('active');
          allTooltipSeriesGroups[i].style.display = w.config.tooltip.items.display;
        } else {
          allTooltipSeriesGroups[i].classList.remove('active');
          allTooltipSeriesGroups[i].style.display = 'none';
        }
      }
    }
  }]);

  return Utils;
}();

/**
 * ApexCharts Tooltip.Labels Class to draw texts on the tooltip.
 *
 * @module Tooltip.Labels
 **/

var Labels =
/*#__PURE__*/
function () {
  function Labels(tooltipContext) {
    _classCallCheck(this, Labels);

    this.w = tooltipContext.w;
    this.ctx = tooltipContext.ctx;
    this.ttCtx = tooltipContext;
    this.tooltipUtil = new Utils$1(tooltipContext);
  }

  _createClass(Labels, [{
    key: "drawSeriesTexts",
    value: function drawSeriesTexts(_ref) {
      var _ref$shared = _ref.shared,
          shared = _ref$shared === void 0 ? true : _ref$shared,
          ttItems = _ref.ttItems,
          _ref$i = _ref.i,
          i = _ref$i === void 0 ? 0 : _ref$i,
          _ref$j = _ref.j,
          j = _ref$j === void 0 ? null : _ref$j;
      var w = this.w;

      if (w.config.tooltip.custom !== undefined) {
        this.handleCustomTooltip({
          i: i,
          j: j
        });
      } else {
        this.toggleActiveInactiveSeries(shared);
      }

      var values = this.getValuesToPrint({
        i: i,
        j: j
      });
      this.printLabels({
        i: i,
        j: j,
        values: values,
        ttItems: ttItems,
        shared: shared
      }); // Re-calculate tooltip dimensions now that we have drawn the text

      var tooltipEl = this.ttCtx.getElTooltip();
      this.ttCtx.tooltipRect.ttWidth = tooltipEl.getBoundingClientRect().width;
      this.ttCtx.tooltipRect.ttHeight = tooltipEl.getBoundingClientRect().height;
    }
  }, {
    key: "printLabels",
    value: function printLabels(_ref2) {
      var i = _ref2.i,
          j = _ref2.j,
          values = _ref2.values,
          ttItems = _ref2.ttItems,
          shared = _ref2.shared;
      var w = this.w;
      var val;
      var xVal = values.xVal,
          zVal = values.zVal,
          xAxisTTVal = values.xAxisTTVal;
      var seriesName = '';
      var pColor = w.globals.colors[i];

      if (j !== null && w.config.plotOptions.bar.distributed) {
        pColor = w.globals.colors[j];
      }

      for (var t = 0, inverset = w.globals.series.length - 1; t < w.globals.series.length; t++, inverset--) {
        var f = this.getFormatters(i);
        seriesName = this.getSeriesName({
          fn: f.yLbTitleFormatter,
          index: i,
          seriesIndex: i,
          j: j
        });

        if (shared) {
          var tIndex = w.config.tooltip.inverseOrder ? inverset : t;
          f = this.getFormatters(tIndex);
          seriesName = this.getSeriesName({
            fn: f.yLbTitleFormatter,
            index: tIndex,
            seriesIndex: i,
            j: j
          });
          pColor = w.globals.colors[tIndex]; // for plot charts, not for pie/donuts

          val = f.yLbFormatter(w.globals.series[tIndex][j], {
            series: w.globals.series,
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          }); // discard 0 values in BARS

          if (this.ttCtx.hasBars() && w.config.chart.stacked && w.globals.series[tIndex][j] === 0 || typeof w.globals.series[tIndex][j] === 'undefined') {
            val = undefined;
          }
        } else {
          val = f.yLbFormatter(w.globals.series[i][j], {
            series: w.globals.series,
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          });
        } // for pie / donuts


        if (j === null) {
          val = f.yLbFormatter(w.globals.series[i], w);
        }

        this.DOMHandling({
          t: t,
          ttItems: ttItems,
          values: {
            val: val,
            xVal: xVal,
            xAxisTTVal: xAxisTTVal,
            zVal: zVal
          },
          seriesName: seriesName,
          shared: shared,
          pColor: pColor
        });
      }
    }
  }, {
    key: "getFormatters",
    value: function getFormatters(i) {
      var w = this.w;
      var yLbFormatter = w.globals.yLabelFormatters[i];
      var yLbTitleFormatter;

      if (w.globals.ttVal !== undefined) {
        if (Array.isArray(w.globals.ttVal)) {
          yLbFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].formatter;
          yLbTitleFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].title && w.globals.ttVal[i].title.formatter;
        } else {
          yLbFormatter = w.globals.ttVal.formatter;

          if (typeof w.globals.ttVal.title.formatter === 'function') {
            yLbTitleFormatter = w.globals.ttVal.title.formatter;
          }
        }
      } else {
        yLbTitleFormatter = w.config.tooltip.y.title.formatter;
      }

      if (typeof yLbFormatter !== 'function') {
        if (w.globals.yLabelFormatters[0]) {
          yLbFormatter = w.globals.yLabelFormatters[0];
        } else {
          yLbFormatter = function yLbFormatter(label) {
            return label;
          };
        }
      }

      if (typeof yLbTitleFormatter !== 'function') {
        yLbTitleFormatter = function yLbTitleFormatter(label) {
          return label;
        };
      }

      return {
        yLbFormatter: yLbFormatter,
        yLbTitleFormatter: yLbTitleFormatter
      };
    }
  }, {
    key: "getSeriesName",
    value: function getSeriesName(_ref3) {
      var fn = _ref3.fn,
          index = _ref3.index,
          seriesIndex = _ref3.seriesIndex,
          j = _ref3.j;
      var w = this.w;
      return fn(String(w.globals.seriesNames[index]), {
        series: w.globals.series,
        seriesIndex: seriesIndex,
        dataPointIndex: j,
        w: w
      });
    }
  }, {
    key: "DOMHandling",
    value: function DOMHandling(_ref4) {
      var t = _ref4.t,
          ttItems = _ref4.ttItems,
          values = _ref4.values,
          seriesName = _ref4.seriesName,
          shared = _ref4.shared,
          pColor = _ref4.pColor;
      var w = this.w;
      var ttCtx = this.ttCtx;
      var val = values.val,
          xVal = values.xVal,
          xAxisTTVal = values.xAxisTTVal,
          zVal = values.zVal;
      var ttItemsChildren = null;
      ttItemsChildren = ttItems[t].children;

      if (w.config.tooltip.fillSeriesColor) {
        //  elTooltip.style.backgroundColor = pColor
        ttItems[t].style.backgroundColor = pColor;
        ttItemsChildren[0].style.display = 'none';
      }

      if (ttCtx.showTooltipTitle) {
        if (ttCtx.tooltipTitle === null) {
          // get it once if null, and store it in class property
          ttCtx.tooltipTitle = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-title');
        }

        ttCtx.tooltipTitle.innerHTML = xVal;
      } // if xaxis tooltip is constructed, we need to replace the innerHTML


      if (ttCtx.blxaxisTooltip) {
        ttCtx.xaxisTooltipText.innerHTML = xAxisTTVal !== '' ? xAxisTTVal : xVal;
      }

      var ttYLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-label');

      if (ttYLabel) {
        ttYLabel.innerHTML = seriesName ? seriesName + ': ' : '';
      }

      var ttYVal = ttItems[t].querySelector('.apexcharts-tooltip-text-value');

      if (ttYVal) {
        ttYVal.innerHTML = val;
      }

      if (ttItemsChildren[0] && ttItemsChildren[0].classList.contains('apexcharts-tooltip-marker')) {
        ttItemsChildren[0].style.backgroundColor = pColor;
      }

      if (!w.config.tooltip.marker.show) {
        ttItemsChildren[0].style.display = 'none';
      }

      if (zVal !== null) {
        var ttZLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-z-label');
        ttZLabel.innerHTML = w.config.tooltip.z.title;
        var ttZVal = ttItems[t].querySelector('.apexcharts-tooltip-text-z-value');
        ttZVal.innerHTML = zVal;
      }

      if (shared && ttItemsChildren[0]) {
        // hide when no Val or series collapsed
        if (typeof val === 'undefined' || val === null || w.globals.collapsedSeriesIndices.indexOf(t) > -1) {
          ttItemsChildren[0].parentNode.style.display = 'none';
        } else {
          ttItemsChildren[0].parentNode.style.display = w.config.tooltip.items.display;
        }
      }
    }
  }, {
    key: "toggleActiveInactiveSeries",
    value: function toggleActiveInactiveSeries(shared) {
      var w = this.w;

      if (shared) {
        // make all tooltips active
        this.tooltipUtil.toggleAllTooltipSeriesGroups('enable');
      } else {
        // disable all tooltip text groups
        this.tooltipUtil.toggleAllTooltipSeriesGroups('disable'); // enable the first tooltip text group

        var firstTooltipSeriesGroup = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-series-group');

        if (firstTooltipSeriesGroup) {
          firstTooltipSeriesGroup.classList.add('active');
          firstTooltipSeriesGroup.style.display = w.config.tooltip.items.display;
        }
      }
    }
  }, {
    key: "getValuesToPrint",
    value: function getValuesToPrint(_ref5) {
      var i = _ref5.i,
          j = _ref5.j;
      var w = this.w;
      var filteredSeriesX = this.ctx.series.filteredSeriesX();
      var xVal = '';
      var xAxisTTVal = '';
      var zVal = null;
      var val = null;
      var customFormatterOpts = {
        series: w.globals.series,
        seriesIndex: i,
        dataPointIndex: j,
        w: w
      };
      var zFormatter = w.globals.ttZFormatter;

      if (j === null) {
        val = w.globals.series[i];
      } else {
        if (w.globals.isXNumeric) {
          xVal = filteredSeriesX[i][j];

          if (filteredSeriesX[i].length === 0) {
            // a series (possibly the first one) might be collapsed, so get the next active index
            var firstActiveSeriesIndex = this.tooltipUtil.getFirstActiveXArray(filteredSeriesX);
            xVal = filteredSeriesX[firstActiveSeriesIndex][j];
          }
        } else {
          xVal = typeof w.globals.labels[j] !== 'undefined' ? w.globals.labels[j] : '';
        }
      }

      var bufferXVal = xVal;

      if (w.globals.isXNumeric && w.config.xaxis.type === 'datetime') {
        var xFormat = new Formatters(this.ctx);
        xVal = xFormat.xLabelFormat(w.globals.ttKeyFormatter, bufferXVal);
      } else {
        xVal = w.globals.xLabelFormatter(bufferXVal, customFormatterOpts);
      } // override default x-axis formatter with tooltip formatter


      if (w.config.tooltip.x.formatter !== undefined) {
        xVal = w.globals.ttKeyFormatter(bufferXVal, customFormatterOpts);
      }

      if (w.globals.seriesZ.length > 0 && w.globals.seriesZ[0].length > 0) {
        zVal = zFormatter(w.globals.seriesZ[i][j], w);
      }

      if (typeof w.config.xaxis.tooltip.formatter === 'function') {
        xAxisTTVal = w.globals.xaxisTooltipFormatter(bufferXVal, customFormatterOpts);
      } else {
        xAxisTTVal = xVal;
      }

      return {
        val: val,
        xVal: xVal,
        xAxisTTVal: xAxisTTVal,
        zVal: zVal
      };
    }
  }, {
    key: "handleCustomTooltip",
    value: function handleCustomTooltip(_ref6) {
      var i = _ref6.i,
          j = _ref6.j;
      var w = this.w;
      var tooltipEl = this.ttCtx.getElTooltip(); // override everything with a custom html tooltip and replace it

      tooltipEl.innerHTML = w.config.tooltip.custom({
        series: w.globals.series,
        seriesIndex: i,
        dataPointIndex: j,
        w: w
      });
    }
  }]);

  return Labels;
}();

/**
 * ApexCharts Tooltip.Position Class to move the tooltip based on x and y position.
 *
 * @module Tooltip.Position
 **/

var Position =
/*#__PURE__*/
function () {
  function Position(tooltipContext) {
    _classCallCheck(this, Position);

    this.ttCtx = tooltipContext;
    this.ctx = tooltipContext.ctx;
    this.w = tooltipContext.w;
  }
  /**
   * This will move the crosshair (the vertical/horz line that moves along with mouse)
   * Along with this, this function also calls the xaxisMove function
   * @memberof Position
   * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair
   */


  _createClass(Position, [{
    key: "moveXCrosshairs",
    value: function moveXCrosshairs(cx) {
      var j = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var ttCtx = this.ttCtx;
      var w = this.w;
      var xcrosshairs = ttCtx.getElXCrosshairs();
      var x = cx - ttCtx.xcrosshairsWidth / 2;
      var tickAmount = w.globals.labels.slice().length;

      if (j !== null) {
        x = w.globals.gridWidth / tickAmount * j;
      }

      if (w.config.xaxis.crosshairs.width === 'tickWidth' || w.config.xaxis.crosshairs.width === 'barWidth') {
        if (x + ttCtx.xcrosshairsWidth > w.globals.gridWidth) {
          x = w.globals.gridWidth - ttCtx.xcrosshairsWidth;
        }
      } else {
        if (j !== null) {
          x = x + w.globals.gridWidth / tickAmount / 2;
        }
      }

      if (x < 0) {
        x = 0;
      }

      if (x > w.globals.gridWidth) {
        x = w.globals.gridWidth;
      }

      if (xcrosshairs !== null) {
        xcrosshairs.setAttribute('x', x);
        xcrosshairs.setAttribute('x1', x);
        xcrosshairs.setAttribute('x2', x);
        xcrosshairs.setAttribute('y2', w.globals.gridHeight);
        xcrosshairs.classList.add('active');
      }

      if (ttCtx.blxaxisTooltip) {
        var tx = x;

        if (w.config.xaxis.crosshairs.width === 'tickWidth' || w.config.xaxis.crosshairs.width === 'barWidth') {
          tx = x + ttCtx.xcrosshairsWidth / 2;
        }

        this.moveXAxisTooltip(tx);
      }
    }
    /**
     * This will move the crosshair (the vertical/horz line that moves along with mouse)
     * Along with this, this function also calls the xaxisMove function
     * @memberof Position
     * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair
     */

  }, {
    key: "moveYCrosshairs",
    value: function moveYCrosshairs(cy) {
      var ttCtx = this.ttCtx;

      if (ttCtx.ycrosshairs !== null) {
        Graphics.setAttrs(ttCtx.ycrosshairs, {
          y1: cy,
          y2: cy
        });
        Graphics.setAttrs(ttCtx.ycrosshairsHidden, {
          y1: cy,
          y2: cy
        });
      }
    }
    /**
     ** AxisTooltip is the small rectangle which appears on x axis with x value, when user moves
     * @memberof Position
     * @param {int} - cx = point's x position, wherever point's x is, you need to move
     */

  }, {
    key: "moveXAxisTooltip",
    value: function moveXAxisTooltip(cx) {
      var w = this.w;
      var ttCtx = this.ttCtx;

      if (ttCtx.xaxisTooltip !== null) {
        ttCtx.xaxisTooltip.classList.add('active');
        var cy = ttCtx.xaxisOffY + w.config.xaxis.tooltip.offsetY + w.globals.translateY + 1 + w.config.xaxis.offsetY;
        var xaxisTTText = ttCtx.xaxisTooltip.getBoundingClientRect();
        var xaxisTTTextWidth = xaxisTTText.width;
        cx = cx - xaxisTTTextWidth / 2;

        if (!isNaN(cx)) {
          cx = cx + w.globals.translateX;
          var textRect = 0;
          var graphics = new Graphics(this.ctx);
          textRect = graphics.getTextRects(ttCtx.xaxisTooltipText.innerHTML);
          ttCtx.xaxisTooltipText.style.minWidth = textRect.width + 'px';
          ttCtx.xaxisTooltip.style.left = cx + 'px';
          ttCtx.xaxisTooltip.style.top = cy + 'px';
        }
      }
    }
  }, {
    key: "moveYAxisTooltip",
    value: function moveYAxisTooltip(index) {
      var w = this.w;
      var ttCtx = this.ttCtx;

      if (ttCtx.yaxisTTEls === null) {
        ttCtx.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');
      }

      var ycrosshairsHiddenRectY1 = parseInt(ttCtx.ycrosshairsHidden.getAttribute('y1'));
      var cy = w.globals.translateY + ycrosshairsHiddenRectY1;
      var yAxisTTRect = ttCtx.yaxisTTEls[index].getBoundingClientRect();
      var yAxisTTHeight = yAxisTTRect.height;
      var cx = w.globals.translateYAxisX[index] - 2;

      if (w.config.yaxis[index].opposite) {
        cx = cx - 26;
      }

      cy = cy - yAxisTTHeight / 2;

      if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1) {
        ttCtx.yaxisTTEls[index].classList.add('active');
        ttCtx.yaxisTTEls[index].style.top = cy + 'px';
        ttCtx.yaxisTTEls[index].style.left = cx + w.config.yaxis[index].tooltip.offsetX + 'px';
      } else {
        ttCtx.yaxisTTEls[index].classList.remove('active');
      }
    }
    /**
     ** moves the whole tooltip by changing x, y attrs
     * @memberof Position
     * @param {int} - cx = point's x position, wherever point's x is, you need to move tooltip
     * @param {int} - cy = point's y position, wherever point's y is, you need to move tooltip
     * @param {int} - r = point's radius
     */

  }, {
    key: "moveTooltip",
    value: function moveTooltip(cx, cy) {
      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var w = this.w;
      var ttCtx = this.ttCtx;
      var tooltipEl = ttCtx.getElTooltip();
      var tooltipRect = ttCtx.tooltipRect;
      var pointR = r !== null ? parseInt(r) : 1;
      var x = parseInt(cx) + pointR + 5;
      var y = parseInt(cy) + pointR / 2; // - tooltipRect.ttHeight / 2

      if (x > w.globals.gridWidth / 2) {
        x = x - tooltipRect.ttWidth - pointR - 15;
      }

      if (x > w.globals.gridWidth - tooltipRect.ttWidth - 10) {
        x = w.globals.gridWidth - tooltipRect.ttWidth;
      }

      if (x < -20) {
        x = -20;
      }

      if (w.config.tooltip.followCursor) {
        var elGrid = ttCtx.getElGrid();
        var seriesBound = elGrid.getBoundingClientRect();
        y = ttCtx.e.clientY - seriesBound.top - tooltipRect.ttHeight / 2;
      }

      var newPositions = this.positionChecks(tooltipRect, x, y);
      x = newPositions.x;
      y = newPositions.y;

      if (!isNaN(x)) {
        x = x + w.globals.translateX;
        tooltipEl.style.left = x + 'px';
        tooltipEl.style.top = y + 'px';
      }
    }
  }, {
    key: "positionChecks",
    value: function positionChecks(tooltipRect, x, y) {
      var w = this.w;

      if (tooltipRect.ttHeight + y > w.globals.gridHeight) {
        y = w.globals.gridHeight - tooltipRect.ttHeight + w.globals.translateY;
      }

      if (y < 0) {
        y = 0;
      }

      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "moveMarkers",
    value: function moveMarkers(i, j) {
      var w = this.w;
      var ttCtx = this.ttCtx;

      if (w.globals.markers.size[i] > 0) {
        var allPoints = w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(i, "'] .apexcharts-marker"));

        for (var p = 0; p < allPoints.length; p++) {
          if (parseInt(allPoints[p].getAttribute('rel')) === j) {
            ttCtx.marker.resetPointsSize();
            ttCtx.marker.enlargeCurrentPoint(j, allPoints[p]);
          }
        }
      } else {
        ttCtx.marker.resetPointsSize();
        this.moveDynamicPointOnHover(j, i);
      }
    } // This function is used when you need to show markers/points only on hover -
    // DIFFERENT X VALUES in multiple series

  }, {
    key: "moveDynamicPointOnHover",
    value: function moveDynamicPointOnHover(j, capturedSeries) {
      var w = this.w;
      var ttCtx = this.ttCtx;
      var cx = 0;
      var cy = 0;
      var pointsArr = w.globals.pointsArray;
      var hoverSize = w.config.markers.hover.size;

      if (hoverSize === undefined) {
        hoverSize = w.globals.markers.size[capturedSeries] + w.config.markers.hover.sizeOffset;
      }

      cx = pointsArr[capturedSeries][j][0];
      cy = pointsArr[capturedSeries][j][1] ? pointsArr[capturedSeries][j][1] : 0;
      var point = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(capturedSeries, "'] .apexcharts-series-markers circle"));
      point.setAttribute('r', hoverSize);
      point.setAttribute('cx', cx);
      point.setAttribute('cy', cy); // point.style.opacity = w.config.markers.hover.opacity

      this.moveXCrosshairs(cx);

      if (!ttCtx.fixedTooltip) {
        this.moveTooltip(cx, cy, hoverSize);
      }
    } // This function is used when you need to show markers/points only on hover -
    // SAME X VALUES in multiple series

  }, {
    key: "moveDynamicPointsOnHover",
    value: function moveDynamicPointsOnHover(j) {
      var ttCtx = this.ttCtx;
      var w = ttCtx.w;
      var cx = 0;
      var cy = 0;
      var activeSeries = 0;
      var pointsArr = w.globals.pointsArray;
      var series = new Series(this.ctx);
      activeSeries = series.getActiveSeriesIndex();
      var hoverSize = w.config.markers.hover.size;

      if (hoverSize === undefined) {
        hoverSize = w.globals.markers.size[activeSeries] + w.config.markers.hover.sizeOffset;
      }

      if (pointsArr[activeSeries]) {
        cx = pointsArr[activeSeries][j][0];
        cy = pointsArr[activeSeries][j][1];
      }

      var points = null;
      var allPoints = ttCtx.getAllMarkers();

      if (allPoints !== null) {
        points = allPoints;
      } else {
        points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers circle');
      }

      if (points !== null) {
        for (var p = 0; p < points.length; p++) {
          var pointArr = pointsArr[p];

          if (pointArr && pointArr.length) {
            var pcy = pointsArr[p][j][1];
            points[p].setAttribute('cx', cx);
            var realIndex = parseInt(points[p].parentNode.parentNode.parentNode.getAttribute('data:realIndex'));

            if (pcy !== null) {
              points[realIndex] && points[realIndex].setAttribute('r', hoverSize);
              points[realIndex] && points[realIndex].setAttribute('cy', pcy);
            } else {
              points[realIndex] && points[realIndex].setAttribute('r', 0);
            }
          }
        }
      }

      this.moveXCrosshairs(cx);

      if (!ttCtx.fixedTooltip) {
        var tcy = cy || w.globals.gridHeight;
        this.moveTooltip(cx, tcy, hoverSize);
      }
    }
  }, {
    key: "moveStickyTooltipOverBars",
    value: function moveStickyTooltipOverBars(j) {
      var w = this.w;
      var ttCtx = this.ttCtx;
      var jBar = w.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='1'] path[j='".concat(j, "'], .apexcharts-candlestick-series .apexcharts-series[rel='1'] path[j='").concat(j, "']"));
      var bcx = jBar ? parseFloat(jBar.getAttribute('cx')) : 0;
      var bcy = 0;
      var bw = jBar ? parseFloat(jBar.getAttribute('barWidth')) : 0;

      if (w.globals.isXNumeric) {
        bcx = bcx - bw / 2;
      } else {
        bcx = ttCtx.xAxisTicksPositions[j - 1] + ttCtx.dataPointsDividedWidth / 2;

        if (isNaN(bcx)) {
          bcx = ttCtx.xAxisTicksPositions[j] - ttCtx.dataPointsDividedWidth / 2;
        }
      } // tooltip will move vertically along with mouse as it is a shared tooltip


      var elGrid = ttCtx.getElGrid();
      var seriesBound = elGrid.getBoundingClientRect();
      bcy = ttCtx.e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2;
      this.moveXCrosshairs(bcx);

      if (!ttCtx.fixedTooltip) {
        var tcy = bcy || w.globals.gridHeight;
        this.moveTooltip(bcx, tcy);
      }
    }
  }]);

  return Position;
}();

/**
 * ApexCharts Tooltip.Marker Class to draw texts on the tooltip.
 *
 * @module Tooltip.Marker
 **/

var Marker =
/*#__PURE__*/
function () {
  function Marker(tooltipContext) {
    _classCallCheck(this, Marker);

    this.w = tooltipContext.w;
    this.ttCtx = tooltipContext;
    this.ctx = tooltipContext.ctx;
    this.tooltipPosition = new Position(tooltipContext);
  }

  _createClass(Marker, [{
    key: "drawDynamicPoints",
    value: function drawDynamicPoints() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var marker = new Markers(this.ctx);
      var elsSeries = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');

      for (var i = 0; i < elsSeries.length; i++) {
        var seriesIndex = parseInt(elsSeries[i].getAttribute('data:realIndex'));
        var pointsMain = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(seriesIndex, "'] .apexcharts-series-markers-wrap"));

        if (pointsMain !== null) {
          // it can be null as we have tooltips in donut/bar charts
          var point = void 0;
          var PointClasses = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));

          if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {
            PointClasses += ' no-pointer-events';
          }

          var elPointOptions = marker.getMarkerConfig(PointClasses, seriesIndex);
          point = graphics.drawMarker(0, 0, elPointOptions);
          point.node.setAttribute('default-marker-size', 0);
          var elPointsG = document.createElementNS(w.globals.SVGNS, 'g');
          elPointsG.classList.add('apexcharts-series-markers');
          elPointsG.appendChild(point.node);
          pointsMain.appendChild(elPointsG);
        }
      }
    }
  }, {
    key: "enlargeCurrentPoint",
    value: function enlargeCurrentPoint(rel, point) {
      var w = this.w;

      if (w.config.chart.type !== 'bubble') {
        this.newPointSize(rel, point);
      }

      var cx = point.getAttribute('cx');
      var cy = point.getAttribute('cy');
      this.tooltipPosition.moveXCrosshairs(cx);

      if (!this.fixedTooltip) {
        if (w.config.chart.type === 'radar') {
          var elGrid = this.ttCtx.getElGrid();
          var seriesBound = elGrid.getBoundingClientRect();
          cx = this.ttCtx.e.clientX - seriesBound.left;
        }

        this.tooltipPosition.moveTooltip(cx, cy, w.config.markers.hover.size);
      }
    }
  }, {
    key: "enlargePoints",
    value: function enlargePoints(j) {
      var w = this.w;
      var me = this;
      var ttCtx = this.ttCtx;
      var col = j;
      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');
      var newSize = w.config.markers.hover.size;

      for (var p = 0; p < points.length; p++) {
        var rel = points[p].getAttribute('rel');
        var index = points[p].getAttribute('index');

        if (newSize === undefined) {
          newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;
        }

        if (col === parseInt(rel)) {
          me.newPointSize(col, points[p]);
          var cx = points[p].getAttribute('cx');
          var cy = points[p].getAttribute('cy');
          me.tooltipPosition.moveXCrosshairs(cx);

          if (!ttCtx.fixedTooltip) {
            me.tooltipPosition.moveTooltip(cx, cy, newSize);
          }
        } else {
          me.oldPointSize(points[p]);
        }
      }
    }
  }, {
    key: "newPointSize",
    value: function newPointSize(rel, point) {
      var w = this.w;
      var newSize = w.config.markers.hover.size;
      var elPoint = null;

      if (rel === 0) {
        elPoint = point.parentNode.firstChild;
      } else {
        elPoint = point.parentNode.lastChild;
      }

      var index = parseInt(elPoint.getAttribute('index'));

      if (newSize === undefined) {
        newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;
      }

      elPoint.setAttribute('r', newSize);
    }
  }, {
    key: "oldPointSize",
    value: function oldPointSize(point) {
      var size = parseInt(point.getAttribute('default-marker-size'));
      point.setAttribute('r', size);
    }
  }, {
    key: "resetPointsSize",
    value: function resetPointsSize() {
      var w = this.w;
      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');

      for (var p = 0; p < points.length; p++) {
        var size = parseInt(points[p].getAttribute('default-marker-size'));

        if (Utils.isNumber(size)) {
          points[p].setAttribute('r', size);
        } else {
          points[p].setAttribute('r', 0);
        }
      }
    }
  }]);

  return Marker;
}();

/**
 * ApexCharts Tooltip.Intersect Class.
 *
 * @module Tooltip.Intersect
 **/

var Intersect =
/*#__PURE__*/
function () {
  function Intersect(tooltipContext) {
    _classCallCheck(this, Intersect);

    this.w = tooltipContext.w;
    this.ttCtx = tooltipContext;
  }

  _createClass(Intersect, [{
    key: "getAttr",
    value: function getAttr(e, attr) {
      return parseFloat(e.target.getAttribute(attr));
    }
  }, {
    key: "handleHeatTooltip",
    value: function handleHeatTooltip(_ref) {
      var e = _ref.e,
          opt = _ref.opt,
          x = _ref.x,
          y = _ref.y;
      var ttCtx = this.ttCtx;
      var w = this.w;

      if (e.target.classList.contains('apexcharts-heatmap-rect')) {
        var i = this.getAttr(e, 'i');
        var j = this.getAttr(e, 'j');
        var cx = this.getAttr(e, 'cx');
        var cy = this.getAttr(e, 'cy');
        var width = this.getAttr(e, 'width');
        var height = this.getAttr(e, 'height');
        ttCtx.tooltipLabels.drawSeriesTexts({
          ttItems: opt.ttItems,
          i: i,
          j: j,
          shared: false
        });
        x = cx + ttCtx.tooltipRect.ttWidth / 2 + width;
        y = cy + ttCtx.tooltipRect.ttHeight / 2 - height / 2;
        ttCtx.tooltipPosition.moveXCrosshairs(cx + width / 2);

        if (x > w.globals.gridWidth / 2) {
          x = cx - ttCtx.tooltipRect.ttWidth / 2 + width;
        }

        if (ttCtx.w.config.tooltip.followCursor) {
          var elGrid = ttCtx.getElGrid();
          var seriesBound = elGrid.getBoundingClientRect(); // x = ttCtx.e.clientX - seriesBound.left

          y = ttCtx.e.clientY - seriesBound.top + w.globals.translateY / 2 - 10;
        }
      }

      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "handleMarkerTooltip",
    value: function handleMarkerTooltip(_ref2) {
      var e = _ref2.e,
          opt = _ref2.opt,
          x = _ref2.x,
          y = _ref2.y;
      var w = this.w;
      var ttCtx = this.ttCtx;
      var i;
      var j;

      if (e.target.classList.contains('apexcharts-marker')) {
        var cx = parseInt(opt.paths.getAttribute('cx'));
        var cy = parseInt(opt.paths.getAttribute('cy'));
        var val = parseFloat(opt.paths.getAttribute('val'));
        j = parseInt(opt.paths.getAttribute('rel'));
        i = parseInt(opt.paths.parentNode.parentNode.parentNode.getAttribute('rel')) - 1;

        if (ttCtx.intersect) {
          var el = Utils.findAncestor(opt.paths, 'apexcharts-series');

          if (el) {
            i = parseInt(el.getAttribute('data:realIndex'));
          }
        }

        ttCtx.tooltipLabels.drawSeriesTexts({
          ttItems: opt.ttItems,
          i: i,
          j: j,
          shared: ttCtx.intersect ? false : w.config.tooltip.shared
        });
        ttCtx.marker.enlargeCurrentPoint(j, opt.paths);
        x = cx;
        y = cy - ttCtx.tooltipRect.ttHeight * 1.4;

        if (ttCtx.w.config.tooltip.followCursor) {
          var elGrid = ttCtx.getElGrid();
          var seriesBound = elGrid.getBoundingClientRect();
          y = ttCtx.e.clientY - seriesBound.top;
        }

        if (val < 0) {
          y = cy;
        }
      }

      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "handleBarTooltip",
    value: function handleBarTooltip(_ref3) {
      var e = _ref3.e,
          opt = _ref3.opt;
      var w = this.w;
      var ttCtx = this.ttCtx;
      var tooltipEl = ttCtx.getElTooltip();
      var bx = 0;
      var x = 0;
      var y = 0; // let bW = 0

      var i = 0;
      var strokeWidth;
      var barXY = this.getBarTooltipXY({
        e: e,
        opt: opt
      });
      i = barXY.i;
      var barHeight = barXY.barHeight;
      var j = barXY.j;

      if (ttCtx.isBarHorizontal && ttCtx.hasBars() || !w.config.tooltip.shared) {
        x = barXY.x;
        y = barXY.y;
        strokeWidth = Array.isArray(w.config.stroke.width) ? w.config.stroke.width[i] : w.config.stroke.width; // bW = barXY.barWidth

        bx = x;
      } else {
        if (!w.globals.comboCharts && !w.config.tooltip.shared) {
          bx = bx / 2;
        }
      } // y is NaN, make it touch the bottom of grid area


      if (isNaN(y)) {
        y = w.globals.svgHeight - ttCtx.tooltipRect.ttHeight;
      } // x exceeds gridWidth


      if (x + ttCtx.tooltipRect.ttWidth > w.globals.gridWidth) {
        x = x - ttCtx.tooltipRect.ttWidth;
      } else if (x < 0) {
        x = x + ttCtx.tooltipRect.ttWidth;
      }

      if (ttCtx.w.config.tooltip.followCursor) {
        var elGrid = ttCtx.getElGrid();
        var seriesBound = elGrid.getBoundingClientRect();
        y = ttCtx.e.clientY - seriesBound.top;
      } // if tooltip is still null, querySelector


      if (ttCtx.tooltip === null) {
        ttCtx.tooltip = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');
      }

      if (!w.config.tooltip.shared) {
        if (w.globals.comboChartsHasBars) {
          ttCtx.tooltipPosition.moveXCrosshairs(bx + strokeWidth / 2);
        } else {
          ttCtx.tooltipPosition.moveXCrosshairs(bx);
        }
      } // move tooltip here


      if (!ttCtx.fixedTooltip && (!w.config.tooltip.shared || ttCtx.isBarHorizontal && ttCtx.hasBars())) {
        if (isReversed) {
          x = w.globals.gridWidth - x;
        }

        tooltipEl.style.left = x + w.globals.translateX + 'px';
        var seriesIndex = parseInt(opt.paths.parentNode.getAttribute('data:realIndex'));
        var isReversed = w.globals.isMultipleYAxis ? w.config.yaxis[seriesIndex].reversed : w.config.yaxis[0].reversed;

        if (isReversed && !(ttCtx.isBarHorizontal && ttCtx.hasBars())) {
          y = y + barHeight - (w.globals.series[i][j] < 0 ? barHeight : 0) * 2;
        }

        if (ttCtx.tooltipRect.ttHeight + y > w.globals.gridHeight) {
          y = w.globals.gridHeight - ttCtx.tooltipRect.ttHeight + w.globals.translateY;
          tooltipEl.style.top = y + 'px';
        } else {
          tooltipEl.style.top = y + w.globals.translateY - ttCtx.tooltipRect.ttHeight / 2 + 'px';
        }
      }
    }
  }, {
    key: "getBarTooltipXY",
    value: function getBarTooltipXY(_ref4) {
      var e = _ref4.e,
          opt = _ref4.opt;
      var w = this.w;
      var j = null;
      var ttCtx = this.ttCtx;
      var i = 0;
      var x = 0;
      var y = 0;
      var barWidth = 0;
      var barHeight = 0;
      var cl = e.target.classList;

      if (cl.contains('apexcharts-bar-area') || cl.contains('apexcharts-candlestick-area')) {
        var bar = e.target;
        var barRect = bar.getBoundingClientRect();
        var seriesBound = opt.elGrid.getBoundingClientRect();
        var bh = barRect.height;
        barHeight = barRect.height;
        var bw = barRect.width;
        var cx = parseInt(bar.getAttribute('cx'));
        var cy = parseInt(bar.getAttribute('cy'));
        barWidth = parseFloat(bar.getAttribute('barWidth'));
        var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        j = parseInt(bar.getAttribute('j'));
        i = parseInt(bar.parentNode.getAttribute('rel')) - 1;

        if (w.globals.comboCharts) {
          i = parseInt(bar.parentNode.getAttribute('data:realIndex'));
        } // if (w.config.tooltip.shared) {
        // this check not needed  at the moment
        //   const yDivisor = w.globals.gridHeight / (w.globals.series.length)
        //   const hoverY = ttCtx.clientY - ttCtx.seriesBound.top
        //   j = Math.ceil(hoverY / yDivisor)
        // }


        ttCtx.tooltipLabels.drawSeriesTexts({
          ttItems: opt.ttItems,
          i: i,
          j: j,
          shared: ttCtx.showOnIntersect ? false : w.config.tooltip.shared
        });

        if (w.config.tooltip.followCursor) {
          if (w.config.plotOptions.bar.horizontal) {
            x = clientX - seriesBound.left + 15;
            y = cy - ttCtx.dataPointsDividedHeight + bh / 2 - ttCtx.tooltipRect.ttHeight / 2;
          } else {
            if (w.globals.isXNumeric) {
              x = cx - bw / 2;
            } else {
              x = cx - ttCtx.dataPointsDividedWidth + bw / 2;
            }

            y = e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2 - 15;
          }
        } else {
          if (w.config.plotOptions.bar.horizontal) {
            x = cx;

            if (x < ttCtx.xyRatios.baseLineInvertedY) {
              x = cx - ttCtx.tooltipRect.ttWidth;
            }

            y = cy - ttCtx.dataPointsDividedHeight + bh / 2 - ttCtx.tooltipRect.ttHeight / 2;
          } else {
            // if columns
            if (w.globals.isXNumeric) {
              x = cx - bw / 2;
            } else {
              x = cx - ttCtx.dataPointsDividedWidth + bw / 2;
            }

            y = cy; // - ttCtx.tooltipRect.ttHeight / 2 + 10
          }
        }
      }

      return {
        x: x,
        y: y,
        barHeight: barHeight,
        barWidth: barWidth,
        i: i,
        j: j
      };
    }
  }]);

  return Intersect;
}();

/**
 * ApexCharts Tooltip.AxesTooltip Class.
 *
 * @module Tooltip.AxesTooltip
 **/
var AxesTooltip =
/*#__PURE__*/
function () {
  function AxesTooltip(tooltipContext) {
    _classCallCheck(this, AxesTooltip);

    this.w = tooltipContext.w;
    this.ttCtx = tooltipContext;
  }
  /**
   * This method adds the secondary tooltip which appears below x axis
   * @memberof Tooltip
   **/


  _createClass(AxesTooltip, [{
    key: "drawXaxisTooltip",
    value: function drawXaxisTooltip() {
      var w = this.w;
      var ttCtx = this.ttCtx;
      var isBottom = w.config.xaxis.position === 'bottom';
      ttCtx.xaxisOffY = isBottom ? w.globals.gridHeight + 1 : 1;
      var tooltipCssClass = isBottom ? 'apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom' : 'apexcharts-xaxistooltip apexcharts-xaxistooltip-top';
      var renderTo = w.globals.dom.elWrap;

      if (ttCtx.blxaxisTooltip) {
        var xaxisTooltip = w.globals.dom.baseEl.querySelector('.apexcharts-xaxistooltip');

        if (xaxisTooltip === null) {
          ttCtx.xaxisTooltip = document.createElement('div');
          ttCtx.xaxisTooltip.setAttribute('class', tooltipCssClass);
          renderTo.appendChild(ttCtx.xaxisTooltip);
          ttCtx.xaxisTooltipText = document.createElement('div');
          ttCtx.xaxisTooltipText.classList.add('apexcharts-xaxistooltip-text');
          ttCtx.xaxisTooltipText.style.fontFamily = w.config.xaxis.tooltip.style.fontFamily || w.config.chart.fontFamily;
          ttCtx.xaxisTooltipText.style.fontSize = w.config.xaxis.tooltip.style.fontSize;
          ttCtx.xaxisTooltip.appendChild(ttCtx.xaxisTooltipText);
        }
      }
    }
    /**
     * This method adds the secondary tooltip which appears below x axis
     * @memberof Tooltip
     **/

  }, {
    key: "drawYaxisTooltip",
    value: function drawYaxisTooltip() {
      var w = this.w;
      var ttCtx = this.ttCtx;

      for (var i = 0; i < w.config.yaxis.length; i++) {
        var isRight = w.config.yaxis[i].opposite || w.config.yaxis[i].crosshairs.opposite;
        ttCtx.yaxisOffX = isRight ? w.globals.gridWidth + 1 : 1;
        var tooltipCssClass = isRight ? "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, " apexcharts-yaxistooltip-right") : "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, " apexcharts-yaxistooltip-left");
        var renderTo = w.globals.dom.elWrap;

        if (ttCtx.blyaxisTooltip) {
          var yaxisTooltip = w.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i));

          if (yaxisTooltip === null) {
            ttCtx.yaxisTooltip = document.createElement('div');
            ttCtx.yaxisTooltip.setAttribute('class', tooltipCssClass);
            renderTo.appendChild(ttCtx.yaxisTooltip);
            if (i === 0) ttCtx.yaxisTooltipText = [];
            ttCtx.yaxisTooltipText.push(document.createElement('div'));
            ttCtx.yaxisTooltipText[i].classList.add('apexcharts-yaxistooltip-text');
            ttCtx.yaxisTooltip.appendChild(ttCtx.yaxisTooltipText[i]);
          }
        }
      }
    }
    /**
     * @memberof Tooltip
     **/

  }, {
    key: "setXCrosshairWidth",
    value: function setXCrosshairWidth() {
      var w = this.w;
      var ttCtx = this.ttCtx; // set xcrosshairs width

      var xcrosshairs = ttCtx.getElXCrosshairs();
      ttCtx.xcrosshairsWidth = parseInt(w.config.xaxis.crosshairs.width);

      if (!w.globals.comboCharts) {
        if (w.config.xaxis.crosshairs.width === 'tickWidth') {
          var count = w.globals.labels.length;
          ttCtx.xcrosshairsWidth = w.globals.gridWidth / count;
        } else if (w.config.xaxis.crosshairs.width === 'barWidth') {
          var bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');

          if (bar !== null) {
            var barWidth = parseFloat(bar.getAttribute('barWidth'));
            ttCtx.xcrosshairsWidth = barWidth;
          } else {
            ttCtx.xcrosshairsWidth = 1;
          }
        }
      } else {
        var _bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');

        if (_bar !== null && w.config.xaxis.crosshairs.width === 'barWidth') {
          var _barWidth = parseFloat(_bar.getAttribute('barWidth'));

          ttCtx.xcrosshairsWidth = _barWidth;
        } else {
          if (w.config.xaxis.crosshairs.width === 'tickWidth') {
            var _count = w.globals.labels.length;
            ttCtx.xcrosshairsWidth = w.globals.gridWidth / _count;
          }
        }
      }

      if (w.config.chart.type === 'bar' && w.config.plotOptions.bar.horizontal) {
        ttCtx.xcrosshairsWidth = 0;
      }

      if (xcrosshairs !== null && ttCtx.xcrosshairsWidth > 0) {
        xcrosshairs.setAttribute('width', ttCtx.xcrosshairsWidth);
      }
    }
  }, {
    key: "handleYCrosshair",
    value: function handleYCrosshair() {
      var w = this.w;
      var ttCtx = this.ttCtx; // set ycrosshairs height

      ttCtx.ycrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs');
      ttCtx.ycrosshairsHidden = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs-hidden');
    }
  }, {
    key: "drawYaxisTooltipText",
    value: function drawYaxisTooltipText(index, clientY, xyRatios) {
      var ttCtx = this.ttCtx;
      var w = this.w;
      var lbFormatter = w.globals.yLabelFormatters[index];

      if (ttCtx.blyaxisTooltip) {
        var elGrid = ttCtx.getElGrid();
        var seriesBound = elGrid.getBoundingClientRect();
        var hoverY = (clientY - seriesBound.top) * xyRatios.yRatio[index];
        var height = w.globals.maxYArr[index] - w.globals.minYArr[index];
        var val = w.globals.minYArr[index] + (height - hoverY);
        ttCtx.tooltipPosition.moveYCrosshairs(clientY - seriesBound.top);
        ttCtx.yaxisTooltipText[index].innerHTML = lbFormatter(val);
        ttCtx.tooltipPosition.moveYAxisTooltip(index);
      }
    }
  }]);

  return AxesTooltip;
}();

/**
 * ApexCharts Core Tooltip Class to handle the tooltip generation.
 *
 * @module Tooltip
 **/

var Tooltip =
/*#__PURE__*/
function () {
  function Tooltip(ctx) {
    _classCallCheck(this, Tooltip);

    this.ctx = ctx;
    this.w = ctx.w;
    var w = this.w;
    this.tooltipUtil = new Utils$1(this);
    this.tooltipLabels = new Labels(this);
    this.tooltipPosition = new Position(this);
    this.marker = new Marker(this);
    this.intersect = new Intersect(this);
    this.axesTooltip = new AxesTooltip(this);
    this.showOnIntersect = w.config.tooltip.intersect;
    this.showTooltipTitle = w.config.tooltip.x.show;
    this.fixedTooltip = w.config.tooltip.fixed.enabled;
    this.xaxisTooltip = null;
    this.yaxisTTEls = null;
    this.isBarHorizontal = w.config.plotOptions.bar.horizontal;
    this.isBarShared = !w.config.plotOptions.bar.horizontal && w.config.tooltip.shared;
  }

  _createClass(Tooltip, [{
    key: "getElTooltip",
    value: function getElTooltip(ctx) {
      if (!ctx) ctx = this;
      return ctx.w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');
    }
  }, {
    key: "getElXCrosshairs",
    value: function getElXCrosshairs() {
      return this.w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs');
    }
  }, {
    key: "getElGrid",
    value: function getElGrid() {
      return this.w.globals.dom.baseEl.querySelector('.apexcharts-grid');
    }
  }, {
    key: "drawTooltip",
    value: function drawTooltip(xyRatios) {
      var w = this.w;
      this.xyRatios = xyRatios;
      this.blxaxisTooltip = w.config.xaxis.tooltip.enabled && w.globals.axisCharts;
      this.blyaxisTooltip = w.config.yaxis[0].tooltip.enabled && w.globals.axisCharts;
      this.allTooltipSeriesGroups = [];

      if (!w.globals.axisCharts) {
        this.showTooltipTitle = false;
      }

      var tooltipEl = document.createElement('div');
      tooltipEl.classList.add('apexcharts-tooltip');
      tooltipEl.classList.add(w.config.tooltip.theme);
      w.globals.dom.elWrap.appendChild(tooltipEl);

      if (w.globals.axisCharts) {
        this.axesTooltip.drawXaxisTooltip();
        this.axesTooltip.drawYaxisTooltip();
        this.axesTooltip.setXCrosshairWidth();
        this.axesTooltip.handleYCrosshair();
        var xAxis = new XAxis(this.ctx);
        this.xAxisTicksPositions = xAxis.getXAxisTicksPositions();
      } // we forcefully set intersect true for these conditions


      if (w.globals.comboCharts && !w.config.tooltip.shared || w.config.tooltip.intersect && !w.config.tooltip.shared || w.config.chart.type === 'bar' && !w.config.tooltip.shared) {
        this.showOnIntersect = true;
      }

      if (w.config.markers.size === 0 || w.globals.markers.largestSize === 0) {
        // when user don't want to show points all the time, but only on when hovering on series
        this.marker.drawDynamicPoints(this);
      } // no visible series, exit


      if (w.globals.collapsedSeries.length === w.globals.series.length) return;
      this.dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;
      this.dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;

      if (this.showTooltipTitle) {
        this.tooltipTitle = document.createElement('div');
        this.tooltipTitle.classList.add('apexcharts-tooltip-title');
        this.tooltipTitle.style.fontFamily = w.config.tooltip.style.fontFamily || w.config.chart.fontFamily;
        this.tooltipTitle.style.fontSize = w.config.tooltip.style.fontSize;
        tooltipEl.appendChild(this.tooltipTitle);
      }

      var ttItemsCnt = w.globals.series.length; // whether shared or not, default is shared

      if ((w.globals.xyCharts || w.globals.comboCharts) && w.config.tooltip.shared) {
        if (!this.showOnIntersect) {
          ttItemsCnt = w.globals.series.length;
        } else {
          ttItemsCnt = 1;
        }
      }

      this.ttItems = this.createTTElements(ttItemsCnt);
      this.addSVGEvents();
    }
  }, {
    key: "createTTElements",
    value: function createTTElements(ttItemsCnt) {
      var w = this.w;
      var ttItems = [];
      var tooltipEl = this.getElTooltip();

      for (var i = 0; i < ttItemsCnt; i++) {
        var gTxt = document.createElement('div');
        gTxt.classList.add('apexcharts-tooltip-series-group');
        var point = document.createElement('span');
        point.classList.add('apexcharts-tooltip-marker');
        point.style.backgroundColor = w.globals.colors[i];
        gTxt.appendChild(point);
        var gYZ = document.createElement('div');
        gYZ.classList.add('apexcharts-tooltip-text');
        gYZ.style.fontFamily = w.config.tooltip.style.fontFamily || w.config.chart.fontFamily;
        gYZ.style.fontSize = w.config.tooltip.style.fontSize; // y values group

        var gYValText = document.createElement('div');
        gYValText.classList.add('apexcharts-tooltip-y-group');
        var txtLabel = document.createElement('span');
        txtLabel.classList.add('apexcharts-tooltip-text-label');
        gYValText.appendChild(txtLabel);
        var txtValue = document.createElement('span');
        txtValue.classList.add('apexcharts-tooltip-text-value');
        gYValText.appendChild(txtValue); // z values group

        var gZValText = document.createElement('div');
        gZValText.classList.add('apexcharts-tooltip-z-group');
        var txtZLabel = document.createElement('span');
        txtZLabel.classList.add('apexcharts-tooltip-text-z-label');
        gZValText.appendChild(txtZLabel);
        var txtZValue = document.createElement('span');
        txtZValue.classList.add('apexcharts-tooltip-text-z-value');
        gZValText.appendChild(txtZValue);
        gYZ.appendChild(gYValText);
        gYZ.appendChild(gZValText);
        gTxt.appendChild(gYZ);
        tooltipEl.appendChild(gTxt);
        ttItems.push(gTxt);
      }

      return ttItems;
    }
  }, {
    key: "addSVGEvents",
    value: function addSVGEvents() {
      var w = this.w;
      var type = w.config.chart.type;
      var tooltipEl = this.getElTooltip();
      var barOrCandlestick = !!(type === 'bar' || type === 'candlestick');
      var hoverArea = w.globals.dom.Paper.node;
      var elGrid = this.getElGrid();

      if (elGrid) {
        this.seriesBound = elGrid.getBoundingClientRect();
      }

      var tooltipY = [];
      var tooltipX = [];
      var seriesHoverParams = {
        hoverArea: hoverArea,
        elGrid: elGrid,
        tooltipEl: tooltipEl,
        tooltipY: tooltipY,
        tooltipX: tooltipX,
        ttItems: this.ttItems
      };
      var points;

      if (w.globals.axisCharts) {
        if (type === 'area' || type === 'line' || type === 'scatter' || type === 'bubble') {
          points = w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker");
        } else if (barOrCandlestick) {
          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-bar-area', '.apexcharts-series .apexcharts-candlestick-area');
        } else if (type === 'heatmap') {
          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-heatmap');
        } else if (type === 'radar') {
          points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-marker');
        }

        if (points && points.length) {
          for (var p = 0; p < points.length; p++) {
            tooltipY.push(points[p].getAttribute('cy'));
            tooltipX.push(points[p].getAttribute('cx'));
          }
        }
      }

      var validSharedChartTypes = w.globals.xyCharts && !this.showOnIntersect || w.globals.comboCharts && !this.showOnIntersect || barOrCandlestick && this.hasBars() && w.config.tooltip.shared;

      if (validSharedChartTypes) {
        this.addPathsEventListeners([hoverArea], seriesHoverParams);
      } else if (barOrCandlestick && !w.globals.comboCharts) {
        this.addBarsEventListeners(seriesHoverParams);
      } else if (type === 'bubble' || type === 'scatter' || type === 'radar' || this.showOnIntersect && (type === 'area' || type === 'line')) {
        this.addPointsEventsListeners(seriesHoverParams);
      } else if (!w.globals.axisCharts || type === 'heatmap') {
        var seriesAll = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');
        this.addPathsEventListeners(seriesAll, seriesHoverParams);
      }

      if (this.showOnIntersect) {
        var linePoints = w.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-marker');

        if (linePoints.length > 0) {
          // if we find any lineSeries, addEventListeners for them
          this.addPathsEventListeners(linePoints, seriesHoverParams);
        }

        var areaPoints = w.globals.dom.baseEl.querySelectorAll('.apexcharts-area-series .apexcharts-marker');

        if (areaPoints.length > 0) {
          // if we find any areaSeries, addEventListeners for them
          this.addPathsEventListeners(areaPoints, seriesHoverParams);
        } // combo charts may have bars, so add event listeners here too


        if (this.hasBars() && !w.config.tooltip.shared) {
          this.addBarsEventListeners(seriesHoverParams);
        }
      }
    }
  }, {
    key: "drawFixedTooltipRect",
    value: function drawFixedTooltipRect() {
      var w = this.w;
      var tooltipEl = this.getElTooltip();
      var tooltipRect = tooltipEl.getBoundingClientRect();
      var ttWidth = tooltipRect.width + 10;
      var ttHeight = tooltipRect.height + 10;
      var x = w.config.tooltip.fixed.offsetX;
      var y = w.config.tooltip.fixed.offsetY;

      if (w.config.tooltip.fixed.position.toLowerCase().indexOf('right') > -1) {
        x = x + w.globals.svgWidth - ttWidth + 10;
      }

      if (w.config.tooltip.fixed.position.toLowerCase().indexOf('bottom') > -1) {
        y = y + w.globals.svgHeight - ttHeight - 10;
      }

      tooltipEl.style.left = x + 'px';
      tooltipEl.style.top = y + 'px';
      return {
        x: x,
        y: y,
        ttWidth: ttWidth,
        ttHeight: ttHeight
      };
    }
  }, {
    key: "addPointsEventsListeners",
    value: function addPointsEventsListeners(seriesHoverParams) {
      var w = this.w;
      var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker');
      this.addPathsEventListeners(points, seriesHoverParams);
    }
  }, {
    key: "addBarsEventListeners",
    value: function addBarsEventListeners(seriesHoverParams) {
      var w = this.w;
      var bars = w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-area, .apexcharts-candlestick-area');
      this.addPathsEventListeners(bars, seriesHoverParams);
    }
  }, {
    key: "addPathsEventListeners",
    value: function addPathsEventListeners(paths, opts) {
      var _this = this;

      var self = this;

      var _loop = function _loop(p) {
        var extendedOpts = {
          paths: paths[p],
          tooltipEl: opts.tooltipEl,
          tooltipY: opts.tooltipY,
          tooltipX: opts.tooltipX,
          elGrid: opts.elGrid,
          hoverArea: opts.hoverArea,
          ttItems: opts.ttItems
        };
        _this.w.globals.tooltipOpts = extendedOpts;
        var events = ['mousemove', 'touchmove', 'mouseout', 'touchend'];
        events.map(function (ev) {
          return paths[p].addEventListener(ev, self.seriesHover.bind(self, extendedOpts), {
            capture: false,
            passive: true
          });
        });
      };

      for (var p = 0; p < paths.length; p++) {
        _loop(p);
      }
    }
    /*
     ** The actual series hover function
     */

  }, {
    key: "seriesHover",
    value: function seriesHover(opt, e) {
      var _this2 = this;

      var chartGroups = [];
      var w = this.w; // if user has more than one charts in group, we need to sync

      if (w.config.chart.group) {
        chartGroups = this.ctx.getGroupedCharts();
      }

      if (w.globals.axisCharts && (w.globals.minX === -Infinity && w.globals.maxX === Infinity || w.globals.dataPoints === 0)) {
        return;
      }

      if (chartGroups.length) {
        chartGroups.forEach(function (ch) {
          var tooltipEl = _this2.getElTooltip(ch);

          var newOpts = {
            paths: opt.paths,
            tooltipEl: tooltipEl,
            tooltipY: opt.tooltipY,
            tooltipX: opt.tooltipX,
            elGrid: opt.elGrid,
            hoverArea: opt.hoverArea,
            ttItems: ch.w.globals.tooltip.ttItems // all the charts should have the same minX and maxX (same xaxis) for multiple tooltips to work correctly

          };

          if (ch.w.globals.minX === _this2.w.globals.minX && ch.w.globals.maxX === _this2.w.globals.maxX) {
            ch.w.globals.tooltip.seriesHoverByContext({
              chartCtx: ch,
              ttCtx: ch.w.globals.tooltip,
              opt: newOpts,
              e: e
            });
          }
        });
      } else {
        this.seriesHoverByContext({
          chartCtx: this.ctx,
          ttCtx: this.w.globals.tooltip,
          opt: opt,
          e: e
        });
      }
    }
  }, {
    key: "seriesHoverByContext",
    value: function seriesHoverByContext(_ref) {
      var chartCtx = _ref.chartCtx,
          ttCtx = _ref.ttCtx,
          opt = _ref.opt,
          e = _ref.e;
      var w = chartCtx.w;
      var tooltipEl = this.getElTooltip(); // tooltipRect is calculated on every mousemove, because the text is dynamic

      ttCtx.tooltipRect = {
        x: 0,
        y: 0,
        ttWidth: tooltipEl.getBoundingClientRect().width,
        ttHeight: tooltipEl.getBoundingClientRect().height
      };
      ttCtx.e = e; // highlight the current hovered bars

      if (ttCtx.hasBars() && !w.globals.comboCharts && !ttCtx.isBarShared) {
        if (w.config.tooltip.onDatasetHover.highlightDataSeries) {
          var series = new Series(chartCtx);
          series.toggleSeriesOnHover(e, e.target.parentNode);
        }
      }

      if (ttCtx.fixedTooltip) {
        ttCtx.drawFixedTooltipRect();
      }

      if (w.globals.axisCharts) {
        ttCtx.axisChartsTooltips({
          e: e,
          opt: opt,
          tooltipRect: ttCtx.tooltipRect
        });
      } else {
        // non-plot charts i.e pie/donut/circle
        ttCtx.nonAxisChartsTooltips({
          e: e,
          opt: opt,
          tooltipRect: ttCtx.tooltipRect
        });
      }
    } // tooltip handling for line/area/bar/columns/scatter

  }, {
    key: "axisChartsTooltips",
    value: function axisChartsTooltips(_ref2) {
      var e = _ref2.e,
          opt = _ref2.opt;
      var w = this.w;
      var j, x, y;
      var self = this;
      var capj = null;
      var seriesBound = opt.elGrid.getBoundingClientRect();
      var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
      var clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
      this.clientY = clientY;
      this.clientX = clientX;

      if (clientY < seriesBound.top || clientY > seriesBound.top + seriesBound.height) {
        self.handleMouseOut(opt);
        return;
      }

      var tooltipEl = this.getElTooltip();
      var xcrosshairs = this.getElXCrosshairs();
      var isStickyTooltip = w.globals.xyCharts || w.config.chart.type === 'bar' && !this.isBarHorizontal && this.hasBars() && w.config.tooltip.shared || w.globals.comboCharts && this.hasBars;

      if (w.config.chart.type === 'bar' && this.isBarHorizontal && this.hasBars()) {
        isStickyTooltip = false;
      }

      if (e.type === 'mousemove' || e.type === 'touchmove') {
        if (xcrosshairs !== null) {
          xcrosshairs.classList.add('active');
        }

        if (self.ycrosshairs !== null && self.blyaxisTooltip) {
          self.ycrosshairs.classList.add('active');
        }

        if (isStickyTooltip && !self.showOnIntersect) {
          capj = self.tooltipUtil.getNearestValues({
            context: self,
            hoverArea: opt.hoverArea,
            elGrid: opt.elGrid,
            clientX: clientX,
            clientY: clientY,
            hasBars: self.hasBars
          });
          j = capj.j;
          var capturedSeries = capj.capturedSeries;

          if (capj.hoverX < 0 || capj.hoverX > w.globals.gridWidth) {
            self.handleMouseOut(opt);
            return;
          }

          if (capturedSeries !== null) {
            var ignoreNull = w.globals.series[capturedSeries][j] === null;

            if (ignoreNull) {
              opt.tooltipEl.classList.remove('active');
              return;
            }

            if (typeof w.globals.series[capturedSeries][j] !== 'undefined') {
              if (w.config.tooltip.shared && this.tooltipUtil.isXoverlap(j) && this.tooltipUtil.isinitialSeriesSameLen()) {
                this.create(self, capturedSeries, j, opt.ttItems);
              } else {
                this.create(self, capturedSeries, j, opt.ttItems, false);
              }
            } else {
              if (this.tooltipUtil.isXoverlap(j)) {
                self.create(self, 0, j, opt.ttItems);
              }
            }
          } else {
            // couldn't capture any series. check if shared X is same,
            // if yes, draw a grouped tooltip
            if (this.tooltipUtil.isXoverlap(j)) {
              self.create(self, 0, j, opt.ttItems);
            }
          }
        } else {
          if (w.config.chart.type === 'heatmap') {
            var markerXY = this.intersect.handleHeatTooltip({
              e: e,
              opt: opt,
              x: x,
              y: y
            });
            x = markerXY.x;
            y = markerXY.y;
            tooltipEl.style.left = x + 'px';
            tooltipEl.style.top = y + 'px';
          } else {
            if (this.hasBars) {
              this.intersect.handleBarTooltip({
                e: e,
                opt: opt
              });
            }

            if (this.hasMarkers) {
              // intersect - line/area/scatter/bubble
              this.intersect.handleMarkerTooltip({
                e: e,
                opt: opt,
                x: x,
                y: y
              });
            }
          }
        }

        if (this.blyaxisTooltip) {
          for (var yt = 0; yt < w.config.yaxis.length; yt++) {
            self.axesTooltip.drawYaxisTooltipText(yt, clientY, self.xyRatios);
          }
        }

        opt.tooltipEl.classList.add('active');
      } else if (e.type === 'mouseout' || e.type === 'touchend') {
        this.handleMouseOut(opt);
      }
    } // tooltip handling for pie/donuts

  }, {
    key: "nonAxisChartsTooltips",
    value: function nonAxisChartsTooltips(_ref3) {
      var e = _ref3.e,
          opt = _ref3.opt,
          tooltipRect = _ref3.tooltipRect;
      var w = this.w;
      var rel = opt.paths.getAttribute('rel');
      var tooltipEl = this.getElTooltip();
      var trX = 0;
      var trY = 0;
      var elPie = null;
      var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;

      if (w.config.chart.type === 'radialBar') {
        elPie = w.globals.dom.baseEl.querySelector('.apexcharts-radialbar');
      } else {
        elPie = w.globals.dom.baseEl.querySelector('.apexcharts-pie');
        trX = parseInt(elPie.getAttribute('data:innerTranslateX'));
        trY = parseInt(elPie.getAttribute('data:innerTranslateY'));
      }

      var seriesBound = elPie.getBoundingClientRect();

      if (e.type === 'mousemove' || e.type === 'touchmove') {
        tooltipEl.classList.add('active');
        this.tooltipLabels.drawSeriesTexts({
          ttItems: opt.ttItems,
          i: parseInt(rel) - 1,
          shared: false
        });
        var x = clientX - seriesBound.left - tooltipRect.ttWidth / 2.2 + trX;
        var y = e.clientY - seriesBound.top - tooltipRect.ttHeight / 2 - 15 + trY;

        if (x < 0) {
          x = 0;
        } else if (x + tooltipRect.ttWidth > w.globals.gridWidth) {
          x = clientX - seriesBound.left - tooltipRect.ttWidth + trX;
        }

        if (y < 0) y = tooltipRect.ttHeight + 20;
        tooltipEl.style.left = x + w.globals.translateX + 'px';
        tooltipEl.style.top = y + 'px';
      } else if (e.type === 'mouseout' || e.type === 'touchend') {
        tooltipEl.classList.remove('active');
      }
    }
  }, {
    key: "deactivateHoverFilter",
    value: function deactivateHoverFilter() {
      var w = this.w;
      var graphics = new Graphics(this.ctx);
      var allPaths = w.globals.dom.Paper.select(".apexcharts-bar-area");

      for (var b = 0; b < allPaths.length; b++) {
        graphics.pathMouseLeave(allPaths[b]);
      }
    }
  }, {
    key: "handleMouseOut",
    value: function handleMouseOut(opt) {
      var w = this.w;
      var xcrosshairs = this.getElXCrosshairs();
      opt.tooltipEl.classList.remove('active');
      this.deactivateHoverFilter();

      if (w.config.chart.type !== 'bubble') {
        this.marker.resetPointsSize();
      }

      if (xcrosshairs !== null) {
        xcrosshairs.classList.remove('active');
      }

      if (this.ycrosshairs !== null) {
        this.ycrosshairs.classList.remove('active');
      }

      if (this.blxaxisTooltip) {
        this.xaxisTooltip.classList.remove('active');
      }

      if (this.blyaxisTooltip) {
        if (this.yaxisTTEls === null) {
          this.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');
        }

        for (var i = 0; i < this.yaxisTTEls.length; i++) {
          this.yaxisTTEls[i].classList.remove('active');
        }
      }
    }
  }, {
    key: "getElMarkers",
    value: function getElMarkers() {
      return this.w.globals.dom.baseEl.querySelectorAll(' .apexcharts-series-markers');
    }
  }, {
    key: "getAllMarkers",
    value: function getAllMarkers() {
      return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker');
    }
  }, {
    key: "hasMarkers",
    value: function hasMarkers() {
      var markers = this.getElMarkers();
      return markers.length > 0;
    }
  }, {
    key: "getElBars",
    value: function getElBars() {
      return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series,  .apexcharts-candlestick-series');
    }
  }, {
    key: "hasBars",
    value: function hasBars() {
      var bars = this.getElBars();
      return bars.length > 0;
    }
  }, {
    key: "create",
    value: function create(context, capturedSeries, j, ttItems) {
      var shared = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var w = this.w;
      var self = context;
      if (shared === null) shared = w.config.tooltip.shared;
      var hasMarkers = this.hasMarkers();
      var bars = this.getElBars();

      if (shared) {
        self.tooltipLabels.drawSeriesTexts({
          ttItems: ttItems,
          i: capturedSeries,
          j: j,
          shared: this.showOnIntersect ? false : w.config.tooltip.shared
        });

        if (hasMarkers) {
          if (w.globals.markers.largestSize > 0) {
            self.marker.enlargePoints(j);
          } else {
            self.tooltipPosition.moveDynamicPointsOnHover(j);
          }
        }

        if (this.hasBars()) {
          this.barSeriesHeight = this.tooltipUtil.getBarsHeight(bars);

          if (this.barSeriesHeight > 0) {
            // hover state, activate snap filter
            var graphics = new Graphics(this.ctx);
            var paths = w.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(j, "']")); // de-activate first

            this.deactivateHoverFilter();
            this.tooltipPosition.moveStickyTooltipOverBars(j);

            for (var b = 0; b < paths.length; b++) {
              graphics.pathMouseEnter(paths[b]);
            }
          }
        }
      } else {
        self.tooltipLabels.drawSeriesTexts({
          shared: false,
          ttItems: ttItems,
          i: capturedSeries,
          j: j
        });

        if (this.hasBars()) {
          self.tooltipPosition.moveStickyTooltipOverBars(j);
        }

        if (hasMarkers) {
          self.tooltipPosition.moveMarkers(capturedSeries, j);
        }
      }
    }
  }]);

  return Tooltip;
}();

var icoPan = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\n    <defs>\n        <path d=\"M0 0h24v24H0z\" id=\"a\"/>\n    </defs>\n    <clipPath id=\"b\">\n        <use overflow=\"visible\" xlink:href=\"#a\"/>\n    </clipPath>\n    <path clip-path=\"url(#b)\" d=\"M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z\"/>\n</svg>";

var icoZoom = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\n    <path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"/>\n    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n    <path d=\"M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z\"/>\n</svg>";

var icoReset = "<svg fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z\"/>\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n</svg>";

var icoZoomIn = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n</svg>\n";

var icoZoomOut = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n</svg>\n";

var icoSelect = "<svg fill=\"#6E8192\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z\"/>\n</svg>";

var icoMenu = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path fill=\"none\" d=\"M0 0h24v24H0V0z\"/><path d=\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\"/></svg>";

/**
 * ApexCharts Toolbar Class for creating toolbar in axis based charts.
 *
 * @module Toolbar
 **/

var Toolbar =
/*#__PURE__*/
function () {
  function Toolbar(ctx) {
    _classCallCheck(this, Toolbar);

    this.ctx = ctx;
    this.w = ctx.w;
    this.ev = this.w.config.chart.events;
    this.localeValues = this.w.globals.locale.toolbar;
  }

  _createClass(Toolbar, [{
    key: "createToolbar",
    value: function createToolbar() {
      var w = this.w;
      var elToolbarWrap = document.createElement('div');
      elToolbarWrap.setAttribute('class', 'apexcharts-toolbar');
      w.globals.dom.elWrap.appendChild(elToolbarWrap);
      this.elZoom = document.createElement('div');
      this.elZoomIn = document.createElement('div');
      this.elZoomOut = document.createElement('div');
      this.elPan = document.createElement('div');
      this.elSelection = document.createElement('div');
      this.elZoomReset = document.createElement('div');
      this.elMenuIcon = document.createElement('div');
      this.elMenu = document.createElement('div');
      this.elCustomIcons = [];
      this.t = w.config.chart.toolbar.tools;

      if (Array.isArray(this.t.customIcons)) {
        for (var i = 0; i < this.t.customIcons.length; i++) {
          this.elCustomIcons.push(document.createElement('div'));
        }
      }

      this.elMenuItems = [];
      var toolbarControls = [];

      if (this.t.zoomin && w.config.chart.zoom.enabled) {
        toolbarControls.push({
          el: this.elZoomIn,
          icon: typeof this.t.zoomin === 'string' ? this.t.zoomin : icoZoomIn,
          title: this.localeValues.zoomIn,
          class: 'apexcharts-zoom-in-icon'
        });
      }

      if (this.t.zoomout && w.config.chart.zoom.enabled) {
        toolbarControls.push({
          el: this.elZoomOut,
          icon: typeof this.t.zoomout === 'string' ? this.t.zoomout : icoZoomOut,
          title: this.localeValues.zoomOut,
          class: 'apexcharts-zoom-out-icon'
        });
      }

      if (this.t.zoom && w.config.chart.zoom.enabled) {
        toolbarControls.push({
          el: this.elZoom,
          icon: typeof this.t.zoom === 'string' ? this.t.zoom : icoZoom,
          title: this.localeValues.selectionZoom,
          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-zoom-icon'
        });
      }

      if (this.t.selection && w.config.chart.selection.enabled) {
        toolbarControls.push({
          el: this.elSelection,
          icon: typeof this.t.selection === 'string' ? this.t.selection : icoSelect,
          title: this.localeValues.selection,
          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-selection-icon'
        });
      }

      if (this.t.pan && w.config.chart.zoom.enabled) {
        toolbarControls.push({
          el: this.elPan,
          icon: typeof this.t.pan === 'string' ? this.t.pan : icoPan,
          title: this.localeValues.pan,
          class: w.globals.isTouchDevice ? 'hidden' : 'apexcharts-pan-icon'
        });
      }

      if (this.t.reset && w.config.chart.zoom.enabled) {
        toolbarControls.push({
          el: this.elZoomReset,
          icon: typeof this.t.reset === 'string' ? this.t.reset : icoReset,
          title: this.localeValues.reset,
          class: 'apexcharts-reset-zoom-icon'
        });
      }

      if (this.t.download) {
        toolbarControls.push({
          el: this.elMenuIcon,
          icon: typeof this.t.download === 'string' ? this.t.download : icoMenu,
          title: this.localeValues.menu,
          class: 'apexcharts-menu-icon'
        });
      }

      for (var _i = 0; _i < this.elCustomIcons.length; _i++) {
        toolbarControls.push({
          el: this.elCustomIcons[_i],
          icon: this.t.customIcons[_i].icon,
          title: this.t.customIcons[_i].title,
          index: this.t.customIcons[_i].index,
          class: 'apexcharts-toolbar-custom-icon ' + this.t.customIcons[_i].class
        });
      }

      toolbarControls.forEach(function (t, index) {
        if (t.index) {
          Utils.moveIndexInArray(toolbarControls, index, t.index);
        }
      });

      for (var _i2 = 0; _i2 < toolbarControls.length; _i2++) {
        Graphics.setAttrs(toolbarControls[_i2].el, {
          class: toolbarControls[_i2].class,
          title: toolbarControls[_i2].title
        });
        toolbarControls[_i2].el.innerHTML = toolbarControls[_i2].icon;
        elToolbarWrap.appendChild(toolbarControls[_i2].el);
      }

      elToolbarWrap.appendChild(this.elMenu);
      Graphics.setAttrs(this.elMenu, {
        class: 'apexcharts-menu'
      });
      var menuItems = [{
        name: 'exportSVG',
        title: this.localeValues.exportToSVG
      }, {
        name: 'exportPNG',
        title: this.localeValues.exportToPNG
      }];

      for (var _i3 = 0; _i3 < menuItems.length; _i3++) {
        this.elMenuItems.push(document.createElement('div'));
        this.elMenuItems[_i3].innerHTML = menuItems[_i3].title;
        Graphics.setAttrs(this.elMenuItems[_i3], {
          class: "apexcharts-menu-item ".concat(menuItems[_i3].name),
          title: menuItems[_i3].title
        });
        this.elMenu.appendChild(this.elMenuItems[_i3]);
      }

      if (w.globals.zoomEnabled) {
        this.elZoom.classList.add('selected');
      } else if (w.globals.panEnabled) {
        this.elPan.classList.add('selected');
      } else if (w.globals.selectionEnabled) {
        this.elSelection.classList.add('selected');
      }

      this.addToolbarEventListeners();
    }
  }, {
    key: "addToolbarEventListeners",
    value: function addToolbarEventListeners() {
      var _this = this;

      this.elZoomReset.addEventListener('click', this.handleZoomReset.bind(this));
      this.elSelection.addEventListener('click', this.toggleSelection.bind(this));
      this.elZoom.addEventListener('click', this.toggleZooming.bind(this));
      this.elZoomIn.addEventListener('click', this.handleZoomIn.bind(this));
      this.elZoomOut.addEventListener('click', this.handleZoomOut.bind(this));
      this.elPan.addEventListener('click', this.togglePanning.bind(this));
      this.elMenuIcon.addEventListener('click', this.toggleMenu.bind(this));
      this.elMenuItems.forEach(function (m) {
        if (m.classList.contains('exportSVG')) {
          m.addEventListener('click', _this.downloadSVG.bind(_this));
        } else if (m.classList.contains('exportPNG')) {
          m.addEventListener('click', _this.downloadPNG.bind(_this));
        }
      });

      for (var i = 0; i < this.t.customIcons.length; i++) {
        this.elCustomIcons[i].addEventListener('click', this.t.customIcons[i].click);
      }
    }
  }, {
    key: "toggleSelection",
    value: function toggleSelection() {
      this.toggleOtherControls();
      this.w.globals.selectionEnabled = !this.w.globals.selectionEnabled;

      if (!this.elSelection.classList.contains('selected')) {
        this.elSelection.classList.add('selected');
      } else {
        this.elSelection.classList.remove('selected');
      }
    }
  }, {
    key: "toggleZooming",
    value: function toggleZooming() {
      this.toggleOtherControls();
      this.w.globals.zoomEnabled = !this.w.globals.zoomEnabled;

      if (!this.elZoom.classList.contains('selected')) {
        this.elZoom.classList.add('selected');
      } else {
        this.elZoom.classList.remove('selected');
      }
    }
  }, {
    key: "getToolbarIconsReference",
    value: function getToolbarIconsReference() {
      var w = this.w;

      if (!this.elZoom) {
        this.elZoom = w.globals.dom.baseEl.querySelector('.apexcharts-zoom-icon');
      }

      if (!this.elPan) {
        this.elPan = w.globals.dom.baseEl.querySelector('.apexcharts-pan-icon');
      }

      if (!this.elSelection) {
        this.elSelection = w.globals.dom.baseEl.querySelector('.apexcharts-selection-icon');
      }
    }
  }, {
    key: "enableZooming",
    value: function enableZooming() {
      this.toggleOtherControls();
      this.w.globals.zoomEnabled = true;

      if (this.elZoom) {
        this.elZoom.classList.add('selected');
      }

      if (this.elPan) {
        this.elPan.classList.remove('selected');
      }
    }
  }, {
    key: "enablePanning",
    value: function enablePanning() {
      this.toggleOtherControls();
      this.w.globals.panEnabled = true;

      if (this.elPan) {
        this.elPan.classList.add('selected');
      }

      if (this.elZoom) {
        this.elZoom.classList.remove('selected');
      }
    }
  }, {
    key: "togglePanning",
    value: function togglePanning() {
      this.toggleOtherControls();
      this.w.globals.panEnabled = !this.w.globals.panEnabled;

      if (!this.elPan.classList.contains('selected')) {
        this.elPan.classList.add('selected');
      } else {
        this.elPan.classList.remove('selected');
      }
    }
  }, {
    key: "toggleOtherControls",
    value: function toggleOtherControls() {
      var w = this.w;
      w.globals.panEnabled = false;
      w.globals.zoomEnabled = false;
      w.globals.selectionEnabled = false;
      this.getToolbarIconsReference();

      if (this.elPan) {
        this.elPan.classList.remove('selected');
      }

      if (this.elSelection) {
        this.elSelection.classList.remove('selected');
      }

      if (this.elZoom) {
        this.elZoom.classList.remove('selected');
      }
    }
  }, {
    key: "handleZoomIn",
    value: function handleZoomIn() {
      var w = this.w;
      var centerX = (w.globals.minX + w.globals.maxX) / 2;
      var newMinX = (w.globals.minX + centerX) / 2;
      var newMaxX = (w.globals.maxX + centerX) / 2;

      if (!w.globals.disableZoomIn) {
        this.zoomUpdateOptions(newMinX, newMaxX);
      }
    }
  }, {
    key: "handleZoomOut",
    value: function handleZoomOut() {
      var w = this.w; // avoid zooming out beyond 1000 which may result in NaN values being printed on x-axis

      if (w.config.xaxis.type === 'datetime' && new Date(w.globals.minX).getUTCFullYear() < 1000) {
        return;
      }

      var centerX = (w.globals.minX + w.globals.maxX) / 2;
      var newMinX = w.globals.minX - (centerX - w.globals.minX);
      var newMaxX = w.globals.maxX - (centerX - w.globals.maxX);

      if (!w.globals.disableZoomOut) {
        this.zoomUpdateOptions(newMinX, newMaxX);
      }
    }
  }, {
    key: "zoomUpdateOptions",
    value: function zoomUpdateOptions(newMinX, newMaxX) {
      var xaxis = {
        min: newMinX,
        max: newMaxX
      };
      var beforeZoomRange = this.getBeforeZoomRange(xaxis);

      if (beforeZoomRange) {
        xaxis = beforeZoomRange.xaxis;
      }

      this.w.globals.zoomed = true;

      this.ctx._updateOptions({
        xaxis: xaxis
      }, false, this.w.config.chart.animations.dynamicAnimation.enabled);

      this.zoomCallback(xaxis);
    }
  }, {
    key: "zoomCallback",
    value: function zoomCallback(xaxis, yaxis) {
      if (typeof this.ev.zoomed === 'function') {
        this.ev.zoomed(this.ctx, {
          xaxis: xaxis,
          yaxis: yaxis
        });
      }
    }
  }, {
    key: "getBeforeZoomRange",
    value: function getBeforeZoomRange(xaxis, yaxis) {
      var newRange = null;

      if (typeof this.ev.beforeZoom === 'function') {
        newRange = this.ev.beforeZoom(this, {
          xaxis: xaxis,
          yaxis: yaxis
        });
      }

      return newRange;
    }
  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      if (this.elMenu.classList.contains('open')) {
        this.elMenu.classList.remove('open');
      } else {
        this.elMenu.classList.add('open');
      }
    }
  }, {
    key: "downloadPNG",
    value: function downloadPNG() {
      var downloadPNG = new Exports(this.ctx);
      downloadPNG.exportToPng(this.ctx);
      this.toggleMenu();
    }
  }, {
    key: "downloadSVG",
    value: function downloadSVG() {
      var downloadSVG = new Exports(this.ctx);
      downloadSVG.exportToSVG();
      this.toggleMenu();
    }
  }, {
    key: "handleZoomReset",
    value: function handleZoomReset(e) {
      var _this2 = this;

      var charts = this.ctx.getSyncedCharts();
      charts.forEach(function (ch) {
        var w = ch.w;

        if (w.globals.minX !== w.globals.initialminX && w.globals.maxX !== w.globals.initialmaxX) {
          ch.revertDefaultAxisMinMax();

          if (typeof w.config.chart.events.zoomed === 'function') {
            _this2.zoomCallback({
              min: w.config.xaxis.min,
              max: w.config.xaxis.max
            });
          }

          w.globals.zoomed = false;

          ch._updateSeries(w.globals.initialSeries, w.config.chart.animations.dynamicAnimation.enabled);
        }
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.elZoomReset) {
        this.elZoomReset.removeEventListener('click', this.handleZoomReset.bind(this));
        this.elSelection.removeEventListener('click', this.toggleSelection.bind(this));
        this.elZoom.removeEventListener('click', this.toggleZooming.bind(this));
        this.elZoomIn.removeEventListener('click', this.handleZoomIn.bind(this));
        this.elZoomOut.removeEventListener('click', this.handleZoomOut.bind(this));
        this.elPan.removeEventListener('click', this.togglePanning.bind(this));
        this.elMenuIcon.removeEventListener('click', this.toggleMenu.bind(this));
      }

      this.elZoom = null;
      this.elZoomIn = null;
      this.elZoomOut = null;
      this.elPan = null;
      this.elSelection = null;
      this.elZoomReset = null;
      this.elMenuIcon = null;
    }
  }]);

  return Toolbar;
}();

/**
 * ApexCharts Zoom Class for handling zooming and panning on axes based charts.
 *
 * @module ZoomPanSelection
 **/

var ZoomPanSelection =
/*#__PURE__*/
function (_Toolbar) {
  _inherits(ZoomPanSelection, _Toolbar);

  function ZoomPanSelection(ctx) {
    var _this;

    _classCallCheck(this, ZoomPanSelection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZoomPanSelection).call(this, ctx));
    _this.ctx = ctx;
    _this.w = ctx.w;
    _this.dragged = false;
    _this.graphics = new Graphics(_this.ctx);
    _this.eventList = ['mousedown', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'];
    _this.clientX = 0;
    _this.clientY = 0;
    _this.startX = 0;
    _this.endX = 0;
    _this.dragX = 0;
    _this.startY = 0;
    _this.endY = 0;
    _this.dragY = 0;
    return _this;
  }

  _createClass(ZoomPanSelection, [{
    key: "init",
    value: function init(_ref) {
      var _this2 = this;

      var xyRatios = _ref.xyRatios;
      var w = this.w;
      var me = this;
      this.xyRatios = xyRatios;
      this.zoomRect = this.graphics.drawRect(0, 0, 0, 0);
      this.selectionRect = this.graphics.drawRect(0, 0, 0, 0);
      this.gridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid');
      this.zoomRect.node.classList.add('apexcharts-zoom-rect');
      this.selectionRect.node.classList.add('apexcharts-selection-rect');
      w.globals.dom.elGraphical.add(this.zoomRect);
      w.globals.dom.elGraphical.add(this.selectionRect);

      if (w.config.chart.selection.type === 'x') {
        this.slDraggableRect = this.selectionRect.draggable({
          minX: 0,
          minY: 0,
          maxX: w.globals.gridWidth,
          maxY: w.globals.gridHeight
        }).on('dragmove', this.selectionDragging.bind(this, 'dragging'));
      } else if (w.config.chart.selection.type === 'y') {
        this.slDraggableRect = this.selectionRect.draggable({
          minX: 0,
          maxX: w.globals.gridWidth
        }).on('dragmove', this.selectionDragging.bind(this, 'dragging'));
      } else {
        this.slDraggableRect = this.selectionRect.draggable().on('dragmove', this.selectionDragging.bind(this, 'dragging'));
      }

      this.preselectedSelection();
      this.hoverArea = w.globals.dom.baseEl.querySelector(w.globals.chartClass);
      this.hoverArea.classList.add('zoomable');
      this.eventList.forEach(function (event) {
        _this2.hoverArea.addEventListener(event, me.svgMouseEvents.bind(me, xyRatios), {
          capture: false,
          passive: true
        });
      });
    } // remove the event listeners which were previously added on hover area

  }, {
    key: "destroy",
    value: function destroy() {
      var _this3 = this;

      var me = this;
      this.eventList.forEach(function (event) {
        if (_this3.hoverArea) {
          _this3.hoverArea.removeEventListener(event, me.svgMouseEvents.bind(me, me.xyRatios), {
            capture: false,
            passive: true
          });
        }
      });

      if (this.slDraggableRect) {
        this.slDraggableRect.draggable(false);
        this.slDraggableRect.off();
        this.selectionRect.off();
      }

      this.selectionRect = null;
      this.zoomRect = null;
      this.gridRect = null;
    }
  }, {
    key: "svgMouseEvents",
    value: function svgMouseEvents(xyRatios, e) {
      var w = this.w;
      var me = this;
      var toolbar = this.ctx.toolbar;
      var zoomtype = w.globals.zoomEnabled ? w.config.chart.zoom.type : w.config.chart.selection.type;

      if (e.shiftKey) {
        this.shiftWasPressed = true;
        toolbar.enablePanning();
      } else {
        if (this.shiftWasPressed) {
          toolbar.enableZooming();
          this.shiftWasPressed = false;
        }
      }

      var falsePositives = e.target.classList.contains('apexcharts-selection-rect') || e.target.parentNode.classList.contains('apexcharts-toolbar');
      if (falsePositives) return;
      me.clientX = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientX : e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
      me.clientY = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientY : e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;

      if (e.type === 'mousedown' && e.which === 1) {
        var gridRectDim = me.gridRect.getBoundingClientRect();
        me.startX = me.clientX - gridRectDim.left;
        me.startY = me.clientY - gridRectDim.top;
        me.dragged = false;
        me.w.globals.mousedown = true;
      }

      if (e.type === 'mousemove' && e.which === 1 || e.type === 'touchmove') {
        me.dragged = true;

        if (w.globals.panEnabled) {
          w.globals.selection = null;

          if (me.w.globals.mousedown) {
            me.panDragging({
              context: me,
              zoomtype: zoomtype,
              xyRatios: xyRatios
            });
          }
        } else {
          if (me.w.globals.mousedown && w.globals.zoomEnabled || me.w.globals.mousedown && w.globals.selectionEnabled) {
            me.selection = me.selectionDrawing({
              context: me,
              zoomtype: zoomtype
            });
          }
        }
      }

      if (e.type === 'mouseup' || e.type === 'touchend') {
        // we will be calling getBoundingClientRect on each mousedown/mousemove/mouseup
        var _gridRectDim = me.gridRect.getBoundingClientRect();

        if (me.w.globals.mousedown) {
          // user released the drag, now do all the calculations
          me.endX = me.clientX - _gridRectDim.left;
          me.endY = me.clientY - _gridRectDim.top;
          me.dragX = Math.abs(me.endX - me.startX);
          me.dragY = Math.abs(me.endY - me.startY);

          if (w.globals.zoomEnabled || w.globals.selectionEnabled) {
            me.selectionDrawn({
              context: me,
              zoomtype: zoomtype
            });
          }
        }

        if (w.globals.zoomEnabled) {
          me.hideSelectionRect(this.selectionRect);
        }

        me.dragged = false;
        me.w.globals.mousedown = false;
      }

      this.makeSelectionRectDraggable();
    }
  }, {
    key: "makeSelectionRectDraggable",
    value: function makeSelectionRectDraggable() {
      var w = this.w;
      if (!this.selectionRect) return;
      var rectDim = this.selectionRect.node.getBoundingClientRect();

      if (rectDim.width > 0 && rectDim.height > 0) {
        this.slDraggableRect.selectize().resize({
          constraint: {
            minX: 0,
            minY: 0,
            maxX: w.globals.gridWidth,
            maxY: w.globals.gridHeight
          }
        }).on('resizing', this.selectionDragging.bind(this, 'resizing'));
      }
    }
  }, {
    key: "preselectedSelection",
    value: function preselectedSelection() {
      var w = this.w;
      var xyRatios = this.xyRatios;

      if (!w.globals.zoomEnabled) {
        if (typeof w.globals.selection !== 'undefined' && w.globals.selection !== null) {
          this.drawSelectionRect(w.globals.selection);
        } else {
          if (w.config.chart.selection.xaxis.min !== undefined && w.config.chart.selection.xaxis.max !== undefined) {
            var x = (w.config.chart.selection.xaxis.min - w.globals.minX) / xyRatios.xRatio;
            var width = w.globals.gridWidth - (w.globals.maxX - w.config.chart.selection.xaxis.max) / xyRatios.xRatio - x;
            var selectionRect = {
              x: x,
              y: 0,
              width: width,
              height: w.globals.gridHeight,
              translateX: 0,
              translateY: 0,
              selectionEnabled: true
            };
            this.drawSelectionRect(selectionRect);
            this.makeSelectionRectDraggable();

            if (typeof w.config.chart.events.selection === 'function') {
              w.config.chart.events.selection(this.ctx, {
                xaxis: {
                  min: w.config.chart.selection.xaxis.min,
                  max: w.config.chart.selection.xaxis.max
                },
                yaxis: {}
              });
            }
          }
        }
      }
    }
  }, {
    key: "drawSelectionRect",
    value: function drawSelectionRect(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          width = _ref2.width,
          height = _ref2.height,
          translateX = _ref2.translateX,
          translateY = _ref2.translateY;
      var w = this.w;
      var zoomRect = this.zoomRect;
      var selectionRect = this.selectionRect;

      if (this.dragged || w.globals.selection !== null) {
        var scalingAttrs = {
          transform: 'translate(' + translateX + ', ' + translateY + ')' // change styles based on zoom or selection
          // zoom is Enabled and user has dragged, so draw blue rect

        };

        if (w.globals.zoomEnabled && this.dragged) {
          zoomRect.attr({
            x: x,
            y: y,
            width: width,
            height: height,
            fill: w.config.chart.zoom.zoomedArea.fill.color,
            'fill-opacity': w.config.chart.zoom.zoomedArea.fill.opacity,
            stroke: w.config.chart.zoom.zoomedArea.stroke.color,
            'stroke-width': w.config.chart.zoom.zoomedArea.stroke.width,
            'stroke-opacity': w.config.chart.zoom.zoomedArea.stroke.opacity
          });
          Graphics.setAttrs(zoomRect.node, scalingAttrs);
        } // selection is enabled


        if (w.globals.selectionEnabled) {
          selectionRect.attr({
            x: x,
            y: y,
            width: width > 0 ? width : 0,
            height: height > 0 ? height : 0,
            fill: w.config.chart.selection.fill.color,
            'fill-opacity': w.config.chart.selection.fill.opacity,
            stroke: w.config.chart.selection.stroke.color,
            'stroke-width': w.config.chart.selection.stroke.width,
            'stroke-dasharray': w.config.chart.selection.stroke.dashArray,
            'stroke-opacity': w.config.chart.selection.stroke.opacity
          });
          Graphics.setAttrs(selectionRect.node, scalingAttrs);
        }
      }
    }
  }, {
    key: "hideSelectionRect",
    value: function hideSelectionRect(rect) {
      if (rect) {
        rect.attr({
          x: 0,
          y: 0,
          width: 0,
          height: 0
        });
      }
    }
  }, {
    key: "selectionDrawing",
    value: function selectionDrawing(_ref3) {
      var context = _ref3.context,
          zoomtype = _ref3.zoomtype;
      var w = this.w;
      var me = context;
      var gridRectDim = this.gridRect.getBoundingClientRect();
      var startX = me.startX - 1;
      var startY = me.startY;
      var selectionWidth = me.clientX - gridRectDim.left - startX;
      var selectionHeight = me.clientY - gridRectDim.top - startY;
      var translateX = 0;
      var translateY = 0;
      var selectionRect = {};

      if (Math.abs(selectionWidth + startX) > w.globals.gridWidth || me.clientX - gridRectDim.left < 0) {
        // user dragged the mouse outside drawing area
        // TODO: test the selectionRect and make sure it doesn't crosses drawing area
        me.hideSelectionRect(this.zoomRect);
        me.dragged = false;
        me.w.globals.mousedown = false;
      } // inverse selection X


      if (startX > me.clientX - gridRectDim.left) {
        selectionWidth = Math.abs(selectionWidth);
        translateX = -selectionWidth;
      } // inverse selection Y


      if (startY > me.clientY - gridRectDim.top) {
        selectionHeight = Math.abs(selectionHeight);
        translateY = -selectionHeight;
      }

      if (zoomtype === 'x') {
        selectionRect = {
          x: startX,
          y: 0,
          width: selectionWidth,
          height: w.globals.gridHeight,
          translateX: translateX,
          translateY: 0
        };
      } else if (zoomtype === 'y') {
        selectionRect = {
          x: 0,
          y: startY,
          width: w.globals.gridWidth,
          height: selectionHeight,
          translateX: 0,
          translateY: translateY
        };
      } else {
        selectionRect = {
          x: startX,
          y: startY,
          width: selectionWidth,
          height: selectionHeight,
          translateX: translateX,
          translateY: translateY
        };
      }

      me.drawSelectionRect(selectionRect);
      return selectionRect;
    }
  }, {
    key: "selectionDragging",
    value: function selectionDragging(type, e) {
      var _this4 = this;

      var w = this.w;
      var xyRatios = this.xyRatios;
      var selRect = this.selectionRect;
      var timerInterval = 0;

      if (type === 'resizing') {
        timerInterval = 30;
      }

      if (typeof w.config.chart.events.selection === 'function') {
        // a small debouncer is required when resizing to avoid freezing the chart
        clearTimeout(this.w.globals.selectionResizeTimer);
        this.w.globals.selectionResizeTimer = window.setTimeout(function () {
          var gridRectDim = _this4.gridRect.getBoundingClientRect();

          var selectionRect = selRect.node.getBoundingClientRect();
          var minX = w.globals.xAxisScale.niceMin + (selectionRect.left - gridRectDim.left) * xyRatios.xRatio;
          var maxX = w.globals.xAxisScale.niceMin + (selectionRect.right - gridRectDim.left) * xyRatios.xRatio;
          var minY = w.globals.yAxisScale[0].niceMin + (gridRectDim.bottom - selectionRect.bottom) * xyRatios.yRatio[0];
          var maxY = w.globals.yAxisScale[0].niceMax - (selectionRect.top - gridRectDim.top) * xyRatios.yRatio[0];
          w.config.chart.events.selection(_this4.ctx, {
            xaxis: {
              min: minX,
              max: maxX
            },
            yaxis: {
              min: minY,
              max: maxY
            }
          });
        }, timerInterval);
      }
    }
  }, {
    key: "selectionDrawn",
    value: function selectionDrawn(_ref4) {
      var context = _ref4.context,
          zoomtype = _ref4.zoomtype;
      var w = this.w;
      var me = context;
      var xyRatios = this.xyRatios;
      var toolbar = this.ctx.toolbar;

      if (me.startX > me.endX) {
        var tempX = me.startX;
        me.startX = me.endX;
        me.endX = tempX;
      }

      if (me.startY > me.endY) {
        var tempY = me.startY;
        me.startY = me.endY;
        me.endY = tempY;
      }

      var xLowestValue = w.globals.xAxisScale.niceMin + me.startX * xyRatios.xRatio;
      var xHighestValue = w.globals.xAxisScale.niceMin + me.endX * xyRatios.xRatio; // TODO: we will consider the 1st y axis values here for getting highest and lowest y

      var yHighestValue = [];
      var yLowestValue = [];
      w.config.yaxis.forEach(function (yaxe, index) {
        yHighestValue.push(Math.floor(w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[index] * me.startY));
        yLowestValue.push(Math.floor(w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[index] * me.endY));
      });

      if (me.dragged && (me.dragX > 10 || me.dragY > 10) && xLowestValue !== xHighestValue) {
        if (w.globals.zoomEnabled) {
          var yaxis = Utils.clone(w.config.yaxis); // before zooming in/out, store the last yaxis and xaxis range, so that when user hits the RESET button, we get the original range
          // also - make sure user is not already zoomed in/out - otherwise we will store zoomed values in lastAxis

          if (!w.globals.zoomed) {
            w.globals.lastXAxis = Utils.clone(w.config.xaxis);
            w.globals.lastYAxis = Utils.clone(w.config.yaxis);
          }

          var xaxis = {
            min: xLowestValue,
            max: xHighestValue
          };

          if (zoomtype === 'xy' || zoomtype === 'y') {
            yaxis.forEach(function (yaxe, index) {
              yaxis[index].min = yLowestValue[index];
              yaxis[index].max = yHighestValue[index];
            });
          }

          if (w.config.chart.zoom.autoScaleYaxis) {
            var scale = new Range(me.ctx);
            yaxis = scale.autoScaleY(me.ctx, {
              xaxis: xaxis
            });
          }

          if (toolbar) {
            var beforeZoomRange = toolbar.getBeforeZoomRange(xaxis, yaxis);

            if (beforeZoomRange) {
              xaxis = beforeZoomRange.xaxis ? beforeZoomRange.xaxis : xaxis;
              yaxis = beforeZoomRange.yaxis ? beforeZoomRange.yaxe : yaxis;
            }
          }

          if (zoomtype === 'x') {
            me.ctx._updateOptions({
              xaxis: xaxis
            }, false, me.w.config.chart.animations.dynamicAnimation.enabled);
          } else if (zoomtype === 'y') {
            me.ctx._updateOptions({
              yaxis: yaxis
            }, false, me.w.config.chart.animations.dynamicAnimation.enabled);
          } else {
            me.ctx._updateOptions({
              xaxis: xaxis,
              yaxis: yaxis
            }, false, me.w.config.chart.animations.dynamicAnimation.enabled);
          }

          if (typeof w.config.chart.events.zoomed === 'function') {
            toolbar.zoomCallback(xaxis, yaxis);
          }

          w.globals.zoomed = true;
        } else if (w.globals.selectionEnabled) {
          var _yaxis = null;
          var _xaxis = null;
          _xaxis = {
            min: xLowestValue,
            max: xHighestValue
          };

          if (zoomtype === 'xy' || zoomtype === 'y') {
            _yaxis = Utils.clone(w.config.yaxis);

            _yaxis.forEach(function (yaxe, index) {
              _yaxis[index].min = yLowestValue[index];
              _yaxis[index].max = yHighestValue[index];
            });
          }

          w.globals.selection = me.selection;

          if (typeof w.config.chart.events.selection === 'function') {
            w.config.chart.events.selection(me.ctx, {
              xaxis: _xaxis,
              yaxis: _yaxis
            });
          }
        }
      }
    }
  }, {
    key: "panDragging",
    value: function panDragging(_ref5) {
      var context = _ref5.context,
          zoomtype = _ref5.zoomtype;
      var w = this.w;
      var me = context;
      var moveDirection; // check to make sure there is data to compare against

      if (typeof w.globals.lastClientPosition.x !== 'undefined') {
        // get the change from last position to this position
        var deltaX = w.globals.lastClientPosition.x - me.clientX;
        var deltaY = w.globals.lastClientPosition.y - me.clientY; // check which direction had the highest amplitude and then figure out direction by checking if the value is greater or less than zero

        if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 0) {
          moveDirection = 'left';
        } else if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX < 0) {
          moveDirection = 'right';
        } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > 0) {
          moveDirection = 'up';
        } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY < 0) {
          moveDirection = 'down';
        }
      } // set the new last position to the current for next time (to get the position of drag)


      w.globals.lastClientPosition = {
        x: me.clientX,
        y: me.clientY
      };
      var xLowestValue = w.globals.minX;
      var xHighestValue = w.globals.maxX;
      this.panScrolled(moveDirection, xLowestValue, xHighestValue);
    }
  }, {
    key: "panScrolled",
    value: function panScrolled(moveDirection, xLowestValue, xHighestValue) {
      var w = this.w;
      var xyRatios = this.xyRatios;
      var yaxis = Utils.clone(w.config.yaxis);

      if (moveDirection === 'left') {
        xLowestValue = w.globals.minX + w.globals.gridWidth / 15 * xyRatios.xRatio;
        xHighestValue = w.globals.maxX + w.globals.gridWidth / 15 * xyRatios.xRatio;
      } else if (moveDirection === 'right') {
        xLowestValue = w.globals.minX - w.globals.gridWidth / 15 * xyRatios.xRatio;
        xHighestValue = w.globals.maxX - w.globals.gridWidth / 15 * xyRatios.xRatio;
      }

      if (xLowestValue < w.globals.initialminX || xHighestValue > w.globals.initialmaxX) {
        xLowestValue = w.globals.minX;
        xHighestValue = w.globals.maxX;
      }

      var xaxis = {
        min: xLowestValue,
        max: xHighestValue
      };

      if (w.config.chart.zoom.autoScaleYaxis) {
        var scale = new Range(me.ctx);
        yaxis = scale.autoScaleY(me.ctx, {
          xaxis: xaxis
        });
      }

      this.ctx._updateOptions({
        xaxis: {
          min: xLowestValue,
          max: xHighestValue
        },
        yaxis: yaxis
      }, false, false);

      if (typeof w.config.chart.events.scrolled === 'function') {
        w.config.chart.events.scrolled(this.ctx, {
          xaxis: {
            min: xLowestValue,
            max: xHighestValue
          }
        });
      }
    }
  }]);

  return ZoomPanSelection;
}(Toolbar);

var TitleSubtitle =
/*#__PURE__*/
function () {
  function TitleSubtitle(ctx) {
    _classCallCheck(this, TitleSubtitle);

    this.ctx = ctx;
    this.w = ctx.w;
  }

  _createClass(TitleSubtitle, [{
    key: "draw",
    value: function draw() {
      this.drawTitleSubtitle('title');
      this.drawTitleSubtitle('subtitle');
    }
  }, {
    key: "drawTitleSubtitle",
    value: function drawTitleSubtitle(type) {
      var w = this.w;
      var tsConfig = type === 'title' ? w.config.title : w.config.subtitle;
      var x = w.globals.svgWidth / 2;
      var y = tsConfig.offsetY;
      var textAnchor = 'middle';

      if (tsConfig.align === 'left') {
        x = 10;
        textAnchor = 'start';
      } else if (tsConfig.align === 'right') {
        x = w.globals.svgWidth - 10;
        textAnchor = 'end';
      }

      x = x + tsConfig.offsetX;
      y = y + parseInt(tsConfig.style.fontSize) + 2;

      if (tsConfig.text !== undefined) {
        var graphics = new Graphics(this.ctx);
        var titleText = graphics.drawText({
          x: x,
          y: y,
          text: tsConfig.text,
          textAnchor: textAnchor,
          fontSize: tsConfig.style.fontSize,
          fontFamily: tsConfig.style.fontFamily,
          foreColor: tsConfig.style.color,
          opacity: 1
        });
        titleText.node.setAttribute('class', "apexcharts-".concat(type, "-text"));
        w.globals.dom.Paper.add(titleText);
      }
    }
  }]);

  return TitleSubtitle;
}();

(function (root, factory) {
  /* istanbul ignore next */
  if (typeof define === 'function' && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) {
    define(function () {
      return factory(root, root.document);
    });
  } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
    module.exports = root.document ? factory(root, root.document) : function (w) {
      return factory(w, w.document);
    };
  } else {
    root.SVG = factory(root, root.document);
  }
})(typeof window !== 'undefined' ? window : undefined, function (window, document) {
  // Find global reference - uses 'this' by default when available,
  // falls back to 'window' otherwise (for bundlers like Webpack)
  var globalRef = typeof this !== 'undefined' ? this : window; // The main wrapping element

  var SVG = globalRef.SVG = function (element) {
    if (SVG.supported) {
      element = new SVG.Doc(element);

      if (!SVG.parser.draw) {
        SVG.prepare();
      }

      return element;
    }
  }; // Default namespaces


  SVG.ns = 'http://www.w3.org/2000/svg';
  SVG.xmlns = 'http://www.w3.org/2000/xmlns/';
  SVG.xlink = 'http://www.w3.org/1999/xlink';
  SVG.svgjs = 'http://svgjs.com/svgjs'; // Svg support test

  SVG.supported = function () {
    return true; // !!document.createElementNS &&
    //     !! document.createElementNS(SVG.ns,'svg').createSVGRect
  }(); // Don't bother to continue if SVG is not supported


  if (!SVG.supported) return false; // Element id sequence

  SVG.did = 1000; // Get next named element id

  SVG.eid = function (name) {
    return 'Svgjs' + capitalize(name) + SVG.did++;
  }; // Method for element creation


  SVG.create = function (name) {
    // create element
    var element = document.createElementNS(this.ns, name); // apply unique id

    element.setAttribute('id', this.eid(name));
    return element;
  }; // Method for extending objects


  SVG.extend = function () {
    var modules, methods, key, i; // Get list of modules

    modules = [].slice.call(arguments); // Get object with extensions

    methods = modules.pop();

    for (i = modules.length - 1; i >= 0; i--) {
      if (modules[i]) {
        for (key in methods) {
          modules[i].prototype[key] = methods[key];
        }
      }
    } // Make sure SVG.Set inherits any newly added methods


    if (SVG.Set && SVG.Set.inherit) {
      SVG.Set.inherit();
    }
  }; // Invent new element


  SVG.invent = function (config) {
    // Create element initializer
    var initializer = typeof config.create === 'function' ? config.create : function () {
      this.constructor.call(this, SVG.create(config.create));
    }; // Inherit prototype

    if (config.inherit) {
      initializer.prototype = new config.inherit();
    } // Extend with methods


    if (config.extend) {
      SVG.extend(initializer, config.extend);
    } // Attach construct method to parent


    if (config.construct) {
      SVG.extend(config.parent || SVG.Container, config.construct);
    }

    return initializer;
  }; // Adopt existing svg elements


  SVG.adopt = function (node) {
    // check for presence of node
    if (!node) return null; // make sure a node isn't already adopted

    if (node.instance) return node.instance; // initialize variables

    var element; // adopt with element-specific settings

    if (node.nodeName == 'svg') {
      element = node.parentNode instanceof window.SVGElement ? new SVG.Nested() : new SVG.Doc();
    } else if (node.nodeName == 'linearGradient') {
      element = new SVG.Gradient('linear');
    } else if (node.nodeName == 'radialGradient') {
      element = new SVG.Gradient('radial');
    } else if (SVG[capitalize(node.nodeName)]) {
      element = new SVG[capitalize(node.nodeName)]();
    } else {
      element = new SVG.Element(node);
    } // ensure references


    element.type = node.nodeName;
    element.node = node;
    node.instance = element; // SVG.Class specific preparations

    if (element instanceof SVG.Doc) {
      element.namespace().defs();
    } // pull svgjs data from the dom (getAttributeNS doesn't work in html5)


    element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});
    return element;
  }; // Initialize parsing element


  SVG.prepare = function () {
    // Select document body and create invisible svg element
    var body = document.getElementsByTagName('body')[0],
        draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0); // Create parser object

    SVG.parser = {
      body: body || document.documentElement,
      draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').node,
      poly: draw.polyline().node,
      path: draw.path().node,
      native: SVG.create('svg')
    };
  };

  SVG.parser = {
    native: SVG.create('svg')
  };
  document.addEventListener('DOMContentLoaded', function () {
    if (!SVG.parser.draw) {
      SVG.prepare();
    }
  }, false); // Storage for regular expressions

  SVG.regex = {
    // Parse unit value
    numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
    // Parse hex value
    hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
    // Parse rgb value
    rgb: /rgb\((\d+),(\d+),(\d+)\)/,
    // Parse reference id
    reference: /#([a-z0-9\-_]+)/i,
    // splits a transformation chain
    transforms: /\)\s*,?\s*/,
    // Whitespace
    whitespace: /\s/g,
    // Test hex value
    isHex: /^#[a-f0-9]{3,6}$/i,
    // Test rgb value
    isRgb: /^rgb\(/,
    // Test css declaration
    isCss: /[^:]+:[^;]+;?/,
    // Test for blank string
    isBlank: /^(\s+)?$/,
    // Test for numeric string
    isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    // Test for percent value
    isPercent: /^-?[\d\.]+%$/,
    // Test for image url
    isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
    // split at whitespace and comma
    delimiter: /[\s,]+/,
    // The following regex are used to parse the d attribute of a path
    // Matches all hyphens which are not after an exponent
    hyphen: /([^e])\-/gi,
    // Replaces and tests for all path letters
    pathLetters: /[MLHVCSQTAZ]/gi,
    // yes we need this one, too
    isPathLetter: /[MLHVCSQTAZ]/i,
    // matches 0.154.23.45
    numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
    // matches .
    dots: /\./g
  };
  SVG.utils = {
    // Map function
    map: function map(array, block) {
      var i,
          il = array.length,
          result = [];

      for (i = 0; i < il; i++) {
        result.push(block(array[i]));
      }

      return result;
    },
    // Filter function
    filter: function filter(array, block) {
      var i,
          il = array.length,
          result = [];

      for (i = 0; i < il; i++) {
        if (block(array[i])) {
          result.push(array[i]);
        }
      }

      return result;
    },
    // Degrees to radians
    radians: function radians(d) {
      return d % 360 * Math.PI / 180;
    },
    // Radians to degrees
    degrees: function degrees(r) {
      return r * 180 / Math.PI % 360;
    },
    filterSVGElements: function filterSVGElements(nodes) {
      return this.filter(nodes, function (el) {
        return el instanceof window.SVGElement;
      });
    }
  };
  SVG.defaults = {
    // Default attribute values
    attrs: {
      // fill and stroke
      'fill-opacity': 1,
      'stroke-opacity': 1,
      'stroke-width': 0,
      'stroke-linejoin': 'miter',
      'stroke-linecap': 'butt',
      fill: '#000000',
      stroke: '#000000',
      opacity: 1,
      // position
      x: 0,
      y: 0,
      cx: 0,
      cy: 0,
      // size
      width: 0,
      height: 0,
      // radius
      r: 0,
      rx: 0,
      ry: 0,
      // gradient
      offset: 0,
      'stop-opacity': 1,
      'stop-color': '#000000',
      // text
      'font-size': 16,
      'font-family': 'Helvetica, Arial, sans-serif',
      'text-anchor': 'start'
    } // Module for color convertions

  };

  SVG.Color = function (color) {
    var match; // initialize defaults

    this.r = 0;
    this.g = 0;
    this.b = 0;
    if (!color) return; // parse color

    if (typeof color === 'string') {
      if (SVG.regex.isRgb.test(color)) {
        // get rgb values
        match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace, '')); // parse numeric values

        this.r = parseInt(match[1]);
        this.g = parseInt(match[2]);
        this.b = parseInt(match[3]);
      } else if (SVG.regex.isHex.test(color)) {
        // get hex values
        match = SVG.regex.hex.exec(fullHex(color)); // parse numeric values

        this.r = parseInt(match[1], 16);
        this.g = parseInt(match[2], 16);
        this.b = parseInt(match[3], 16);
      }
    } else if (_typeof(color) === 'object') {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
    }
  };

  SVG.extend(SVG.Color, {
    // Default to hex conversion
    toString: function toString() {
      return this.toHex();
    },
    // Build hex value
    toHex: function toHex() {
      return '#' + compToHex(this.r) + compToHex(this.g) + compToHex(this.b);
    },
    // Build rgb value
    toRgb: function toRgb() {
      return 'rgb(' + [this.r, this.g, this.b].join() + ')';
    },
    // Calculate true brightness
    brightness: function brightness() {
      return this.r / 255 * 0.30 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
    },
    // Make color morphable
    morph: function morph(color) {
      this.destination = new SVG.Color(color);
      return this;
    },
    // Get morphed color at given position
    at: function at(pos) {
      // make sure a destination is defined
      if (!this.destination) return this; // normalise pos

      pos = pos < 0 ? 0 : pos > 1 ? 1 : pos; // generate morphed color

      return new SVG.Color({
        r: ~~(this.r + (this.destination.r - this.r) * pos),
        g: ~~(this.g + (this.destination.g - this.g) * pos),
        b: ~~(this.b + (this.destination.b - this.b) * pos)
      });
    }
  }); // Testers
  // Test if given value is a color string

  SVG.Color.test = function (color) {
    color += '';
    return SVG.regex.isHex.test(color) || SVG.regex.isRgb.test(color);
  }; // Test if given value is a rgb object


  SVG.Color.isRgb = function (color) {
    return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';
  }; // Test if given value is a color


  SVG.Color.isColor = function (color) {
    return SVG.Color.isRgb(color) || SVG.Color.test(color);
  }; // Module for array conversion


  SVG.Array = function (array, fallback) {
    array = (array || []).valueOf(); // if array is empty and fallback is provided, use fallback

    if (array.length == 0 && fallback) {
      array = fallback.valueOf();
    } // parse array


    this.value = this.parse(array);
  };

  SVG.extend(SVG.Array, {
    // Make array morphable
    morph: function morph(array) {
      this.destination = this.parse(array); // normalize length of arrays

      if (this.value.length != this.destination.length) {
        var lastValue = this.value[this.value.length - 1],
            lastDestination = this.destination[this.destination.length - 1];

        while (this.value.length > this.destination.length) {
          this.destination.push(lastDestination);
        }

        while (this.value.length < this.destination.length) {
          this.value.push(lastValue);
        }
      }

      return this;
    },
    // Clean up any duplicate points
    settle: function settle() {
      // find all unique values
      for (var i = 0, il = this.value.length, seen = []; i < il; i++) {
        if (seen.indexOf(this.value[i]) == -1) {
          seen.push(this.value[i]);
        }
      } // set new value


      return this.value = seen;
    },
    // Get morphed array at given position
    at: function at(pos) {
      // make sure a destination is defined
      if (!this.destination) return this; // generate morphed array

      for (var i = 0, il = this.value.length, array = []; i < il; i++) {
        array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos);
      }

      return new SVG.Array(array);
    },
    // Convert array to string
    toString: function toString() {
      return this.value.join(' ');
    },
    // Real value
    valueOf: function valueOf() {
      return this.value;
    },
    // Parse whitespace separated string
    parse: function parse(array) {
      array = array.valueOf(); // if already is an array, no need to parse it

      if (Array.isArray(array)) return array;
      return this.split(array);
    },
    // Strip unnecessary whitespace
    split: function split(string) {
      return string.trim().split(SVG.regex.delimiter).map(parseFloat);
    },
    // Reverse array
    reverse: function reverse() {
      this.value.reverse();
      return this;
    },
    clone: function clone() {
      var clone = new this.constructor();
      clone.value = array_clone(this.value);
      return clone;
    }
  }); // Poly points array

  SVG.PointArray = function (array, fallback) {
    SVG.Array.call(this, array, fallback || [[0, 0]]);
  }; // Inherit from SVG.Array


  SVG.PointArray.prototype = new SVG.Array();
  SVG.PointArray.prototype.constructor = SVG.PointArray;
  SVG.extend(SVG.PointArray, {
    // Convert array to string
    toString: function toString() {
      // convert to a poly point string
      for (var i = 0, il = this.value.length, array = []; i < il; i++) {
        array.push(this.value[i].join(','));
      }

      return array.join(' ');
    },
    // Convert array to line object
    toLine: function toLine() {
      return {
        x1: this.value[0][0],
        y1: this.value[0][1],
        x2: this.value[1][0],
        y2: this.value[1][1]
      };
    },
    // Get morphed array at given position
    at: function at(pos) {
      // make sure a destination is defined
      if (!this.destination) return this; // generate morphed point string

      for (var i = 0, il = this.value.length, array = []; i < il; i++) {
        array.push([this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos, this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos]);
      }

      return new SVG.PointArray(array);
    },
    // Parse point string and flat array
    parse: function parse(array) {
      var points = [];
      array = array.valueOf(); // if it is an array

      if (Array.isArray(array)) {
        // and it is not flat, there is no need to parse it
        if (Array.isArray(array[0])) {
          // make sure to use a clone
          return array.map(function (el) {
            return el.slice();
          });
        } else if (array[0].x != null) {
          // allow point objects to be passed
          return array.map(function (el) {
            return [el.x, el.y];
          });
        }
      } else {
        // Else, it is considered as a string
        // parse points
        array = array.trim().split(SVG.regex.delimiter).map(parseFloat);
      } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
      // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.


      if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples and parse points as floats

      for (var i = 0, len = array.length; i < len; i = i + 2) {
        points.push([array[i], array[i + 1]]);
      }

      return points;
    },
    // Move point string
    move: function move(x, y) {
      var box = this.bbox(); // get relative offset

      x -= box.x;
      y -= box.y; // move every point

      if (!isNaN(x) && !isNaN(y)) {
        for (var i = this.value.length - 1; i >= 0; i--) {
          this.value[i] = [this.value[i][0] + x, this.value[i][1] + y];
        }
      }

      return this;
    },
    // Resize poly string
    size: function size(width, height) {
      var i,
          box = this.bbox(); // recalculate position of all points according to new size

      for (i = this.value.length - 1; i >= 0; i--) {
        if (box.width) this.value[i][0] = (this.value[i][0] - box.x) * width / box.width + box.x;
        if (box.height) this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;
      }

      return this;
    },
    // Get bounding box of points
    bbox: function bbox() {
      if (!SVG.parser.draw) {
        SVG.prepare();
      }

      SVG.parser.poly.setAttribute('points', this.toString());
      return SVG.parser.poly.getBBox();
    }
  });
  var pathHandlers = {
    M: function M(c, p, p0) {
      p.x = p0.x = c[0];
      p.y = p0.y = c[1];
      return ['M', p.x, p.y];
    },
    L: function L(c, p) {
      p.x = c[0];
      p.y = c[1];
      return ['L', c[0], c[1]];
    },
    H: function H(c, p) {
      p.x = c[0];
      return ['H', c[0]];
    },
    V: function V(c, p) {
      p.y = c[0];
      return ['V', c[0]];
    },
    C: function C(c, p) {
      p.x = c[4];
      p.y = c[5];
      return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];
    },
    S: function S(c, p) {
      p.x = c[2];
      p.y = c[3];
      return ['S', c[0], c[1], c[2], c[3]];
    },
    Q: function Q(c, p) {
      p.x = c[2];
      p.y = c[3];
      return ['Q', c[0], c[1], c[2], c[3]];
    },
    T: function T(c, p) {
      p.x = c[0];
      p.y = c[1];
      return ['T', c[0], c[1]];
    },
    Z: function Z(c, p, p0) {
      p.x = p0.x;
      p.y = p0.y;
      return ['Z'];
    },
    A: function A(c, p) {
      p.x = c[5];
      p.y = c[6];
      return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];
    }
  };
  var mlhvqtcsa = 'mlhvqtcsaz'.split('');

  for (var i = 0, il = mlhvqtcsa.length; i < il; ++i) {
    pathHandlers[mlhvqtcsa[i]] = function (i) {
      return function (c, p, p0) {
        if (i == 'H') c[0] = c[0] + p.x;else if (i == 'V') c[0] = c[0] + p.y;else if (i == 'A') {
          c[5] = c[5] + p.x, c[6] = c[6] + p.y;
        } else {
          for (var j = 0, jl = c.length; j < jl; ++j) {
            c[j] = c[j] + (j % 2 ? p.y : p.x);
          }
        }
        return pathHandlers[i](c, p, p0);
      };
    }(mlhvqtcsa[i].toUpperCase());
  } // Path points array


  SVG.PathArray = function (array, fallback) {
    SVG.Array.call(this, array, fallback || [['M', 0, 0]]);
  }; // Inherit from SVG.Array


  SVG.PathArray.prototype = new SVG.Array();
  SVG.PathArray.prototype.constructor = SVG.PathArray;
  SVG.extend(SVG.PathArray, {
    // Convert array to string
    toString: function toString() {
      return arrayToString(this.value);
    },
    // Move path string
    move: function move(x, y) {
      // get bounding box of current situation
      var box = this.bbox(); // get relative offset

      x -= box.x;
      y -= box.y;

      if (!isNaN(x) && !isNaN(y)) {
        // move every point
        for (var l, i = this.value.length - 1; i >= 0; i--) {
          l = this.value[i][0];

          if (l == 'M' || l == 'L' || l == 'T') {
            this.value[i][1] += x;
            this.value[i][2] += y;
          } else if (l == 'H') {
            this.value[i][1] += x;
          } else if (l == 'V') {
            this.value[i][1] += y;
          } else if (l == 'C' || l == 'S' || l == 'Q') {
            this.value[i][1] += x;
            this.value[i][2] += y;
            this.value[i][3] += x;
            this.value[i][4] += y;

            if (l == 'C') {
              this.value[i][5] += x;
              this.value[i][6] += y;
            }
          } else if (l == 'A') {
            this.value[i][6] += x;
            this.value[i][7] += y;
          }
        }
      }

      return this;
    },
    // Resize path string
    size: function size(width, height) {
      // get bounding box of current situation
      var i,
          l,
          box = this.bbox(); // recalculate position of all points according to new size

      for (i = this.value.length - 1; i >= 0; i--) {
        l = this.value[i][0];

        if (l == 'M' || l == 'L' || l == 'T') {
          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;
          this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y;
        } else if (l == 'H') {
          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;
        } else if (l == 'V') {
          this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;
        } else if (l == 'C' || l == 'S' || l == 'Q') {
          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;
          this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y;
          this.value[i][3] = (this.value[i][3] - box.x) * width / box.width + box.x;
          this.value[i][4] = (this.value[i][4] - box.y) * height / box.height + box.y;

          if (l == 'C') {
            this.value[i][5] = (this.value[i][5] - box.x) * width / box.width + box.x;
            this.value[i][6] = (this.value[i][6] - box.y) * height / box.height + box.y;
          }
        } else if (l == 'A') {
          // resize radii
          this.value[i][1] = this.value[i][1] * width / box.width;
          this.value[i][2] = this.value[i][2] * height / box.height; // move position values

          this.value[i][6] = (this.value[i][6] - box.x) * width / box.width + box.x;
          this.value[i][7] = (this.value[i][7] - box.y) * height / box.height + box.y;
        }
      }

      return this;
    },
    // Test if the passed path array use the same path data commands as this path array
    equalCommands: function equalCommands(pathArray) {
      var i, il, equalCommands;
      pathArray = new SVG.PathArray(pathArray);
      equalCommands = this.value.length === pathArray.value.length;

      for (i = 0, il = this.value.length; equalCommands && i < il; i++) {
        equalCommands = this.value[i][0] === pathArray.value[i][0];
      }

      return equalCommands;
    },
    // Make path array morphable
    morph: function morph(pathArray) {
      pathArray = new SVG.PathArray(pathArray);

      if (this.equalCommands(pathArray)) {
        this.destination = pathArray;
      } else {
        this.destination = null;
      }

      return this;
    },
    // Get morphed path array at given position
    at: function at(pos) {
      // make sure a destination is defined
      if (!this.destination) return this;
      var sourceArray = this.value,
          destinationArray = this.destination.value,
          array = [],
          pathArray = new SVG.PathArray(),
          i,
          il,
          j,
          jl; // Animate has specified in the SVG spec
      // See: https://www.w3.org/TR/SVG11/paths.html#PathElement

      for (i = 0, il = sourceArray.length; i < il; i++) {
        array[i] = [sourceArray[i][0]];

        for (j = 1, jl = sourceArray[i].length; j < jl; j++) {
          array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;
        } // For the two flags of the elliptical arc command, the SVG spec say:
        // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true
        // Elliptical arc command as an array followed by corresponding indexes:
        // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        //   0    1   2        3                 4             5      6  7


        if (array[i][0] === 'A') {
          array[i][4] = +(array[i][4] != 0);
          array[i][5] = +(array[i][5] != 0);
        }
      } // Directly modify the value of a path array, this is done this way for performance


      pathArray.value = array;
      return pathArray;
    },
    // Absolutize and parse path to array
    parse: function parse(array) {
      // if it's already a patharray, no need to parse it
      if (array instanceof SVG.PathArray) return array.valueOf(); // prepare for parsing

      var s,
          arr,
          paramCnt = {
        'M': 2,
        'L': 2,
        'H': 1,
        'V': 1,
        'C': 6,
        'S': 4,
        'Q': 4,
        'T': 2,
        'A': 7,
        'Z': 0
      };

      if (typeof array === 'string') {
        array = array.replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123
        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers
        .replace(SVG.regex.hyphen, '$1 -') // add space before hyphen
        .trim() // trim
        .split(SVG.regex.delimiter); // split into array
      } else {
        array = array.reduce(function (prev, curr) {
          return [].concat.call(prev, curr);
        }, []);
      } // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]


      var arr = [],
          p = new SVG.Point(),
          p0 = new SVG.Point(),
          index = 0,
          len = array.length;

      do {
        // Test if we have a path letter
        if (SVG.regex.isPathLetter.test(array[index])) {
          s = array[index];
          ++index; // If last letter was a move command and we got no new, it defaults to [L]ine
        } else if (s == 'M') {
          s = 'L';
        } else if (s == 'm') {
          s = 'l';
        }

        arr.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));
      } while (len > index);

      return arr;
    },
    // Get bounding box of path
    bbox: function bbox() {
      if (!SVG.parser.draw) {
        SVG.prepare();
      }

      SVG.parser.path.setAttribute('d', this.toString());
      return SVG.parser.path.getBBox();
    }
  }); // Module for unit convertions

  SVG.Number = SVG.invent({
    // Initialize
    create: function create(value, unit) {
      // initialize defaults
      this.value = 0;
      this.unit = unit || ''; // parse value

      if (typeof value === 'number') {
        // ensure a valid numeric value
        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;
      } else if (typeof value === 'string') {
        unit = value.match(SVG.regex.numberAndUnit);

        if (unit) {
          // make value numeric
          this.value = parseFloat(unit[1]); // normalize

          if (unit[5] == '%') {
            this.value /= 100;
          } else if (unit[5] == 's') {
            this.value *= 1000;
          } // store unit


          this.unit = unit[5];
        }
      } else {
        if (value instanceof SVG.Number) {
          this.value = value.valueOf();
          this.unit = value.unit;
        }
      }
    },
    // Add methods
    extend: {
      // Stringalize
      toString: function toString() {
        return (this.unit == '%' ? ~~(this.value * 1e8) / 1e6 : this.unit == 's' ? this.value / 1e3 : this.value) + this.unit;
      },
      toJSON: function toJSON() {
        return this.toString();
      },
      // Convert to primitive
      valueOf: function valueOf() {
        return this.value;
      },
      // Add number
      plus: function plus(number) {
        number = new SVG.Number(number);
        return new SVG.Number(this + number, this.unit || number.unit);
      },
      // Subtract number
      minus: function minus(number) {
        number = new SVG.Number(number);
        return new SVG.Number(this - number, this.unit || number.unit);
      },
      // Multiply number
      times: function times(number) {
        number = new SVG.Number(number);
        return new SVG.Number(this * number, this.unit || number.unit);
      },
      // Divide number
      divide: function divide(number) {
        number = new SVG.Number(number);
        return new SVG.Number(this / number, this.unit || number.unit);
      },
      // Convert to different unit
      to: function to(unit) {
        var number = new SVG.Number(this);

        if (typeof unit === 'string') {
          number.unit = unit;
        }

        return number;
      },
      // Make number morphable
      morph: function morph(number) {
        this.destination = new SVG.Number(number);

        if (number.relative) {
          this.destination.value += this.value;
        }

        return this;
      },
      // Get morphed number at given position
      at: function at(pos) {
        // Make sure a destination is defined
        if (!this.destination) return this; // Generate new morphed number

        return new SVG.Number(this.destination).minus(this).times(pos).plus(this);
      }
    }
  });
  SVG.Element = SVG.invent({
    // Initialize node
    create: function create(node) {
      // make stroke value accessible dynamically
      this._stroke = SVG.defaults.attrs.stroke;
      this._event = null; // initialize data object

      this.dom = {}; // create circular reference

      if (this.node = node) {
        this.type = node.nodeName;
        this.node.instance = this; // store current attribute value

        this._stroke = node.getAttribute('stroke') || this._stroke;
      }
    },
    // Add class methods
    extend: {
      // Move over x-axis
      x: function x(_x) {
        return this.attr('x', _x);
      },
      // Move over y-axis
      y: function y(_y) {
        return this.attr('y', _y);
      },
      // Move by center over x-axis
      cx: function cx(x) {
        return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);
      },
      // Move by center over y-axis
      cy: function cy(y) {
        return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);
      },
      // Move element to given x and y values
      move: function move(x, y) {
        return this.x(x).y(y);
      },
      // Move element by its center
      center: function center(x, y) {
        return this.cx(x).cy(y);
      },
      // Set width of element
      width: function width(_width) {
        return this.attr('width', _width);
      },
      // Set height of element
      height: function height(_height) {
        return this.attr('height', _height);
      },
      // Set element size to given width and height
      size: function size(width, height) {
        var p = proportionalSize(this, width, height);
        return this.width(new SVG.Number(p.width)).height(new SVG.Number(p.height));
      },
      // Clone element
      clone: function clone(parent) {
        // write dom data to the dom so the clone can pickup the data
        this.writeDataToDom(); // clone element and assign new id

        var clone = assignNewId(this.node.cloneNode(true)); // insert the clone in the given parent or after myself

        if (parent) parent.add(clone);else this.after(clone);
        return clone;
      },
      // Remove element
      remove: function remove() {
        if (this.parent()) {
          this.parent().removeElement(this);
        }

        return this;
      },
      // Replace element
      replace: function replace(element) {
        this.after(element).remove();
        return element;
      },
      // Add element to given container and return self
      addTo: function addTo(parent) {
        return parent.put(this);
      },
      // Add element to given container and return container
      putIn: function putIn(parent) {
        return parent.add(this);
      },
      // Get / set id
      id: function id(_id) {
        return this.attr('id', _id);
      },
      // Checks whether the given point inside the bounding box of the element
      inside: function inside(x, y) {
        var box = this.bbox();
        return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;
      },
      // Show element
      show: function show() {
        return this.style('display', '');
      },
      // Hide element
      hide: function hide() {
        return this.style('display', 'none');
      },
      // Is element visible?
      visible: function visible() {
        return this.style('display') != 'none';
      },
      // Return id on string conversion
      toString: function toString() {
        return this.attr('id');
      },
      // Return array of classes on the node
      classes: function classes() {
        var attr = this.attr('class');
        return attr == null ? [] : attr.trim().split(SVG.regex.delimiter);
      },
      // Return true if class exists on the node, false otherwise
      hasClass: function hasClass(name) {
        return this.classes().indexOf(name) != -1;
      },
      // Add class to the node
      addClass: function addClass(name) {
        if (!this.hasClass(name)) {
          var array = this.classes();
          array.push(name);
          this.attr('class', array.join(' '));
        }

        return this;
      },
      // Remove class from the node
      removeClass: function removeClass(name) {
        if (this.hasClass(name)) {
          this.attr('class', this.classes().filter(function (c) {
            return c != name;
          }).join(' '));
        }

        return this;
      },
      // Toggle the presence of a class on the node
      toggleClass: function toggleClass(name) {
        return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);
      },
      // Get referenced element form attribute value
      reference: function reference(attr) {
        return SVG.get(this.attr(attr));
      },
      // Returns the parent element instance
      parent: function parent(type) {
        var parent = this; // check for parent

        if (!parent.node.parentNode) return null; // get parent element

        parent = SVG.adopt(parent.node.parentNode);
        if (!type) return parent; // loop trough ancestors if type is given

        while (parent && parent.node instanceof window.SVGElement) {
          if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;
          if (!parent.node.parentNode || parent.node.parentNode.nodeName == '#document') return null; // #759, #720

          parent = SVG.adopt(parent.node.parentNode);
        }
      },
      // Get parent document
      doc: function doc() {
        return this instanceof SVG.Doc ? this : this.parent(SVG.Doc);
      },
      // return array of all ancestors of given type up to the root svg
      parents: function parents(type) {
        var parents = [],
            parent = this;

        do {
          parent = parent.parent(type);
          if (!parent || !parent.node) break;
          parents.push(parent);
        } while (parent.parent);

        return parents;
      },
      // matches the element vs a css selector
      matches: function matches(selector) {
        return _matches(this.node, selector);
      },
      // Returns the svg node to call native svg methods on it
      native: function native() {
        return this.node;
      },
      // Import raw svg
      svg: function svg(_svg) {
        // create temporary holder
        var well = document.createElement('svg'); // act as a setter if svg is given

        if (_svg && this instanceof SVG.Parent) {
          // dump raw svg
          well.innerHTML = '<svg>' + _svg.replace(/\n/, '').replace(/<([\w:-]+)([^<]+?)\/>/g, '<$1$2></$1>') + '</svg>'; // transplant nodes

          for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++) {
            this.node.appendChild(well.firstChild.firstChild);
          } // otherwise act as a getter

        } else {
          // create a wrapping svg element in case of partial content
          well.appendChild(_svg = document.createElement('svg')); // write svgjs data to the dom

          this.writeDataToDom(); // insert a copy of this node

          _svg.appendChild(this.node.cloneNode(true)); // return target element


          return well.innerHTML.replace(/^<svg>/, '').replace(/<\/svg>$/, '');
        }

        return this;
      },
      // write svgjs data to the dom
      writeDataToDom: function writeDataToDom() {
        // dump variables recursively
        if (this.each || this.lines) {
          var fn = this.each ? this : this.lines();
          fn.each(function () {
            this.writeDataToDom();
          });
        } // remove previously set data


        this.node.removeAttribute('svgjs:data');

        if (Object.keys(this.dom).length) {
          this.node.setAttribute('svgjs:data', JSON.stringify(this.dom));
        } // see #428


        return this;
      },
      // set given data to the elements data property
      setData: function setData(o) {
        this.dom = o;
        return this;
      },
      is: function is(obj) {
        return _is(this, obj);
      }
    }
  });
  SVG.easing = {
    '-': function _(pos) {
      return pos;
    },
    '<>': function _(pos) {
      return -Math.cos(pos * Math.PI) / 2 + 0.5;
    },
    '>': function _(pos) {
      return Math.sin(pos * Math.PI / 2);
    },
    '<': function _(pos) {
      return -Math.cos(pos * Math.PI / 2) + 1;
    }
  };

  SVG.morph = function (pos) {
    return function (from, to) {
      return new SVG.MorphObj(from, to).at(pos);
    };
  };

  SVG.Situation = SVG.invent({
    create: function create(o) {
      this.init = false;
      this.reversed = false;
      this.reversing = false;
      this.duration = new SVG.Number(o.duration).valueOf();
      this.delay = new SVG.Number(o.delay).valueOf();
      this.start = +new Date() + this.delay;
      this.finish = this.start + this.duration;
      this.ease = o.ease; // this.loop is incremented from 0 to this.loops
      // it is also incremented when in an infinite loop (when this.loops is true)

      this.loop = 0;
      this.loops = false;
      this.animations = {// functionToCall: [list of morphable objects]
        // e.g. move: [SVG.Number, SVG.Number]
      };
      this.attrs = {// holds all attributes which are not represented from a function svg.js provides
        // e.g. someAttr: SVG.Number
      };
      this.styles = {// holds all styles which should be animated
        // e.g. fill-color: SVG.Color
      };
      this.transforms = [// holds all transformations as transformation objects
        // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]
      ];
      this.once = {// functions to fire at a specific position
        // e.g. "0.5": function foo(){}
      };
    }
  });
  SVG.FX = SVG.invent({
    create: function create(element) {
      this._target = element;
      this.situations = [];
      this.active = false;
      this.situation = null;
      this.paused = false;
      this.lastPos = 0;
      this.pos = 0; // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)
      // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1

      this.absPos = 0;
      this._speed = 1;
    },
    extend: {
      /**
       * sets or returns the target of this animation
       * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation
       * @param ease function || string Function which should be used for easing or easing keyword
       * @param delay Number indicating the delay before the animation starts
       * @return target || this
       */
      animate: function animate(o, ease, delay) {
        if (_typeof(o) === 'object') {
          ease = o.ease;
          delay = o.delay;
          o = o.duration;
        }

        var situation = new SVG.Situation({
          duration: o || 1000,
          delay: delay || 0,
          ease: SVG.easing[ease || '-'] || ease
        });
        this.queue(situation);
        return this;
      },

      /**
      * sets a delay before the next element of the queue is called
      * @param delay Duration of delay in milliseconds
      * @return this.target()
      */
      delay: function delay(_delay) {
        // The delay is performed by an empty situation with its duration
        // attribute set to the duration of the delay
        var situation = new SVG.Situation({
          duration: _delay,
          delay: 0,
          ease: SVG.easing['-']
        });
        return this.queue(situation);
      },

      /**
      * sets or returns the target of this animation
      * @param null || target SVG.Element which should be set as new target
      * @return target || this
      */
      target: function target(_target) {
        if (_target && _target instanceof SVG.Element) {
          this._target = _target;
          return this;
        }

        return this._target;
      },
      // returns the absolute position at a given time
      timeToAbsPos: function timeToAbsPos(timestamp) {
        return (timestamp - this.situation.start) / (this.situation.duration / this._speed);
      },
      // returns the timestamp from a given absolute positon
      absPosToTime: function absPosToTime(absPos) {
        return this.situation.duration / this._speed * absPos + this.situation.start;
      },
      // starts the animationloop
      startAnimFrame: function startAnimFrame() {
        this.stopAnimFrame();
        this.animationFrame = window.requestAnimationFrame(function () {
          this.step();
        }.bind(this));
      },
      // cancels the animationframe
      stopAnimFrame: function stopAnimFrame() {
        window.cancelAnimationFrame(this.animationFrame);
      },
      // kicks off the animation - only does something when the queue is currently not active and at least one situation is set
      start: function start() {
        // dont start if already started
        if (!this.active && this.situation) {
          this.active = true;
          this.startCurrent();
        }

        return this;
      },
      // start the current situation
      startCurrent: function startCurrent() {
        this.situation.start = +new Date() + this.situation.delay / this._speed;
        this.situation.finish = this.situation.start + this.situation.duration / this._speed;
        return this.initAnimations().step();
      },

      /**
      * adds a function / Situation to the animation queue
      * @param fn function / situation to add
      * @return this
      */
      queue: function queue(fn) {
        if (typeof fn === 'function' || fn instanceof SVG.Situation) {
          this.situations.push(fn);
        }

        if (!this.situation) this.situation = this.situations.shift();
        return this;
      },

      /**
      * pulls next element from the queue and execute it
      * @return this
      */
      dequeue: function dequeue() {
        // stop current animation
        this.stop(); // get next animation from queue

        this.situation = this.situations.shift();

        if (this.situation) {
          if (this.situation instanceof SVG.Situation) {
            this.start();
          } else {
            // If it is not a SVG.Situation, then it is a function, we execute it
            this.situation.call(this);
          }
        }

        return this;
      },
      // updates all animations to the current state of the element
      // this is important when one property could be changed from another property
      initAnimations: function initAnimations() {
        var i, j, source;
        var s = this.situation;
        if (s.init) return this;

        for (i in s.animations) {
          source = this.target()[i]();

          if (!Array.isArray(source)) {
            source = [source];
          }

          if (!Array.isArray(s.animations[i])) {
            s.animations[i] = [s.animations[i]];
          } // if(s.animations[i].length > source.length) {
          //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))
          // }


          for (j = source.length; j--;) {
            // The condition is because some methods return a normal number instead
            // of a SVG.Number
            if (s.animations[i][j] instanceof SVG.Number) {
              source[j] = new SVG.Number(source[j]);
            }

            s.animations[i][j] = source[j].morph(s.animations[i][j]);
          }
        }

        for (i in s.attrs) {
          s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i]);
        }

        for (i in s.styles) {
          s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i]);
        }

        s.initialTransformation = this.target().matrixify();
        s.init = true;
        return this;
      },
      clearQueue: function clearQueue() {
        this.situations = [];
        return this;
      },
      clearCurrent: function clearCurrent() {
        this.situation = null;
        return this;
      },

      /** stops the animation immediately
      * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.
      * @param clearQueue A Boolean indicating whether to remove queued animation as well.
      * @return this
      */
      stop: function stop(jumpToEnd, clearQueue) {
        var active = this.active;
        this.active = false;

        if (clearQueue) {
          this.clearQueue();
        }

        if (jumpToEnd && this.situation) {
          // initialize the situation if it was not
          !active && this.startCurrent();
          this.atEnd();
        }

        this.stopAnimFrame();
        return this.clearCurrent();
      },

      /** resets the element to the state where the current element has started
      * @return this
      */
      reset: function reset() {
        if (this.situation) {
          var temp = this.situation;
          this.stop();
          this.situation = temp;
          this.atStart();
        }

        return this;
      },
      // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.
      finish: function finish() {
        this.stop(true, false);

        while (this.dequeue().situation && this.stop(true, false)) {
        }

        this.clearQueue().clearCurrent();
        return this;
      },
      // set the internal animation pointer at the start position, before any loops, and updates the visualisation
      atStart: function atStart() {
        return this.at(0, true);
      },
      // set the internal animation pointer at the end position, after all the loops, and updates the visualisation
      atEnd: function atEnd() {
        if (this.situation.loops === true) {
          // If in a infinite loop, we end the current iteration
          this.situation.loops = this.situation.loop + 1;
        }

        if (typeof this.situation.loops === 'number') {
          // If performing a finite number of loops, we go after all the loops
          return this.at(this.situation.loops, true);
        } else {
          // If no loops, we just go at the end
          return this.at(1, true);
        }
      },
      // set the internal animation pointer to the specified position and updates the visualisation
      // if isAbsPos is true, pos is treated as an absolute position
      at: function at(pos, isAbsPos) {
        var durDivSpd = this.situation.duration / this._speed;
        this.absPos = pos; // If pos is not an absolute position, we convert it into one

        if (!isAbsPos) {
          if (this.situation.reversed) this.absPos = 1 - this.absPos;
          this.absPos += this.situation.loop;
        }

        this.situation.start = +new Date() - this.absPos * durDivSpd;
        this.situation.finish = this.situation.start + durDivSpd;
        return this.step(true);
      },

      /**
      * sets or returns the speed of the animations
      * @param speed null || Number The new speed of the animations
      * @return Number || this
      */
      speed: function speed(_speed) {
        if (_speed === 0) return this.pause();

        if (_speed) {
          this._speed = _speed; // We use an absolute position here so that speed can affect the delay before the animation

          return this.at(this.absPos, true);
        } else return this._speed;
      },
      // Make loopable
      loop: function loop(times, reverse) {
        var c = this.last(); // store total loops

        c.loops = times != null ? times : true;
        c.loop = 0;
        if (reverse) c.reversing = true;
        return this;
      },
      // pauses the animation
      pause: function pause() {
        this.paused = true;
        this.stopAnimFrame();
        return this;
      },
      // unpause the animation
      play: function play() {
        if (!this.paused) return this;
        this.paused = false; // We use an absolute position here so that the delay before the animation can be paused

        return this.at(this.absPos, true);
      },

      /**
      * toggle or set the direction of the animation
      * true sets direction to backwards while false sets it to forwards
      * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)
      * @return this
      */
      reverse: function reverse(reversed) {
        var c = this.last();
        if (typeof reversed === 'undefined') c.reversed = !c.reversed;else c.reversed = reversed;
        return this;
      },

      /**
      * returns a float from 0-1 indicating the progress of the current animation
      * @param eased Boolean indicating whether the returned position should be eased or not
      * @return number
      */
      progress: function progress(easeIt) {
        return easeIt ? this.situation.ease(this.pos) : this.pos;
      },

      /**
      * adds a callback function which is called when the current animation is finished
      * @param fn Function which should be executed as callback
      * @return number
      */
      after: function after(fn) {
        var c = this.last(),
            wrapper = function wrapper(e) {
          if (e.detail.situation == c) {
            fn.call(this, c);
            this.off('finished.fx', wrapper); // prevent memory leak
          }
        };

        this.target().on('finished.fx', wrapper);
        return this._callStart();
      },
      // adds a callback which is called whenever one animation step is performed
      during: function during(fn) {
        var c = this.last(),
            wrapper = function wrapper(e) {
          if (e.detail.situation == c) {
            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c);
          }
        }; // see above


        this.target().off('during.fx', wrapper).on('during.fx', wrapper);
        this.after(function () {
          this.off('during.fx', wrapper);
        });
        return this._callStart();
      },
      // calls after ALL animations in the queue are finished
      afterAll: function afterAll(fn) {
        var wrapper = function wrapper(e) {
          fn.call(this);
          this.off('allfinished.fx', wrapper);
        }; // see above


        this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper);
        return this._callStart();
      },
      // calls on every animation step for all animations
      duringAll: function duringAll(fn) {
        var wrapper = function wrapper(e) {
          fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation);
        };

        this.target().off('during.fx', wrapper).on('during.fx', wrapper);
        this.afterAll(function () {
          this.off('during.fx', wrapper);
        });
        return this._callStart();
      },
      last: function last() {
        return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
      },
      // adds one property to the animations
      add: function add(method, args, type) {
        this.last()[type || 'animations'][method] = args;
        return this._callStart();
      },

      /** perform one step of the animation
      *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time
      *  @return this
      */
      step: function step(ignoreTime) {
        // convert current time to an absolute position
        if (!ignoreTime) this.absPos = this.timeToAbsPos(+new Date()); // This part convert an absolute position to a position

        if (this.situation.loops !== false) {
          var absPos, absPosInt, lastLoop; // If the absolute position is below 0, we just treat it as if it was 0

          absPos = Math.max(this.absPos, 0);
          absPosInt = Math.floor(absPos);

          if (this.situation.loops === true || absPosInt < this.situation.loops) {
            this.pos = absPos - absPosInt;
            lastLoop = this.situation.loop;
            this.situation.loop = absPosInt;
          } else {
            this.absPos = this.situation.loops;
            this.pos = 1; // The -1 here is because we don't want to toggle reversed when all the loops have been completed

            lastLoop = this.situation.loop - 1;
            this.situation.loop = this.situation.loops;
          }

          if (this.situation.reversing) {
            // Toggle reversed if an odd number of loops as occured since the last call of step
            this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2);
          }
        } else {
          // If there are no loop, the absolute position must not be above 1
          this.absPos = Math.min(this.absPos, 1);
          this.pos = this.absPos;
        } // while the absolute position can be below 0, the position must not be below 0


        if (this.pos < 0) this.pos = 0;
        if (this.situation.reversed) this.pos = 1 - this.pos; // apply easing

        var eased = this.situation.ease(this.pos); // call once-callbacks

        for (var i in this.situation.once) {
          if (i > this.lastPos && i <= eased) {
            this.situation.once[i].call(this.target(), this.pos, eased);
            delete this.situation.once[i];
          }
        } // fire during callback with position, eased position and current situation as parameter


        if (this.active) this.target().fire('during', {
          pos: this.pos,
          eased: eased,
          fx: this,
          situation: this.situation
        }); // the user may call stop or finish in the during callback
        // so make sure that we still have a valid situation

        if (!this.situation) {
          return this;
        } // apply the actual animation to every property


        this.eachAt(); // do final code when situation is finished

        if (this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0) {
          // stop animation callback
          this.stopAnimFrame(); // fire finished callback with current situation as parameter

          this.target().fire('finished', {
            fx: this,
            situation: this.situation
          });

          if (!this.situations.length) {
            this.target().fire('allfinished'); // Recheck the length since the user may call animate in the afterAll callback

            if (!this.situations.length) {
              this.target().off('.fx'); // there shouldnt be any binding left, but to make sure...

              this.active = false;
            }
          } // start next animation


          if (this.active) this.dequeue();else this.clearCurrent();
        } else if (!this.paused && this.active) {
          // we continue animating when we are not at the end
          this.startAnimFrame();
        } // save last eased position for once callback triggering


        this.lastPos = eased;
        return this;
      },
      // calculates the step for every property and calls block with it
      eachAt: function eachAt() {
        var i,
            len,
            at,
            self = this,
            target = this.target(),
            s = this.situation; // apply animations which can be called trough a method

        for (i in s.animations) {
          at = [].concat(s.animations[i]).map(function (el) {
            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;
          });
          target[i].apply(target, at);
        } // apply animation which has to be applied with attr()


        for (i in s.attrs) {
          at = [i].concat(s.attrs[i]).map(function (el) {
            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;
          });
          target.attr.apply(target, at);
        } // apply animation which has to be applied with style()


        for (i in s.styles) {
          at = [i].concat(s.styles[i]).map(function (el) {
            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;
          });
          target.style.apply(target, at);
        } // animate initialTransformation which has to be chained


        if (s.transforms.length) {
          // get initial initialTransformation
          at = s.initialTransformation;

          for (i = 0, len = s.transforms.length; i < len; i++) {
            // get next transformation in chain
            var a = s.transforms[i]; // multiply matrix directly

            if (a instanceof SVG.Matrix) {
              if (a.relative) {
                at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)));
              } else {
                at = at.morph(a).at(s.ease(this.pos));
              }

              continue;
            } // when transformation is absolute we have to reset the needed transformation first


            if (!a.relative) {
              a.undo(at.extract());
            } // and reapply it after


            at = at.multiply(a.at(s.ease(this.pos)));
          } // set new matrix on element


          target.matrix(at);
        }

        return this;
      },
      // adds an once-callback which is called at a specific position and never again
      once: function once(pos, fn, isEased) {
        var c = this.last();
        if (!isEased) pos = c.ease(pos);
        c.once[pos] = fn;
        return this;
      },
      _callStart: function _callStart() {
        setTimeout(function () {
          this.start();
        }.bind(this), 0);
        return this;
      }
    },
    parent: SVG.Element,
    // Add method to parent elements
    construct: {
      // Get fx module or create a new one, then animate with given duration and ease
      animate: function animate(o, ease, delay) {
        return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay);
      },
      delay: function delay(_delay2) {
        return (this.fx || (this.fx = new SVG.FX(this))).delay(_delay2);
      },
      stop: function stop(jumpToEnd, clearQueue) {
        if (this.fx) {
          this.fx.stop(jumpToEnd, clearQueue);
        }

        return this;
      },
      finish: function finish() {
        if (this.fx) {
          this.fx.finish();
        }

        return this;
      },
      // Pause current animation
      pause: function pause() {
        if (this.fx) {
          this.fx.pause();
        }

        return this;
      },
      // Play paused current animation
      play: function play() {
        if (this.fx) {
          this.fx.play();
        }

        return this;
      },
      // Set/Get the speed of the animations
      speed: function speed(_speed2) {
        if (this.fx) {
          if (_speed2 == null) {
            return this.fx.speed();
          } else {
            this.fx.speed(_speed2);
          }
        }

        return this;
      }
    }
  }); // MorphObj is used whenever no morphable object is given

  SVG.MorphObj = SVG.invent({
    create: function create(from, to) {
      // prepare color for morphing
      if (SVG.Color.isColor(to)) return new SVG.Color(from).morph(to); // check if we have a list of values

      if (SVG.regex.delimiter.test(from)) {
        // prepare path for morphing
        if (SVG.regex.pathLetters.test(from)) return new SVG.PathArray(from).morph(to); // prepare value list for morphing
        else return new SVG.Array(from).morph(to);
      } // prepare number for morphing


      if (SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to); // prepare for plain morphing

      this.value = from;
      this.destination = to;
    },
    extend: {
      at: function at(pos, real) {
        return real < 1 ? this.value : this.destination;
      },
      valueOf: function valueOf() {
        return this.value;
      }
    }
  });
  SVG.extend(SVG.FX, {
    // Add animatable attributes
    attr: function attr(a, v, relative) {
      // apply attributes individually
      if (_typeof(a) === 'object') {
        for (var key in a) {
          this.attr(key, a[key]);
        }
      } else {
        this.add(a, v, 'attrs');
      }

      return this;
    },
    // Add animatable styles
    style: function style(s, v) {
      if (_typeof(s) === 'object') {
        for (var key in s) {
          this.style(key, s[key]);
        }
      } else {
        this.add(s, v, 'styles');
      }

      return this;
    },
    // Animatable x-axis
    x: function x(_x2, relative) {
      if (this.target() instanceof SVG.G) {
        this.transform({
          x: _x2
        }, relative);
        return this;
      }

      var num = new SVG.Number(_x2);
      num.relative = relative;
      return this.add('x', num);
    },
    // Animatable y-axis
    y: function y(_y2, relative) {
      if (this.target() instanceof SVG.G) {
        this.transform({
          y: _y2
        }, relative);
        return this;
      }

      var num = new SVG.Number(_y2);
      num.relative = relative;
      return this.add('y', num);
    },
    // Animatable center x-axis
    cx: function cx(x) {
      return this.add('cx', new SVG.Number(x));
    },
    // Animatable center y-axis
    cy: function cy(y) {
      return this.add('cy', new SVG.Number(y));
    },
    // Add animatable move
    move: function move(x, y) {
      return this.x(x).y(y);
    },
    // Add animatable center
    center: function center(x, y) {
      return this.cx(x).cy(y);
    },
    // Add animatable size
    size: function size(width, height) {
      if (this.target() instanceof SVG.Text) {
        // animate font size for Text elements
        this.attr('font-size', width);
      } else {
        // animate bbox based size for all other elements
        var box;

        if (!width || !height) {
          box = this.target().bbox();
        }

        if (!width) {
          width = box.width / box.height * height;
        }

        if (!height) {
          height = box.height / box.width * width;
        }

        this.add('width', new SVG.Number(width)).add('height', new SVG.Number(height));
      }

      return this;
    },
    // Add animatable width
    width: function width(_width2) {
      return this.add('width', new SVG.Number(_width2));
    },
    // Add animatable height
    height: function height(_height2) {
      return this.add('height', new SVG.Number(_height2));
    },
    // Add animatable plot
    plot: function plot(a, b, c, d) {
      // Lines can be plotted with 4 arguments
      if (arguments.length == 4) {
        return this.plot([a, b, c, d]);
      }

      return this.add('plot', new (this.target().morphArray)(a));
    },
    // Add leading method
    leading: function leading(value) {
      return this.target().leading ? this.add('leading', new SVG.Number(value)) : this;
    },
    // Add animatable viewbox
    viewbox: function viewbox(x, y, width, height) {
      if (this.target() instanceof SVG.Container) {
        this.add('viewbox', new SVG.ViewBox(x, y, width, height));
      }

      return this;
    },
    update: function update(o) {
      if (this.target() instanceof SVG.Stop) {
        if (typeof o === 'number' || o instanceof SVG.Number) {
          return this.update({
            offset: arguments[0],
            color: arguments[1],
            opacity: arguments[2]
          });
        }

        if (o.opacity != null) this.attr('stop-opacity', o.opacity);
        if (o.color != null) this.attr('stop-color', o.color);
        if (o.offset != null) this.attr('offset', o.offset);
      }

      return this;
    }
  });
  SVG.Box = SVG.invent({
    create: function create(x, y, width, height) {
      if (_typeof(x) === 'object' && !(x instanceof SVG.Element)) {
        // chromes getBoundingClientRect has no x and y property
        return SVG.Box.call(this, x.left != null ? x.left : x.x, x.top != null ? x.top : x.y, x.width, x.height);
      } else if (arguments.length == 4) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      } // add center, right, bottom...


      fullBox(this);
    },
    extend: {
      // Merge rect box with another, return a new instance
      merge: function merge(box) {
        var b = new this.constructor(); // merge boxes

        b.x = Math.min(this.x, box.x);
        b.y = Math.min(this.y, box.y);
        b.width = Math.max(this.x + this.width, box.x + box.width) - b.x;
        b.height = Math.max(this.y + this.height, box.y + box.height) - b.y;
        return fullBox(b);
      },
      transform: function transform(m) {
        var xMin = Infinity,
            xMax = -Infinity,
            yMin = Infinity,
            yMax = -Infinity,
            bbox;
        var pts = [new SVG.Point(this.x, this.y), new SVG.Point(this.x2, this.y), new SVG.Point(this.x, this.y2), new SVG.Point(this.x2, this.y2)];
        pts.forEach(function (p) {
          p = p.transform(m);
          xMin = Math.min(xMin, p.x);
          xMax = Math.max(xMax, p.x);
          yMin = Math.min(yMin, p.y);
          yMax = Math.max(yMax, p.y);
        });
        bbox = new this.constructor();
        bbox.x = xMin;
        bbox.width = xMax - xMin;
        bbox.y = yMin;
        bbox.height = yMax - yMin;
        fullBox(bbox);
        return bbox;
      }
    }
  });
  SVG.BBox = SVG.invent({
    // Initialize
    create: function create(element) {
      SVG.Box.apply(this, [].slice.call(arguments)); // get values if element is given

      if (element instanceof SVG.Element) {
        var box; // yes this is ugly, but Firefox can be a pain when it comes to elements that are not yet rendered

        try {
          if (!document.documentElement.contains) {
            // This is IE - it does not support contains() for top-level SVGs
            var topParent = element.node;

            while (topParent.parentNode) {
              topParent = topParent.parentNode;
            }

            if (topParent != document) throw new Error('Element not in the dom');
          } // the element is NOT in the dom, throw error
          // disabling the check below which fixes issue #76
          // if (!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')
          // find native bbox


          box = element.node.getBBox();
        } catch (e) {
          if (element instanceof SVG.Shape) {
            if (!SVG.parser.draw) {
              // fixes apexcharts/vue-apexcharts #14
              SVG.prepare();
            }

            var clone = element.clone(SVG.parser.draw.instance).show();
            box = clone.node.getBBox();
            clone.remove();
          } else {
            box = {
              x: element.node.clientLeft,
              y: element.node.clientTop,
              width: element.node.clientWidth,
              height: element.node.clientHeight
            };
          }
        }

        SVG.Box.call(this, box);
      }
    },
    // Define ancestor
    inherit: SVG.Box,
    // Define Parent
    parent: SVG.Element,
    // Constructor
    construct: {
      // Get bounding box
      bbox: function bbox() {
        return new SVG.BBox(this);
      }
    }
  });
  SVG.BBox.prototype.constructor = SVG.BBox;
  SVG.extend(SVG.Element, {
    tbox: function tbox() {
      console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.');
      return this.rbox(this.doc());
    }
  });
  SVG.RBox = SVG.invent({
    // Initialize
    create: function create(element) {
      SVG.Box.apply(this, [].slice.call(arguments));

      if (element instanceof SVG.Element) {
        SVG.Box.call(this, element.node.getBoundingClientRect());
      }
    },
    inherit: SVG.Box,
    // define Parent
    parent: SVG.Element,
    extend: {
      addOffset: function addOffset() {
        // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
        this.x += window.pageXOffset;
        this.y += window.pageYOffset;
        return this;
      }
    },
    // Constructor
    construct: {
      // Get rect box
      rbox: function rbox(el) {
        if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse());
        return new SVG.RBox(this).addOffset();
      }
    }
  });
  SVG.RBox.prototype.constructor = SVG.RBox;
  SVG.Matrix = SVG.invent({
    // Initialize
    create: function create(source) {
      var i,
          base = arrayToMatrix([1, 0, 0, 1, 0, 0]); // ensure source as object

      source = source instanceof SVG.Element ? source.matrixify() : typeof source === 'string' ? arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? arrayToMatrix([].slice.call(arguments)) : Array.isArray(source) ? arrayToMatrix(source) : _typeof(source) === 'object' ? source : base; // merge source

      for (i = abcdef.length - 1; i >= 0; --i) {
        this[abcdef[i]] = source[abcdef[i]] != null ? source[abcdef[i]] : base[abcdef[i]];
      }
    },
    // Add methods
    extend: {
      // Extract individual transformations
      extract: function extract() {
        // find delta transform points
        var px = deltaTransformPoint(this, 0, 1),
            py = deltaTransformPoint(this, 1, 0),
            skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;
        return {
          // translation
          x: this.e,
          y: this.f,
          transformedX: (this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
          transformedY: (this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
          // skew
          skewX: -skewX,
          skewY: 180 / Math.PI * Math.atan2(py.y, py.x),
          // scale
          scaleX: Math.sqrt(this.a * this.a + this.b * this.b),
          scaleY: Math.sqrt(this.c * this.c + this.d * this.d),
          // rotation
          rotation: skewX,
          a: this.a,
          b: this.b,
          c: this.c,
          d: this.d,
          e: this.e,
          f: this.f,
          matrix: new SVG.Matrix(this)
        };
      },
      // Clone matrix
      clone: function clone() {
        return new SVG.Matrix(this);
      },
      // Morph one matrix into another
      morph: function morph(matrix) {
        // store new destination
        this.destination = new SVG.Matrix(matrix);
        return this;
      },
      // Get morphed matrix at a given position
      at: function at(pos) {
        // make sure a destination is defined
        if (!this.destination) return this; // calculate morphed matrix at a given position

        var matrix = new SVG.Matrix({
          a: this.a + (this.destination.a - this.a) * pos,
          b: this.b + (this.destination.b - this.b) * pos,
          c: this.c + (this.destination.c - this.c) * pos,
          d: this.d + (this.destination.d - this.d) * pos,
          e: this.e + (this.destination.e - this.e) * pos,
          f: this.f + (this.destination.f - this.f) * pos
        });
        return matrix;
      },
      // Multiplies by given matrix
      multiply: function multiply(matrix) {
        return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()));
      },
      // Inverses matrix
      inverse: function inverse() {
        return new SVG.Matrix(this.native().inverse());
      },
      // Translate matrix
      translate: function translate(x, y) {
        return new SVG.Matrix(this.native().translate(x || 0, y || 0));
      },
      // Scale matrix
      scale: function scale(x, y, cx, cy) {
        // support uniformal scale
        if (arguments.length == 1) {
          y = x;
        } else if (arguments.length == 3) {
          cy = cx;
          cx = y;
          y = x;
        }

        return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0));
      },
      // Rotate matrix
      rotate: function rotate(r, cx, cy) {
        // convert degrees to radians
        r = SVG.utils.radians(r);
        return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0));
      },
      // Flip matrix on x or y, at a given offset
      flip: function flip(a, o) {
        return a == 'x' ? this.scale(-1, 1, o, 0) : a == 'y' ? this.scale(1, -1, 0, o) : this.scale(-1, -1, a, o != null ? o : a);
      },
      // Skew
      skew: function skew(x, y, cx, cy) {
        // support uniformal skew
        if (arguments.length == 1) {
          y = x;
        } else if (arguments.length == 3) {
          cy = cx;
          cx = y;
          y = x;
        } // convert degrees to radians


        x = SVG.utils.radians(x);
        y = SVG.utils.radians(y);
        return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0));
      },
      // SkewX
      skewX: function skewX(x, cx, cy) {
        return this.skew(x, 0, cx, cy);
      },
      // SkewY
      skewY: function skewY(y, cx, cy) {
        return this.skew(0, y, cx, cy);
      },
      // Transform around a center point
      around: function around(cx, cy, matrix) {
        return this.multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0)).multiply(matrix).multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0));
      },
      // Convert to native SVGMatrix
      native: function native() {
        // create new matrix
        var matrix = SVG.parser.native.createSVGMatrix(); // update with current values

        for (var i = abcdef.length - 1; i >= 0; i--) {
          matrix[abcdef[i]] = this[abcdef[i]];
        }

        return matrix;
      },
      // Convert matrix to string
      toString: function toString() {
        // Construct the matrix directly, avoid values that are too small
        return 'matrix(' + float32String(this.a) + ',' + float32String(this.b) + ',' + float32String(this.c) + ',' + float32String(this.d) + ',' + float32String(this.e) + ',' + float32String(this.f) + ')';
      }
    },
    // Define parent
    parent: SVG.Element,
    // Add parent method
    construct: {
      // Get current matrix
      ctm: function ctm() {
        return new SVG.Matrix(this.node.getCTM());
      },
      // Get current screen matrix
      screenCTM: function screenCTM() {
        /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
           This is needed because FF does not return the transformation matrix
           for the inner coordinate system when getScreenCTM() is called on nested svgs.
           However all other Browsers do that */
        if (this instanceof SVG.Nested) {
          var rect = this.rect(1, 1);
          var m = rect.node.getScreenCTM();
          rect.remove();
          return new SVG.Matrix(m);
        }

        return new SVG.Matrix(this.node.getScreenCTM());
      }
    }
  });
  SVG.Point = SVG.invent({
    // Initialize
    create: function create(x, y) {
      var source,
          base = {
        x: 0,
        y: 0 // ensure source as object

      };
      source = Array.isArray(x) ? {
        x: x[0],
        y: x[1]
      } : _typeof(x) === 'object' ? {
        x: x.x,
        y: x.y
      } : x != null ? {
        x: x,
        y: y != null ? y : x
      } : base; // If y has no value, then x is used has its value
      // merge source

      this.x = source.x;
      this.y = source.y;
    },
    // Add methods
    extend: {
      // Clone point
      clone: function clone() {
        return new SVG.Point(this);
      },
      // Morph one point into another
      morph: function morph(x, y) {
        // store new destination
        this.destination = new SVG.Point(x, y);
        return this;
      },
      // Get morphed point at a given position
      at: function at(pos) {
        // make sure a destination is defined
        if (!this.destination) return this; // calculate morphed matrix at a given position

        var point = new SVG.Point({
          x: this.x + (this.destination.x - this.x) * pos,
          y: this.y + (this.destination.y - this.y) * pos
        });
        return point;
      },
      // Convert to native SVGPoint
      native: function native() {
        // create new point
        var point = SVG.parser.native.createSVGPoint(); // update with current values

        point.x = this.x;
        point.y = this.y;
        return point;
      },
      // transform point with matrix
      transform: function transform(matrix) {
        return new SVG.Point(this.native().matrixTransform(matrix.native()));
      }
    }
  });
  SVG.extend(SVG.Element, {
    // Get point
    point: function point(x, y) {
      return new SVG.Point(x, y).transform(this.screenCTM().inverse());
    }
  });
  SVG.extend(SVG.Element, {
    // Set svg element attribute
    attr: function attr(a, v, n) {
      // act as full getter
      if (a == null) {
        // get an object of attributes
        a = {};
        v = this.node.attributes;

        for (n = v.length - 1; n >= 0; n--) {
          a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue;
        }

        return a;
      } else if (_typeof(a) === 'object') {
        // apply every attribute individually if an object is passed
        for (v in a) {
          this.attr(v, a[v]);
        }
      } else if (v === null) {
        // remove value
        this.node.removeAttribute(a);
      } else if (v == null) {
        // act as a getter if the first and only argument is not an object
        v = this.node.getAttribute(a);
        return v == null ? SVG.defaults.attrs[a] : SVG.regex.isNumber.test(v) ? parseFloat(v) : v;
      } else {
        // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0
        if (a == 'stroke-width') {
          this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null);
        } else if (a == 'stroke') {
          this._stroke = v;
        } // convert image fill and stroke to patterns


        if (a == 'fill' || a == 'stroke') {
          if (SVG.regex.isImage.test(v)) {
            v = this.doc().defs().image(v, 0, 0);
          }

          if (v instanceof SVG.Image) {
            v = this.doc().defs().pattern(0, 0, function () {
              this.add(v);
            });
          }
        } // ensure correct numeric values (also accepts NaN and Infinity)


        if (typeof v === 'number') {
          v = new SVG.Number(v);
        } // ensure full hex color
        else if (SVG.Color.isColor(v)) {
            v = new SVG.Color(v);
          } // parse array values
          else if (Array.isArray(v)) {
              v = new SVG.Array(v);
            } // if the passed attribute is leading...


        if (a == 'leading') {
          // ... call the leading method instead
          if (this.leading) {
            this.leading(v);
          }
        } else {
          // set given attribute on node
          typeof n === 'string' ? this.node.setAttributeNS(n, a, v.toString()) : this.node.setAttribute(a, v.toString());
        } // rebuild if required


        if (this.rebuild && (a == 'font-size' || a == 'x')) {
          this.rebuild(a, v);
        }
      }

      return this;
    }
  });
  SVG.extend(SVG.Element, {
    // Add transformations
    transform: function transform(o, relative) {
      // get target in case of the fx module, otherwise reference this
      var target = this,
          matrix,
          bbox; // act as a getter

      if (_typeof(o) !== 'object') {
        // get current matrix
        matrix = new SVG.Matrix(target).extract();
        return typeof o === 'string' ? matrix[o] : matrix;
      } // get current matrix


      matrix = new SVG.Matrix(target); // ensure relative flag

      relative = !!relative || !!o.relative; // act on matrix

      if (o.a != null) {
        matrix = relative // relative
        ? matrix.multiply(new SVG.Matrix(o)) // absolute
        : new SVG.Matrix(o); // act on rotation
      } else if (o.rotation != null) {
        // ensure centre point
        ensureCentre(o, target); // apply transformation

        matrix = relative // relative
        ? matrix.rotate(o.rotation, o.cx, o.cy) // absolute
        : matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy); // act on scale
      } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
        // ensure centre point
        ensureCentre(o, target); // ensure scale values on both axes

        o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;
        o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;

        if (!relative) {
          // absolute; multiply inversed values
          var e = matrix.extract();
          o.scaleX = o.scaleX * 1 / e.scaleX;
          o.scaleY = o.scaleY * 1 / e.scaleY;
        }

        matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy); // act on skew
      } else if (o.skew != null || o.skewX != null || o.skewY != null) {
        // ensure centre point
        ensureCentre(o, target); // ensure skew values on both axes

        o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0;
        o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0;

        if (!relative) {
          // absolute; reset skew values
          var e = matrix.extract();
          matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse());
        }

        matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy); // act on flip
      } else if (o.flip) {
        if (o.flip == 'x' || o.flip == 'y') {
          o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset;
        } else {
          if (o.offset == null) {
            bbox = target.bbox();
            o.flip = bbox.cx;
            o.offset = bbox.cy;
          } else {
            o.flip = o.offset;
          }
        }

        matrix = new SVG.Matrix().flip(o.flip, o.offset); // act on translate
      } else if (o.x != null || o.y != null) {
        if (relative) {
          // relative
          matrix = matrix.translate(o.x, o.y);
        } else {
          // absolute
          if (o.x != null) matrix.e = o.x;
          if (o.y != null) matrix.f = o.y;
        }
      }

      return this.attr('transform', matrix);
    }
  });
  SVG.extend(SVG.FX, {
    transform: function transform(o, relative) {
      // get target in case of the fx module, otherwise reference this
      var target = this.target(),
          matrix,
          bbox; // act as a getter

      if (_typeof(o) !== 'object') {
        // get current matrix
        matrix = new SVG.Matrix(target).extract();
        return typeof o === 'string' ? matrix[o] : matrix;
      } // ensure relative flag


      relative = !!relative || !!o.relative; // act on matrix

      if (o.a != null) {
        matrix = new SVG.Matrix(o); // act on rotation
      } else if (o.rotation != null) {
        // ensure centre point
        ensureCentre(o, target); // apply transformation

        matrix = new SVG.Rotate(o.rotation, o.cx, o.cy); // act on scale
      } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
        // ensure centre point
        ensureCentre(o, target); // ensure scale values on both axes

        o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;
        o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;
        matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy); // act on skew
      } else if (o.skewX != null || o.skewY != null) {
        // ensure centre point
        ensureCentre(o, target); // ensure skew values on both axes

        o.skewX = o.skewX != null ? o.skewX : 0;
        o.skewY = o.skewY != null ? o.skewY : 0;
        matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy); // act on flip
      } else if (o.flip) {
        if (o.flip == 'x' || o.flip == 'y') {
          o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset;
        } else {
          if (o.offset == null) {
            bbox = target.bbox();
            o.flip = bbox.cx;
            o.offset = bbox.cy;
          } else {
            o.flip = o.offset;
          }
        }

        matrix = new SVG.Matrix().flip(o.flip, o.offset); // act on translate
      } else if (o.x != null || o.y != null) {
        matrix = new SVG.Translate(o.x, o.y);
      }

      if (!matrix) return this;
      matrix.relative = relative;
      this.last().transforms.push(matrix);
      return this._callStart();
    }
  });
  SVG.extend(SVG.Element, {
    // Reset all transformations
    untransform: function untransform() {
      return this.attr('transform', null);
    },
    // merge the whole transformation chain into one matrix and returns it
    matrixify: function matrixify() {
      var matrix = (this.attr('transform') || ''). // split transformations
      split(SVG.regex.transforms).slice(0, -1).map(function (str) {
        // generate key => value pairs
        var kv = str.trim().split('(');
        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function (str) {
          return parseFloat(str);
        })];
      }) // merge every transformation into one matrix
      .reduce(function (matrix, transform) {
        if (transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]));
        return matrix[transform[0]].apply(matrix, transform[1]);
      }, new SVG.Matrix());
      return matrix;
    },
    // add an element to another parent without changing the visual representation on the screen
    toParent: function toParent(parent) {
      if (this == parent) return this;
      var ctm = this.screenCTM();
      var pCtm = parent.screenCTM().inverse();
      this.addTo(parent).untransform().transform(pCtm.multiply(ctm));
      return this;
    },
    // same as above with parent equals root-svg
    toDoc: function toDoc() {
      return this.toParent(this.doc());
    }
  });
  SVG.Transformation = SVG.invent({
    create: function create(source, inversed) {
      if (arguments.length > 1 && typeof inversed !== 'boolean') {
        return this.constructor.call(this, [].slice.call(arguments));
      }

      if (Array.isArray(source)) {
        for (var i = 0, len = this.arguments.length; i < len; ++i) {
          this[this.arguments[i]] = source[i];
        }
      } else if (_typeof(source) === 'object') {
        for (var i = 0, len = this.arguments.length; i < len; ++i) {
          this[this.arguments[i]] = source[this.arguments[i]];
        }
      }

      this.inversed = false;

      if (inversed === true) {
        this.inversed = true;
      }
    },
    extend: {
      arguments: [],
      method: '',
      at: function at(pos) {
        var params = [];

        for (var i = 0, len = this.arguments.length; i < len; ++i) {
          params.push(this[this.arguments[i]]);
        }

        var m = this._undo || new SVG.Matrix();
        m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos);
        return this.inversed ? m.inverse() : m;
      },
      undo: function undo(o) {
        for (var i = 0, len = this.arguments.length; i < len; ++i) {
          o[this.arguments[i]] = typeof this[this.arguments[i]] === 'undefined' ? 0 : o[this.arguments[i]];
        } // The method SVG.Matrix.extract which was used before calling this
        // method to obtain a value for the parameter o doesn't return a cx and
        // a cy so we use the ones that were provided to this object at its creation


        o.cx = this.cx;
        o.cy = this.cy;
        this._undo = new SVG[capitalize(this.method)](o, true).at(1);
        return this;
      }
    }
  });
  SVG.Translate = SVG.invent({
    parent: SVG.Matrix,
    inherit: SVG.Transformation,
    create: function create(source, inversed) {
      this.constructor.apply(this, [].slice.call(arguments));
    },
    extend: {
      arguments: ['transformedX', 'transformedY'],
      method: 'translate'
    }
  });
  SVG.Rotate = SVG.invent({
    parent: SVG.Matrix,
    inherit: SVG.Transformation,
    create: function create(source, inversed) {
      this.constructor.apply(this, [].slice.call(arguments));
    },
    extend: {
      arguments: ['rotation', 'cx', 'cy'],
      method: 'rotate',
      at: function at(pos) {
        var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy);
        return this.inversed ? m.inverse() : m;
      },
      undo: function undo(o) {
        this._undo = o;
        return this;
      }
    }
  });
  SVG.Scale = SVG.invent({
    parent: SVG.Matrix,
    inherit: SVG.Transformation,
    create: function create(source, inversed) {
      this.constructor.apply(this, [].slice.call(arguments));
    },
    extend: {
      arguments: ['scaleX', 'scaleY', 'cx', 'cy'],
      method: 'scale'
    }
  });
  SVG.Skew = SVG.invent({
    parent: SVG.Matrix,
    inherit: SVG.Transformation,
    create: function create(source, inversed) {
      this.constructor.apply(this, [].slice.call(arguments));
    },
    extend: {
      arguments: ['skewX', 'skewY', 'cx', 'cy'],
      method: 'skew'
    }
  });
  SVG.extend(SVG.Element, {
    // Dynamic style generator
    style: function style(s, v) {
      if (arguments.length == 0) {
        // get full style
        return this.node.style.cssText || '';
      } else if (arguments.length < 2) {
        // apply every style individually if an object is passed
        if (_typeof(s) === 'object') {
          for (v in s) {
            this.style(v, s[v]);
          }
        } else if (SVG.regex.isCss.test(s)) {
          // parse css string
          s = s.split(/\s*;\s*/) // filter out suffix ; and stuff like ;;
          .filter(function (e) {
            return !!e;
          }).map(function (e) {
            return e.split(/\s*:\s*/);
          }); // apply every definition individually

          while (v = s.pop()) {
            this.style(v[0], v[1]);
          }
        } else {
          // act as a getter if the first and only argument is not an object
          return this.node.style[camelCase(s)];
        }
      } else {
        this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v;
      }

      return this;
    }
  });
  SVG.Parent = SVG.invent({
    // Initialize node
    create: function create(element) {
      this.constructor.call(this, element);
    },
    // Inherit from
    inherit: SVG.Element,
    // Add class methods
    extend: {
      // Returns all child elements
      children: function children() {
        return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function (node) {
          return SVG.adopt(node);
        });
      },
      // Add given element at a position
      add: function add(element, i) {
        if (i == null) {
          this.node.appendChild(element.node);
        } else if (element.node != this.node.childNodes[i]) {
          this.node.insertBefore(element.node, this.node.childNodes[i]);
        }

        return this;
      },
      // Basically does the same as `add()` but returns the added element instead
      put: function put(element, i) {
        this.add(element, i);
        return element;
      },
      // Checks if the given element is a child
      has: function has(element) {
        return this.index(element) >= 0;
      },
      // Gets index of given element
      index: function index(element) {
        return [].slice.call(this.node.childNodes).indexOf(element.node);
      },
      // Get a element at the given index
      get: function get(i) {
        return SVG.adopt(this.node.childNodes[i]);
      },
      // Get first child
      first: function first() {
        return this.get(0);
      },
      // Get the last child
      last: function last() {
        return this.get(this.node.childNodes.length - 1);
      },
      // Iterates over all children and invokes a given block
      each: function each(block, deep) {
        var i,
            il,
            children = this.children();

        for (i = 0, il = children.length; i < il; i++) {
          if (children[i] instanceof SVG.Element) {
            block.apply(children[i], [i, children]);
          }

          if (deep && children[i] instanceof SVG.Container) {
            children[i].each(block, deep);
          }
        }

        return this;
      },
      // Remove a given child
      removeElement: function removeElement(element) {
        this.node.removeChild(element.node);
        return this;
      },
      // Remove all elements in this container
      clear: function clear() {
        // remove children
        while (this.node.hasChildNodes()) {
          this.node.removeChild(this.node.lastChild);
        } // remove defs reference


        delete this._defs;
        return this;
      },
      // Get defs
      defs: function defs() {
        return this.doc().defs();
      }
    }
  });
  SVG.extend(SVG.Parent, {
    ungroup: function ungroup(parent, depth) {
      if (depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this;
      parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent));
      depth = depth || Infinity;
      this.each(function () {
        if (this instanceof SVG.Defs) return this;
        if (this instanceof SVG.Parent) return this.ungroup(parent, depth - 1);
        return this.toParent(parent);
      });
      this.node.firstChild || this.remove();
      return this;
    },
    flatten: function flatten(parent, depth) {
      return this.ungroup(parent, depth);
    }
  });
  SVG.Container = SVG.invent({
    // Initialize node
    create: function create(element) {
      this.constructor.call(this, element);
    },
    // Inherit from
    inherit: SVG.Parent
  });
  SVG.ViewBox = SVG.invent({
    create: function create(source) {
      var base = [0, 0, 0, 0];
      var x,
          y,
          width,
          height,
          box,
          view,
          we,
          he,
          wm = 1,
          // width multiplier
      hm = 1,
          // height multiplier
      reg = /[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?/gi;

      if (source instanceof SVG.Element) {
        we = source;
        he = source;
        view = (source.attr('viewBox') || '').match(reg);
        box = source.bbox; // get dimensions of current node

        width = new SVG.Number(source.width());
        height = new SVG.Number(source.height()); // find nearest non-percentual dimensions

        while (width.unit == '%') {
          wm *= width.value;
          width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width());
          we = we.parent();
        }

        while (height.unit == '%') {
          hm *= height.value;
          height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height());
          he = he.parent();
        } // ensure defaults


        this.x = 0;
        this.y = 0;
        this.width = width * wm;
        this.height = height * hm;
        this.zoom = 1;

        if (view) {
          // get width and height from viewbox
          x = parseFloat(view[0]);
          y = parseFloat(view[1]);
          width = parseFloat(view[2]);
          height = parseFloat(view[3]); // calculate zoom accoring to viewbox

          this.zoom = this.width / this.height > width / height ? this.height / height : this.width / width; // calculate real pixel dimensions on parent SVG.Doc element

          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
        }
      } else {
        // ensure source as object
        source = typeof source === 'string' ? source.match(reg).map(function (el) {
          return parseFloat(el);
        }) : Array.isArray(source) ? source : _typeof(source) === 'object' ? [source.x, source.y, source.width, source.height] : arguments.length == 4 ? [].slice.call(arguments) : base;
        this.x = source[0];
        this.y = source[1];
        this.width = source[2];
        this.height = source[3];
      }
    },
    extend: {
      toString: function toString() {
        return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;
      },
      morph: function morph(x, y, width, height) {
        this.destination = new SVG.ViewBox(x, y, width, height);
        return this;
      },
      at: function at(pos) {
        if (!this.destination) return this;
        return new SVG.ViewBox([this.x + (this.destination.x - this.x) * pos, this.y + (this.destination.y - this.y) * pos, this.width + (this.destination.width - this.width) * pos, this.height + (this.destination.height - this.height) * pos]);
      }
    },
    // Define parent
    parent: SVG.Container,
    // Add parent method
    construct: {
      // get/set viewbox
      viewbox: function viewbox(x, y, width, height) {
        if (arguments.length == 0) // act as a getter if there are no arguments
          {
            return new SVG.ViewBox(this);
          } // otherwise act as a setter


        return this.attr('viewBox', new SVG.ViewBox(x, y, width, height));
      }
    }
  }) // Add events to elements
  ;
  ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', // , 'mouseenter' -> not supported by IE
  // , 'mouseleave' -> not supported by IE
  'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].forEach(function (event) {
    // add event to SVG.Element
    SVG.Element.prototype[event] = function (f) {
      // bind event to element rather than element node
      SVG.on(this.node, event, f);
      return this;
    };
  }); // Initialize listeners stack

  SVG.listeners = [];
  SVG.handlerMap = [];
  SVG.listenerId = 0; // Add event binder in the SVG namespace

  SVG.on = function (node, event, listener, binding, options) {
    // create listener, get object-index
    var l = listener.bind(binding || node.instance || node),
        index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1,
        ev = event.split('.')[0],
        ns = event.split('.')[1] || '*'; // ensure valid object

    SVG.listeners[index] = SVG.listeners[index] || {};
    SVG.listeners[index][ev] = SVG.listeners[index][ev] || {};
    SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {};

    if (!listener._svgjsListenerId) {
      listener._svgjsListenerId = ++SVG.listenerId;
    } // reference listener


    SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l; // add listener

    node.addEventListener(ev, l, options || false);
  }; // Add event unbinder in the SVG namespace


  SVG.off = function (node, event, listener) {
    var index = SVG.handlerMap.indexOf(node),
        ev = event && event.split('.')[0],
        ns = event && event.split('.')[1],
        namespace = '';
    if (index == -1) return;

    if (listener) {
      if (typeof listener === 'function') listener = listener._svgjsListenerId;
      if (!listener) return; // remove listener reference

      if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {
        // remove listener
        node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false);
        delete SVG.listeners[index][ev][ns || '*'][listener];
      }
    } else if (ns && ev) {
      // remove all listeners for a namespaced event
      if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {
        for (listener in SVG.listeners[index][ev][ns]) {
          SVG.off(node, [ev, ns].join('.'), listener);
        }

        delete SVG.listeners[index][ev][ns];
      }
    } else if (ns) {
      // remove all listeners for a specific namespace
      for (event in SVG.listeners[index]) {
        for (namespace in SVG.listeners[index][event]) {
          if (ns === namespace) {
            SVG.off(node, [event, ns].join('.'));
          }
        }
      }
    } else if (ev) {
      // remove all listeners for the event
      if (SVG.listeners[index][ev]) {
        for (namespace in SVG.listeners[index][ev]) {
          SVG.off(node, [ev, namespace].join('.'));
        }

        delete SVG.listeners[index][ev];
      }
    } else {
      // remove all listeners on a given node
      for (event in SVG.listeners[index]) {
        SVG.off(node, event);
      }

      delete SVG.listeners[index];
      delete SVG.handlerMap[index];
    }
  }; //


  SVG.extend(SVG.Element, {
    // Bind given event to listener
    on: function on(event, listener, binding, options) {
      SVG.on(this.node, event, listener, binding, options);
      return this;
    },
    // Unbind event from listener
    off: function off(event, listener) {
      SVG.off(this.node, event, listener);
      return this;
    },
    // Fire given event
    fire: function fire(event, data) {
      // Dispatch event
      if (event instanceof window.Event) {
        this.node.dispatchEvent(event);
      } else {
        this.node.dispatchEvent(event = new SVG.CustomEvent(event, {
          detail: data,
          cancelable: true
        }));
      }

      this._event = event;
      return this;
    },
    event: function event() {
      return this._event;
    }
  });
  SVG.Defs = SVG.invent({
    // Initialize node
    create: 'defs',
    // Inherit from
    inherit: SVG.Container
  });
  SVG.G = SVG.invent({
    // Initialize node
    create: 'g',
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Move over x-axis
      x: function x(_x3) {
        return _x3 == null ? this.transform('x') : this.transform({
          x: _x3 - this.x()
        }, true);
      },
      // Move over y-axis
      y: function y(_y3) {
        return _y3 == null ? this.transform('y') : this.transform({
          y: _y3 - this.y()
        }, true);
      },
      // Move by center over x-axis
      cx: function cx(x) {
        return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2);
      },
      // Move by center over y-axis
      cy: function cy(y) {
        return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2);
      },
      gbox: function gbox() {
        var bbox = this.bbox(),
            trans = this.transform();
        bbox.x += trans.x;
        bbox.x2 += trans.x;
        bbox.cx += trans.x;
        bbox.y += trans.y;
        bbox.y2 += trans.y;
        bbox.cy += trans.y;
        return bbox;
      }
    },
    // Add parent method
    construct: {
      // Create a group element
      group: function group() {
        return this.put(new SVG.G());
      }
    }
  });
  SVG.Doc = SVG.invent({
    // Initialize node
    create: function create(element) {
      if (element) {
        // ensure the presence of a dom element
        element = typeof element === 'string' ? document.getElementById(element) : element; // If the target is an svg element, use that element as the main wrapper.
        // This allows svg.js to work with svg documents as well.

        if (element.nodeName == 'svg') {
          this.constructor.call(this, element);
        } else {
          this.constructor.call(this, SVG.create('svg'));
          element.appendChild(this.node);
          this.size('100%', '100%');
        } // set svg element attributes and ensure defs node


        this.namespace().defs();
      }
    },
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Add namespaces
      namespace: function namespace() {
        return this.attr({
          xmlns: SVG.ns,
          version: '1.1'
        }).attr('xmlns:xlink', SVG.xlink, SVG.xmlns).attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns);
      },
      // Creates and returns defs element
      defs: function defs() {
        if (!this._defs) {
          var defs; // Find or create a defs element in this instance

          if (defs = this.node.getElementsByTagName('defs')[0]) {
            this._defs = SVG.adopt(defs);
          } else {
            this._defs = new SVG.Defs();
          } // Make sure the defs node is at the end of the stack


          this.node.appendChild(this._defs.node);
        }

        return this._defs;
      },
      // custom parent method
      parent: function parent() {
        if (!this.node.parentNode || this.node.parentNode.nodeName == '#document') return null;
        return this.node.parentNode;
      },
      // Fix for possible sub-pixel offset. See:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=608812
      spof: function spof() {
        var pos = this.node.getScreenCTM();

        if (pos) {
          this.style('left', -pos.e % 1 + 'px').style('top', -pos.f % 1 + 'px');
        }

        return this;
      },
      // Removes the doc from the DOM
      remove: function remove() {
        if (this.parent()) {
          this.parent().removeChild(this.node);
        }

        return this;
      },
      clear: function clear() {
        // remove children
        while (this.node.hasChildNodes()) {
          this.node.removeChild(this.node.lastChild);
        } // remove defs reference


        delete this._defs; // add back parser

        if (SVG.parser.draw && !SVG.parser.draw.parentNode) {
          this.node.appendChild(SVG.parser.draw);
        }

        return this;
      },
      clone: function clone(parent) {
        // write dom data to the dom so the clone can pickup the data
        this.writeDataToDom(); // get reference to node

        var node = this.node; // clone element and assign new id

        var clone = assignNewId(node.cloneNode(true)); // insert the clone in the given parent or after myself

        if (parent) {
          (parent.node || parent).appendChild(clone.node);
        } else {
          node.parentNode.insertBefore(clone.node, node.nextSibling);
        }

        return clone;
      }
    }
  }); // ### This module adds backward / forward functionality to elements.
  //

  SVG.extend(SVG.Element, {
    // Get all siblings, including myself
    siblings: function siblings() {
      return this.parent().children();
    },
    // Get the curent position siblings
    position: function position() {
      return this.parent().index(this);
    },
    // Get the next element (will return null if there is none)
    next: function next() {
      return this.siblings()[this.position() + 1];
    },
    // Get the next element (will return null if there is none)
    previous: function previous() {
      return this.siblings()[this.position() - 1];
    },
    // Send given element one step forward
    forward: function forward() {
      var i = this.position() + 1,
          p = this.parent(); // move node one step forward

      p.removeElement(this).add(this, i); // make sure defs node is always at the top

      if (p instanceof SVG.Doc) {
        p.node.appendChild(p.defs().node);
      }

      return this;
    },
    // Send given element one step backward
    backward: function backward() {
      var i = this.position();

      if (i > 0) {
        this.parent().removeElement(this).add(this, i - 1);
      }

      return this;
    },
    // Send given element all the way to the front
    front: function front() {
      var p = this.parent(); // Move node forward

      p.node.appendChild(this.node); // Make sure defs node is always at the top

      if (p instanceof SVG.Doc) {
        p.node.appendChild(p.defs().node);
      }

      return this;
    },
    // Send given element all the way to the back
    back: function back() {
      if (this.position() > 0) {
        this.parent().removeElement(this).add(this, 0);
      }

      return this;
    },
    // Inserts a given element before the targeted element
    before: function before(element) {
      element.remove();
      var i = this.position();
      this.parent().add(element, i);
      return this;
    },
    // Insters a given element after the targeted element
    after: function after(element) {
      element.remove();
      var i = this.position();
      this.parent().add(element, i + 1);
      return this;
    }
  });
  SVG.Mask = SVG.invent({
    // Initialize node
    create: function create() {
      this.constructor.call(this, SVG.create('mask')); // keep references to masked elements

      this.targets = [];
    },
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Unmask all masked elements and remove itself
      remove: function remove() {
        // unmask all targets
        for (var i = this.targets.length - 1; i >= 0; i--) {
          if (this.targets[i]) {
            this.targets[i].unmask();
          }
        }

        this.targets = []; // remove mask from parent

        SVG.Element.prototype.remove.call(this);
        return this;
      }
    },
    // Add parent method
    construct: {
      // Create masking element
      mask: function mask() {
        return this.defs().put(new SVG.Mask());
      }
    }
  });
  SVG.extend(SVG.Element, {
    // Distribute mask to svg element
    maskWith: function maskWith(element) {
      // use given mask or create a new one
      this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element); // store reverence on self in mask

      this.masker.targets.push(this); // apply mask

      return this.attr('mask', 'url("#' + this.masker.attr('id') + '")');
    },
    // Unmask element
    unmask: function unmask() {
      delete this.masker;
      return this.attr('mask', null);
    }
  });
  SVG.ClipPath = SVG.invent({
    // Initialize node
    create: function create() {
      this.constructor.call(this, SVG.create('clipPath')); // keep references to clipped elements

      this.targets = [];
    },
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Unclip all clipped elements and remove itself
      remove: function remove() {
        // unclip all targets
        for (var i = this.targets.length - 1; i >= 0; i--) {
          if (this.targets[i]) {
            this.targets[i].unclip();
          }
        }

        this.targets = []; // remove clipPath from parent

        this.parent().removeElement(this);
        return this;
      }
    },
    // Add parent method
    construct: {
      // Create clipping element
      clip: function clip() {
        return this.defs().put(new SVG.ClipPath());
      }
    }
  }); //

  SVG.extend(SVG.Element, {
    // Distribute clipPath to svg element
    clipWith: function clipWith(element) {
      // use given clip or create a new one
      this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element); // store reverence on self in mask

      this.clipper.targets.push(this); // apply mask

      return this.attr('clip-path', 'url("#' + this.clipper.attr('id') + '")');
    },
    // Unclip element
    unclip: function unclip() {
      delete this.clipper;
      return this.attr('clip-path', null);
    }
  });
  SVG.Gradient = SVG.invent({
    // Initialize node
    create: function create(type) {
      this.constructor.call(this, SVG.create(type + 'Gradient')); // store type

      this.type = type;
    },
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Add a color stop
      at: function at(offset, color, opacity) {
        return this.put(new SVG.Stop()).update(offset, color, opacity);
      },
      // Update gradient
      update: function update(block) {
        // remove all stops
        this.clear(); // invoke passed block

        if (typeof block === 'function') {
          block.call(this, this);
        }

        return this;
      },
      // Return the fill id
      fill: function fill() {
        return 'url(#' + this.id() + ')';
      },
      // Alias string convertion to fill
      toString: function toString() {
        return this.fill();
      },
      // custom attr to handle transform
      attr: function attr(a, b, c) {
        if (a == 'transform') a = 'gradientTransform';
        return SVG.Container.prototype.attr.call(this, a, b, c);
      }
    },
    // Add parent method
    construct: {
      // Create gradient element in defs
      gradient: function gradient(type, block) {
        return this.defs().gradient(type, block);
      }
    }
  }); // Add animatable methods to both gradient and fx module

  SVG.extend(SVG.Gradient, SVG.FX, {
    // From position
    from: function from(x, y) {
      return (this._target || this).type == 'radial' ? this.attr({
        fx: new SVG.Number(x),
        fy: new SVG.Number(y)
      }) : this.attr({
        x1: new SVG.Number(x),
        y1: new SVG.Number(y)
      });
    },
    // To position
    to: function to(x, y) {
      return (this._target || this).type == 'radial' ? this.attr({
        cx: new SVG.Number(x),
        cy: new SVG.Number(y)
      }) : this.attr({
        x2: new SVG.Number(x),
        y2: new SVG.Number(y)
      });
    }
  }); // Base gradient generation

  SVG.extend(SVG.Defs, {
    // define gradient
    gradient: function gradient(type, block) {
      return this.put(new SVG.Gradient(type)).update(block);
    }
  });
  SVG.Stop = SVG.invent({
    // Initialize node
    create: 'stop',
    // Inherit from
    inherit: SVG.Element,
    // Add class methods
    extend: {
      // add color stops
      update: function update(o) {
        if (typeof o === 'number' || o instanceof SVG.Number) {
          o = {
            offset: arguments[0],
            color: arguments[1],
            opacity: arguments[2]
          };
        } // set attributes


        if (o.opacity != null) this.attr('stop-opacity', o.opacity);
        if (o.color != null) this.attr('stop-color', o.color);
        if (o.offset != null) this.attr('offset', new SVG.Number(o.offset));
        return this;
      }
    }
  });
  SVG.Pattern = SVG.invent({
    // Initialize node
    create: 'pattern',
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Return the fill id
      fill: function fill() {
        return 'url(#' + this.id() + ')';
      },
      // Update pattern by rebuilding
      update: function update(block) {
        // remove content
        this.clear(); // invoke passed block

        if (typeof block === 'function') {
          block.call(this, this);
        }

        return this;
      },
      // Alias string convertion to fill
      toString: function toString() {
        return this.fill();
      },
      // custom attr to handle transform
      attr: function attr(a, b, c) {
        if (a == 'transform') a = 'patternTransform';
        return SVG.Container.prototype.attr.call(this, a, b, c);
      }
    },
    // Add parent method
    construct: {
      // Create pattern element in defs
      pattern: function pattern(width, height, block) {
        return this.defs().pattern(width, height, block);
      }
    }
  });
  SVG.extend(SVG.Defs, {
    // Define gradient
    pattern: function pattern(width, height, block) {
      return this.put(new SVG.Pattern()).update(block).attr({
        x: 0,
        y: 0,
        width: width,
        height: height,
        patternUnits: 'userSpaceOnUse'
      });
    }
  });
  SVG.Shape = SVG.invent({
    // Initialize node
    create: function create(element) {
      this.constructor.call(this, element);
    },
    // Inherit from
    inherit: SVG.Element
  });
  SVG.Bare = SVG.invent({
    // Initialize
    create: function create(element, inherit) {
      // construct element
      this.constructor.call(this, SVG.create(element)); // inherit custom methods

      if (inherit) {
        for (var method in inherit.prototype) {
          if (typeof inherit.prototype[method] === 'function') {
            this[method] = inherit.prototype[method];
          }
        }
      }
    },
    // Inherit from
    inherit: SVG.Element,
    // Add methods
    extend: {
      // Insert some plain text
      words: function words(text) {
        // remove contents
        while (this.node.hasChildNodes()) {
          this.node.removeChild(this.node.lastChild);
        } // create text node


        this.node.appendChild(document.createTextNode(text));
        return this;
      }
    }
  });
  SVG.extend(SVG.Parent, {
    // Create an element that is not described by SVG.js
    element: function element(_element, inherit) {
      return this.put(new SVG.Bare(_element, inherit));
    }
  });
  SVG.Symbol = SVG.invent({
    // Initialize node
    create: 'symbol',
    // Inherit from
    inherit: SVG.Container,
    construct: {
      // create symbol
      symbol: function symbol() {
        return this.put(new SVG.Symbol());
      }
    }
  });
  SVG.Use = SVG.invent({
    // Initialize node
    create: 'use',
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // Use element as a reference
      element: function element(_element2, file) {
        // Set lined element
        return this.attr('href', (file || '') + '#' + _element2, SVG.xlink);
      }
    },
    // Add parent method
    construct: {
      // Create a use element
      use: function use(element, file) {
        return this.put(new SVG.Use()).element(element, file);
      }
    }
  });
  SVG.Rect = SVG.invent({
    // Initialize node
    create: 'rect',
    // Inherit from
    inherit: SVG.Shape,
    // Add parent method
    construct: {
      // Create a rect element
      rect: function rect(width, height) {
        return this.put(new SVG.Rect()).size(width, height);
      }
    }
  });
  SVG.Circle = SVG.invent({
    // Initialize node
    create: 'circle',
    // Inherit from
    inherit: SVG.Shape,
    // Add parent method
    construct: {
      // Create circle element, based on ellipse
      circle: function circle(size) {
        return this.put(new SVG.Circle()).rx(new SVG.Number(size).divide(2)).move(0, 0);
      }
    }
  });
  SVG.extend(SVG.Circle, SVG.FX, {
    // Radius x value
    rx: function rx(_rx) {
      return this.attr('r', _rx);
    },
    // Alias radius x value
    ry: function ry(_ry) {
      return this.rx(_ry);
    }
  });
  SVG.Ellipse = SVG.invent({
    // Initialize node
    create: 'ellipse',
    // Inherit from
    inherit: SVG.Shape,
    // Add parent method
    construct: {
      // Create an ellipse
      ellipse: function ellipse(width, height) {
        return this.put(new SVG.Ellipse()).size(width, height).move(0, 0);
      }
    }
  });
  SVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {
    // Radius x value
    rx: function rx(_rx2) {
      return this.attr('rx', _rx2);
    },
    // Radius y value
    ry: function ry(_ry2) {
      return this.attr('ry', _ry2);
    }
  }); // Add common method

  SVG.extend(SVG.Circle, SVG.Ellipse, {
    // Move over x-axis
    x: function x(_x4) {
      return _x4 == null ? this.cx() - this.rx() : this.cx(_x4 + this.rx());
    },
    // Move over y-axis
    y: function y(_y4) {
      return _y4 == null ? this.cy() - this.ry() : this.cy(_y4 + this.ry());
    },
    // Move by center over x-axis
    cx: function cx(x) {
      return x == null ? this.attr('cx') : this.attr('cx', x);
    },
    // Move by center over y-axis
    cy: function cy(y) {
      return y == null ? this.attr('cy') : this.attr('cy', y);
    },
    // Set width of element
    width: function width(_width3) {
      return _width3 == null ? this.rx() * 2 : this.rx(new SVG.Number(_width3).divide(2));
    },
    // Set height of element
    height: function height(_height3) {
      return _height3 == null ? this.ry() * 2 : this.ry(new SVG.Number(_height3).divide(2));
    },
    // Custom size function
    size: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.rx(new SVG.Number(p.width).divide(2)).ry(new SVG.Number(p.height).divide(2));
    }
  });
  SVG.Line = SVG.invent({
    // Initialize node
    create: 'line',
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // Get array
      array: function array() {
        return new SVG.PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);
      },
      // Overwrite native plot() method
      plot: function plot(x1, y1, x2, y2) {
        if (x1 == null) {
          return this.array();
        } else if (typeof y1 !== 'undefined') {
          x1 = {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          };
        } else {
          x1 = new SVG.PointArray(x1).toLine();
        }

        return this.attr(x1);
      },
      // Move by left top corner
      move: function move(x, y) {
        return this.attr(this.array().move(x, y).toLine());
      },
      // Set element size to given width and height
      size: function size(width, height) {
        var p = proportionalSize(this, width, height);
        return this.attr(this.array().size(p.width, p.height).toLine());
      }
    },
    // Add parent method
    construct: {
      // Create a line element
      line: function line(x1, y1, x2, y2) {
        // make sure plot is called as a setter
        // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray
        return SVG.Line.prototype.plot.apply(this.put(new SVG.Line()), x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]);
      }
    }
  });
  SVG.Polyline = SVG.invent({
    // Initialize node
    create: 'polyline',
    // Inherit from
    inherit: SVG.Shape,
    // Add parent method
    construct: {
      // Create a wrapped polyline element
      polyline: function polyline(p) {
        // make sure plot is called as a setter
        return this.put(new SVG.Polyline()).plot(p || new SVG.PointArray());
      }
    }
  });
  SVG.Polygon = SVG.invent({
    // Initialize node
    create: 'polygon',
    // Inherit from
    inherit: SVG.Shape,
    // Add parent method
    construct: {
      // Create a wrapped polygon element
      polygon: function polygon(p) {
        // make sure plot is called as a setter
        return this.put(new SVG.Polygon()).plot(p || new SVG.PointArray());
      }
    }
  }); // Add polygon-specific functions

  SVG.extend(SVG.Polyline, SVG.Polygon, {
    // Get array
    array: function array() {
      return this._array || (this._array = new SVG.PointArray(this.attr('points')));
    },
    // Plot new path
    plot: function plot(p) {
      return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new SVG.PointArray(p));
    },
    // Clear array cache
    clear: function clear() {
      delete this._array;
      return this;
    },
    // Move by left top corner
    move: function move(x, y) {
      return this.attr('points', this.array().move(x, y));
    },
    // Set element size to given width and height
    size: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.attr('points', this.array().size(p.width, p.height));
    }
  }); // unify all point to point elements

  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {
    // Define morphable array
    morphArray: SVG.PointArray,
    // Move by left top corner over x-axis
    x: function x(_x5) {
      return _x5 == null ? this.bbox().x : this.move(_x5, this.bbox().y);
    },
    // Move by left top corner over y-axis
    y: function y(_y5) {
      return _y5 == null ? this.bbox().y : this.move(this.bbox().x, _y5);
    },
    // Set width of element
    width: function width(_width4) {
      var b = this.bbox();
      return _width4 == null ? b.width : this.size(_width4, b.height);
    },
    // Set height of element
    height: function height(_height4) {
      var b = this.bbox();
      return _height4 == null ? b.height : this.size(b.width, _height4);
    }
  });
  SVG.Path = SVG.invent({
    // Initialize node
    create: 'path',
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // Define morphable array
      morphArray: SVG.PathArray,
      // Get array
      array: function array() {
        return this._array || (this._array = new SVG.PathArray(this.attr('d')));
      },
      // Plot new path
      plot: function plot(d) {
        return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new SVG.PathArray(d));
      },
      // Clear array cache
      clear: function clear() {
        delete this._array;
        return this;
      },
      // Move by left top corner
      move: function move(x, y) {
        return this.attr('d', this.array().move(x, y));
      },
      // Move by left top corner over x-axis
      x: function x(_x6) {
        return _x6 == null ? this.bbox().x : this.move(_x6, this.bbox().y);
      },
      // Move by left top corner over y-axis
      y: function y(_y6) {
        return _y6 == null ? this.bbox().y : this.move(this.bbox().x, _y6);
      },
      // Set element size to given width and height
      size: function size(width, height) {
        var p = proportionalSize(this, width, height);
        return this.attr('d', this.array().size(p.width, p.height));
      },
      // Set width of element
      width: function width(_width5) {
        return _width5 == null ? this.bbox().width : this.size(_width5, this.bbox().height);
      },
      // Set height of element
      height: function height(_height5) {
        return _height5 == null ? this.bbox().height : this.size(this.bbox().width, _height5);
      }
    },
    // Add parent method
    construct: {
      // Create a wrapped path element
      path: function path(d) {
        // make sure plot is called as a setter
        return this.put(new SVG.Path()).plot(d || new SVG.PathArray());
      }
    }
  });
  SVG.Image = SVG.invent({
    // Initialize node
    create: 'image',
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // (re)load image
      load: function load(url) {
        if (!url) return this;
        var self = this,
            img = new window.Image(); // preload image

        SVG.on(img, 'load', function () {
          SVG.off(img);
          var p = self.parent(SVG.Pattern);
          if (p === null) return; // ensure image size

          if (self.width() == 0 && self.height() == 0) {
            self.size(img.width, img.height);
          } // ensure pattern size if not set


          if (p && p.width() == 0 && p.height() == 0) {
            p.size(self.width(), self.height());
          } // callback


          if (typeof self._loaded === 'function') {
            self._loaded.call(self, {
              width: img.width,
              height: img.height,
              ratio: img.width / img.height,
              url: url
            });
          }
        });
        SVG.on(img, 'error', function (e) {
          SVG.off(img);

          if (typeof self._error === 'function') {
            self._error.call(self, e);
          }
        });
        return this.attr('href', img.src = this.src = url, SVG.xlink);
      },
      // Add loaded callback
      loaded: function loaded(_loaded) {
        this._loaded = _loaded;
        return this;
      },
      error: function error(_error) {
        this._error = _error;
        return this;
      }
    },
    // Add parent method
    construct: {
      // create image element, load image and set its size
      image: function image(source, width, height) {
        return this.put(new SVG.Image()).load(source).size(width || 0, height || width || 0);
      }
    }
  });
  SVG.Text = SVG.invent({
    // Initialize node
    create: function create() {
      this.constructor.call(this, SVG.create('text'));
      this.dom.leading = new SVG.Number(1.3); // store leading value for rebuilding

      this._rebuild = true; // enable automatic updating of dy values

      this._build = false; // disable build mode for adding multiple lines
      // set default font

      this.attr('font-family', SVG.defaults.attrs['font-family']);
    },
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // Move over x-axis
      x: function x(_x7) {
        // act as getter
        if (_x7 == null) {
          return this.attr('x');
        }

        return this.attr('x', _x7);
      },
      // Move over y-axis
      y: function y(_y7) {
        var oy = this.attr('y'),
            o = typeof oy === 'number' ? oy - this.bbox().y : 0; // act as getter

        if (_y7 == null) {
          return typeof oy === 'number' ? oy - o : oy;
        }

        return this.attr('y', typeof _y7.valueOf() === 'number' ? _y7 + o : _y7);
      },
      // Move center over x-axis
      cx: function cx(x) {
        return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2);
      },
      // Move center over y-axis
      cy: function cy(y) {
        return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2);
      },
      // Set the text content
      text: function text(_text) {
        // act as getter
        if (typeof _text === 'undefined') {
          var _text = '';
          var children = this.node.childNodes;

          for (var i = 0, len = children.length; i < len; ++i) {
            // add newline if its not the first child and newLined is set to true
            if (i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true) {
              _text += '\n';
            } // add content of this node


            _text += children[i].textContent;
          }

          return _text;
        } // remove existing content


        this.clear().build(true);

        if (typeof _text === 'function') {
          // call block
          _text.call(this, this);
        } else {
          // store text and make sure text is not blank
          _text = _text.split('\n'); // build new lines

          for (var i = 0, il = _text.length; i < il; i++) {
            this.tspan(_text[i]).newLine();
          }
        } // disable build mode and rebuild lines


        return this.build(false).rebuild();
      },
      // Set font size
      size: function size(_size) {
        return this.attr('font-size', _size).rebuild();
      },
      // Set / get leading
      leading: function leading(value) {
        // act as getter
        if (value == null) {
          return this.dom.leading;
        } // act as setter


        this.dom.leading = new SVG.Number(value);
        return this.rebuild();
      },
      // Get all the first level lines
      lines: function lines() {
        var node = (this.textPath && this.textPath() || this).node; // filter tspans and map them to SVG.js instances

        var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function (el) {
          return SVG.adopt(el);
        }); // return an instance of SVG.set

        return new SVG.Set(lines);
      },
      // Rebuild appearance type
      rebuild: function rebuild(_rebuild) {
        // store new rebuild flag if given
        if (typeof _rebuild === 'boolean') {
          this._rebuild = _rebuild;
        } // define position of all lines


        if (this._rebuild) {
          var self = this,
              blankLineOffset = 0,
              dy = this.dom.leading * new SVG.Number(this.attr('font-size'));
          this.lines().each(function () {
            if (this.dom.newLined) {
              if (!self.textPath()) {
                this.attr('x', self.attr('x'));
              }

              if (this.text() == '\n') {
                blankLineOffset += dy;
              } else {
                this.attr('dy', dy + blankLineOffset);
                blankLineOffset = 0;
              }
            }
          });
          this.fire('rebuild');
        }

        return this;
      },
      // Enable / disable build mode
      build: function build(_build) {
        this._build = !!_build;
        return this;
      },
      // overwrite method from parent to set data properly
      setData: function setData(o) {
        this.dom = o;
        this.dom.leading = new SVG.Number(o.leading || 1.3);
        return this;
      }
    },
    // Add parent method
    construct: {
      // Create text element
      text: function text(_text2) {
        return this.put(new SVG.Text()).text(_text2);
      },
      // Create plain text element
      plain: function plain(text) {
        return this.put(new SVG.Text()).plain(text);
      }
    }
  });
  SVG.Tspan = SVG.invent({
    // Initialize node
    create: 'tspan',
    // Inherit from
    inherit: SVG.Shape,
    // Add class methods
    extend: {
      // Set text content
      text: function text(_text3) {
        if (_text3 == null) return this.node.textContent + (this.dom.newLined ? '\n' : '');
        typeof _text3 === 'function' ? _text3.call(this, this) : this.plain(_text3);
        return this;
      },
      // Shortcut dx
      dx: function dx(_dx) {
        return this.attr('dx', _dx);
      },
      // Shortcut dy
      dy: function dy(_dy) {
        return this.attr('dy', _dy);
      },
      // Create new line
      newLine: function newLine() {
        // fetch text parent
        var t = this.parent(SVG.Text); // mark new line

        this.dom.newLined = true; // apply new hyn

        return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x());
      }
    }
  });
  SVG.extend(SVG.Text, SVG.Tspan, {
    // Create plain text node
    plain: function plain(text) {
      // clear if build mode is disabled
      if (this._build === false) {
        this.clear();
      } // create text node


      this.node.appendChild(document.createTextNode(text));
      return this;
    },
    // Create a tspan
    tspan: function tspan(text) {
      var node = (this.textPath && this.textPath() || this).node,
          tspan = new SVG.Tspan(); // clear if build mode is disabled

      if (this._build === false) {
        this.clear();
      } // add new tspan


      node.appendChild(tspan.node);
      return tspan.text(text);
    },
    // Clear all lines
    clear: function clear() {
      var node = (this.textPath && this.textPath() || this).node; // remove existing child nodes

      while (node.hasChildNodes()) {
        node.removeChild(node.lastChild);
      }

      return this;
    },
    // Get length of text element
    length: function length() {
      return this.node.getComputedTextLength();
    }
  });
  SVG.TextPath = SVG.invent({
    // Initialize node
    create: 'textPath',
    // Inherit from
    inherit: SVG.Parent,
    // Define parent class
    parent: SVG.Text,
    // Add parent method
    construct: {
      morphArray: SVG.PathArray,
      // Create path for text to run on
      path: function path(d) {
        // create textPath element
        var path = new SVG.TextPath(),
            track = this.doc().defs().path(d); // move lines to textpath

        while (this.node.hasChildNodes()) {
          path.node.appendChild(this.node.firstChild);
        } // add textPath element as child node


        this.node.appendChild(path.node); // link textPath to path and add content

        path.attr('href', '#' + track, SVG.xlink);
        return this;
      },
      // return the array of the path track element
      array: function array() {
        var track = this.track();
        return track ? track.array() : null;
      },
      // Plot path if any
      plot: function plot(d) {
        var track = this.track(),
            pathArray = null;

        if (track) {
          pathArray = track.plot(d);
        }

        return d == null ? pathArray : this;
      },
      // Get the path track element
      track: function track() {
        var path = this.textPath();

        if (path) {
          return path.reference('href');
        }
      },
      // Get the textPath child
      textPath: function textPath() {
        if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath') {
          return SVG.adopt(this.node.firstChild);
        }
      }
    }
  });
  SVG.Nested = SVG.invent({
    // Initialize node
    create: function create() {
      this.constructor.call(this, SVG.create('svg'));
      this.style('overflow', 'visible');
    },
    // Inherit from
    inherit: SVG.Container,
    // Add parent method
    construct: {
      // Create nested svg document
      nested: function nested() {
        return this.put(new SVG.Nested());
      }
    }
  });
  SVG.A = SVG.invent({
    // Initialize node
    create: 'a',
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Link url
      to: function to(url) {
        return this.attr('href', url, SVG.xlink);
      },
      // Link show attribute
      show: function show(target) {
        return this.attr('show', target, SVG.xlink);
      },
      // Link target attribute
      target: function target(_target2) {
        return this.attr('target', _target2);
      }
    },
    // Add parent method
    construct: {
      // Create a hyperlink element
      link: function link(url) {
        return this.put(new SVG.A()).to(url);
      }
    }
  });
  SVG.extend(SVG.Element, {
    // Create a hyperlink element
    linkTo: function linkTo(url) {
      var link = new SVG.A();

      if (typeof url === 'function') {
        url.call(link, link);
      } else {
        link.to(url);
      }

      return this.parent().put(link).put(this);
    }
  });
  SVG.Marker = SVG.invent({
    // Initialize node
    create: 'marker',
    // Inherit from
    inherit: SVG.Container,
    // Add class methods
    extend: {
      // Set width of element
      width: function width(_width6) {
        return this.attr('markerWidth', _width6);
      },
      // Set height of element
      height: function height(_height6) {
        return this.attr('markerHeight', _height6);
      },
      // Set marker refX and refY
      ref: function ref(x, y) {
        return this.attr('refX', x).attr('refY', y);
      },
      // Update marker
      update: function update(block) {
        // remove all content
        this.clear(); // invoke passed block

        if (typeof block === 'function') {
          block.call(this, this);
        }

        return this;
      },
      // Return the fill id
      toString: function toString() {
        return 'url(#' + this.id() + ')';
      }
    },
    // Add parent method
    construct: {
      marker: function marker(width, height, block) {
        // Create marker element in defs
        return this.defs().marker(width, height, block);
      }
    }
  });
  SVG.extend(SVG.Defs, {
    // Create marker
    marker: function marker(width, height, block) {
      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
      return this.put(new SVG.Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);
    }
  });
  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {
    // Create and attach markers
    marker: function marker(_marker, width, height, block) {
      var attr = ['marker']; // Build attribute name

      if (_marker != 'all') attr.push(_marker);
      attr = attr.join('-'); // Set marker attribute

      _marker = arguments[1] instanceof SVG.Marker ? arguments[1] : this.doc().marker(width, height, block);
      return this.attr(attr, _marker);
    }
  }); // Define list of available attributes for stroke and fill

  var sugar = {
    stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],
    fill: ['color', 'opacity', 'rule'],
    prefix: function prefix(t, a) {
      return a == 'color' ? t : t + '-' + a;
    } // Add sugar for fill and stroke

  };
  ['fill', 'stroke'].forEach(function (m) {
    var i,
        extension = {};

    extension[m] = function (o) {
      if (typeof o === 'undefined') {
        return this;
      }

      if (typeof o === 'string' || SVG.Color.isRgb(o) || o && typeof o.fill === 'function') {
        this.attr(m, o);
      } else // set all attributes from sugar.fill and sugar.stroke list
        {
          for (i = sugar[m].length - 1; i >= 0; i--) {
            if (o[sugar[m][i]] != null) {
              this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
            }
          }
        }

      return this;
    };

    SVG.extend(SVG.Element, SVG.FX, extension);
  });
  SVG.extend(SVG.Element, SVG.FX, {
    // Map rotation to transform
    rotate: function rotate(d, cx, cy) {
      return this.transform({
        rotation: d,
        cx: cx,
        cy: cy
      });
    },
    // Map skew to transform
    skew: function skew(x, y, cx, cy) {
      return arguments.length == 1 || arguments.length == 3 ? this.transform({
        skew: x,
        cx: y,
        cy: cx
      }) : this.transform({
        skewX: x,
        skewY: y,
        cx: cx,
        cy: cy
      });
    },
    // Map scale to transform
    scale: function scale(x, y, cx, cy) {
      return arguments.length == 1 || arguments.length == 3 ? this.transform({
        scale: x,
        cx: y,
        cy: cx
      }) : this.transform({
        scaleX: x,
        scaleY: y,
        cx: cx,
        cy: cy
      });
    },
    // Map translate to transform
    translate: function translate(x, y) {
      return this.transform({
        x: x,
        y: y
      });
    },
    // Map flip to transform
    flip: function flip(a, o) {
      o = typeof a === 'number' ? a : o;
      return this.transform({
        flip: a || 'both',
        offset: o
      });
    },
    // Map matrix to transform
    matrix: function matrix(m) {
      return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m));
    },
    // Opacity
    opacity: function opacity(value) {
      return this.attr('opacity', value);
    },
    // Relative move over x axis
    dx: function dx(x) {
      return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true);
    },
    // Relative move over y axis
    dy: function dy(y) {
      return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true);
    },
    // Relative move over x and y axes
    dmove: function dmove(x, y) {
      return this.dx(x).dy(y);
    }
  });
  SVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {
    // Add x and y radius
    radius: function radius(x, y) {
      var type = (this._target || this).type;
      return type == 'radial' || type == 'circle' ? this.attr('r', new SVG.Number(x)) : this.rx(x).ry(y == null ? x : y);
    }
  });
  SVG.extend(SVG.Path, {
    // Get path length
    length: function length() {
      return this.node.getTotalLength();
    },
    // Get point at length
    pointAt: function pointAt(length) {
      return this.node.getPointAtLength(length);
    }
  });
  SVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {
    // Set font
    font: function font(a, v) {
      if (_typeof(a) === 'object') {
        for (v in a) {
          this.font(v, a[v]);
        }
      }

      return a == 'leading' ? this.leading(v) : a == 'anchor' ? this.attr('text-anchor', v) : a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ? this.attr('font-' + a, v) : this.attr(a, v);
    }
  });
  SVG.Set = SVG.invent({
    // Initialize
    create: function create(members) {
      // Set initial state
      Array.isArray(members) ? this.members = members : this.clear();
    },
    // Add class methods
    extend: {
      // Add element to set
      add: function add() {
        var i,
            il,
            elements = [].slice.call(arguments);

        for (i = 0, il = elements.length; i < il; i++) {
          this.members.push(elements[i]);
        }

        return this;
      },
      // Remove element from set
      remove: function remove(element) {
        var i = this.index(element); // remove given child

        if (i > -1) {
          this.members.splice(i, 1);
        }

        return this;
      },
      // Iterate over all members
      each: function each(block) {
        for (var i = 0, il = this.members.length; i < il; i++) {
          block.apply(this.members[i], [i, this.members]);
        }

        return this;
      },
      // Restore to defaults
      clear: function clear() {
        // initialize store
        this.members = [];
        return this;
      },
      // Get the length of a set
      length: function length() {
        return this.members.length;
      },
      // Checks if a given element is present in set
      has: function has(element) {
        return this.index(element) >= 0;
      },
      // retuns index of given element in set
      index: function index(element) {
        return this.members.indexOf(element);
      },
      // Get member at given index
      get: function get(i) {
        return this.members[i];
      },
      // Get first member
      first: function first() {
        return this.get(0);
      },
      // Get last member
      last: function last() {
        return this.get(this.members.length - 1);
      },
      // Default value
      valueOf: function valueOf() {
        return this.members;
      },
      // Get the bounding box of all members included or empty box if set has no items
      bbox: function bbox() {
        // return an empty box of there are no members
        if (this.members.length == 0) {
          return new SVG.RBox();
        } // get the first rbox and update the target bbox


        var rbox = this.members[0].rbox(this.members[0].doc());
        this.each(function () {
          // user rbox for correct position and visual representation
          rbox = rbox.merge(this.rbox(this.doc()));
        });
        return rbox;
      }
    },
    // Add parent method
    construct: {
      // Create a new set
      set: function set(members) {
        return new SVG.Set(members);
      }
    }
  });
  SVG.FX.Set = SVG.invent({
    // Initialize node
    create: function create(set) {
      // store reference to set
      this.set = set;
    }
  }); // Alias methods

  SVG.Set.inherit = function () {
    var m,
        methods = []; // gather shape methods

    for (var m in SVG.Shape.prototype) {
      if (typeof SVG.Shape.prototype[m] === 'function' && typeof SVG.Set.prototype[m] !== 'function') {
        methods.push(m);
      }
    } // apply shape aliasses


    methods.forEach(function (method) {
      SVG.Set.prototype[method] = function () {
        for (var i = 0, il = this.members.length; i < il; i++) {
          if (this.members[i] && typeof this.members[i][method] === 'function') {
            this.members[i][method].apply(this.members[i], arguments);
          }
        }

        return method == 'animate' ? this.fx || (this.fx = new SVG.FX.Set(this)) : this;
      };
    }); // clear methods for the next round

    methods = []; // gather fx methods

    for (var m in SVG.FX.prototype) {
      if (typeof SVG.FX.prototype[m] === 'function' && typeof SVG.FX.Set.prototype[m] !== 'function') {
        methods.push(m);
      }
    } // apply fx aliasses


    methods.forEach(function (method) {
      SVG.FX.Set.prototype[method] = function () {
        for (var i = 0, il = this.set.members.length; i < il; i++) {
          this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments);
        }

        return this;
      };
    });
  };

  SVG.extend(SVG.Element, {
    // Store data values on svg nodes
    data: function data(a, v, r) {
      if (_typeof(a) === 'object') {
        for (v in a) {
          this.data(v, a[v]);
        }
      } else if (arguments.length < 2) {
        try {
          return JSON.parse(this.attr('data-' + a));
        } catch (e) {
          return this.attr('data-' + a);
        }
      } else {
        this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));
      }

      return this;
    }
  });
  SVG.extend(SVG.Element, {
    // Remember arbitrary data
    remember: function remember(k, v) {
      // remember every item in an object individually
      if (_typeof(arguments[0]) === 'object') {
        for (var v in k) {
          this.remember(v, k[v]);
        }
      } // retrieve memory
      else if (arguments.length == 1) {
          return this.memory()[k];
        } // store memory
        else {
            this.memory()[k] = v;
          }

      return this;
    },
    // Erase a given memory
    forget: function forget() {
      if (arguments.length == 0) {
        this._memory = {};
      } else {
        for (var i = arguments.length - 1; i >= 0; i--) {
          delete this.memory()[arguments[i]];
        }
      }

      return this;
    },
    // Initialize or return local memory object
    memory: function memory() {
      return this._memory || (this._memory = {});
    }
  }); // Method for getting an element by id

  SVG.get = function (id) {
    var node = document.getElementById(idFromReference(id) || id);
    return SVG.adopt(node);
  }; // Select elements by query string


  SVG.select = function (query, parent) {
    return new SVG.Set(SVG.utils.map((parent || document).querySelectorAll(query), function (node) {
      return SVG.adopt(node);
    }));
  };

  SVG.extend(SVG.Parent, {
    // Scoped select method
    select: function select(query) {
      return SVG.select(query, this.node);
    }
  });

  function pathRegReplace(a, b, c, d) {
    return c + d.replace(SVG.regex.dots, ' .');
  } // creates deep clone of array


  function array_clone(arr) {
    var clone = arr.slice(0);

    for (var i = clone.length; i--;) {
      if (Array.isArray(clone[i])) {
        clone[i] = array_clone(clone[i]);
      }
    }

    return clone;
  } // tests if a given element is instance of an object


  function _is(el, obj) {
    return el instanceof obj;
  } // tests if a given selector matches an element


  function _matches(el, selector) {
    return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
  } // Convert dash-separated-string to camelCase


  function camelCase(s) {
    return s.toLowerCase().replace(/-(.)/g, function (m, g) {
      return g.toUpperCase();
    });
  } // Capitalize first letter of a string


  function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  } // Ensure to six-based hex


  function fullHex(hex) {
    return hex.length == 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;
  } // Component to hex value


  function compToHex(comp) {
    var hex = comp.toString(16);
    return hex.length == 1 ? '0' + hex : hex;
  } // Calculate proportional width and height values when necessary


  function proportionalSize(element, width, height) {
    if (width == null || height == null) {
      var box = element.bbox();

      if (width == null) {
        width = box.width / box.height * height;
      } else if (height == null) {
        height = box.height / box.width * width;
      }
    }

    return {
      width: width,
      height: height
    };
  } // Delta transform point


  function deltaTransformPoint(matrix, x, y) {
    return {
      x: x * matrix.a + y * matrix.c + 0,
      y: x * matrix.b + y * matrix.d + 0
    };
  } // Map matrix array to object


  function arrayToMatrix(a) {
    return {
      a: a[0],
      b: a[1],
      c: a[2],
      d: a[3],
      e: a[4],
      f: a[5]
    };
  } // Parse matrix if required


  function parseMatrix(matrix) {
    if (!(matrix instanceof SVG.Matrix)) {
      matrix = new SVG.Matrix(matrix);
    }

    return matrix;
  } // Add centre point to transform object


  function ensureCentre(o, target) {
    o.cx = o.cx == null ? target.bbox().cx : o.cx;
    o.cy = o.cy == null ? target.bbox().cy : o.cy;
  } // PathArray Helpers


  function arrayToString(a) {
    for (var i = 0, il = a.length, s = ''; i < il; i++) {
      s += a[i][0];

      if (a[i][1] != null) {
        s += a[i][1];

        if (a[i][2] != null) {
          s += ' ';
          s += a[i][2];

          if (a[i][3] != null) {
            s += ' ';
            s += a[i][3];
            s += ' ';
            s += a[i][4];

            if (a[i][5] != null) {
              s += ' ';
              s += a[i][5];
              s += ' ';
              s += a[i][6];

              if (a[i][7] != null) {
                s += ' ';
                s += a[i][7];
              }
            }
          }
        }
      }
    }

    return s + ' ';
  } // Deep new id assignment


  function assignNewId(node) {
    // do the same for SVG child nodes as well
    for (var i = node.childNodes.length - 1; i >= 0; i--) {
      if (node.childNodes[i] instanceof window.SVGElement) {
        assignNewId(node.childNodes[i]);
      }
    }

    return SVG.adopt(node).id(SVG.eid(node.nodeName));
  } // Add more bounding box properties


  function fullBox(b) {
    if (b.x == null) {
      b.x = 0;
      b.y = 0;
      b.width = 0;
      b.height = 0;
    }

    b.w = b.width;
    b.h = b.height;
    b.x2 = b.x + b.width;
    b.y2 = b.y + b.height;
    b.cx = b.x + b.width / 2;
    b.cy = b.y + b.height / 2;
    return b;
  } // Get id from reference string


  function idFromReference(url) {
    var m = (url || '').toString().match(SVG.regex.reference);
    if (m) return m[1];
  } // If values like 1e-88 are passed, this is not a valid 32 bit float,
  // but in those cases, we are so close to 0 that 0 works well!


  function float32String(v) {
    return Math.abs(v) > 1e-37 ? v : 0;
  } // Create matrix array for looping


  var abcdef = 'abcdef'.split(''); // Add CustomEvent to IE9 and IE10

  if (typeof window.CustomEvent !== 'function') {
    // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
    var CustomEventPoly = function CustomEventPoly(event, options) {
      options = options || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      var e = document.createEvent('CustomEvent');
      e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail);
      return e;
    };

    CustomEventPoly.prototype = window.Event.prototype;
    SVG.CustomEvent = CustomEventPoly;
  } else {
    SVG.CustomEvent = window.CustomEvent;
  } // requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish


  (function (w) {
    var lastTime = 0;
    var vendors = ['moz', 'webkit'];

    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame'];
      w.cancelAnimationFrame = w[vendors[x] + 'CancelAnimationFrame'] || w[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    w.requestAnimationFrame = w.requestAnimationFrame || function (callback) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = w.setTimeout(function () {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };

    w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;
  })(window);

  return SVG;
});

/*! svg.filter.js - v2.0.2 - 2016-02-24
* https://github.com/wout/svg.filter.js
* Copyright (c) 2016 Wout Fierens; Licensed MIT */
(function() {

  // Main filter class
  SVG.Filter = SVG.invent({
    create: 'filter',
    inherit: SVG.Parent,
    extend: {
      // Static strings
      source:           'SourceGraphic',
      sourceAlpha:      'SourceAlpha',
      background:       'BackgroundImage',
      backgroundAlpha:  'BackgroundAlpha',
      fill:             'FillPaint',
      stroke:           'StrokePaint',

      autoSetIn: true,
      // Custom put method for leaner code
      put: function(element, i) {
        this.add(element, i);

        if(!element.attr('in') && this.autoSetIn){
          element.attr('in',this.source);
        }
        if(!element.attr('result')){
          element.attr('result',element);
        }

        return element
      },
      // Blend effect
      blend: function(in1, in2, mode) {
        return this.put(new SVG.BlendEffect(in1, in2, mode))
      },
      // ColorMatrix effect
      colorMatrix: function(type, values) {
        return this.put(new SVG.ColorMatrixEffect(type, values))
      },
      // ConvolveMatrix effect
      convolveMatrix: function(matrix) {
        return this.put(new SVG.ConvolveMatrixEffect(matrix))
      },
      // ComponentTransfer effect
      componentTransfer: function(components) {
        return this.put(new SVG.ComponentTransferEffect(components))
      },
      // Composite effect
      composite: function(in1, in2, operator) {
        return this.put(new SVG.CompositeEffect(in1, in2, operator))
      },
      // Flood effect
      flood: function(color, opacity) {
        return this.put(new SVG.FloodEffect(color, opacity))
      },
      // Offset effect
      offset: function(x, y) {
        return this.put(new SVG.OffsetEffect(x,y))
      },
      // Image effect
      image: function(src) {
        return this.put(new SVG.ImageEffect(src))
      },
      // Merge effect
      merge: function() {
        //pass the array of arguments to the constructor because we dont know if the user gave us an array as the first arguemnt or wether they listed the effects in the arguments
        var args = [undefined];
        for(var i in arguments) args.push(arguments[i]);
        return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect,args)))
      },
      // Gaussian Blur effect
      gaussianBlur: function(x,y) {
        return this.put(new SVG.GaussianBlurEffect(x,y))
      },
      // Morphology effect
      morphology: function(operator,radius){
        return this.put(new SVG.MorphologyEffect(operator,radius))
      },
      // DiffuseLighting effect
      diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){
        return this.put(new SVG.DiffuseLightingEffect(surfaceScale,diffuseConstant,kernelUnitLength))
      },
      // DisplacementMap effect
      displacementMap: function(in1,in2,scale,xChannelSelector,yChannelSelector){
        return this.put(new SVG.DisplacementMapEffect(in1,in2,scale,xChannelSelector,yChannelSelector))
      },
      // SpecularLighting effect
      specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){
        return this.put(new SVG.SpecularLightingEffect(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength))
      },
      // Tile effect
      tile: function(){
        return this.put(new SVG.TileEffect());
      },
      // Turbulence effect
      turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){
        return this.put(new SVG.TurbulenceEffect(baseFrequency,numOctaves,seed,stitchTiles,type))
      },
      // Default string value
      toString: function() {
        return 'url(#' + this.attr('id') + ')'
      }
    }
  });

  //add .filter function
  SVG.extend(SVG.Defs, {
    // Define filter
    filter: function(block) {
      var filter = this.put(new SVG.Filter);

      /* invoke passed block */
      if (typeof block === 'function')
        block.call(filter, filter);

      return filter
    }
  });
  SVG.extend(SVG.Container, {
    // Define filter on defs
    filter: function(block) {
      return this.defs().filter(block)
    }
  });
  SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
    // Create filter element in defs and store reference
    filter: function(block) {
      this.filterer = block instanceof SVG.Element ?
        block : this.doc().filter(block);

      if(this.doc() && this.filterer.doc() !== this.doc()){
        this.doc().defs().add(this.filterer);
      }

      this.attr('filter', this.filterer);

      return this.filterer
    },
    // Remove filter
    unfilter: function(remove) {
      /* also remove the filter node */
      if (this.filterer && remove === true)
        this.filterer.remove();

      /* delete reference to filterer */
      delete this.filterer;

      /* remove filter attribute */
      return this.attr('filter', null)
    }
  });

  // Create SVG.Effect class
  SVG.Effect = SVG.invent({
    create: function(){
      this.constructor.call(this);
    },
    inherit: SVG.Element,
    extend: {
      // Set in attribute
      in: function(effect) {
        return effect == null? this.parent() && this.parent().select('[result="'+this.attr('in')+'"]').get(0) || this.attr('in') : this.attr('in', effect)
      },
      // Named result
      result: function(result) {
        return result == null? this.attr('result') : this.attr('result',result)
      },
      // Stringification
      toString: function() {
        return this.result()
      }
    }
  });

  // create class for parent effects like merge
  // Inherit from SVG.Parent
  SVG.ParentEffect = SVG.invent({
    create: function(){
      this.constructor.call(this);
    },
    inherit: SVG.Parent,
    extend: {
      // Set in attribute
      in: function(effect) {
        return effect == null? this.parent() && this.parent().select('[result="'+this.attr('in')+'"]').get(0) || this.attr('in') : this.attr('in', effect)
      },
      // Named result
      result: function(result) {
        return result == null? this.attr('result') : this.attr('result',result)
      },
      // Stringification
      toString: function() {
        return this.result()
      }
    }
  });

  //chaining
  var chainingEffects = {
    // Blend effect
    blend: function(in2, mode) {
      return this.parent() && this.parent().blend(this, in2, mode) //pass this as the first input
    },
    // ColorMatrix effect
    colorMatrix: function(type, values) {
      return this.parent() && this.parent().colorMatrix(type, values).in(this)
    },
    // ConvolveMatrix effect
    convolveMatrix: function(matrix) {
      return this.parent() && this.parent().convolveMatrix(matrix).in(this)
    },
    // ComponentTransfer effect
    componentTransfer: function(components) {
      return this.parent() && this.parent().componentTransfer(components).in(this)
    },
    // Composite effect
    composite: function(in2, operator) {
      return this.parent() && this.parent().composite(this, in2, operator) //pass this as the first input
    },
    // Flood effect
    flood: function(color, opacity) {
      return this.parent() && this.parent().flood(color, opacity) //this effect dont have inputs
    },
    // Offset effect
    offset: function(x, y) {
      return this.parent() && this.parent().offset(x,y).in(this)
    },
    // Image effect
    image: function(src) {
      return this.parent() && this.parent().image(src) //this effect dont have inputs
    },
    // Merge effect
    merge: function() {
      return this.parent() && this.parent().merge.apply(this.parent(),[this].concat(arguments)) //pass this as the first argument
    },
    // Gaussian Blur effect
    gaussianBlur: function(x,y) {
      return this.parent() && this.parent().gaussianBlur(x,y).in(this)
    },
    // Morphology effect
    morphology: function(operator,radius){
      return this.parent() && this.parent().morphology(operator,radius).in(this)
    },
    // DiffuseLighting effect
    diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){
      return this.parent() && this.parent().diffuseLighting(surfaceScale,diffuseConstant,kernelUnitLength).in(this)
    },
    // DisplacementMap effect
    displacementMap: function(in2,scale,xChannelSelector,yChannelSelector){
      return this.parent() && this.parent().displacementMap(this,in2,scale,xChannelSelector,yChannelSelector) //pass this as the first input
    },
    // SpecularLighting effect
    specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){
      return this.parent() && this.parent().specularLighting(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength).in(this)
    },
    // Tile effect
    tile: function(){
      return this.parent() && this.parent().tile().in(this)
    },
    // Turbulence effect
    turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){
      return this.parent() && this.parent().turbulence(baseFrequency,numOctaves,seed,stitchTiles,type).in(this)
    }
  };
  SVG.extend(SVG.Effect,chainingEffects);
  SVG.extend(SVG.ParentEffect,chainingEffects);

  //crea class for child effects, like MergeNode, FuncR and lights
  SVG.ChildEffect = SVG.invent({
    create: function(){
      this.constructor.call(this);
    },
    inherit: SVG.Element,
    extend: {
    in: function(effect){
      this.attr('in',effect);
    }
    //dont include any "result" functions because these types of nodes dont have them
    }
  });

  // Create all different effects
  var effects = {
    blend: function(in1,in2,mode){
      this.attr({
        in: in1,
        in2: in2,
        mode: mode || 'normal'
      });
    },
    colorMatrix: function(type,values){
      if (type == 'matrix')
        values = normaliseMatrix(values);

      this.attr({
        type:   type
      , values: typeof values == 'undefined' ? null : values
      });
    },
    convolveMatrix: function(matrix){
      matrix = normaliseMatrix(matrix);

      this.attr({
        order:        Math.sqrt(matrix.split(' ').length)
      , kernelMatrix: matrix
      });
    },
    composite: function(in1, in2, operator){
      this.attr({
        in: in1,
        in2: in2,
        operator: operator
      });
    },
    flood: function(color,opacity){
      this.attr('flood-color',color);
      if(opacity != null) this.attr('flood-opacity',opacity);
    },
    offset: function(x,y){
      this.attr({
        dx: x,
        dy: y
      });
    },
    image: function(src){
      this.attr('href', src, SVG.xlink);
    },
    displacementMap: function(in1,in2,scale,xChannelSelector,yChannelSelector){
      this.attr({
        in: in1,
        in2: in2,
        scale: scale,
        xChannelSelector: xChannelSelector,
        yChannelSelector: yChannelSelector
      });
    },
    gaussianBlur: function(x,y){
      if(x != null || y != null)
        this.attr('stdDeviation', listString(Array.prototype.slice.call(arguments)));
      else
        this.attr('stdDeviation', '0 0');
    },
    morphology: function(operator,radius){
      this.attr({
        operator: operator,
        radius: radius
      });
    },
    tile: function(){

    },
    turbulence: function(baseFrequency,numOctaves,seed,stitchTiles,type){
      this.attr({
        numOctaves: numOctaves,
        seed: seed,
        stitchTiles: stitchTiles,
        baseFrequency: baseFrequency,
        type: type
      });
    }
  };

  // Create all parent effects
  var parentEffects = {
    merge: function(){
      var children;

      //test to see if we have a set
      if(arguments[0] instanceof SVG.Set){
        var that = this;
        arguments[0].each(function(i){
          if(this instanceof SVG.MergeNode)
            that.put(this);
          else if(this instanceof SVG.Effect || this instanceof SVG.ParentEffect)
            that.put(new SVG.MergeNode(this));
        });
      }
      else{
        //if the first argument is an array use it
        if(Array.isArray(arguments[0]))
          children = arguments[0];
        else
          children = arguments;

        for(var i = 0; i < children.length; i++){
          if(children[i] instanceof SVG.MergeNode){
            this.put(children[i]);
          }
          else this.put(new SVG.MergeNode(children[i]));
        }
      }
    },
    componentTransfer: function(compontents){
      /* create rgb set */
      this.rgb = new SVG.Set

      /* create components */
      ;(['r', 'g', 'b', 'a']).forEach(function(c) {
        /* create component */
        this[c] = new SVG['Func' + c.toUpperCase()]('identity');

        /* store component in set */
        this.rgb.add(this[c]);

        /* add component node */
        this.node.appendChild(this[c].node);
      }.bind(this)); //lost context in foreach

      /* set components */
      if (compontents) {
        if (compontents.rgb) {
(['r', 'g', 'b']).forEach(function(c) {
            this[c].attr(compontents.rgb);
          }.bind(this));

          delete compontents.rgb;
        }

        /* set individual components */
        for (var c in compontents)
          this[c].attr(compontents[c]);
      }
    },
    diffuseLighting: function(surfaceScale,diffuseConstant,kernelUnitLength){
      this.attr({
        surfaceScale: surfaceScale,
        diffuseConstant: diffuseConstant,
        kernelUnitLength: kernelUnitLength
      });
    },
    specularLighting: function(surfaceScale,diffuseConstant,specularExponent,kernelUnitLength){
      this.attr({
        surfaceScale: surfaceScale,
        diffuseConstant: diffuseConstant,
        specularExponent: specularExponent,
        kernelUnitLength: kernelUnitLength
      });
    },
  };

  // Create child effects like PointLight and MergeNode
  var childEffects = {
    distantLight: function(azimuth, elevation){
      this.attr({
        azimuth: azimuth,
        elevation: elevation
      });
    },
    pointLight: function(x,y,z){
      this.attr({
        x: x,
        y: y,
        z: z
      });
    },
    spotLight: function(x,y,z,pointsAtX,pointsAtY,pointsAtZ){
      this.attr({
        x: x,
        y: y,
        z: z,
        pointsAtX: pointsAtX,
        pointsAtY: pointsAtY,
        pointsAtZ: pointsAtZ
      });
    },
    mergeNode: function(in1){
      this.attr('in',in1);
    }
  }

  // Create compontent functions
  ;(['r', 'g', 'b', 'a']).forEach(function(c) {
    /* create class */
    childEffects['Func' + c.toUpperCase()] = function(type) {
      this.attr('type',type);

      // take diffent arguments based on the type
      switch(type){
        case 'table':
          this.attr('tableValues',arguments[1]);
          break
        case 'linear':
          this.attr('slope',arguments[1]);
          this.attr('intercept',arguments[2]);
          break
        case 'gamma':
          this.attr('amplitude',arguments[1]);
          this.attr('exponent',arguments[2]);
          this.attr('offset',arguments[2]);
          break
      }
    };
  });

  //create effects
  foreach(effects,function(effect,i){

    /* capitalize name */
    var name = i.charAt(0).toUpperCase() + i.slice(1);
    var proto = {};

    /* create class */
    SVG[name + 'Effect'] = SVG.invent({
      create: function() {
        //call super
        this.constructor.call(this, SVG.create('fe' + name));

        //call constructor for this effect
        effect.apply(this,arguments);

        //set the result
        this.result(this.attr('id') + 'Out');
      },
      inherit: SVG.Effect,
      extend: proto
    });
  });

  //create parent effects
  foreach(parentEffects,function(effect,i){

    /* capitalize name */
    var name = i.charAt(0).toUpperCase() + i.slice(1);
    var proto = {};

    /* create class */
    SVG[name + 'Effect'] = SVG.invent({
      create: function() {
        //call super
        this.constructor.call(this, SVG.create('fe' + name));

        //call constructor for this effect
        effect.apply(this,arguments);

        //set the result
        this.result(this.attr('id') + 'Out');
      },
      inherit: SVG.ParentEffect,
      extend: proto
    });
  });

  //create child effects
  foreach(childEffects,function(effect,i){

    /* capitalize name */
    var name = i.charAt(0).toUpperCase() + i.slice(1);
    var proto = {};

    /* create class */
    SVG[name] = SVG.invent({
      create: function() {
        //call super
        this.constructor.call(this, SVG.create('fe' + name));

        //call constructor for this effect
        effect.apply(this,arguments);
      },
      inherit: SVG.ChildEffect,
      extend: proto
    });
  });

  // Effect-specific extensions
  SVG.extend(SVG.MergeEffect,{
    in: function(effect){
      if(effect instanceof SVG.MergeNode)
        this.add(effect,0);
      else
        this.add(new SVG.MergeNode(effect),0);

      return this
    }
  });
  SVG.extend(SVG.CompositeEffect,SVG.BlendEffect,SVG.DisplacementMapEffect,{
    in2: function(effect){
        return effect == null? this.parent() && this.parent().select('[result="'+this.attr('in2')+'"]').get(0) || this.attr('in2') : this.attr('in2', effect)
    }
  });

  // Presets
  SVG.filter = {
    sepiatone:  [ .343, .669, .119, 0, 0
                , .249, .626, .130, 0, 0
                , .172, .334, .111, 0, 0
                , .000, .000, .000, 1, 0 ]
  };

  // Helpers
  function normaliseMatrix(matrix) {
    /* convert possible array value to string */
    if (Array.isArray(matrix))
      matrix = new SVG.Array(matrix);

    /* ensure there are no leading, tailing or double spaces */
    return matrix.toString().replace(/^\s+/, '').replace(/\s+$/, '').replace(/\s+/g, ' ')
  }

  function listString(list) {
    if (!Array.isArray(list))
      return list

    for (var i = 0, l = list.length, s = []; i < l; i++)
      s.push(list[i]);

    return s.join(' ')
  }

  function foreach(){ //loops through mutiple objects
    var fn = function(){};
    if(typeof arguments[arguments.length-1] == 'function'){
      fn = arguments[arguments.length-1];
      Array.prototype.splice.call(arguments,arguments.length-1,1);
    }
    for(var k in arguments){
      for(var i in arguments[k]){
        fn(arguments[k][i],i,arguments[k]);
      }
    }
  }

}).call(undefined);

(function() {

SVG.extend(SVG.PathArray, {
  morph: function(array) {

    var startArr = this.value
      ,  destArr = this.parse(array);

    var startOffsetM = 0
      ,  destOffsetM = 0;

    var startOffsetNextM = false
      ,  destOffsetNextM = false;

    while(true){
      // stop if there is no M anymore
      if(startOffsetM === false && destOffsetM === false) break

      // find the next M in path array
      startOffsetNextM = findNextM(startArr, startOffsetM === false ? false : startOffsetM+1);
       destOffsetNextM = findNextM( destArr,  destOffsetM === false ? false :  destOffsetM+1);

      // We have to add one M to the startArray
      if(startOffsetM === false){
        var bbox = new SVG.PathArray(result.start).bbox();

        // when the last block had no bounding box we simply take the first M we got
        if(bbox.height == 0 || bbox.width == 0){
          startOffsetM =  startArr.push(startArr[0]) - 1;
        }else{
          // we take the middle of the bbox instead when we got one
          startOffsetM = startArr.push( ['M', bbox.x + bbox.width/2, bbox.y + bbox.height/2 ] ) - 1;
        }
      }

      // We have to add one M to the destArray
      if( destOffsetM === false){
        var bbox = new SVG.PathArray(result.dest).bbox();

        if(bbox.height == 0 || bbox.width == 0){
          destOffsetM =  destArr.push(destArr[0]) - 1;
        }else{
          destOffsetM =  destArr.push( ['M', bbox.x + bbox.width/2, bbox.y + bbox.height/2 ] ) - 1;
        }
      }

      // handle block from M to next M
      var result = handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM);

      // update the arrays to their new values
      startArr = startArr.slice(0, startOffsetM).concat(result.start, startOffsetNextM === false ? [] : startArr.slice(startOffsetNextM));
       destArr =  destArr.slice(0,  destOffsetM).concat(result.dest ,  destOffsetNextM === false ? [] :  destArr.slice( destOffsetNextM));

      // update offsets
      startOffsetM = startOffsetNextM === false ? false : startOffsetM + result.start.length;
       destOffsetM =  destOffsetNextM === false ? false :  destOffsetM + result.dest.length;

    }

    // copy back arrays
    this.value = startArr;
    this.destination = new SVG.PathArray();
    this.destination.value = destArr;

    return this
  }
});



// sorry for the long declaration
// slices out one block (from M to M) and syncronize it so the types and length match
function handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM, undefined){

  // slice out the block we need
  var startArrTemp = startArr.slice(startOffsetM, startOffsetNextM || undefined)
    ,  destArrTemp =  destArr.slice( destOffsetM,  destOffsetNextM || undefined);

  var i = 0
    , posStart = {pos:[0,0], start:[0,0]}
    , posDest  = {pos:[0,0], start:[0,0]};

  do{

    // convert shorthand types to long form
    startArrTemp[i] = simplyfy.call(posStart, startArrTemp[i]);
     destArrTemp[i] = simplyfy.call(posDest ,  destArrTemp[i]);

    // check if both shape types match
    // 2 elliptical arc curve commands ('A'), are considered different if the
    // flags (large-arc-flag, sweep-flag) don't match
    if(startArrTemp[i][0] != destArrTemp[i][0] || startArrTemp[i][0] == 'M' ||
        (startArrTemp[i][0] == 'A' &&
          (startArrTemp[i][4] != destArrTemp[i][4] || startArrTemp[i][5] != destArrTemp[i][5])
        )
      ) {

      // if not, convert shapes to beziere
      Array.prototype.splice.apply(startArrTemp, [i, 1].concat(toBeziere.call(posStart, startArrTemp[i])));
       Array.prototype.splice.apply(destArrTemp, [i, 1].concat(toBeziere.call(posDest, destArrTemp[i])));

    } else {

      // only update positions otherwise
      startArrTemp[i] = setPosAndReflection.call(posStart, startArrTemp[i]);
       destArrTemp[i] = setPosAndReflection.call(posDest ,  destArrTemp[i]);

    }

    // we are at the end at both arrays. stop here
    if(++i == startArrTemp.length && i == destArrTemp.length) break

    // destArray is longer. Add one element
    if(i == startArrTemp.length){
      startArrTemp.push([
        'C',
        posStart.pos[0],
        posStart.pos[1],
        posStart.pos[0],
        posStart.pos[1],
        posStart.pos[0],
        posStart.pos[1],
      ]);
    }

    // startArr is longer. Add one element
    if(i == destArrTemp.length){
      destArrTemp.push([
        'C',
        posDest.pos[0],
        posDest.pos[1],
        posDest.pos[0],
        posDest.pos[1],
        posDest.pos[0],
        posDest.pos[1]
      ]);
    }


  }while(true)

  // return the updated block
  return {start:startArrTemp, dest:destArrTemp}
}

// converts shorthand types to long form
function simplyfy(val){

  switch(val[0]){
    case 'z': // shorthand line to start
    case 'Z':
      val[0] = 'L';
      val[1] = this.start[0];
      val[2] = this.start[1];
      break
    case 'H': // shorthand horizontal line
      val[0] = 'L';
      val[2] = this.pos[1];
      break
    case 'V': // shorthand vertical line
      val[0] = 'L';
      val[2] = val[1];
      val[1] = this.pos[0];
      break
    case 'T': // shorthand quadratic beziere
      val[0] = 'Q';
      val[3] = val[1];
      val[4] = val[2];
      val[1] = this.reflection[1];
      val[2] = this.reflection[0];
      break
    case 'S': // shorthand cubic beziere
      val[0] = 'C';
      val[6] = val[4];
      val[5] = val[3];
      val[4] = val[2];
      val[3] = val[1];
      val[2] = this.reflection[1];
      val[1] = this.reflection[0];
      break
  }

  return val

}

// updates reflection point and current position
function setPosAndReflection(val){

  var len = val.length;

  this.pos = [ val[len-2], val[len-1] ];

  if('SCQT'.indexOf(val[0]) != -1)
    this.reflection = [ 2 * this.pos[0] - val[len-4], 2 * this.pos[1] - val[len-3] ];

  return val
}

// converts all types to cubic beziere
function toBeziere(val){
  var retVal = [val];

  switch(val[0]){
    case 'M': // special handling for M
      this.pos = this.start = [val[1], val[2]];
      return retVal
    case 'L':
      val[5] = val[3] = val[1];
      val[6] = val[4] = val[2];
      val[1] = this.pos[0];
      val[2] = this.pos[1];
      break
    case 'Q':
      val[6] = val[4];
      val[5] = val[3];
      val[4] = val[4] * 1/3 + val[2] * 2/3;
      val[3] = val[3] * 1/3 + val[1] * 2/3;
      val[2] = this.pos[1] * 1/3 + val[2] * 2/3;
      val[1] = this.pos[0] * 1/3 + val[1] * 2/3;
      break
    case 'A':
      retVal = arcToBeziere(this.pos, val);
      val = retVal[0];
      break
  }

  val[0] = 'C';
  this.pos = [val[5], val[6]];
  this.reflection = [2 * val[5] - val[3], 2 * val[6] - val[4]];

  return retVal

}

// finds the next position of type M
function findNextM(arr, offset){

  if(offset === false) return false

  for(var i = offset, len = arr.length;i < len;++i){

    if(arr[i][0] == 'M') return i

  }

  return false
}



// Convert an arc segment into equivalent cubic Bezier curves
// Depending on the arc, up to 4 curves might be used to represent it since a
// curve gives a good approximation for only a quarter of an ellipse
// The curves are returned as an array of SVG curve commands:
// [ ['C', x1, y1, x2, y2, x, y] ... ]
function arcToBeziere(pos, val) {
    // Parameters extraction, handle out-of-range parameters as specified in the SVG spec
    // See: https://www.w3.org/TR/SVG11/implnote.html#ArcOutOfRangeParameters
    var rx = Math.abs(val[1]), ry = Math.abs(val[2]), xAxisRotation = val[3] % 360
      , largeArcFlag = val[4], sweepFlag = val[5], x = val[6], y = val[7]
      , A = new SVG.Point(pos), B = new SVG.Point(x, y)
      , primedCoord, lambda, mat, k, c, cSquare, t, O, OA, OB, tetaStart, tetaEnd
      , deltaTeta, nbSectors, f, arcSegPoints, angle, sinAngle, cosAngle, pt, i, il
      , retVal = [], x1, y1, x2, y2;

    // Ensure radii are non-zero
    if(rx === 0 || ry === 0 || (A.x === B.x && A.y === B.y)) {
      // treat this arc as a straight line segment
      return [['C', A.x, A.y, B.x, B.y, B.x, B.y]]
    }

    // Ensure radii are large enough using the algorithm provided in the SVG spec
    // See: https://www.w3.org/TR/SVG11/implnote.html#ArcCorrectionOutOfRangeRadii
    primedCoord = new SVG.Point((A.x-B.x)/2, (A.y-B.y)/2).transform(new SVG.Matrix().rotate(xAxisRotation));
    lambda = (primedCoord.x * primedCoord.x) / (rx * rx) + (primedCoord.y * primedCoord.y) / (ry * ry);
    if(lambda > 1) {
      lambda = Math.sqrt(lambda);
      rx = lambda*rx;
      ry = lambda*ry;
    }

    // To simplify calculations, we make the arc part of a unit circle (rayon is 1) instead of an ellipse
    mat = new SVG.Matrix().rotate(xAxisRotation).scale(1/rx, 1/ry).rotate(-xAxisRotation);
    A = A.transform(mat);
    B = B.transform(mat);

    // Calculate the horizontal and vertical distance between the initial and final point of the arc
    k = [B.x-A.x, B.y-A.y];

    // Find the length of the chord formed by A and B
    cSquare = k[0]*k[0] + k[1]*k[1];
    c = Math.sqrt(cSquare);

    // Calculate the ratios of the horizontal and vertical distance on the length of the chord
    k[0] /= c;
    k[1] /= c;

    // Calculate the distance between the circle center and the chord midpoint
    // using this formula: t = sqrt(r^2 - c^2 / 4)
    // where t is the distance between the cirle center and the chord midpoint,
    //       r is the rayon of the circle and c is the chord length
    // From: http://www.ajdesigner.com/phpcircle/circle_segment_chord_t.php
    // Because of the imprecision of floating point numbers, cSquare might end
    // up being slightly above 4 which would result in a negative radicand
    // To prevent that, a test is made before computing the square root
    t = (cSquare < 4) ? Math.sqrt(1 - cSquare/4) : 0;

    // For most situations, there are actually two different ellipses that
    // satisfy the constraints imposed by the points A and B, the radii rx and ry,
    // and the xAxisRotation
    // When the flags largeArcFlag and sweepFlag are equal, it means that the
    // second ellipse is used as a solution
    // See: https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
    if(largeArcFlag === sweepFlag) {
        t *= -1;
    }

    // Calculate the coordinates of the center of the circle from the midpoint of the chord
    // This is done by multiplying the ratios calculated previously by the distance between
    // the circle center and the chord midpoint and using these values to go from the midpoint
    // to the center of the circle
    // The negative of the vertical distance ratio is used to modify the x coordinate while
    // the horizontal distance ratio is used to modify the y coordinate
    // That is because the center of the circle is perpendicular to the chord and perpendicular
    // lines are negative reciprocals
    O = new SVG.Point((B.x+A.x)/2 + t*-k[1], (B.y+A.y)/2 + t*k[0]);
    // Move the center of the circle at the origin
    OA = new SVG.Point(A.x-O.x, A.y-O.y);
    OB = new SVG.Point(B.x-O.x, B.y-O.y);

    // Calculate the start and end angle
    tetaStart = Math.acos(OA.x/Math.sqrt(OA.x*OA.x + OA.y*OA.y));
    if (OA.y < 0) {
      tetaStart *= -1;
    }
    tetaEnd = Math.acos(OB.x/Math.sqrt(OB.x*OB.x + OB.y*OB.y));
    if (OB.y < 0) {
      tetaEnd *= -1;
    }

    // If sweep-flag is '1', then the arc will be drawn in a "positive-angle" direction,
    // make sure that the end angle is above the start angle
    if (sweepFlag && tetaStart > tetaEnd) {
      tetaEnd += 2*Math.PI;
    }
    // If sweep-flag is '0', then the arc will be drawn in a "negative-angle" direction,
    // make sure that the end angle is below the start angle
    if (!sweepFlag && tetaStart < tetaEnd) {
      tetaEnd -= 2*Math.PI;
    }

    // Find the number of Bezier curves that are required to represent the arc
    // A cubic Bezier curve gives a good enough approximation when representing at most a quarter of a circle
    nbSectors = Math.ceil(Math.abs(tetaStart-tetaEnd) * 2/Math.PI);

    // Calculate the coordinates of the points of all the Bezier curves required to represent the arc
    // For an in-depth explanation of this part see: http://pomax.github.io/bezierinfo/#circles_cubic
    arcSegPoints = [];
    angle = tetaStart;
    deltaTeta = (tetaEnd-tetaStart)/nbSectors;
    f = 4*Math.tan(deltaTeta/4)/3;
    for (i = 0; i <= nbSectors; i++) { // The <= is because a Bezier curve have a start and a endpoint
      cosAngle = Math.cos(angle);
      sinAngle = Math.sin(angle);

      pt = new SVG.Point(O.x+cosAngle, O.y+sinAngle);
      arcSegPoints[i] = [new SVG.Point(pt.x+f*sinAngle, pt.y-f*cosAngle), pt, new SVG.Point(pt.x-f*sinAngle, pt.y+f*cosAngle)];

      angle += deltaTeta;
    }

    // Remove the first control point of the first segment point and remove the second control point of the last segment point
    // These two control points are not used in the approximation of the arc, that is why they are removed
    arcSegPoints[0][0] = arcSegPoints[0][1].clone();
    arcSegPoints[arcSegPoints.length-1][2] = arcSegPoints[arcSegPoints.length-1][1].clone();

    // Revert the transformation that was applied to make the arc part of a unit circle instead of an ellipse
    mat = new SVG.Matrix().rotate(xAxisRotation).scale(rx, ry).rotate(-xAxisRotation);
    for (i = 0, il = arcSegPoints.length; i < il; i++) {
      arcSegPoints[i][0] = arcSegPoints[i][0].transform(mat);
      arcSegPoints[i][1] = arcSegPoints[i][1].transform(mat);
      arcSegPoints[i][2] = arcSegPoints[i][2].transform(mat);
    }


    // Convert the segments points to SVG curve commands
    for (i = 1, il = arcSegPoints.length; i < il; i++) {
      pt = arcSegPoints[i-1][2];
      x1 = pt.x;
      y1 = pt.y;

      pt = arcSegPoints[i][0];
      x2 = pt.x;
      y2 = pt.y;

      pt = arcSegPoints[i][1];
      x = pt.x;
      y = pt.y;

      retVal.push(['C', x1, y1, x2, y2, x, y]);
    }

    return retVal
}
}());

/*! svg.draggable.js - v2.2.1 - 2016-08-25
* https://github.com/wout/svg.draggable.js
* Copyright (c) 2016 Wout Fierens; Licensed MIT */
(function() {

  // creates handler, saves it
  function DragHandler(el){
    el.remember('_draggable', this);
    this.el = el;
  }


  // Sets new parameter, starts dragging
  DragHandler.prototype.init = function(constraint, val){
    var _this = this;
    this.constraint = constraint;
    this.value = val;
    this.el.on('mousedown.drag', function(e){ _this.start(e); });
    this.el.on('touchstart.drag', function(e){ _this.start(e); });
  };

  // transforms one point from screen to user coords
  DragHandler.prototype.transformPoint = function(event, offset){
      event = event || window.event;
      var touches = event.changedTouches && event.changedTouches[0] || event;
      this.p.x = touches.pageX - (offset || 0);
      this.p.y = touches.pageY;
      return this.p.matrixTransform(this.m)
  };
  
  // gets elements bounding box with special handling of groups, nested and use
  DragHandler.prototype.getBBox = function(){

    var box = this.el.bbox();

    if(this.el instanceof SVG.Nested) box = this.el.rbox();
    
    if (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) {
      box.x = this.el.x();
      box.y = this.el.y();
    }

    return box
  };

  // start dragging
  DragHandler.prototype.start = function(e){

    // check for left button
    if(e.type == 'click'|| e.type == 'mousedown' || e.type == 'mousemove'){
      if((e.which || e.buttons) != 1){
          return
      }
    }
  
    var _this = this;

    // fire beforedrag event
    this.el.fire('beforedrag', { event: e, handler: this });

    // search for parent on the fly to make sure we can call
    // draggable() even when element is not in the dom currently
    this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc);
    this.p = this.parent.node.createSVGPoint();

    // save current transformation matrix
    this.m = this.el.node.getScreenCTM().inverse();

    var box = this.getBBox();
    
    var anchorOffset;
    
    // fix text-anchor in text-element (#37)
    if(this.el instanceof SVG.Text){
      anchorOffset = this.el.node.getComputedTextLength();
        
      switch(this.el.attr('text-anchor')){
        case 'middle':
          anchorOffset /= 2;
          break
        case 'start':
          anchorOffset = 0;
          break;
      }
    }
    
    this.startPoints = {
      // We take absolute coordinates since we are just using a delta here
      point: this.transformPoint(e, anchorOffset),
      box:   box,
      transform: this.el.transform()
    };
    
    // add drag and end events to window
    SVG.on(window, 'mousemove.drag', function(e){ _this.drag(e); });
    SVG.on(window, 'touchmove.drag', function(e){ _this.drag(e); });
    SVG.on(window, 'mouseup.drag', function(e){ _this.end(e); });
    SVG.on(window, 'touchend.drag', function(e){ _this.end(e); });

    // fire dragstart event
    this.el.fire('dragstart', {event: e, p: this.startPoints.point, m: this.m, handler: this});

    // prevent browser drag behavior
    e.preventDefault();

    // prevent propagation to a parent that might also have dragging enabled
    e.stopPropagation();
  };

  // while dragging
  DragHandler.prototype.drag = function(e){

    var box = this.getBBox()
      , p   = this.transformPoint(e)
      , x   = this.startPoints.box.x + p.x - this.startPoints.point.x
      , y   = this.startPoints.box.y + p.y - this.startPoints.point.y
      , c   = this.constraint
      , gx  = p.x - this.startPoints.point.x
      , gy  = p.y - this.startPoints.point.y;
      
    var event = new CustomEvent('dragmove', {
        detail: {
            event: e
          , p: p
          , m: this.m
          , handler: this
        }
      , cancelable: true
    });
      
    this.el.fire(event);
    
    if(event.defaultPrevented) return p

    // move the element to its new position, if possible by constraint
    if (typeof c == 'function') {

      var coord = c.call(this.el, x, y, this.m);

      // bool, just show us if movement is allowed or not
      if (typeof coord == 'boolean') {
        coord = {
          x: coord,
          y: coord
        };
      }

      // if true, we just move. If !false its a number and we move it there
      if (coord.x === true) {
        this.el.x(x);
      } else if (coord.x !== false) {
        this.el.x(coord.x);
      }

      if (coord.y === true) {
        this.el.y(y);
      } else if (coord.y !== false) {
        this.el.y(coord.y);
      }

    } else if (typeof c == 'object') {

      // keep element within constrained box
      if (c.minX != null && x < c.minX)
        x = c.minX;
      else if (c.maxX != null && x > c.maxX - box.width){
        x = c.maxX - box.width;
      }if (c.minY != null && y < c.minY)
        y = c.minY;
      else if (c.maxY != null && y > c.maxY - box.height)
        y = c.maxY - box.height;
        
      if(this.el instanceof SVG.G)
        this.el.matrix(this.startPoints.transform).transform({x:gx, y: gy}, true);
      else
        this.el.move(x, y);
    }
    
    // so we can use it in the end-method, too
    return p
  };

  DragHandler.prototype.end = function(e){

    // final drag
    var p = this.drag(e);

    // fire dragend event
    this.el.fire('dragend', { event: e, p: p, m: this.m, handler: this });

    // unbind events
    SVG.off(window, 'mousemove.drag');
    SVG.off(window, 'touchmove.drag');
    SVG.off(window, 'mouseup.drag');
    SVG.off(window, 'touchend.drag');

  };

  SVG.extend(SVG.Element, {
    // Make element draggable
    // Constraint might be an object (as described in readme.md) or a function in the form "function (x, y)" that gets called before every move.
    // The function can return a boolean or an object of the form {x, y}, to which the element will be moved. "False" skips moving, true moves to raw x, y.
    draggable: function(value, constraint) {

      // Check the parameters and reassign if needed
      if (typeof value == 'function' || typeof value == 'object') {
        constraint = value;
        value = true;
      }

      var dragHandler = this.remember('_draggable') || new DragHandler(this);

      // When no parameter is given, value is true
      value = typeof value === 'undefined' ? true : value;

      if(value) dragHandler.init(constraint || {}, value);
      else {
        this.off('mousedown.drag');
        this.off('touchstart.drag');
      }

      return this
    }

  });

}).call(undefined);

(function() {

function SelectHandler(el) {

    this.el = el;
    el.remember('_selectHandler', this);
    this.pointSelection = {isSelected: false};
    this.rectSelection = {isSelected: false};

}

SelectHandler.prototype.init = function (value, options) {

    var bbox = this.el.bbox();
    this.options = {};

    // Merging the defaults and the options-object together
    for (var i in this.el.selectize.defaults) {
        this.options[i] = this.el.selectize.defaults[i];
        if (options[i] !== undefined) {
            this.options[i] = options[i];
        }
    }

    this.parent = this.el.parent();
    this.nested = (this.nested || this.parent.group());
    this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));

    // When deepSelect is enabled and the element is a line/polyline/polygon, draw only points for moving
    if (this.options.deepSelect && ['line', 'polyline', 'polygon'].indexOf(this.el.type) !== -1) {
        this.selectPoints(value);
    } else {
        this.selectRect(value);
    }

    this.observe();
    this.cleanup();

};

SelectHandler.prototype.selectPoints = function (value) {

    this.pointSelection.isSelected = value;

    // When set is already there we dont have to create one
    if (this.pointSelection.set) {
        return this;
    }

    // Create our set of elements
    this.pointSelection.set = this.parent.set();
    // draw the circles and mark the element as selected
    this.drawCircles();

    return this;

};

// create the point-array which contains the 2 points of a line or simply the points-array of polyline/polygon
SelectHandler.prototype.getPointArray = function () {
    var bbox = this.el.bbox();

    return this.el.array().valueOf().map(function (el) {
        return [el[0] - bbox.x, el[1] - bbox.y];
    });
};

// The function to draw the circles
SelectHandler.prototype.drawCircles = function () {

    var _this = this, array = this.getPointArray();

    // go through the array of points
    for (var i = 0, len = array.length; i < len; ++i) {

        var curriedEvent = (function (k) {
            return function (ev) {
                ev = ev || window.event;
                ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
                ev.stopPropagation();

                var x = ev.pageX || ev.touches[0].pageX;
                var y = ev.pageY || ev.touches[0].pageY;
                _this.el.fire('point', {x: x, y: y, i: k, event: ev});
            };
        })(i);

        // add every point to the set
        this.pointSelection.set.add(
            // a circle with our css-classes and a touchstart-event which fires our event for moving points
            this.nested.circle(this.options.radius)
                .center(array[i][0], array[i][1])
                .addClass(this.options.classPoints)
                .addClass(this.options.classPoints + '_point')
                .on('touchstart', curriedEvent)
                .on('mousedown', curriedEvent)
        );
    }

};

// every time a circle is moved, we have to update the positions of our circle
SelectHandler.prototype.updatePointSelection = function () {
    var array = this.getPointArray();

    this.pointSelection.set.each(function (i) {
        if (this.cx() === array[i][0] && this.cy() === array[i][1]) {
            return;
        }
        this.center(array[i][0], array[i][1]);
    });
};

SelectHandler.prototype.updateRectSelection = function () {
    var bbox = this.el.bbox();

    this.rectSelection.set.get(0).attr({
        width: bbox.width,
        height: bbox.height
    });

    // set.get(1) is always in the upper left corner. no need to move it
    if (this.options.points) {
        this.rectSelection.set.get(2).center(bbox.width, 0);
        this.rectSelection.set.get(3).center(bbox.width, bbox.height);
        this.rectSelection.set.get(4).center(0, bbox.height);

        this.rectSelection.set.get(5).center(bbox.width / 2, 0);
        this.rectSelection.set.get(6).center(bbox.width, bbox.height / 2);
        this.rectSelection.set.get(7).center(bbox.width / 2, bbox.height);
        this.rectSelection.set.get(8).center(0, bbox.height / 2);
    }

    if (this.options.rotationPoint) {
        if (this.options.points) {
            this.rectSelection.set.get(9).center(bbox.width / 2, 20);
        } else {
            this.rectSelection.set.get(1).center(bbox.width / 2, 20);
        }
    }
};

SelectHandler.prototype.selectRect = function (value) {

    var _this = this, bbox = this.el.bbox();

    this.rectSelection.isSelected = value;

    // when set is already p
    this.rectSelection.set = this.rectSelection.set || this.parent.set();

    // helperFunction to create a mouse-down function which triggers the event specified in `eventName`
    function getMoseDownFunc(eventName) {
        return function (ev) {
            ev = ev || window.event;
            ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
            ev.stopPropagation();

            var x = ev.pageX || ev.touches[0].pageX;
            var y = ev.pageY || ev.touches[0].pageY;
            _this.el.fire(eventName, {x: x, y: y, event: ev});
        };
    }

    // create the selection-rectangle and add the css-class
    if (!this.rectSelection.set.get(0)) {
        this.rectSelection.set.add(this.nested.rect(bbox.width, bbox.height).addClass(this.options.classRect));
    }

    // Draw Points at the edges, if enabled
    if (this.options.points && !this.rectSelection.set.get(1)) {
        var ename ="touchstart", mname = "mousedown";
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, 0).attr('class', this.options.classPoints + '_lt').on(mname, getMoseDownFunc('lt')).on(ename, getMoseDownFunc('lt')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, 0).attr('class', this.options.classPoints + '_rt').on(mname, getMoseDownFunc('rt')).on(ename, getMoseDownFunc('rt')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, bbox.height).attr('class', this.options.classPoints + '_rb').on(mname, getMoseDownFunc('rb')).on(ename, getMoseDownFunc('rb')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, bbox.height).attr('class', this.options.classPoints + '_lb').on(mname, getMoseDownFunc('lb')).on(ename, getMoseDownFunc('lb')));

        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, 0).attr('class', this.options.classPoints + '_t').on(mname, getMoseDownFunc('t')).on(ename, getMoseDownFunc('t')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width, bbox.height / 2).attr('class', this.options.classPoints + '_r').on(mname, getMoseDownFunc('r')).on(ename, getMoseDownFunc('r')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, bbox.height).attr('class', this.options.classPoints + '_b').on(mname, getMoseDownFunc('b')).on(ename, getMoseDownFunc('b')));
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(0, bbox.height / 2).attr('class', this.options.classPoints + '_l').on(mname, getMoseDownFunc('l')).on(ename, getMoseDownFunc('l')));

        this.rectSelection.set.each(function () {
            this.addClass(_this.options.classPoints);
        });
    }

    // draw rotationPint, if enabled
    if (this.options.rotationPoint && ((this.options.points && !this.rectSelection.set.get(9)) || (!this.options.points && !this.rectSelection.set.get(1)))) {

        var curriedEvent = function (ev) {
            ev = ev || window.event;
            ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
            ev.stopPropagation();

            var x = ev.pageX || ev.touches[0].pageX;
            var y = ev.pageY || ev.touches[0].pageY;
            _this.el.fire('rot', {x: x, y: y, event: ev});
        };
        this.rectSelection.set.add(this.nested.circle(this.options.radius).center(bbox.width / 2, 20).attr('class', this.options.classPoints + '_rot')
            .on("touchstart", curriedEvent).on("mousedown", curriedEvent));

    }

};

SelectHandler.prototype.handler = function () {

    var bbox = this.el.bbox();
    this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));

    if (this.rectSelection.isSelected) {
        this.updateRectSelection();
    }

    if (this.pointSelection.isSelected) {
        this.updatePointSelection();
    }

};

SelectHandler.prototype.observe = function () {
    var _this = this;

    if (MutationObserver) {
        if (this.rectSelection.isSelected || this.pointSelection.isSelected) {
            this.observerInst = this.observerInst || new MutationObserver(function () {
                _this.handler();
            });
            this.observerInst.observe(this.el.node, {attributes: true});
        } else {
            try {
                this.observerInst.disconnect();
                delete this.observerInst;
            } catch (e) {
            }
        }
    } else {
        this.el.off('DOMAttrModified.select');

        if (this.rectSelection.isSelected || this.pointSelection.isSelected) {
            this.el.on('DOMAttrModified.select', function () {
                _this.handler();
            });
        }
    }
};

SelectHandler.prototype.cleanup = function () {

    //var _this = this;

    if (!this.rectSelection.isSelected && this.rectSelection.set) {
        // stop watching the element, remove the selection
        this.rectSelection.set.each(function () {
            this.remove();
        });

        this.rectSelection.set.clear();
        delete this.rectSelection.set;
    }

    if (!this.pointSelection.isSelected && this.pointSelection.set) {
        // Remove all points, clear the set, stop watching the element
        this.pointSelection.set.each(function () {
            this.remove();
        });

        this.pointSelection.set.clear();
        delete this.pointSelection.set;
    }

    if (!this.pointSelection.isSelected && !this.rectSelection.isSelected) {
        this.nested.remove();
        delete this.nested;

    }
};


SVG.extend(SVG.Element, {
    // Select element with mouse
    selectize: function (value, options) {

        // Check the parameters and reassign if needed
        if (typeof value === 'object') {
            options = value;
            value = true;
        }

        var selectHandler = this.remember('_selectHandler') || new SelectHandler(this);

        selectHandler.init(value === undefined ? true : value, options || {});

        return this;

    }
});

SVG.Element.prototype.selectize.defaults = {
    points: true,                            // If true, points at the edges are drawn. Needed for resize!
    classRect: 'svg_select_boundingRect',    // Css-class added to the rect
    classPoints: 'svg_select_points',        // Css-class added to the points
    radius: 7,                               // radius of the points
    rotationPoint: true,                     // If true, rotation point is drawn. Needed for rotation!
    deepSelect: false                        // If true, moving of single points is possible (only line, polyline, polyon)
};
}());

(function() {
(function () {

    function ResizeHandler(el) {

        el.remember('_resizeHandler', this);

        this.el = el;
        this.parameters = {};
        this.lastUpdateCall = null;
        this.p = el.doc().node.createSVGPoint();
    }

    ResizeHandler.prototype.transformPoint = function(x, y, m){

        this.p.x = x - (this.offset.x - window.pageXOffset);
        this.p.y = y - (this.offset.y - window.pageYOffset);

        return this.p.matrixTransform(m || this.m);

    };

    ResizeHandler.prototype._extractPosition = function(event) {
        // Extract a position from a mouse/touch event.
        // Returns { x: .., y: .. }
        return {
            x: event.clientX != null ? event.clientX : event.touches[0].clientX,
            y: event.clientY != null ? event.clientY : event.touches[0].clientY
        }
    };

    ResizeHandler.prototype.init = function (options) {

        var _this = this;

        this.stop();

        if (options === 'stop') {
            return;
        }

        this.options = {};

        // Merge options and defaults
        for (var i in this.el.resize.defaults) {
            this.options[i] = this.el.resize.defaults[i];
            if (typeof options[i] !== 'undefined') {
                this.options[i] = options[i];
            }
        }

        // We listen to all these events which are specifying different edges
        this.el.on('lt.resize', function(e){ _this.resize(e || window.event); });  // Left-Top
        this.el.on('rt.resize', function(e){ _this.resize(e || window.event); });  // Right-Top
        this.el.on('rb.resize', function(e){ _this.resize(e || window.event); });  // Right-Bottom
        this.el.on('lb.resize', function(e){ _this.resize(e || window.event); });  // Left-Bottom

        this.el.on('t.resize', function(e){ _this.resize(e || window.event); });   // Top
        this.el.on('r.resize', function(e){ _this.resize(e || window.event); });   // Right
        this.el.on('b.resize', function(e){ _this.resize(e || window.event); });   // Bottom
        this.el.on('l.resize', function(e){ _this.resize(e || window.event); });   // Left

        this.el.on('rot.resize', function(e){ _this.resize(e || window.event); }); // Rotation

        this.el.on('point.resize', function(e){ _this.resize(e || window.event); }); // Point-Moving

        // This call ensures, that the plugin reacts to a change of snapToGrid immediately
        this.update();

    };

    ResizeHandler.prototype.stop = function(){
        this.el.off('lt.resize');
        this.el.off('rt.resize');
        this.el.off('rb.resize');
        this.el.off('lb.resize');

        this.el.off('t.resize');
        this.el.off('r.resize');
        this.el.off('b.resize');
        this.el.off('l.resize');

        this.el.off('rot.resize');

        this.el.off('point.resize');

        return this;
    };

    ResizeHandler.prototype.resize = function (event) {

        var _this = this;

        this.m = this.el.node.getScreenCTM().inverse();
        this.offset = { x: window.pageXOffset, y: window.pageYOffset };

        var txPt = this._extractPosition(event.detail.event);
        this.parameters = {
            type: this.el.type, // the type of element
            p: this.transformPoint(txPt.x, txPt.y),
            x: event.detail.x,      // x-position of the mouse when resizing started
            y: event.detail.y,      // y-position of the mouse when resizing started
            box: this.el.bbox(),    // The bounding-box of the element
            rotation: this.el.transform().rotation  // The current rotation of the element
        };

        // Add font-size parameter if the element type is text
        if (this.el.type === "text") {
            this.parameters.fontSize = this.el.attr()["font-size"];
        }

        // the i-param in the event holds the index of the point which is moved, when using `deepSelect`
        if (event.detail.i !== undefined) {

            // get the point array
            var array = this.el.array().valueOf();

            // Save the index and the point which is moved
            this.parameters.i = event.detail.i;
            this.parameters.pointCoords = [array[event.detail.i][0], array[event.detail.i][1]];
        }

        // Lets check which edge of the bounding-box was clicked and resize the this.el according to this
        switch (event.type) {

            // Left-Top-Edge
            case 'lt':
                // We build a calculating function for every case which gives us the new position of the this.el
                this.calc = function (diffX, diffY) {
                    // The procedure is always the same
                    // First we snap the edge to the given grid (snapping to 1px grid is normal resizing)
                    var snap = this.snapToGrid(diffX, diffY);

                    // Now we check if the new height and width still valid (> 0)
                    if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {
                        // ...if valid, we resize the this.el (which can include moving because the coord-system starts at the left-top and this edge is moving sometimes when resized)

                        /*
                         * but first check if the element is text box, so we can change the font size instead of
                         * the width and height
                         */

                        if (this.parameters.type === "text") {
                            this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);
                            this.el.attr("font-size", this.parameters.fontSize - snap[0]);
                            return;
                        }

                        snap = this.checkAspectRatio(snap);

                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y + snap[1]).size(this.parameters.box.width - snap[0], this.parameters.box.height - snap[1]);
                    }
                };
                break;

            // Right-Top
            case 'rt':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 1 << 1);
                    if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height - snap[1] > 0) {
                        if (this.parameters.type === "text") {
                            this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);
                            this.el.attr("font-size", this.parameters.fontSize + snap[0]);
                            return;
                        }

                        snap = this.checkAspectRatio(snap);

                        this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]).size(this.parameters.box.width + snap[0], this.parameters.box.height - snap[1]);
                    }
                };
                break;

            // Right-Bottom
            case 'rb':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 0);
                    if (this.parameters.box.width + snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {
                        if (this.parameters.type === "text") {
                            this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);
                            this.el.attr("font-size", this.parameters.fontSize + snap[0]);
                            return;
                        }

                        snap = this.checkAspectRatio(snap);

                        this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + snap[0], this.parameters.box.height + snap[1]);
                    }
                };
                break;

            // Left-Bottom
            case 'lb':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 1);
                    if (this.parameters.box.width - snap[0] > 0 && this.parameters.box.height + snap[1] > 0) {
                        if (this.parameters.type === "text") {
                            this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);
                            this.el.attr("font-size", this.parameters.fontSize - snap[0]);
                            return;
                        }

                        snap = this.checkAspectRatio(snap);

                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y).size(this.parameters.box.width - snap[0], this.parameters.box.height + snap[1]);
                    }
                };
                break;

            // Top
            case 't':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 1 << 1);
                    if (this.parameters.box.height - snap[1] > 0) {
                        // Disable the font-resizing if it is not from the corner of bounding-box
                        if (this.parameters.type === "text") {
                            return;
                        }

                        this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]).height(this.parameters.box.height - snap[1]);
                    }
                };
                break;

            // Right
            case 'r':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 0);
                    if (this.parameters.box.width + snap[0] > 0) {
                        if (this.parameters.type === "text") {
                            return;
                        }

                        this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + snap[0]);
                    }
                };
                break;

            // Bottom
            case 'b':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 0);
                    if (this.parameters.box.height + snap[1] > 0) {
                        if (this.parameters.type === "text") {
                            return;
                        }

                        this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + snap[1]);
                    }
                };
                break;

            // Left
            case 'l':
                // s.a.
                this.calc = function (diffX, diffY) {
                    var snap = this.snapToGrid(diffX, diffY, 1);
                    if (this.parameters.box.width - snap[0] > 0) {
                        if (this.parameters.type === "text") {
                            return;
                        }

                        this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y).width(this.parameters.box.width - snap[0]);
                    }
                };
                break;

            // Rotation
            case 'rot':
                // s.a.
                this.calc = function (diffX, diffY) {

                    // yes this is kinda stupid but we need the mouse coords back...
                    var current = {x: diffX + this.parameters.p.x, y: diffY + this.parameters.p.y};

                    // start minus middle
                    var sAngle = Math.atan2((this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2), (this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2));

                    // end minus middle
                    var pAngle = Math.atan2((current.y - this.parameters.box.y - this.parameters.box.height / 2), (current.x - this.parameters.box.x - this.parameters.box.width / 2));

                    var angle = (pAngle - sAngle) * 180 / Math.PI;

                    // We have to move the element to the center of the box first and change the rotation afterwards
                    // because rotation always works around a rotation-center, which is changed when moving the element
                    // We also set the new rotation center to the center of the box.
                    this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(this.parameters.rotation + angle - angle % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
                };
                break;

            // Moving one single Point (needed when an element is deepSelected which means you can move every single point of the object)
            case 'point':
                this.calc = function (diffX, diffY) {

                    // Snapping the point to the grid
                    var snap = this.snapToGrid(diffX, diffY, this.parameters.pointCoords[0], this.parameters.pointCoords[1]);

                    // Get the point array
                    var array = this.el.array().valueOf();

                    // Changing the moved point in the array
                    array[this.parameters.i][0] = this.parameters.pointCoords[0] + snap[0];
                    array[this.parameters.i][1] = this.parameters.pointCoords[1] + snap[1];

                    // And plot the new this.el
                    this.el.plot(array);
                };
        }

        this.el.fire('resizestart', {dx: this.parameters.x, dy: this.parameters.y, event: event});
        // When resizing started, we have to register events for...
        // Touches.
        SVG.on(window, 'touchmove.resize', function(e) {
            _this.update(e || window.event);
        });
        SVG.on(window, 'touchend.resize', function() {
            _this.done();
        });
        // Mouse.
        SVG.on(window, 'mousemove.resize', function (e) {
            _this.update(e || window.event);
        });
        SVG.on(window, 'mouseup.resize', function () {
            _this.done();
        });

    };

    // The update-function redraws the element every time the mouse is moving
    ResizeHandler.prototype.update = function (event) {

        if (!event) {
            if (this.lastUpdateCall) {
                this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
            }
            return;
        }

        // Calculate the difference between the mouseposition at start and now
        var txPt = this._extractPosition(event);
        var p = this.transformPoint(txPt.x, txPt.y);

        var diffX = p.x - this.parameters.p.x,
            diffY = p.y - this.parameters.p.y;

        this.lastUpdateCall = [diffX, diffY];

        // Calculate the new position and height / width of the element
        this.calc(diffX, diffY);

       // Emit an event to say we have changed.
        this.el.fire('resizing', {dx: diffX, dy: diffY, event: event});
    };

    // Is called on mouseup.
    // Removes the update-function from the mousemove event
    ResizeHandler.prototype.done = function () {
        this.lastUpdateCall = null;
        SVG.off(window, 'mousemove.resize');
        SVG.off(window, 'mouseup.resize');
        SVG.off(window, 'touchmove.resize');
        SVG.off(window, 'touchend.resize');
        this.el.fire('resizedone');
    };

    // The flag is used to determine whether the resizing is used with a left-Point (first bit) and top-point (second bit)
    // In this cases the temp-values are calculated differently
    ResizeHandler.prototype.snapToGrid = function (diffX, diffY, flag, pointCoordsY) {

        var temp;

        // If `pointCoordsY` is given, a single Point has to be snapped (deepSelect). That's why we need a different temp-value
        if (typeof pointCoordsY !== 'undefined') {
            // Note that flag = pointCoordsX in this case
            temp = [(flag + diffX) % this.options.snapToGrid, (pointCoordsY + diffY) % this.options.snapToGrid];
        } else {
            // We check if the flag is set and if not we set a default-value (both bits set - which means upper-left-edge)
            flag = flag == null ? 1 | 1 << 1 : flag;
            temp = [(this.parameters.box.x + diffX + (flag & 1 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + diffY + (flag & (1 << 1) ? 0 : this.parameters.box.height)) % this.options.snapToGrid];
        }


        diffX -= (Math.abs(temp[0]) < this.options.snapToGrid / 2 ?
                  temp[0] :
                  temp[0] - (diffX < 0 ? -this.options.snapToGrid : this.options.snapToGrid));
        diffY -= (Math.abs(temp[1]) < this.options.snapToGrid / 2 ?
                  temp[1] :
                  temp[1] - (diffY < 0 ? -this.options.snapToGrid : this.options.snapToGrid));

        return this.constraintToBox(diffX, diffY, flag, pointCoordsY);

    };

    // keep element within constrained box
    ResizeHandler.prototype.constraintToBox = function (diffX, diffY, flag, pointCoordsY) {
        //return [diffX, diffY]
        var c = this.options.constraint || {};
        var orgX, orgY;

        if (typeof pointCoordsY !== 'undefined') {
          orgX = flag;
          orgY = pointCoordsY;
        } else {
          orgX = this.parameters.box.x + (flag & 1 ? 0 : this.parameters.box.width);
          orgY = this.parameters.box.y + (flag & (1<<1) ? 0 : this.parameters.box.height);
        }

        if (typeof c.minX !== 'undefined' && orgX + diffX < c.minX) {
          diffX = c.minX - orgX;
        }

        if (typeof c.maxX !== 'undefined' && orgX + diffX > c.maxX) {
          diffX = c.maxX - orgX;
        }

        if (typeof c.minY !== 'undefined' && orgY + diffY < c.minY) {
          diffY = c.minY - orgY;
        }

        if (typeof c.maxY !== 'undefined' && orgY + diffY > c.maxY) {
          diffY = c.maxY - orgY;
        }

        return [diffX, diffY];
    };

    ResizeHandler.prototype.checkAspectRatio = function (snap) {
        if (!this.options.saveAspectRatio) {
            return snap;
        }

        var updatedSnap = snap.slice();
        var aspectRatio = this.parameters.box.width / this.parameters.box.height;
        var newW = this.parameters.box.width + snap[0];
        var newH = this.parameters.box.height - snap[1];
        var newAspectRatio = newW / newH;

        if (newAspectRatio < aspectRatio) {
            // Height is too big. Adapt it
            updatedSnap[1] = newW / aspectRatio - this.parameters.box.height;
        } else if (newAspectRatio > aspectRatio) {
            // Width is too big. Adapt it
            updatedSnap[0] = this.parameters.box.width - newH * aspectRatio;
        }

        return updatedSnap;

    };

    SVG.extend(SVG.Element, {
        // Resize element with mouse
        resize: function (options) {

            (this.remember('_resizeHandler') || new ResizeHandler(this)).init(options || {});

            return this;

        }

    });

    SVG.Element.prototype.resize.defaults = {
        snapToAngle: 0.1,       // Specifies the speed the rotation is happening when moving the mouse
        snapToGrid: 1,          // Snaps to a grid of `snapToGrid` Pixels
        constraint: {},         // keep element within constrained box
        saveAspectRatio: false  // Save aspect ratio when resizing using lt, rt, rb or lb points
    };

}).call(this);
}());

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5);\n}\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-gridline, .apexcharts-text {\n  pointer-events: none;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n.apexcharts-tooltip.light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n.apexcharts-tooltip.dark {\n  color: #fff;\n  background: rgba(30,30,30, 0.8);\n}\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line {\n  pointer-events: none;\n}\n\n.apexcharts-tooltip.active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n.apexcharts-tooltip.light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n.apexcharts-tooltip.dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #222;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-text-z-label:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-value, \n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n.apexcharts-tooltip-series-group.active, .apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n.apexcharts-tooltip-candlestick {\n  padding: 4px 8px;\n}\n.apexcharts-tooltip-candlestick > div {\n  margin: 4px 0;\n}\n.apexcharts-tooltip-candlestick span.value {\n  font-weight: bold;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n\tbackground: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip:after, .apexcharts-xaxistooltip:before {\n\tleft: 50%;\n\tborder: solid transparent;\n\tcontent: \" \";\n\theight: 0;\n\twidth: 0;\n\tposition: absolute;\n\tpointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n\tborder-color: rgba(236, 239, 241, 0);\n\tborder-width: 6px;\n\tmargin-left: -6px;\n}\n.apexcharts-xaxistooltip:before {\n\tborder-color: rgba(144, 164, 174, 0);\n\tborder-width: 7px;\n\tmargin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after, .apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-top:after, .apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #ECEFF1;\n}\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip.active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n\tbackground: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip:after, .apexcharts-yaxistooltip:before {\n\ttop: 50%;\n\tborder: solid transparent;\n\tcontent: \" \";\n\theight: 0;\n\twidth: 0;\n\tposition: absolute;\n\tpointer-events: none;\n}\n.apexcharts-yaxistooltip:after {\n\tborder-color: rgba(236, 239, 241, 0);\n\tborder-width: 6px;\n\tmargin-top: -6px;\n}\n.apexcharts-yaxistooltip:before {\n\tborder-color: rgba(144, 164, 174, 0);\n\tborder-width: 7px;\n\tmargin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after, .apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-right:after, .apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip.active {\n  opacity: 1;\n}\n\n.apexcharts-xcrosshairs, .apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.active, .apexcharts-ycrosshairs.active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-zoom-rect {\n  pointer-events: none;\n}\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_points, .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n.svg_select_points_l, .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n  fill: #888;\n}\n.apexcharts-canvas.zoomable .hovering-zoom {\n  cursor: crosshair\n}\n.apexcharts-canvas.zoomable .hovering-pan {\n  cursor: move\n}\n\n.apexcharts-xaxis,\n.apexcharts-yaxis {\n  pointer-events: none;\n}\n\n.apexcharts-zoom-icon, \n.apexcharts-zoom-in-icon,\n.apexcharts-zoom-out-icon,\n.apexcharts-reset-zoom-icon, \n.apexcharts-pan-icon, \n.apexcharts-selection-icon,\n.apexcharts-menu-icon, \n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n.apexcharts-zoom-icon svg, \n.apexcharts-zoom-in-icon svg,\n.apexcharts-zoom-out-icon svg,\n.apexcharts-reset-zoom-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n.apexcharts-zoom-icon.selected svg, \n.apexcharts-selection-icon.selected svg, \n.apexcharts-reset-zoom-icon.selected svg {\n  fill: #008FFB;\n}\n.apexcharts-selection-icon:not(.selected):hover svg,\n.apexcharts-zoom-icon:not(.selected):hover svg, \n.apexcharts-zoom-in-icon:hover svg, \n.apexcharts-zoom-out-icon:hover svg, \n.apexcharts-reset-zoom-icon:hover svg, \n.apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon, .apexcharts-menu-icon {\n  position: relative;\n}\n.apexcharts-reset-zoom-icon {\n  margin-left: 5px;\n}\n.apexcharts-zoom-icon, .apexcharts-reset-zoom-icon, .apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoom-in-icon, .apexcharts-zoom-out-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoom-out-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n.apexcharts-pan-icon.selected svg {\n  stroke: #008FFB;\n}\n.apexcharts-pan-icon:not(.selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  top: 0px;\n  right: 3px;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center; \n}\n\n.apexcharts-toolbar svg {\n  pointer-events: none;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n.apexcharts-menu-item:hover {\n  background: #eee;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-toolbar {\n    /*opacity: 0;*/\n  }\n\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  } \n}\n\n.apexcharts-datalabel.hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabel, .apexcharts-datalabel-label, .apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events, .apexcharts-radar-series path, .apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}";
styleInject(css);

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.2.20171210
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */
if ("document" in self) {
  // Full polyfill for browsers with no classList support
  // Including IE < Edge missing SVGElement.classList
  if (!("classList" in document.createElement("_")) || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg", "g"))) {
    (function (view) {

      if (!('Element' in view)) return;

      var classListProp = "classList",
          protoProp = "prototype",
          elemCtrProto = view.Element[protoProp],
          objCtr = Object,
          strTrim = String[protoProp].trim || function () {
        return this.replace(/^\s+|\s+$/g, "");
      },
          arrIndexOf = Array[protoProp].indexOf || function (item) {
        var i = 0,
            len = this.length;

        for (; i < len; i++) {
          if (i in this && this[i] === item) {
            return i;
          }
        }

        return -1;
      } // Vendors: please allow content code to instantiate DOMExceptions
      ,
          DOMEx = function DOMEx(type, message) {
        this.name = type;
        this.code = DOMException[type];
        this.message = message;
      },
          checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {
        if (token === "") {
          throw new DOMEx("SYNTAX_ERR", "The token must not be empty.");
        }

        if (/\s/.test(token)) {
          throw new DOMEx("INVALID_CHARACTER_ERR", "The token must not contain space characters.");
        }

        return arrIndexOf.call(classList, token);
      },
          ClassList = function ClassList(elem) {
        var trimmedClasses = strTrim.call(elem.getAttribute("class") || ""),
            classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [],
            i = 0,
            len = classes.length;

        for (; i < len; i++) {
          this.push(classes[i]);
        }

        this._updateClassName = function () {
          elem.setAttribute("class", this.toString());
        };
      },
          classListProto = ClassList[protoProp] = [],
          classListGetter = function classListGetter() {
        return new ClassList(this);
      }; // Most DOMException implementations don't allow calling DOMException's toString()
      // on non-DOMExceptions. Error's toString() is sufficient here.


      DOMEx[protoProp] = Error[protoProp];

      classListProto.item = function (i) {
        return this[i] || null;
      };

      classListProto.contains = function (token) {
        return ~checkTokenAndGetIndex(this, token + "");
      };

      classListProto.add = function () {
        var tokens = arguments,
            i = 0,
            l = tokens.length,
            token,
            updated = false;

        do {
          token = tokens[i] + "";

          if (!~checkTokenAndGetIndex(this, token)) {
            this.push(token);
            updated = true;
          }
        } while (++i < l);

        if (updated) {
          this._updateClassName();
        }
      };

      classListProto.remove = function () {
        var tokens = arguments,
            i = 0,
            l = tokens.length,
            token,
            updated = false,
            index;

        do {
          token = tokens[i] + "";
          index = checkTokenAndGetIndex(this, token);

          while (~index) {
            this.splice(index, 1);
            updated = true;
            index = checkTokenAndGetIndex(this, token);
          }
        } while (++i < l);

        if (updated) {
          this._updateClassName();
        }
      };

      classListProto.toggle = function (token, force) {
        var result = this.contains(token),
            method = result ? force !== true && "remove" : force !== false && "add";

        if (method) {
          this[method](token);
        }

        if (force === true || force === false) {
          return force;
        } else {
          return !result;
        }
      };

      classListProto.replace = function (token, replacement_token) {
        var index = checkTokenAndGetIndex(token + "");

        if (~index) {
          this.splice(index, 1, replacement_token);

          this._updateClassName();
        }
      };

      classListProto.toString = function () {
        return this.join(" ");
      };

      if (objCtr.defineProperty) {
        var classListPropDesc = {
          get: classListGetter,
          enumerable: true,
          configurable: true
        };

        try {
          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
        } catch (ex) {
          // IE 8 doesn't support enumerable:true
          // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
          // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
          if (ex.number === undefined || ex.number === -0x7FF5EC54) {
            classListPropDesc.enumerable = false;
            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
          }
        }
      } else if (objCtr[protoProp].__defineGetter__) {
        elemCtrProto.__defineGetter__(classListProp, classListGetter);
      }
    })(self);
  } // There is full or partial native classList support, so just check if we need
  // to normalize the add/remove and toggle APIs.


  (function () {

    var testElement = document.createElement("_");
    testElement.classList.add("c1", "c2"); // Polyfill for IE 10/11 and Firefox <26, where classList.add and
    // classList.remove exist but support only one argument at a time.

    if (!testElement.classList.contains("c2")) {
      var createMethod = function createMethod(method) {
        var original = DOMTokenList.prototype[method];

        DOMTokenList.prototype[method] = function (token) {
          var i,
              len = arguments.length;

          for (i = 0; i < len; i++) {
            token = arguments[i];
            original.call(this, token);
          }
        };
      };

      createMethod('add');
      createMethod('remove');
    }

    testElement.classList.toggle("c3", false); // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
    // support the second argument.

    if (testElement.classList.contains("c3")) {
      var _toggle = DOMTokenList.prototype.toggle;

      DOMTokenList.prototype.toggle = function (token, force) {
        if (1 in arguments && !this.contains(token) === !force) {
          return force;
        } else {
          return _toggle.call(this, token);
        }
      };
    } // replace() polyfill


    if (!("replace" in document.createElement("_").classList)) {
      DOMTokenList.prototype.replace = function (token, replacement_token) {
        var tokens = this.toString().split(" "),
            index = tokens.indexOf(token + "");

        if (~index) {
          tokens = tokens.slice(index);
          this.remove.apply(this, tokens);
          this.add(replacement_token);
          this.add.apply(this, tokens.slice(1));
        }
      };
    }

    testElement = null;
  })();
}

/**
* Detect Element Resize
*
* https://github.com/sdecima/javascript-detect-element-resize
* Sebastian Decima
*
* version: 0.5.3
**/
(function () {
  var stylesCreated = false;

  function resetTriggers(element) {
    var triggers = element.__resizeTriggers__,
        expand = triggers.firstElementChild,
        contract = triggers.lastElementChild,
        expandChild = expand.firstElementChild;
    contract.scrollLeft = contract.scrollWidth;
    contract.scrollTop = contract.scrollHeight;
    expandChild.style.width = expand.offsetWidth + 1 + 'px';
    expandChild.style.height = expand.offsetHeight + 1 + 'px';
    expand.scrollLeft = expand.scrollWidth;
    expand.scrollTop = expand.scrollHeight;
  }

  function checkTriggers(element) {
    return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
  }

  function scrollListener(e) {
    var element = this;
    resetTriggers(this);
    if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
    this.__resizeRAF__ = requestFrame(function () {
      if (checkTriggers(element)) {
        element.__resizeLast__.width = element.offsetWidth;
        element.__resizeLast__.height = element.offsetHeight;

        element.__resizeListeners__.forEach(function (fn) {
          fn.call(e);
        });
      }
    });
  }

  function createStyles() {
    if (!stylesCreated) {
      // opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
      var css = (animationKeyframes || '') + '.resize-triggers { ' + (animationStyle || '') + 'visibility: hidden; opacity: 0; } ' + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
          head = document.head || document.getElementsByTagName('head')[0],
          style = document.createElement('style');
      style.type = 'text/css';

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }

      head.appendChild(style);
      stylesCreated = true;
    }
  }

  var requestFrame = function () {
    var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
      return window.setTimeout(fn, 20);
    };

    return function (fn) {
      return raf(fn);
    };
  }();

  var cancelFrame = function () {
    var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
    return function (id) {
      return cancel(id);
    };
  }();
  /* Detect CSS Animations support to detect element display/re-attach */


  var animation = false,
      keyframeprefix = '',
      animationstartevent = 'animationstart',
      domPrefixes = 'Webkit Moz O ms'.split(' '),
      startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),
      pfx = '';
  {
    var elm = document.createElement('fakeelement');

    if (elm.style.animationName !== undefined) {
      animation = true;
    }

    if (animation === false) {
      for (var i = 0; i < domPrefixes.length; i++) {
        if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
          pfx = domPrefixes[i];
          keyframeprefix = '-' + pfx.toLowerCase() + '-';
          animationstartevent = startEvents[i];
          break;
        }
      }
    }
  }
  var animationName = 'resizeanim';
  var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';
  var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';

  window.addResizeListener = function (element, fn) {
    if (!element.__resizeTriggers__) {
      if (getComputedStyle(element).position == 'static') element.style.position = 'relative';
      createStyles();
      element.__resizeLast__ = {};
      element.__resizeListeners__ = [];
      (element.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers';
      element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div>' + '<div class="contract-trigger"></div>';
      element.appendChild(element.__resizeTriggers__);
      resetTriggers(element);
      element.addEventListener('scroll', scrollListener, true);
      /* Listen for a css animation to detect element display/re-attach */

      animationstartevent && element.__resizeTriggers__.addEventListener(animationstartevent, function (e) {
        if (e.animationName == animationName) {
          resetTriggers(element);
        }
      });
    }

    element.__resizeListeners__.push(fn);
  };

  window.removeResizeListener = function (element, fn) {
    if (element) {
      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);

      if (!element.__resizeListeners__.length) {
        element.removeEventListener('scroll', scrollListener);
        element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
      }
    }
  };
})();

window.Apex = {};
/**
 *
 * @module ApexCharts
 **/

var ApexCharts$1 =
/*#__PURE__*/
function () {
  function ApexCharts(el, opts) {
    _classCallCheck(this, ApexCharts);

    this.opts = opts;
    this.ctx = this; // Pass the user supplied options to the Base Class where these options will be extended with defaults. The returned object from Base Class will become the config object in the entire codebase.

    this.w = new Base(opts).init();
    this.el = el;
    this.w.globals.cuid = (Math.random() + 1).toString(36).substring(4);
    this.w.globals.chartID = this.w.config.chart.id ? this.w.config.chart.id : this.w.globals.cuid;
    this.initModules();
    this.create = Utils.bind(this.create, this);
    this.windowResizeHandler = this.windowResize.bind(this);
  }
  /**
   * The primary method user will call to render the chart.
   */


  _createClass(ApexCharts, [{
    key: "render",
    value: function render() {
      var _this = this;

      // main method
      return new Promise$1(function (resolve, reject) {
        // only draw chart, if element found
        if (_this.el !== null) {
          if (typeof Apex._chartInstances === 'undefined') {
            Apex._chartInstances = [];
          }

          if (_this.w.config.chart.id) {
            Apex._chartInstances.push({
              id: _this.w.globals.chartID,
              group: _this.w.config.chart.group,
              chart: _this
            });
          } // set the locale here


          _this.setLocale(_this.w.config.chart.defaultLocale);

          var beforeMount = _this.w.config.chart.events.beforeMount;

          if (typeof beforeMount === 'function') {
            beforeMount(_this, _this.w);
          }

          _this.fireEvent('beforeMount', [_this, _this.w]);

          window.addEventListener('resize', _this.windowResizeHandler);
          window.addResizeListener(_this.el.parentNode, _this.parentResizeCallback.bind(_this));

          var graphData = _this.create(_this.w.config.series, {});

          if (!graphData) return resolve(_this);

          _this.mount(graphData).then(function () {
            resolve(graphData);

            if (typeof _this.w.config.chart.events.mounted === 'function') {
              _this.w.config.chart.events.mounted(_this, _this.w);
            }

            _this.fireEvent('mounted', [_this, _this.w]);
          }).catch(function (e) {
            reject(e); // handle error in case no data or element not found
          });
        } else {
          reject(new Error('Element not found'));
        }
      });
    }
  }, {
    key: "initModules",
    value: function initModules() {
      this.animations = new Animations(this.ctx);
      this.annotations = new Annotations(this.ctx);
      this.core = new Core(this.el, this);
      this.grid = new Grid(this);
      this.coreUtils = new CoreUtils(this);
      this.config = new Config({});
      this.crosshairs = new Crosshairs(this.ctx);
      this.options = new Options();
      this.responsive = new Responsive(this.ctx);
      this.series = new Series(this.ctx);
      this.theme = new Theme(this.ctx);
      this.formatters = new Formatters(this.ctx);
      this.titleSubtitle = new TitleSubtitle(this.ctx);
      this.legend = new Legend(this.ctx);
      this.toolbar = new Toolbar(this.ctx);
      this.dimensions = new Dimensions(this.ctx);
      this.zoomPanSelection = new ZoomPanSelection(this.ctx);
      this.w.globals.tooltip = new Tooltip(this.ctx);
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(name$$1, handler) {
      var w = this.w;

      if (w.globals.events.hasOwnProperty(name$$1)) {
        w.globals.events[name$$1].push(handler);
      } else {
        w.globals.events[name$$1] = [handler];
      }
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(name$$1, handler) {
      var w = this.w;

      if (!w.globals.events.hasOwnProperty(name$$1)) {
        return;
      }

      var index = w.globals.events[name$$1].indexOf(handler);

      if (index !== -1) {
        w.globals.events[name$$1].splice(index, 1);
      }
    }
  }, {
    key: "fireEvent",
    value: function fireEvent(name$$1, args) {
      var w = this.w;

      if (!w.globals.events.hasOwnProperty(name$$1)) {
        return;
      }

      if (!args || !args.length) {
        args = [];
      }

      var evs = w.globals.events[name$$1];
      var l = evs.length;

      for (var i = 0; i < l; i++) {
        evs[i].apply(null, args);
      }
    }
  }, {
    key: "create",
    value: function create(ser, opts) {
      var w = this.w;
      this.initModules();
      var gl = this.w.globals;
      gl.noData = false;
      gl.animationEnded = false;
      this.responsive.checkResponsiveConfig(opts);

      if (this.el === null) {
        gl.animationEnded = true;
        return null;
      }

      this.core.setupElements();

      if (gl.svgWidth === 0) {
        // if the element is hidden, skip drawing
        gl.animationEnded = true;
        return null;
      }

      var combo = CoreUtils.checkComboSeries(ser);
      gl.comboCharts = combo.comboCharts;
      gl.comboChartsHasBars = combo.comboChartsHasBars;

      if (ser.length === 0 || ser.length === 1 && ser[0].data && ser[0].data.length === 0) {
        this.series.handleNoData();
      }

      this.setupEventHandlers();
      this.core.parseData(ser); // this is a good time to set theme colors first

      this.theme.init(); // labelFormatters should be called before dimensions as in dimensions we need text labels width
      // as markers accepts array, we need to setup global markers for easier access

      var markers = new Markers(this);
      markers.setGlobalMarkerSize();
      this.formatters.setLabelFormatters();
      this.titleSubtitle.draw(); // legend is calculated here before coreCalculations because it affects the plottable area

      this.legend.init(); // check whether in multiple series, all series share the same X

      this.series.hasAllSeriesEqualX(); // coreCalculations will give the min/max range and yaxis/axis values. It should be called here to set series variable from config to globals

      if (gl.axisCharts) {
        this.core.coreCalculations();

        if (w.config.xaxis.type !== 'category') {
          // as we have minX and maxX values, determine the default DateTimeFormat for time series
          this.formatters.setLabelFormatters();
        }
      } // we need to generate yaxis for heatmap separately as we are not showing numerics there, but seriesNames. There are some tweaks which are required for heatmap to align labels correctly which are done in below function
      // Also we need to do this before calcuting Dimentions plotCoords() method of Dimensions


      this.formatters.heatmapLabelFormatters(); // We got plottable area here, next task would be to calculate axis areas

      this.dimensions.plotCoords();
      var xyRatios = this.core.xySettings();
      this.grid.createGridMask();
      var elGraph = this.core.plotChartType(ser, xyRatios); // after all the drawing calculations, shift the graphical area (actual charts/bars) excluding legends

      this.core.shiftGraphPosition();
      var dim = {
        plot: {
          left: w.globals.translateX,
          top: w.globals.translateY,
          width: w.globals.gridWidth,
          height: w.globals.gridHeight
        }
      };
      return {
        elGraph: elGraph,
        xyRatios: xyRatios,
        elInner: w.globals.dom.elGraphical,
        dimensions: dim
      };
    }
  }, {
    key: "mount",
    value: function mount() {
      var graphData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var me = this;
      var w = me.w;
      return new Promise$1(function (resolve, reject) {
        // no data to display
        if (me.el === null) {
          return reject(new Error('Not enough data to display or target element not found'));
        } else if (graphData === null || w.globals.allSeriesCollapsed) {
          me.series.handleNoData();
        }

        me.core.drawAxis(w.config.chart.type, graphData.xyRatios);
        me.grid = new Grid(me);

        if (w.config.grid.position === 'back') {
          me.grid.drawGrid();
        }

        if (w.config.annotations.position === 'back') {
          me.annotations.drawAnnotations();
        }

        if (graphData.elGraph instanceof Array) {
          for (var g = 0; g < graphData.elGraph.length; g++) {
            w.globals.dom.elGraphical.add(graphData.elGraph[g]);
          }
        } else {
          w.globals.dom.elGraphical.add(graphData.elGraph);
        }

        if (w.config.grid.position === 'front') {
          me.grid.drawGrid();
        }

        if (w.config.xaxis.crosshairs.position === 'front') {
          me.crosshairs.drawXCrosshairs();
        }

        if (w.config.yaxis[0].crosshairs.position === 'front') {
          me.crosshairs.drawYCrosshairs();
        }

        if (w.config.annotations.position === 'front') {
          me.annotations.drawAnnotations();
        }

        if (!w.globals.noData) {
          // draw tooltips at the end
          if (w.config.tooltip.enabled && !w.globals.noData) {
            me.w.globals.tooltip.drawTooltip(graphData.xyRatios);
          }

          if (w.globals.axisCharts && w.globals.isXNumeric) {
            if (w.config.chart.zoom.enabled || w.config.chart.selection && w.config.chart.selection.enabled || w.config.chart.pan && w.config.chart.pan.enabled) {
              me.zoomPanSelection.init({
                xyRatios: graphData.xyRatios
              });
            }
          } else {
            var tools = w.config.chart.toolbar.tools;
            tools.zoom = false;
            tools.zoomin = false;
            tools.zoomout = false;
            tools.selection = false;
            tools.pan = false;
            tools.reset = false;
          }

          if (w.config.chart.toolbar.show && !w.globals.allSeriesCollapsed) {
            me.toolbar.createToolbar();
          }
        }

        if (w.globals.memory.methodsToExec.length > 0) {
          w.globals.memory.methodsToExec.forEach(function (fn) {
            fn.method(fn.params, false, fn.context);
          });
        }

        resolve(me);
      });
    }
  }, {
    key: "clearPreviousPaths",
    value: function clearPreviousPaths() {
      var w = this.w;
      w.globals.previousPaths = [];
      w.globals.allSeriesCollapsed = false;
      w.globals.collapsedSeries = [];
      w.globals.collapsedSeriesIndices = [];
    }
    /**
     * Allows users to update Options after the chart has rendered.
     *
     * @param {object} options - A new config object can be passed which will be merged with the existing config object
     * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there
     * @param {boolean} animate - should animate or not on updating Options
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options$$1) {
      var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var overwriteInitialConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var w = this.w;

      if (options$$1.series) {
        if (options$$1.series[0].data) {
          options$$1.series = options$$1.series.map(function (s, i) {
            return _objectSpread({}, w.config.series[i], {
              name: s.name ? s.name : w.config.series[i].name,
              type: s.type ? s.type : w.config.series[i].type,
              data: s.data ? s.data : w.config.series[i].data
            });
          });
        } // user updated the series via updateOptions() function.
        // Hence, we need to reset axis min/max to avoid zooming issues


        this.revertDefaultAxisMinMax();
      } // user has set x-axis min/max externally - hence we need to forcefully set the xaxis min/max


      if (options$$1.xaxis) {
        if (options$$1.xaxis.min || options$$1.xaxis.max) {
          this.forceXAxisUpdate(options$$1);
        }
        /* fixes apexcharts.js#369 and react-apexcharts#46 */


        if (options$$1.xaxis.categories && options$$1.xaxis.categories.length && w.config.xaxis.convertedCatToNumeric) {
          options$$1 = Defaults.convertCatToNumeric(options$$1);
        }
      }

      if (w.globals.collapsedSeriesIndices.length > 0) {
        this.clearPreviousPaths();
      }

      return this._updateOptions(options$$1, redraw, animate, overwriteInitialConfig);
    }
    /**
     * private method to update Options.
     *
     * @param {object} options - A new config object can be passed which will be merged with the existing config object
     * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there
     * @param {boolean} animate - should animate or not on updating Options
     * @param {boolean} overwriteInitialConfig - should update the initial config or not
     */

  }, {
    key: "_updateOptions",
    value: function _updateOptions(options$$1) {
      var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var overwriteInitialConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var charts = this.getSyncedCharts();
      charts.forEach(function (ch) {
        var w = ch.w;
        w.globals.shouldAnimate = animate;

        if (!redraw) {
          w.globals.resized = true;
          w.globals.dataChanged = true;

          if (animate) {
            ch.series.getPreviousPaths();
          }
        }

        if (options$$1 && _typeof(options$$1) === 'object') {
          ch.config = new Config(options$$1);
          options$$1 = CoreUtils.extendArrayProps(ch.config, options$$1);
          w.config = Utils.extend(w.config, options$$1);

          if (overwriteInitialConfig) {
            // we need to forget the lastXAxis and lastYAxis is user forcefully overwriteInitialConfig. If we do not do this, and next time when user zooms the chart after setting yaxis.min/max or xaxis.min/max - the stored lastXAxis will never allow the chart to use the updated min/max by user.
            w.globals.lastXAxis = [];
            w.globals.lastYAxis = []; // After forgetting lastAxes, we need to restore the new config in initialConfig/initialSeries

            w.globals.initialConfig = Utils.extend({}, w.config);
            w.globals.initialSeries = JSON.parse(JSON.stringify(w.config.series));
          }
        }

        return ch.update(options$$1);
      });
    }
    /**
     * Allows users to update Series after the chart has rendered.
     *
     * @param {array} series - New series which will override the existing
     */

  }, {
    key: "updateSeries",
    value: function updateSeries() {
      var newSeries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      this.revertDefaultAxisMinMax();
      return this._updateSeries(newSeries, animate, overwriteInitialSeries);
    }
    /**
     * Allows users to append a new series after the chart has rendered.
     *
     * @param {array} newSerie - New serie which will be appended to the existing series
     */

  }, {
    key: "appendSeries",
    value: function appendSeries(newSerie) {
      var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var newSeries = this.w.config.series.slice();
      newSeries.push(newSerie);
      this.revertDefaultAxisMinMax();
      return this._updateSeries(newSeries, animate);
    }
    /**
     * Private method to update Series.
     *
     * @param {array} series - New series which will override the existing
     */

  }, {
    key: "_updateSeries",
    value: function _updateSeries(newSeries, animate) {
      var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var w = this.w;
      this.w.globals.shouldAnimate = animate;
      w.globals.dataChanged = true; // if user has collapsed some series with legend, we need to clear those

      if (w.globals.allSeriesCollapsed) {
        w.globals.allSeriesCollapsed = false;
      }

      if (animate) {
        this.series.getPreviousPaths();
      }

      var existingSeries; // axis charts

      if (newSeries[0].data) {
        existingSeries = newSeries.map(function (s, i) {
          return _objectSpread({}, w.config.series[i], {
            name: s.name ? s.name : w.config.series[i].name,
            type: s.type ? s.type : w.config.series[i].type,
            data: s.data ? s.data : w.config.series[i].data
          });
        });
        w.config.series = existingSeries;
      } else {
        // non-axis chart (pie/radialbar)
        w.config.series = newSeries.slice();
      }

      if (overwriteInitialSeries) {
        w.globals.initialConfig.series = JSON.parse(JSON.stringify(w.config.series));
        w.globals.initialSeries = JSON.parse(JSON.stringify(w.config.series));
      }

      return this.update();
    }
    /**
     * Get all charts in the same "group" (including the instance which is called upon) to sync them when user zooms in/out or pan.
     */

  }, {
    key: "getSyncedCharts",
    value: function getSyncedCharts() {
      var chartGroups = this.getGroupedCharts();
      var allCharts = [this];

      if (chartGroups.length) {
        allCharts = [];
        chartGroups.forEach(function (ch) {
          allCharts.push(ch);
        });
      }

      return allCharts;
    }
    /**
     * Get charts in the same "group" (excluding the instance which is called upon) to perform operations on the other charts of the same group (eg., tooltip hovering)
     */

  }, {
    key: "getGroupedCharts",
    value: function getGroupedCharts() {
      var _this2 = this;

      return Apex._chartInstances.filter(function (ch) {
        if (ch.group) {
          return true;
        }
      }).map(function (ch) {
        return _this2.w.config.chart.group === ch.group ? ch.chart : _this2;
      });
    }
    /**
     * Allows users to append Data to series.
     *
     * @param {array} newData - New data in the same format as series
     */

  }, {
    key: "appendData",
    value: function appendData(newData) {
      var overwriteInitialSeries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var me = this;
      me.w.globals.dataChanged = true;
      me.series.getPreviousPaths();
      var newSeries = me.w.config.series.slice();

      for (var i = 0; i < newSeries.length; i++) {
        if (typeof newData[i] !== 'undefined') {
          for (var j = 0; j < newData[i].data.length; j++) {
            newSeries[i].data.push(newData[i].data[j]);
          }
        }
      }

      me.w.config.series = newSeries;

      if (overwriteInitialSeries) {
        me.w.globals.initialSeries = JSON.parse(JSON.stringify(me.w.config.series));
      }

      return this.update();
    }
  }, {
    key: "update",
    value: function update(options$$1) {
      var _this3 = this;

      return new Promise$1(function (resolve, reject) {
        _this3.clear();

        var graphData = _this3.create(_this3.w.config.series, options$$1);

        if (!graphData) return resolve(_this3);

        _this3.mount(graphData).then(function () {
          if (typeof _this3.w.config.chart.events.updated === 'function') {
            _this3.w.config.chart.events.updated(_this3, _this3.w);
          }

          _this3.fireEvent('updated', [_this3, _this3.w]);

          _this3.w.globals.isDirty = true;
          resolve(_this3);
        }).catch(function (e) {
          reject(e);
        });
      });
    }
  }, {
    key: "forceXAxisUpdate",
    value: function forceXAxisUpdate(options$$1) {
      var w = this.w;

      if (typeof options$$1.xaxis.min !== 'undefined') {
        w.config.xaxis.min = options$$1.xaxis.min;
        w.globals.lastXAxis.min = options$$1.xaxis.min;
      }

      if (typeof options$$1.xaxis.max !== 'undefined') {
        w.config.xaxis.max = options$$1.xaxis.max;
        w.globals.lastXAxis.max = options$$1.xaxis.max;
      }
    }
    /**
     * This function reverts the yaxis and xaxis min/max values to what it was when the chart was defined.
     * This function fixes an important bug where a user might load a new series after zooming in/out of previous series which resulted in wrong min/max
     * Also, this should never be called internally on zoom/pan - the reset should only happen when user calls the updateSeries() function externally
     */

  }, {
    key: "revertDefaultAxisMinMax",
    value: function revertDefaultAxisMinMax() {
      var w = this.w;
      w.config.xaxis.min = w.globals.lastXAxis.min;
      w.config.xaxis.max = w.globals.lastXAxis.max;
      w.config.yaxis.map(function (yaxe, index) {
        if (w.globals.zoomed) {
          // if user has zoomed, and this function is called
          // then we need to get the lastAxis min and max
          if (typeof w.globals.lastYAxis[index] !== 'undefined') {
            yaxe.min = w.globals.lastYAxis[index].min;
            yaxe.max = w.globals.lastYAxis[index].max;
          }
        }
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.zoomPanSelection) {
        this.zoomPanSelection.destroy();
      }

      if (this.toolbar) {
        this.toolbar.destroy();
      }

      this.animations = null;
      this.annotations = null;
      this.core = null;
      this.grid = null;
      this.series = null;
      this.responsive = null;
      this.theme = null;
      this.formatters = null;
      this.titleSubtitle = null;
      this.legend = null;
      this.dimensions = null;
      this.options = null;
      this.crosshairs = null;
      this.zoomPanSelection = null;
      this.toolbar = null;
      this.w.globals.tooltip = null;
      this.clearDomElements();
    }
  }, {
    key: "killSVG",
    value: function killSVG(draw) {
      return new Promise$1(function (resolve, reject) {
        draw.each(function (i, children) {
          this.removeClass('*');
          this.off();
          this.stop();
        }, true);
        draw.ungroup();
        draw.clear();
        resolve('done');
      });
    }
  }, {
    key: "clearDomElements",
    value: function clearDomElements() {
      var domEls = this.w.globals.dom;

      if (this.el !== null) {
        // remove all child elements - resetting the whole chart
        while (this.el.firstChild) {
          this.el.removeChild(this.el.firstChild);
        }
      }

      this.killSVG(domEls.Paper);
      domEls.Paper.remove();
      domEls.elWrap = null;
      domEls.elGraphical = null;
      domEls.elLegendWrap = null;
      domEls.baseEl = null;
      domEls.elGridRect = null;
      domEls.elGridRectMask = null;
      domEls.elGridRectMarkerMask = null;
      domEls.elDefs = null;
    }
    /**
     * Destroy the chart instance by removing all elements which also clean up event listeners on those elements.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.clear(); // remove the chart's instance from the global Apex._chartInstances

      var chartID = this.w.config.chart.id;

      if (chartID) {
        Apex._chartInstances.forEach(function (c, i) {
          if (c.id === chartID) {
            Apex._chartInstances.splice(i, 1);
          }
        });
      }

      window.removeEventListener('resize', this.windowResizeHandler);
      window.removeResizeListener(this.el.parentNode, this.parentResizeCallback.bind(this));
    }
    /**
     * Allows the user to provide data attrs in the element and the chart will render automatically when this method is called by searching for the elements containing 'data-apexcharts' attribute
     */

  }, {
    key: "toggleSeries",
    value: function toggleSeries(seriesName) {
      var targetElement = this.series.getSeriesByName(seriesName);
      var seriesCnt = parseInt(targetElement.getAttribute('data:realIndex'));
      var isHidden = targetElement.classList.contains('apexcharts-series-collapsed');
      this.legend.toggleDataSeries(seriesCnt, isHidden);
    }
  }, {
    key: "resetToggleSeries",
    value: function resetToggleSeries() {
      this.legend.resetToggleDataSeries();
    }
  }, {
    key: "setupEventHandlers",
    value: function setupEventHandlers() {
      var w = this.w;
      var me = this;
      var clickableArea = w.globals.dom.baseEl.querySelector(w.globals.chartClass);
      var eventList = ['mousedown', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend'];
      eventList.forEach(function (event) {
        clickableArea.addEventListener(event, function (e) {
          if (e.type === 'mousedown' && e.which === 1) ; else if (e.type === 'mouseup' && e.which === 1 || e.type === 'touchend') {
            if (typeof w.config.chart.events.click === 'function') {
              w.config.chart.events.click(e, me, w);
            }

            me.fireEvent('click', [e, me, w]);
          }
        }, {
          capture: false,
          passive: true
        });
      });
      this.core.setupBrushHandler();
    }
  }, {
    key: "addXaxisAnnotation",
    value: function addXaxisAnnotation(opts) {
      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var me = this;

      if (context) {
        me = context;
      }

      me.annotations.addXaxisAnnotationExternal(opts, pushToMemory, me);
    }
  }, {
    key: "addYaxisAnnotation",
    value: function addYaxisAnnotation(opts) {
      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var me = this;

      if (context) {
        me = context;
      }

      me.annotations.addYaxisAnnotationExternal(opts, pushToMemory, me);
    }
  }, {
    key: "addPointAnnotation",
    value: function addPointAnnotation(opts) {
      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var me = this;

      if (context) {
        me = context;
      }

      me.annotations.addPointAnnotationExternal(opts, pushToMemory, me);
    }
  }, {
    key: "clearAnnotations",
    value: function clearAnnotations() {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var me = this;

      if (context) {
        me = context;
      }

      me.annotations.clearAnnotations(me);
    } // This method is never used internally and will be only called externally on the chart instance.
    // Hence, we need to keep all these elements in memory when the chart gets updated and redraw again

  }, {
    key: "addText",
    value: function addText(options$$1) {
      var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var me = this;

      if (context) {
        me = context;
      }

      me.annotations.addText(options$$1, pushToMemory, me);
    }
  }, {
    key: "getChartArea",
    value: function getChartArea() {
      var el = this.w.globals.dom.baseEl.querySelector('.apexcharts-inner');
      return el;
    }
  }, {
    key: "getSeriesTotalXRange",
    value: function getSeriesTotalXRange(minX, maxX) {
      return this.coreUtils.getSeriesTotalsXRange(minX, maxX);
    }
  }, {
    key: "getHighestValueInSeries",
    value: function getHighestValueInSeries() {
      var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var range = new Range$1(this.ctx);
      var minYmaxY = range.getMinYMaxY(seriesIndex);
      return minYmaxY.highestY;
    }
  }, {
    key: "getLowestValueInSeries",
    value: function getLowestValueInSeries() {
      var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var range = new Range$1(this.ctx);
      var minYmaxY = range.getMinYMaxY(seriesIndex);
      return minYmaxY.lowestY;
    }
  }, {
    key: "getSeriesTotal",
    value: function getSeriesTotal() {
      return this.w.globals.seriesTotals;
    }
  }, {
    key: "setLocale",
    value: function setLocale(localeName) {
      this.setCurrentLocaleValues(localeName);
    }
  }, {
    key: "setCurrentLocaleValues",
    value: function setCurrentLocaleValues(localeName) {
      var locales = this.w.config.chart.locales; // check if user has specified locales in global Apex variable
      // if yes - then extend those with local chart's locale

      if (window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0) {
        locales = this.w.config.chart.locales.concat(window.Apex.chart.locales);
      } // find the locale from the array of locales which user has set (either by chart.defaultLocale or by calling setLocale() method.)


      var selectedLocale = locales.filter(function (c) {
        return c.name === localeName;
      })[0];

      if (selectedLocale) {
        // create a complete locale object by extending defaults so you don't get undefined errors.
        var ret = Utils.extend(en, selectedLocale); // store these locale options in global var for ease access

        this.w.globals.locale = ret.options;
      } else {
        throw new Error('Wrong locale name provided. Please make sure you set the correct locale name in options');
      }
    }
  }, {
    key: "svgUrl",
    value: function svgUrl() {
      var exp = new Exports(this.ctx);
      return exp.svgUrl();
    }
  }, {
    key: "dataURI",
    value: function dataURI() {
      var exp = new Exports(this.ctx);
      return exp.dataURI();
    }
  }, {
    key: "paper",
    value: function paper() {
      return this.w.globals.dom.Paper;
    }
  }, {
    key: "parentResizeCallback",
    value: function parentResizeCallback() {
      if (this.w.globals.animationEnded) {
        this.windowResize();
      }
    }
    /**
     * Handle window resize and re-draw the whole chart.
     */

  }, {
    key: "windowResize",
    value: function windowResize() {
      var _this4 = this;

      clearTimeout(this.w.globals.resizeTimer);
      this.w.globals.resizeTimer = window.setTimeout(function () {
        _this4.w.globals.resized = true;
        _this4.w.globals.dataChanged = false; // we need to redraw the whole chart on window resize (with a small delay).

        _this4.update();
      }, 150);
    }
  }], [{
    key: "initOnLoad",
    value: function initOnLoad() {
      var els = document.querySelectorAll('[data-apexcharts]');

      for (var i = 0; i < els.length; i++) {
        var el = els[i];
        var options$$1 = JSON.parse(els[i].getAttribute('data-options'));
        var apexChart = new ApexCharts(el, options$$1);
        apexChart.render();
      }
    }
    /**
     * This static method allows users to call chart methods without necessarily from the
     * instance of the chart in case user has assigned chartID to the targetted chart.
     * The chartID is used for mapping the instance stored in Apex._chartInstances global variable
     *
     * This is helpful in cases when you don't have reference of the chart instance
     * easily and need to call the method from anywhere.
     * For eg, in React/Vue applications when you have many parent/child components,
     * and need easy reference to other charts for performing dynamic operations
     *
     * @param {string} chartID - The unique identifier which will be used to call methods
     * on that chart instance
     * @param {function} fn - The method name to call
     * @param {object} opts - The parameters which are accepted in the original method will be passed here in the same order.
     */

  }, {
    key: "exec",
    value: function exec(chartID, fn) {
      var chart = this.getChartByID(chartID);
      if (!chart) return;

      for (var _len = arguments.length, opts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        opts[_key - 2] = arguments[_key];
      }

      switch (fn) {
        case 'updateOptions':
          {
            return chart.updateOptions.apply(chart, opts);
          }

        case 'updateSeries':
          {
            return chart.updateSeries.apply(chart, opts);
          }

        case 'appendData':
          {
            return chart.appendData.apply(chart, opts);
          }

        case 'addXaxisAnnotation':
          {
            return chart.addXaxisAnnotation.apply(chart, opts);
          }

        case 'addYaxisAnnotation':
          {
            return chart.addYaxisAnnotation.apply(chart, opts);
          }

        case 'addPointAnnotation':
          {
            return chart.addPointAnnotation.apply(chart, opts);
          }

        case 'clearAnnotations':
          {
            return chart.clearAnnotations.apply(chart, opts);
          }

        case 'destroy':
          {
            return chart.destroy();
          }
      }
    }
  }, {
    key: "merge",
    value: function merge(target, source) {
      return Utils.extend(target, source);
    }
  }, {
    key: "getChartByID",
    value: function getChartByID(chartID) {
      var c = Apex._chartInstances.filter(function (ch) {
        return ch.id === chartID;
      })[0];

      return c.chart;
    }
  }]);

  return ApexCharts;
}();

/* harmony default export */ __webpack_exports__["default"] = (ApexCharts$1);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./node_modules/react-apexcharts/dist/react-apexcharts.min.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-apexcharts/dist/react-apexcharts.min.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports,"__esModule",{value:!0});var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},_extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},_createClass=function(){function n(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),_apexcharts=__webpack_require__(/*! apexcharts */ "./node_modules/apexcharts/dist/apexcharts.esm.js"),_apexcharts2=_interopRequireDefault(_apexcharts),_react=__webpack_require__(/*! react */ "./node_modules/react/index.js"),_react2=_interopRequireDefault(_react),_propTypes=__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"),_propTypes2=_interopRequireDefault(_propTypes);function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _defineProperty(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function _objectWithoutProperties(e,t){var r={};for(var n in e)0<=t.indexOf(n)||Object.prototype.hasOwnProperty.call(e,n)&&(r[n]=e[n]);return r}function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function _inherits(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}window.ApexCharts=_apexcharts2.default;var Charts=function(e){function r(e){_classCallCheck(this,r);var t=_possibleConstructorReturn(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,e));return _react2.default.createRef?t.chartRef=_react2.default.createRef():t.setRef=function(e){return t.chartRef=e},t.chart=null,t}return _inherits(r,_react.Component),_createClass(r,[{key:"render",value:function(){var e=this.props,t=(e.type,e.width,e.height,e.series,e.options,_objectWithoutProperties(e,["type","width","height","series","options"]));return _react2.default.createElement("div",_extends({ref:_react2.default.createRef?this.chartRef:this.setRef},t))}},{key:"componentDidMount",value:function(){var e=_react2.default.createRef?this.chartRef.current:this.chartRef;this.chart=new _apexcharts2.default(e,this.getConfig()),this.chart.render()}},{key:"getConfig",value:function(){var e=this.props,t=e.type,r=e.height,n=e.width,o=e.series,i=e.options,a={chart:{type:t,height:r,width:n},series:o};return this.extend(i,a)}},{key:"isObject",value:function(e){return e&&"object"===(void 0===e?"undefined":_typeof(e))&&!Array.isArray(e)&&null!=e}},{key:"extend",value:function(t,r){var n=this;"function"!=typeof Object.assign&&(Object.assign=function(e){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var t=Object(e),r=1;r<arguments.length;r++){var n=arguments[r];if(null!=n)for(var o in n)n.hasOwnProperty(o)&&(t[o]=n[o])}return t});var o=Object.assign({},t);return this.isObject(t)&&this.isObject(r)&&Object.keys(r).forEach(function(e){n.isObject(r[e])&&e in t?o[e]=n.extend(t[e],r[e]):Object.assign(o,_defineProperty({},e,r[e]))}),o}},{key:"componentDidUpdate",value:function(e){if(!this.chart)return null;var t=this.props,r=t.options,n=t.series,o=JSON.stringify(e.options),i=JSON.stringify(e.series),a=JSON.stringify(r),s=JSON.stringify(n);o===a&&i===s||(i===s?this.chart.updateOptions(this.getConfig()):o===a?this.chart.updateSeries(n):this.chart.updateOptions(this.getConfig()))}},{key:"componentWillUnmount",value:function(){this.chart&&"function"==typeof this.chart.destroy&&this.chart.destroy()}}]),r}();(exports.default=Charts).propTypes={type:_propTypes2.default.string.isRequired,width:_propTypes2.default.any,height:_propTypes2.default.any,series:_propTypes2.default.array.isRequired,options:_propTypes2.default.object.isRequired},Charts.defaultProps={type:"line",width:"100%",height:"auto"};

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXBleGNoYXJ0cy9kaXN0L2FwZXhjaGFydHMuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1hcGV4Y2hhcnRzL2Rpc3QvcmVhY3QtYXBleGNoYXJ0cy5taW4uanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQiwwQkFBMEI7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsb0RBQW9EO0FBQ3BEO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLHFCQUFxQjs7QUFFdEQscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRSxlQUFlLEVBQUU7QUFDN0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTLEVBQUU7QUFDaEU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUwsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7O0FBR1QseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUE2QixjQUFjLFNBQUU7QUFDL0QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUwsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFD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S0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOzs7QUFHQSwyRUFBMkU7O0FBRTNFLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qzs7QUFFN0MsZ0RBQWdEOztBQUVoRCwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFFakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQixlQUFlLElBQUk7QUFDbkIsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8sRUFBRSxTQUFTO0FBQ2pDO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRC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QUFDNUU7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxzQ0FBc0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUU7OztBQUdYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qiw4QkFBOEI7QUFDckQsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFlBQVk7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDREQUE0RCwrQ0FBK0M7QUFDM0c7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1SEFBdUg7O0FBRXZIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUVBQXlFOztBQUV6RSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlFQUF5RTs7QUFFekUsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AscUtBQXFLOztBQUVySztBQUNBO0FBQ0EsU0FBUyxLQUFLOztBQUVkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FB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Q0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsb0NBQW9DO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTyxFQUFFOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxxQkFBcUIsbUNBQW1DO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQsNkJBQTZCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlFQUFpRTs7QUFFakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFtQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEdBQThHOztBQUU5RztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGOztBQUUvRjtBQUNBOztBQUVBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLHVCQUF1Qiw4QkFBOEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUwsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRCxtVUFBbVU7O0FBRW5VLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpELHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU8sUUFBUTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7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O0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMLGdFQUFnRTs7QUFFaEU7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FB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O0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFOztBQUVqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtB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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVAsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixxREFBcUQ7QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sYUFBYTs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLEdBQUc7O0FBRUg7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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Q0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUNBQXVDLFNBQVM7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHFEQUFxRCxpQkFBaUI7QUFDdEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0RUFBNEU7O0FBRTVFOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLGlDQUFpQyxFQUFFLEVBQUU7QUFDakYsNENBQTRDLGlDQUFpQyxFQUFFLEVBQUU7QUFDakYsNENBQTRDLGlDQUFpQyxFQUFFLEVBQUU7QUFDakYsNENBQTRDLGlDQUFpQyxFQUFFLEVBQUU7O0FBRWpGLDJDQUEyQyxpQ0FBaUMsRUFBRSxFQUFFO0FBQ2hGLDJDQUEyQyxpQ0FBaUMsRUFBRSxFQUFFO0FBQ2hGLDJDQUEyQyxpQ0FBaUMsRUFBRSxFQUFFO0FBQ2hGLDJDQUEyQyxpQ0FBaUMsRUFBRSxFQUFFOztBQUVoRiw2Q0FBNkMsaUNBQWlDLEVBQUUsRUFBRTs7QUFFbEYsK0NBQStDLGlDQUFpQyxFQUFFLEVBQUU7O0FBRXBGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLDJEQUEyRDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLG1DQUFtQztBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyRkFBMkY7O0FBRTNGOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUEsQ0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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c0IsSUFBSSw4RUFBOEUsb0ZBQW9GLFVBQVUsS0FBSyxFQUFFLDJDQUEyQywyQkFBMkIsdUlBQXVJLDhJQUE4SSxFQUFFLDRDQUE0Qyx5RUFBeUUsS0FBSyxHQUFHLG9DQUFvQyxrTUFBa00sc0JBQXNCLHdDOzs7Ozs7Ozs7OztBQ0F6c0k7QUFDQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBcGV4Q2hhcnRzIHYzLjYuM1xuICogKGMpIDIwMTgtMjAxOSBKdW5lZCBDaGhpcGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG59XG5cbi8qXG4gKiogR2VuZXJpYyBmdW5jdGlvbnMgd2hpY2ggYXJlIG5vdCBkZXBlbmRlbnQgb24gQXBleENoYXJ0c1xuICovXG52YXIgVXRpbHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBVdGlscygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXRpbHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFV0aWxzLCBbe1xuICAgIGtleTogXCJzaGFkZVJHQkNvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoYWRlUkdCQ29sb3IocGVyY2VudCwgY29sb3IpIHtcbiAgICAgIHZhciBmID0gY29sb3Iuc3BsaXQoJywnKSxcbiAgICAgICAgICB0ID0gcGVyY2VudCA8IDAgPyAwIDogMjU1LFxuICAgICAgICAgIHAgPSBwZXJjZW50IDwgMCA/IHBlcmNlbnQgKiAtMSA6IHBlcmNlbnQsXG4gICAgICAgICAgUiA9IHBhcnNlSW50KGZbMF0uc2xpY2UoNCkpLFxuICAgICAgICAgIEcgPSBwYXJzZUludChmWzFdKSxcbiAgICAgICAgICBCID0gcGFyc2VJbnQoZlsyXSk7XG4gICAgICByZXR1cm4gJ3JnYignICsgKE1hdGgucm91bmQoKHQgLSBSKSAqIHApICsgUikgKyAnLCcgKyAoTWF0aC5yb3VuZCgodCAtIEcpICogcCkgKyBHKSArICcsJyArIChNYXRoLnJvdW5kKCh0IC0gQikgKiBwKSArIEIpICsgJyknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGFkZUhleENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoYWRlSGV4Q29sb3IocGVyY2VudCwgY29sb3IpIHtcbiAgICAgIHZhciBmID0gcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSksIDE2KSxcbiAgICAgICAgICB0ID0gcGVyY2VudCA8IDAgPyAwIDogMjU1LFxuICAgICAgICAgIHAgPSBwZXJjZW50IDwgMCA/IHBlcmNlbnQgKiAtMSA6IHBlcmNlbnQsXG4gICAgICAgICAgUiA9IGYgPj4gMTYsXG4gICAgICAgICAgRyA9IGYgPj4gOCAmIDB4MDBmZixcbiAgICAgICAgICBCID0gZiAmIDB4MDAwMGZmO1xuICAgICAgcmV0dXJuICcjJyArICgweDEwMDAwMDAgKyAoTWF0aC5yb3VuZCgodCAtIFIpICogcCkgKyBSKSAqIDB4MTAwMDAgKyAoTWF0aC5yb3VuZCgodCAtIEcpICogcCkgKyBHKSAqIDB4MTAwICsgKE1hdGgucm91bmQoKHQgLSBCKSAqIHApICsgQikpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICB9IC8vIGJlYXV0aWZ1bCBjb2xvciBzaGFkaW5nIGJsZW5kaW5nIGNvZGVcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU1NjAyNDgvcHJvZ3JhbW1hdGljYWxseS1saWdodGVuLW9yLWRhcmtlbi1hLWhleC1jb2xvci1vci1yZ2ItYW5kLWJsZW5kLWNvbG9yc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hhZGVDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGFkZUNvbG9yKHAsIGNvbG9yKSB7XG4gICAgICBpZiAoY29sb3IubGVuZ3RoID4gNykgcmV0dXJuIHRoaXMuc2hhZGVSR0JDb2xvcihwLCBjb2xvcik7ZWxzZSByZXR1cm4gdGhpcy5zaGFkZUhleENvbG9yKHAsIGNvbG9yKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJiaW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmQoZm4sIG1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc09iamVjdChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSAmJiBfdHlwZW9mKGl0ZW0pID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSAmJiBpdGVtICE9IG51bGw7XG4gICAgfSAvLyB0byBleHRlbmQgZGVmYXVsdHMgd2l0aCB1c2VyIG9wdGlvbnNcbiAgICAvLyBjcmVkaXQ6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjc5MzY3NzIvZGVlcC1vYmplY3QtbWVyZ2luZy1pbi1lczYtZXM3I2Fuc3dlci0zNDc0OTg3M1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgIHZhciBfc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgICAgICAgICBpZiAoX3NvdXJjZSAhPT0gdW5kZWZpbmVkICYmIF9zb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIF9zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChfc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IF9zb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dHB1dCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCk7XG5cbiAgICAgIGlmICh0aGlzLmlzT2JqZWN0KHRhcmdldCkgJiYgdGhpcy5pc09iamVjdChzb3VyY2UpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWYgKF90aGlzLmlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBzb3VyY2Vba2V5XSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBfdGhpcy5leHRlbmQodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBzb3VyY2Vba2V5XSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dGVuZEFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZEFycmF5KGFyclRvRXh0ZW5kLCByZXN1bHRBcnIpIHtcbiAgICAgIHZhciBleHRlbmRlZEFyciA9IFtdO1xuICAgICAgYXJyVG9FeHRlbmQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGV4dGVuZGVkQXJyLnB1c2goVXRpbHMuZXh0ZW5kKHJlc3VsdEFyciwgaXRlbSkpO1xuICAgICAgfSk7XG4gICAgICBhcnJUb0V4dGVuZCA9IGV4dGVuZGVkQXJyO1xuICAgICAgcmV0dXJuIGFyclRvRXh0ZW5kO1xuICAgIH0gLy8gSWYgbW9udGggY291bnRlciBleGNlZWRzIDEyLCBpdCBzdGFydHMgYWdhaW4gZnJvbSAxXG5cbiAgfSwge1xuICAgIGtleTogXCJtb250aE1vZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb250aE1vZChtb250aCkge1xuICAgICAgcmV0dXJuIG1vbnRoICUgMTI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFByb3BzKG9iaiwgYXJyLCB2YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyID09PSAnc3RyaW5nJykge1xuICAgICAgICBhcnIgPSBhcnIuc3BsaXQoJy4nKTtcbiAgICAgIH1cblxuICAgICAgb2JqW2FyclswXV0gPSBvYmpbYXJyWzBdXSB8fCB7fTtcbiAgICAgIHZhciB0bXBPYmogPSBvYmpbYXJyWzBdXTtcblxuICAgICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFyci5zaGlmdCgpO1xuICAgICAgICB0aGlzLmFkZFByb3BzKHRtcE9iaiwgYXJyLCB2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2FyclswXV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzb3VyY2UpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHZhciBjbG9uZVJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2xvbmVSZXN1bHRbaV0gPSB0aGlzLmNsb25lKHNvdXJjZVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmVSZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2Yoc291cmNlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIF9jbG9uZVJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgX2Nsb25lUmVzdWx0W3Byb3BdID0gdGhpcy5jbG9uZShzb3VyY2VbcHJvcF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfY2xvbmVSZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2cxMFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdW5kVG9CYXNlMTBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmRUb0Jhc2UxMCh4KSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2cxMCh4KSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3VuZFRvQmFzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZFRvQmFzZSh4LCBiYXNlKSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coYmFzZSwgTWF0aC5mbG9vcihNYXRoLmxvZyh4KSAvIE1hdGgubG9nKGJhc2UpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlTnVtYmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlTnVtYmVyKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIHZhbDtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbCkge1xuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgZWxlbWVudEhlaWdodCAtPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCkgKyBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gICAgICBlbGVtZW50V2lkdGggLT0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgICAgcmV0LnB1c2goZWxlbWVudFdpZHRoKTtcbiAgICAgIHJldC5wdXNoKGVsZW1lbnRIZWlnaHQpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gICAgICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCxcbiAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgeDogcmVjdC54LFxuICAgICAgICB5OiByZWN0LnlcbiAgICAgIH07XG4gICAgfSAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2MjM4MzgvcmdiLXRvLWhleC1hbmQtaGV4LXRvLXJnYiNhbnN3ZXItMTIzNDIyNzVcblxuICB9LCB7XG4gICAga2V5OiBcImhleFRvUmdiYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZXhUb1JnYmEoKSB7XG4gICAgICB2YXIgaGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnIzk5OTk5OSc7XG4gICAgICB2YXIgb3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMC42O1xuXG4gICAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAxKSAhPT0gJyMnKSB7XG4gICAgICAgIGhleCA9ICcjOTk5OTk5JztcbiAgICAgIH1cblxuICAgICAgdmFyIGggPSBoZXgucmVwbGFjZSgnIycsICcnKTtcbiAgICAgIGggPSBoLm1hdGNoKG5ldyBSZWdFeHAoJygueycgKyBoLmxlbmd0aCAvIDMgKyAnfSknLCAnZycpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhbaV0gPSBwYXJzZUludChoW2ldLmxlbmd0aCA9PT0gMSA/IGhbaV0gKyBoW2ldIDogaFtpXSwgMTYpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSBoLnB1c2gob3BhY2l0eSk7XG4gICAgICByZXR1cm4gJ3JnYmEoJyArIGguam9pbignLCcpICsgJyknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcGFjaXR5RnJvbVJHQkFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3BhY2l0eUZyb21SR0JBKHJnYmEpIHtcbiAgICAgIHJnYmEgPSByZ2JhLm1hdGNoKC9ecmdiYT9bXFxzK10/XFwoW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8vaSk7XG4gICAgICByZXR1cm4gcmdiYVszXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmdiMmhleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZ2IyaGV4KHJnYikge1xuICAgICAgcmdiID0gcmdiLm1hdGNoKC9ecmdiYT9bXFxzK10/XFwoW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8vaSk7XG4gICAgICByZXR1cm4gcmdiICYmIHJnYi5sZW5ndGggPT09IDQgPyAnIycgKyAoJzAnICsgcGFyc2VJbnQocmdiWzFdLCAxMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMikgKyAoJzAnICsgcGFyc2VJbnQocmdiWzJdLCAxMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMikgKyAoJzAnICsgcGFyc2VJbnQocmdiWzNdLCAxMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMikgOiAnJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDb2xvckhleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NvbG9ySGV4KGNvbG9yKSB7XG4gICAgICByZXR1cm4gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoY29sb3IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb2xhclRvQ2FydGVzaWFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvbGFyVG9DYXJ0ZXNpYW4oY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCBhbmdsZUluRGVncmVlcykge1xuICAgICAgdmFyIGFuZ2xlSW5SYWRpYW5zID0gKGFuZ2xlSW5EZWdyZWVzIC0gOTApICogTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2VudGVyWCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKSxcbiAgICAgICAgeTogY2VudGVyWSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXNjYXBlU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICAgIHZhciBlc2NhcGVXaXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneCc7XG4gICAgICB2YXIgbmV3U3RyID0gc3RyLnRvU3RyaW5nKCkuc2xpY2UoKTtcbiAgICAgIG5ld1N0ciA9IG5ld1N0ci5yZXBsYWNlKC9bYCB+IUAjJCVeJiooKV98K1xcLT0/OzonXCIsLjw+XFx7XFx9XFxbXFxdXFxcXFxcL10vZ2ksIGVzY2FwZVdpdGgpO1xuICAgICAgcmV0dXJuIG5ld1N0cjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmVnVG9aZXJvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZ1RvWmVybyh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgPCAwID8gMCA6IHZhbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZUluZGV4SW5BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlSW5kZXhJbkFycmF5KGFyciwgb2xkX2luZGV4LCBuZXdfaW5kZXgpIHtcbiAgICAgIGlmIChuZXdfaW5kZXggPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICB2YXIgayA9IG5ld19pbmRleCAtIGFyci5sZW5ndGggKyAxO1xuXG4gICAgICAgIHdoaWxlIChrLS0pIHtcbiAgICAgICAgICBhcnIucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFyci5zcGxpY2UobmV3X2luZGV4LCAwLCBhcnIuc3BsaWNlKG9sZF9pbmRleCwgMSlbMF0pO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdE51bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0TnVtYmVyKHMpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHMucmVwbGFjZSgvW15cXGRcXC5dKi9nLCAnJykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYW5kb21TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFuZG9tU3RyaW5nKGxlbikge1xuICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgIHZhciBwb3NzaWJsZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0ZXh0ICs9IHBvc3NpYmxlLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3NzaWJsZS5sZW5ndGgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRBbmNlc3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQW5jZXN0b3IoZWwsIGNscykge1xuICAgICAgd2hpbGUgKChlbCA9IGVsLnBhcmVudEVsZW1lbnQpICYmICFlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xzKSkge1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEVMc3R5bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEVMc3R5bGVzKGVsLCBzdHlsZXMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgZWwuc3R5bGUua2V5ID0gc3R5bGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNOdW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiAhaXNOYU4odmFsdWUpICYmIHBhcnNlRmxvYXQoTnVtYmVyKHZhbHVlKSkgPT09IHZhbHVlICYmICFpc05hTihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGbG9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Zsb2F0KG4pIHtcbiAgICAgIHJldHVybiBOdW1iZXIobikgPT09IG4gJiYgbiAlIDEgIT09IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU2FmYXJpXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAgICAgcmV0dXJuIC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRmlyZWZveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZpcmVmb3goKSB7XG4gICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSA+IC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0lFMTFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJRTExKCkge1xuICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSAhPT0gLTEgfHwgd2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoJ1RyaWRlbnQvJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJRVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0lFKCkge1xuICAgICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICB2YXIgbXNpZSA9IHVhLmluZGV4T2YoJ01TSUUgJyk7XG5cbiAgICAgIGlmIChtc2llID4gMCkge1xuICAgICAgICAvLyBJRSAxMCBvciBvbGRlciA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhtc2llICsgNSwgdWEuaW5kZXhPZignLicsIG1zaWUpKSwgMTApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJpZGVudCA9IHVhLmluZGV4T2YoJ1RyaWRlbnQvJyk7XG5cbiAgICAgIGlmICh0cmlkZW50ID4gMCkge1xuICAgICAgICAvLyBJRSAxMSA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcbiAgICAgICAgdmFyIHJ2ID0gdWEuaW5kZXhPZigncnY6Jyk7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcocnYgKyAzLCB1YS5pbmRleE9mKCcuJywgcnYpKSwgMTApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZSA9IHVhLmluZGV4T2YoJ0VkZ2UvJyk7XG5cbiAgICAgIGlmIChlZGdlID4gMCkge1xuICAgICAgICAvLyBFZGdlIChJRSAxMispID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKGVkZ2UgKyA1LCB1YS5pbmRleE9mKCcuJywgZWRnZSkpLCAxMCk7XG4gICAgICB9IC8vIG90aGVyIGJyb3dzZXJcblxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFV0aWxzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgRmlsdGVycyBDbGFzcyBmb3Igc2V0dGluZyBob3Zlci9hY3RpdmUgc3RhdGVzIG9uIHRoZSBwYXRocy5cbiAqXG4gKiBAbW9kdWxlIEZvcm1hdHRlcnNcbiAqKi9cblxudmFyIEZpbHRlcnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaWx0ZXJzKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWx0ZXJzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICB9IC8vIGNyZWF0ZSBhIHJlLXVzYWJsZSBmaWx0ZXIgd2hpY2ggY2FuIGJlIGFwcGVuZGVkIG90aGVyIGZpbHRlciBlZmZlY3RzIGFuZCBhcHBsaWVkIHRvIG11bHRpcGxlIGVsZW1lbnRzXG5cblxuICBfY3JlYXRlQ2xhc3MoRmlsdGVycywgW3tcbiAgICBrZXk6IFwiZ2V0RGVmYXVsdEZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZhdWx0RmlsdGVyKGVsKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIGVsLnVuZmlsdGVyKHRydWUpO1xuICAgICAgdmFyIGZpbHRlciA9IG5ldyB3aW5kb3cuU1ZHLkZpbHRlcigpO1xuICAgICAgZmlsdGVyLnNpemUoJzEyMCUnLCAnMTgwJScsICctNSUnLCAnLTQwJScpO1xuXG4gICAgICBpZiAody5jb25maWcuc3RhdGVzLm5vcm1hbC5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVyKGVsLCB3LmNvbmZpZy5zdGF0ZXMubm9ybWFsLmZpbHRlci50eXBlLCB3LmNvbmZpZy5zdGF0ZXMubm9ybWFsLmZpbHRlci52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAody5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5kcm9wU2hhZG93KGVsLCB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGROb3JtYWxGaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9ybWFsRmlsdGVyKGVsKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLmRyb3BTaGFkb3coZWwsIHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGREZXNhdHVyYXRlRmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERlc2F0dXJhdGVGaWx0ZXIoZWwpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgZWwudW5maWx0ZXIodHJ1ZSk7XG4gICAgICB2YXIgZmlsdGVyID0gbmV3IHdpbmRvdy5TVkcuRmlsdGVyKCk7XG4gICAgICBmaWx0ZXIuc2l6ZSgnMTIwJScsICcxODAlJywgJy01JScsICctNDAlJyk7XG4gICAgICBlbC5maWx0ZXIoZnVuY3Rpb24gKGFkZCkge1xuICAgICAgICB2YXIgc2hhZG93QXR0ciA9IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3c7XG5cbiAgICAgICAgaWYgKHNoYWRvd0F0dHIuZW5hYmxlZCkge1xuICAgICAgICAgIGZpbHRlciA9IF90aGlzLmFkZFNoYWRvdyhhZGQsIHNoYWRvd0F0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlciA9IGFkZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlci5jb2xvck1hdHJpeCgnbWF0cml4JywgWzAsIDAsIDAsIDAsIDAuNSwgMCwgMCwgMCwgMCwgMC41LCAwLCAwLCAwLCAwLCAwLjUsIDAsIDAsIDAsIDEuMCwgMF0pLmNvbG9yTWF0cml4KCdzYXR1cmF0ZScsIDApO1xuICAgICAgfSk7XG4gICAgICBlbC5maWx0ZXJlci5ub2RlLnNldEF0dHJpYnV0ZSgnZmlsdGVyVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICB9IC8vIGFwcGVuZHMgZHJvcFNoYWRvdyB0byB0aGUgZmlsdGVyIG9iamVjdCB3aGljaCBjYW4gYmUgY2hhaW5lZCB3aXRoIG90aGVyIGZpbHRlciBlZmZlY3RzXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRMaWdodGVuRmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZExpZ2h0ZW5GaWx0ZXIoZWwsIGF0dHJzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgaW50ZW5zaXR5ID0gYXR0cnMuaW50ZW5zaXR5O1xuXG4gICAgICBpZiAoVXRpbHMuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbC51bmZpbHRlcih0cnVlKTtcbiAgICAgIHZhciBmaWx0ZXIgPSBuZXcgd2luZG93LlNWRy5GaWx0ZXIoKTtcbiAgICAgIGZpbHRlci5zaXplKCcxMjAlJywgJzE4MCUnLCAnLTUlJywgJy00MCUnKTtcbiAgICAgIGVsLmZpbHRlcihmdW5jdGlvbiAoYWRkKSB7XG4gICAgICAgIHZhciBzaGFkb3dBdHRyID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcblxuICAgICAgICBpZiAoc2hhZG93QXR0ci5lbmFibGVkKSB7XG4gICAgICAgICAgZmlsdGVyID0gX3RoaXMyLmFkZFNoYWRvdyhhZGQsIHNoYWRvd0F0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlciA9IGFkZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlci5jb21wb25lbnRUcmFuc2Zlcih7XG4gICAgICAgICAgcmdiOiB7XG4gICAgICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgICAgIHNsb3BlOiAxLjUsXG4gICAgICAgICAgICBpbnRlcmNlcHQ6IGludGVuc2l0eVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGVsLmZpbHRlcmVyLm5vZGUuc2V0QXR0cmlidXRlKCdmaWx0ZXJVbml0cycsICd1c2VyU3BhY2VPblVzZScpO1xuICAgIH0gLy8gYXBwZW5kcyBkcm9wU2hhZG93IHRvIHRoZSBmaWx0ZXIgb2JqZWN0IHdoaWNoIGNhbiBiZSBjaGFpbmVkIHdpdGggb3RoZXIgZmlsdGVyIGVmZmVjdHNcblxuICB9LCB7XG4gICAga2V5OiBcImFkZERhcmtlbkZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGREYXJrZW5GaWx0ZXIoZWwsIGF0dHJzKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgaW50ZW5zaXR5ID0gYXR0cnMuaW50ZW5zaXR5O1xuXG4gICAgICBpZiAoVXRpbHMuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbC51bmZpbHRlcih0cnVlKTtcbiAgICAgIHZhciBmaWx0ZXIgPSBuZXcgd2luZG93LlNWRy5GaWx0ZXIoKTtcbiAgICAgIGZpbHRlci5zaXplKCcxMjAlJywgJzE4MCUnLCAnLTUlJywgJy00MCUnKTtcbiAgICAgIGVsLmZpbHRlcihmdW5jdGlvbiAoYWRkKSB7XG4gICAgICAgIHZhciBzaGFkb3dBdHRyID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcblxuICAgICAgICBpZiAoc2hhZG93QXR0ci5lbmFibGVkKSB7XG4gICAgICAgICAgZmlsdGVyID0gX3RoaXMzLmFkZFNoYWRvdyhhZGQsIHNoYWRvd0F0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlciA9IGFkZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlci5jb21wb25lbnRUcmFuc2Zlcih7XG4gICAgICAgICAgcmdiOiB7XG4gICAgICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgICAgIHNsb3BlOiBpbnRlbnNpdHlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBlbC5maWx0ZXJlci5ub2RlLnNldEF0dHJpYnV0ZSgnZmlsdGVyVW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlGaWx0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlGaWx0ZXIoZWwsIGZpbHRlcikge1xuICAgICAgdmFyIGludGVuc2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMC41O1xuXG4gICAgICBzd2l0Y2ggKGZpbHRlcikge1xuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFkZE5vcm1hbEZpbHRlcihlbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbGlnaHRlbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hZGRMaWdodGVuRmlsdGVyKGVsLCB7XG4gICAgICAgICAgICAgIGludGVuc2l0eTogaW50ZW5zaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkYXJrZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGFya2VuRmlsdGVyKGVsLCB7XG4gICAgICAgICAgICAgIGludGVuc2l0eTogaW50ZW5zaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZXNhdHVyYXRlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFkZERlc2F0dXJhdGVGaWx0ZXIoZWwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gYXBwZW5kcyBkcm9wU2hhZG93IHRvIHRoZSBmaWx0ZXIgb2JqZWN0IHdoaWNoIGNhbiBiZSBjaGFpbmVkIHdpdGggb3RoZXIgZmlsdGVyIGVmZmVjdHNcblxuICB9LCB7XG4gICAga2V5OiBcImFkZFNoYWRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTaGFkb3coYWRkLCBhdHRycykge1xuICAgICAgdmFyIGJsdXIgPSBhdHRycy5ibHVyLFxuICAgICAgICAgIHRvcCA9IGF0dHJzLnRvcCxcbiAgICAgICAgICBsZWZ0ID0gYXR0cnMubGVmdCxcbiAgICAgICAgICBjb2xvciA9IGF0dHJzLmNvbG9yLFxuICAgICAgICAgIG9wYWNpdHkgPSBhdHRycy5vcGFjaXR5O1xuICAgICAgdmFyIHNoYWRvd0JsdXIgPSBhZGQuZmxvb2QoY29sb3IsIG9wYWNpdHkpLmNvbXBvc2l0ZShhZGQuc291cmNlQWxwaGEsICdpbicpLm9mZnNldChsZWZ0LCB0b3ApLmdhdXNzaWFuQmx1cihibHVyKS5tZXJnZShhZGQuc291cmNlKTtcbiAgICAgIHJldHVybiBhZGQuYmxlbmQoYWRkLnNvdXJjZSwgc2hhZG93Qmx1cik7XG4gICAgfSAvLyBkaXJlY3RseSBhZGRzIGRyb3BTaGFkb3cgdG8gdGhlIGVsZW1lbnQgYW5kIHJldHVybnMgdGhlIHNhbWUgZWxlbWVudC5cbiAgICAvLyB0aGUgb25seSB3YXkgaXQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGFkZFNoYWRvdygpIGZ1bmN0aW9uIGlzIHRoYXQgYWRkU2hhZG93IGlzIGNoYWluYWJsZSB0byBvdGhlciBmaWx0ZXJzLCB3aGlsZSB0aGlzIGZ1bmN0aW9uIGRpc2NhcmRzIGFsbCBmaWx0ZXJzIGFuZCBhZGQgZHJvcFNoYWRvd1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJvcFNoYWRvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcm9wU2hhZG93KGVsLCBhdHRycykge1xuICAgICAgdmFyIHRvcCA9IGF0dHJzLnRvcCxcbiAgICAgICAgICBsZWZ0ID0gYXR0cnMubGVmdCxcbiAgICAgICAgICBibHVyID0gYXR0cnMuYmx1cixcbiAgICAgICAgICBjb2xvciA9IGF0dHJzLmNvbG9yLFxuICAgICAgICAgIG9wYWNpdHkgPSBhdHRycy5vcGFjaXR5LFxuICAgICAgICAgIG5vVXNlclNwYWNlT25Vc2UgPSBhdHRycy5ub1VzZXJTcGFjZU9uVXNlO1xuICAgICAgZWwudW5maWx0ZXIodHJ1ZSk7XG4gICAgICB2YXIgZmlsdGVyID0gbmV3IHdpbmRvdy5TVkcuRmlsdGVyKCk7XG4gICAgICBmaWx0ZXIuc2l6ZSgnMTIwJScsICcxODAlJywgJy01JScsICctNDAlJyk7XG4gICAgICBlbC5maWx0ZXIoZnVuY3Rpb24gKGFkZCkge1xuICAgICAgICB2YXIgc2hhZG93Qmx1ciA9IG51bGw7XG5cbiAgICAgICAgaWYgKFV0aWxzLmlzU2FmYXJpKCkgfHwgVXRpbHMuaXNGaXJlZm94KCkgfHwgVXRpbHMuaXNJRSgpKSB7XG4gICAgICAgICAgLy8gc2FmYXJpL2ZpcmVmb3ggaGFzIHNvbWUgYWx0ZXJuYXRpdmUgd2F5IHRvIHVzZSB0aGlzIGZpbHRlclxuICAgICAgICAgIHNoYWRvd0JsdXIgPSBhZGQuZmxvb2QoY29sb3IsIG9wYWNpdHkpLmNvbXBvc2l0ZShhZGQuc291cmNlQWxwaGEsICdpbicpLm9mZnNldChsZWZ0LCB0b3ApLmdhdXNzaWFuQmx1cihibHVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaGFkb3dCbHVyID0gYWRkLmZsb29kKGNvbG9yLCBvcGFjaXR5KS5jb21wb3NpdGUoYWRkLnNvdXJjZUFscGhhLCAnaW4nKS5vZmZzZXQobGVmdCwgdG9wKS5nYXVzc2lhbkJsdXIoYmx1cikubWVyZ2UoYWRkLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhZGQuYmxlbmQoYWRkLnNvdXJjZSwgc2hhZG93Qmx1cik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFub1VzZXJTcGFjZU9uVXNlKSB7XG4gICAgICAgIGVsLmZpbHRlcmVyLm5vZGUuc2V0QXR0cmlidXRlKCdmaWx0ZXJVbml0cycsICd1c2VyU3BhY2VPblVzZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNlbGVjdGlvbkZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb25GaWx0ZXIoZWwsIHJlYWxJbmRleCwgZGF0YVBvaW50SW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbcmVhbEluZGV4XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbcmVhbEluZGV4XS5pbmRleE9mKGRhdGFQb2ludEluZGV4KSA+IC0xKSB7XG4gICAgICAgICAgZWwubm9kZS5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGFjdGl2ZUZpbHRlciA9IHcuY29uZmlnLnN0YXRlcy5hY3RpdmUuZmlsdGVyO1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZUZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RmlsdGVyKGVsLCBhY3RpdmVGaWx0ZXIudHlwZSwgYWN0aXZlRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsdGVycztcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIEFuaW1hdGlvbiBDbGFzcy5cbiAqXG4gKiBAbW9kdWxlIEFuaW1hdGlvbnNcbiAqKi9cblxudmFyIEFuaW1hdGlvbnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb25zKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbmltYXRpb25zKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMuc2V0RWFzaW5nRnVuY3Rpb25zKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQW5pbWF0aW9ucywgW3tcbiAgICBrZXk6IFwic2V0RWFzaW5nRnVuY3Rpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEVhc2luZ0Z1bmN0aW9ucygpIHtcbiAgICAgIHZhciBlYXNpbmc7XG4gICAgICB2YXIgdXNlckRlZmluZWRFYXNpbmcgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZWFzaW5nO1xuXG4gICAgICBzd2l0Y2ggKHVzZXJEZWZpbmVkRWFzaW5nKSB7XG4gICAgICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nID0gJy0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2Vhc2Vpbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nID0gJzwnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2Vhc2VvdXQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZyA9ICc+JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdlYXNlaW5vdXQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZyA9ICc8Pic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3dpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZyA9IGZ1bmN0aW9uIGVhc2luZyhwb3MpIHtcbiAgICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgICAgICAgICAgICByZXR1cm4gKHBvcyAtPSAxKSAqIHBvcyAqICgocyArIDEpICogcG9zICsgcykgKyAxO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2JvdW5jZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nID0gZnVuY3Rpb24gZWFzaW5nKHBvcykge1xuICAgICAgICAgICAgICBpZiAocG9zIDwgMSAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogcG9zICogcG9zO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvcyA8IDIgLyAyLjc1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChwb3MgLT0gMS41IC8gMi43NSkgKiBwb3MgKyAwLjc1O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvcyA8IDIuNSAvIDIuNzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKHBvcyAtPSAyLjI1IC8gMi43NSkgKiBwb3MgKyAwLjkzNzU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChwb3MgLT0gMi42MjUgLyAyLjc1KSAqIHBvcyArIDAuOTg0Mzc1O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZWxhc3RpYyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nID0gZnVuY3Rpb24gZWFzaW5nKHBvcykge1xuICAgICAgICAgICAgICBpZiAocG9zID09PSAhIXBvcykgcmV0dXJuIHBvcztcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMCAqIHBvcykgKiBNYXRoLnNpbigocG9zIC0gMC4wNzUpICogKDIgKiBNYXRoLlBJKSAvIDAuMykgKyAxO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nID0gJzw+JztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudy5nbG9iYWxzLmVhc2luZyA9IGVhc2luZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZUxpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUxpbmUoZWwsIGZyb20sIHRvLCBzcGVlZCkge1xuICAgICAgZWwuYXR0cihmcm9tKS5hbmltYXRlKHNwZWVkKS5hdHRyKHRvKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiogQW5pbWF0ZSByYWRpdXMgb2YgYSBjaXJjbGUgZWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZUNpcmNsZVJhZGl1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlQ2lyY2xlUmFkaXVzKGVsLCBmcm9tLCB0bywgc3BlZWQsIGVhc2luZykge1xuICAgICAgaWYgKCFmcm9tKSBmcm9tID0gMDtcbiAgICAgIGVsLmF0dHIoe1xuICAgICAgICByOiBmcm9tXG4gICAgICB9KS5hbmltYXRlKHNwZWVkLCBlYXNpbmcpLmF0dHIoe1xuICAgICAgICByOiB0b1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICoqIEFuaW1hdGUgcmFkaXVzIGFuZCBwb3NpdGlvbiBvZiBhIGNpcmNsZSBlbGVtZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVDaXJjbGUoZWwsIGZyb20sIHRvLCBzcGVlZCwgZWFzaW5nKSB7XG4gICAgICBlbC5hdHRyKHtcbiAgICAgICAgcjogZnJvbS5yLFxuICAgICAgICBjeDogZnJvbS5jeCxcbiAgICAgICAgY3k6IGZyb20uY3lcbiAgICAgIH0pLmFuaW1hdGUoc3BlZWQsIGVhc2luZykuYXR0cih7XG4gICAgICAgIHI6IHRvLnIsXG4gICAgICAgIGN4OiB0by5jeCxcbiAgICAgICAgY3k6IHRvLmN5XG4gICAgICB9KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiogQW5pbWF0ZSByZWN0IHByb3BlcnRpZXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVSZWN0KGVsLCBmcm9tLCB0bywgc3BlZWQsIGZuKSB7XG4gICAgICBlbC5hdHRyKGZyb20pLmFuaW1hdGUoc3BlZWQpLmF0dHIodG8pLmFmdGVyQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlUGF0aHNHcmFkdWFsbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZVBhdGhzR3JhZHVhbGx5KHBhcmFtcykge1xuICAgICAgdmFyIGVsID0gcGFyYW1zLmVsLFxuICAgICAgICAgIGogPSBwYXJhbXMuaixcbiAgICAgICAgICBwYXRoRnJvbSA9IHBhcmFtcy5wYXRoRnJvbSxcbiAgICAgICAgICBwYXRoVG8gPSBwYXJhbXMucGF0aFRvLFxuICAgICAgICAgIHNwZWVkID0gcGFyYW1zLnNwZWVkLFxuICAgICAgICAgIGRlbGF5ID0gcGFyYW1zLmRlbGF5LFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gcGFyYW1zLnN0cm9rZVdpZHRoO1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGRlbGF5RmFjdG9yID0gMDtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuYW5pbWF0ZUdyYWR1YWxseS5lbmFibGVkKSB7XG4gICAgICAgIGRlbGF5RmFjdG9yID0gdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5hbmltYXRlR3JhZHVhbGx5LmRlbGF5O1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQgJiYgdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIGRlbGF5RmFjdG9yID0gMDtcbiAgICAgIH1cblxuICAgICAgbWUubW9ycGhTVkcoZWwsIGosIHBhdGhGcm9tLCBwYXRoVG8sIHNwZWVkLCBzdHJva2VXaWR0aCwgZGVsYXkgKiBkZWxheUZhY3Rvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNob3dEZWxheWVkRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd0RlbGF5ZWRFbGVtZW50cygpIHtcbiAgICAgIHRoaXMudy5nbG9iYWxzLmRlbGF5ZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBlbGUgPSBkLmVsO1xuICAgICAgICBlbGUuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICB9KTtcbiAgICB9IC8vIFNWRy5qcyBhbmltYXRpb24gZm9yIG1vcnBoaW5nIG9uZSBwYXRoIHRvIGFub3RoZXJcblxuICB9LCB7XG4gICAga2V5OiBcIm1vcnBoU1ZHXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vcnBoU1ZHKGVsLCBqLCBwYXRoRnJvbSwgcGF0aFRvLCBzcGVlZCwgc3Ryb2tlV2lkdGgsIGRlbGF5KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKCFwYXRoRnJvbSkge1xuICAgICAgICBwYXRoRnJvbSA9IGVsLmF0dHIoJ3BhdGhGcm9tJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGF0aFRvKSB7XG4gICAgICAgIHBhdGhUbyA9IGVsLmF0dHIoJ3BhdGhUbycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhdGhGcm9tIHx8IHBhdGhGcm9tLmluZGV4T2YoJ3VuZGVmaW5lZCcpID4gLTEgfHwgcGF0aEZyb20uaW5kZXhPZignTmFOJykgPiAtMSkge1xuICAgICAgICBwYXRoRnJvbSA9IFwiTSAwIFwiLmNvbmNhdCh3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICAgIHNwZWVkID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGhUby5pbmRleE9mKCd1bmRlZmluZWQnKSA+IC0xIHx8IHBhdGhUby5pbmRleE9mKCdOYU4nKSA+IC0xKSB7XG4gICAgICAgIHBhdGhUbyA9IFwiTSAwIFwiLmNvbmNhdCh3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICAgIHNwZWVkID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICBzcGVlZCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGVsLnBsb3QocGF0aEZyb20pLmFuaW1hdGUoMSwgdy5nbG9iYWxzLmVhc2luZywgZGVsYXkpLnBsb3QocGF0aEZyb20pLmFuaW1hdGUoc3BlZWQsIHcuZ2xvYmFscy5lYXNpbmcsIGRlbGF5KS5wbG90KHBhdGhUbykuYWZ0ZXJBbGwoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgb3JpZ2luYWwgbW91bnQgZnVuY3Rpb24gY2FuIHJldHVybiB0cnVlIG5vdyBhcyBhbmltYXRpb24gZmluaXNoZWQgaGVyZVxuICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIoaikpIHtcbiAgICAgICAgICBpZiAoaiA9PT0gdy5nbG9iYWxzLnNlcmllc1t3Lmdsb2JhbHMubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoIC0gMiAmJiB3Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICAgICAgdy5nbG9iYWxzLmFuaW1hdGlvbkVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAody5nbG9iYWxzLnNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuYW5pbWF0aW9uRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuYW5pbWF0aW9uRW5kKF90aGlzLmN0eCwgdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2hvd0RlbGF5ZWRFbGVtZW50cygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFuaW1hdGlvbnM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBHcmFwaGljcyBDbGFzcyBmb3IgYWxsIGRyYXdpbmcgb3BlcmF0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIEdyYXBoaWNzXG4gKiovXG5cbnZhciBHcmFwaGljcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdyYXBoaWNzKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmFwaGljcyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHcmFwaGljcywgW3tcbiAgICBrZXk6IFwiZHJhd0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xpbmUoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHZhciBsaW5lQ29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6ICcjYThhOGE4JztcbiAgICAgIHZhciBkYXNoQXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IG51bGw7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBsaW5lID0gdy5nbG9iYWxzLmRvbS5QYXBlci5saW5lKCkuYXR0cih7XG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkyOiB5MixcbiAgICAgICAgc3Ryb2tlOiBsaW5lQ29sb3IsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogZGFzaEFycmF5LFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlV2lkdGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdSZWN0KCkge1xuICAgICAgdmFyIHgxID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHkxID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdmFyIHgyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgdmFyIHkyID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgICAgIHZhciBjb2xvciA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogJyNmZWZlZmUnO1xuICAgICAgdmFyIG9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IDE7XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IG51bGw7XG4gICAgICB2YXIgc3Ryb2tlQ29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gOCAmJiBhcmd1bWVudHNbOF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s4XSA6IG51bGw7XG4gICAgICB2YXIgc3Ryb2tlRGFzaEFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDkgJiYgYXJndW1lbnRzWzldICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOV0gOiAwO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcmVjdCA9IHcuZ2xvYmFscy5kb20uUGFwZXIucmVjdCgpO1xuICAgICAgcmVjdC5hdHRyKHtcbiAgICAgICAgeDogeDEsXG4gICAgICAgIHk6IHkxLFxuICAgICAgICB3aWR0aDogeDIgPiAwID8geDIgOiAwLFxuICAgICAgICBoZWlnaHQ6IHkyID4gMCA/IHkyIDogMCxcbiAgICAgICAgcng6IHJhZGl1cyxcbiAgICAgICAgcnk6IHJhZGl1cyxcbiAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiBzdHJva2VXaWR0aCAhPT0gbnVsbCA/IHN0cm9rZVdpZHRoIDogMCxcbiAgICAgICAgc3Ryb2tlOiBzdHJva2VDb2xvciAhPT0gbnVsbCA/IHN0cm9rZUNvbG9yIDogJ25vbmUnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IHN0cm9rZURhc2hBcnJheVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1BvbHlnb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BvbHlnb24ocG9seWdvblN0cmluZykge1xuICAgICAgdmFyIHN0cm9rZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyNlMWUxZTEnO1xuICAgICAgdmFyIGZpbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdub25lJztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHBvbHlnb24gPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnBvbHlnb24ocG9seWdvblN0cmluZykuYXR0cih7XG4gICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDaXJjbGUocmFkaXVzKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBjID0gdy5nbG9iYWxzLmRvbS5QYXBlci5jaXJjbGUocmFkaXVzICogMik7XG5cbiAgICAgIGlmIChhdHRycyAhPT0gbnVsbCkge1xuICAgICAgICBjLmF0dHIoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1BhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BhdGgoX3JlZikge1xuICAgICAgdmFyIF9yZWYkZCA9IF9yZWYuZCxcbiAgICAgICAgICBkID0gX3JlZiRkID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkZCxcbiAgICAgICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB2b2lkIDAgPyAnI2E4YThhOCcgOiBfcmVmJHN0cm9rZSxcbiAgICAgICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHZvaWQgMCA/IDEgOiBfcmVmJHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICAgICAgX3JlZiRmaWxsT3BhY2l0eSA9IF9yZWYuZmlsbE9wYWNpdHksXG4gICAgICAgICAgZmlsbE9wYWNpdHkgPSBfcmVmJGZpbGxPcGFjaXR5ID09PSB2b2lkIDAgPyAxIDogX3JlZiRmaWxsT3BhY2l0eSxcbiAgICAgICAgICBfcmVmJHN0cm9rZU9wYWNpdHkgPSBfcmVmLnN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgc3Ryb2tlT3BhY2l0eSA9IF9yZWYkc3Ryb2tlT3BhY2l0eSA9PT0gdm9pZCAwID8gMSA6IF9yZWYkc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICBjbGFzc2VzID0gX3JlZi5jbGFzc2VzLFxuICAgICAgICAgIF9yZWYkc3Ryb2tlTGluZWNhcCA9IF9yZWYuc3Ryb2tlTGluZWNhcCxcbiAgICAgICAgICBzdHJva2VMaW5lY2FwID0gX3JlZiRzdHJva2VMaW5lY2FwID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRzdHJva2VMaW5lY2FwLFxuICAgICAgICAgIF9yZWYkc3Ryb2tlRGFzaEFycmF5ID0gX3JlZi5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5ID0gX3JlZiRzdHJva2VEYXNoQXJyYXkgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHN0cm9rZURhc2hBcnJheTtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAoc3Ryb2tlTGluZWNhcCA9PT0gbnVsbCkge1xuICAgICAgICBzdHJva2VMaW5lY2FwID0gdy5jb25maWcuc3Ryb2tlLmxpbmVDYXA7XG4gICAgICB9XG5cbiAgICAgIGlmIChkLmluZGV4T2YoJ3VuZGVmaW5lZCcpID4gLTEgfHwgZC5pbmRleE9mKCdOYU4nKSA+IC0xKSB7XG4gICAgICAgIGQgPSBcIk0gMCBcIi5jb25jYXQody5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcCA9IHcuZ2xvYmFscy5kb20uUGFwZXIucGF0aChkKS5hdHRyKHtcbiAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IGZpbGxPcGFjaXR5LFxuICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgJ3N0cm9rZS1vcGFjaXR5Jzogc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogc3Ryb2tlTGluZWNhcCxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IHN0cm9rZURhc2hBcnJheSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyb3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuZ3JvdXAoKTtcblxuICAgICAgaWYgKGF0dHJzICE9PSBudWxsKSB7XG4gICAgICAgIGcuYXR0cihhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgICAgdmFyIG1vdmUgPSBbJ00nLCB4LCB5XS5qb2luKCcgJyk7XG4gICAgICByZXR1cm4gbW92ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lKHgsIHkpIHtcbiAgICAgIHZhciBoT1J2ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIGxpbmUgPSBudWxsO1xuXG4gICAgICBpZiAoaE9SdiA9PT0gbnVsbCkge1xuICAgICAgICBsaW5lID0gWydMJywgeCwgeV0uam9pbignICcpO1xuICAgICAgfSBlbHNlIGlmIChoT1J2ID09PSAnSCcpIHtcbiAgICAgICAgbGluZSA9IFsnSCcsIHhdLmpvaW4oJyAnKTtcbiAgICAgIH0gZWxzZSBpZiAoaE9SdiA9PT0gJ1YnKSB7XG4gICAgICAgIGxpbmUgPSBbJ1YnLCB5XS5qb2luKCcgJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXJ2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJ2ZSh4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgICAgdmFyIGN1cnZlID0gWydDJywgeDEsIHkxLCB4MiwgeTIsIHgsIHldLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicXVhZHJhdGljQ3VydmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcXVhZHJhdGljQ3VydmUoeDEsIHkxLCB4LCB5KSB7XG4gICAgICB2YXIgY3VydmUgPSBbJ1EnLCB4MSwgeTEsIHgsIHldLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXJjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFyYyhyeCwgcnksIGF4aXNSb3RhdGlvbiwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHkpIHtcbiAgICAgIHZhciByZWxhdGl2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogZmFsc2U7XG4gICAgICB2YXIgY29vcmQgPSAnQSc7XG4gICAgICBpZiAocmVsYXRpdmUpIGNvb3JkID0gJ2EnO1xuICAgICAgdmFyIGFyYyA9IFtjb29yZCwgcngsIHJ5LCBheGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4LCB5XS5qb2luKCcgJyk7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgR3JhcGhpY3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH1cbiAgICAgKiAgaSA9IHNlcmllcydzIGluZGV4XG4gICAgICogIHJlYWxJbmRleCA9IHJlYWxJbmRleCBpcyBzZXJpZXMncyBhY3R1YWwgaW5kZXggd2hlbiBpdCB3YXMgZHJhd24gdGltZS4gQWZ0ZXIgc2V2ZXJhbCByZWRyYXdzLCB0aGUgaXRlcmF0aW5nIFwiaVwiIG1heSBjaGFuZ2UgaW4gbG9vcHMsIGJ1dCByZWFsSW5kZXggZG9lc24ndFxuICAgICAqICBwYXRoRnJvbSA9IGV4aXN0aW5nIHBhdGhGcm9tIHRvIGFuaW1hdGVUb1xuICAgICAqICBwYXRoVG8gPSBuZXcgUGF0aCB0byB3aGljaCBkIGF0dHIgd2lsbCBiZSBhbmltYXRlZCBmcm9tIHBhdGhGcm9tIHRvIHBhdGhUb1xuICAgICAqICBzdHJva2UgPSBsaW5lIENvbG9yXG4gICAgICogIHN0cm9rZVdpZHRoID0gd2lkdGggb2YgcGF0aCBMaW5lXG4gICAgICogIGZpbGwgPSBpdCBjYW4gYmUgZ3JhZGllbnQsIHNpbmdsZSBjb2xvciwgcGF0dGVybiBvciBpbWFnZVxuICAgICAqICBhbmltYXRpb25EZWxheSA9IGhvdyBtdWNoIHRvIGRlbGF5IHdoZW4gc3RhcnRpbmcgYW5pbWF0aW9uIChpbiBtaWxsaXNlY29uZHMpXG4gICAgICogIGRhdGFDaGFuZ2VTcGVlZCA9IGZvciBkeW5hbWljIGFuaW1hdGlvbnMsIHdoZW4gZGF0YSBjaGFuZ2VzXG4gICAgICogIGNsYXNzTmFtZSA9IGNsYXNzIGF0dHJpYnV0ZSB0byBhZGRcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IHN2Zy5qcyBwYXRoIG9iamVjdFxuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclBhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclBhdGhzKF9yZWYyKSB7XG4gICAgICB2YXIgaSA9IF9yZWYyLmksXG4gICAgICAgICAgaiA9IF9yZWYyLmosXG4gICAgICAgICAgcmVhbEluZGV4ID0gX3JlZjIucmVhbEluZGV4LFxuICAgICAgICAgIHBhdGhGcm9tID0gX3JlZjIucGF0aEZyb20sXG4gICAgICAgICAgcGF0aFRvID0gX3JlZjIucGF0aFRvLFxuICAgICAgICAgIHN0cm9rZSA9IF9yZWYyLnN0cm9rZSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYyLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIHN0cm9rZUxpbmVjYXAgPSBfcmVmMi5zdHJva2VMaW5lY2FwLFxuICAgICAgICAgIGZpbGwgPSBfcmVmMi5maWxsLFxuICAgICAgICAgIGFuaW1hdGlvbkRlbGF5ID0gX3JlZjIuYW5pbWF0aW9uRGVsYXksXG4gICAgICAgICAgaW5pdGlhbFNwZWVkID0gX3JlZjIuaW5pdGlhbFNwZWVkLFxuICAgICAgICAgIGRhdGFDaGFuZ2VTcGVlZCA9IF9yZWYyLmRhdGFDaGFuZ2VTcGVlZCxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICAgICAgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgICBfcmVmMiRzaG91bGRDbGlwVG9HcmkgPSBfcmVmMi5zaG91bGRDbGlwVG9HcmlkLFxuICAgICAgICAgIHNob3VsZENsaXBUb0dyaWQgPSBfcmVmMiRzaG91bGRDbGlwVG9HcmkgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRzaG91bGRDbGlwVG9HcmksXG4gICAgICAgICAgX3JlZjIkYmluZEV2ZW50c09uUGF0ID0gX3JlZjIuYmluZEV2ZW50c09uUGF0aHMsXG4gICAgICAgICAgYmluZEV2ZW50c09uUGF0aHMgPSBfcmVmMiRiaW5kRXZlbnRzT25QYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRiaW5kRXZlbnRzT25QYXQ7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgdmFyIGFuaW0gPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmN0eCk7XG4gICAgICB2YXIgaW5pdGlhbEFuaW0gPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZDtcbiAgICAgIHZhciBkeW5hbWljQW5pbSA9IGluaXRpYWxBbmltICYmIHRoaXMudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQ7XG4gICAgICB2YXIgZDtcbiAgICAgIHZhciBzaG91bGRBbmltYXRlID0gISEoaW5pdGlhbEFuaW0gJiYgIXcuZ2xvYmFscy5yZXNpemVkIHx8IGR5bmFtaWNBbmltICYmIHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCAmJiB3Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSk7XG5cbiAgICAgIGlmIChzaG91bGRBbmltYXRlKSB7XG4gICAgICAgIGQgPSBwYXRoRnJvbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSBwYXRoVG87XG4gICAgICAgIHRoaXMudy5nbG9iYWxzLmFuaW1hdGlvbkVuZGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0cm9rZURhc2hBcnJheU9wdCA9IHcuY29uZmlnLnN0cm9rZS5kYXNoQXJyYXk7XG4gICAgICB2YXIgc3Ryb2tlRGFzaEFycmF5ID0gMDtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3Ryb2tlRGFzaEFycmF5T3B0KSkge1xuICAgICAgICBzdHJva2VEYXNoQXJyYXkgPSBzdHJva2VEYXNoQXJyYXlPcHRbcmVhbEluZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cm9rZURhc2hBcnJheSA9IHcuY29uZmlnLnN0cm9rZS5kYXNoQXJyYXk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbCA9IHRoaXMuZHJhd1BhdGgoe1xuICAgICAgICBkOiBkLFxuICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgICAgY2xhc3NlczogY2xhc3NOYW1lLFxuICAgICAgICBzdHJva2VMaW5lY2FwOiBzdHJva2VMaW5lY2FwLFxuICAgICAgICBzdHJva2VEYXNoQXJyYXk6IHN0cm9rZURhc2hBcnJheVxuICAgICAgfSk7XG4gICAgICBlbC5hdHRyKCdpZCcsIFwiXCIuY29uY2F0KGlkLCBcIi1cIikuY29uY2F0KGkpKTtcbiAgICAgIGVsLmF0dHIoJ2luZGV4JywgcmVhbEluZGV4KTtcblxuICAgICAgaWYgKHNob3VsZENsaXBUb0dyaWQpIHtcbiAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgJ2NsaXAtcGF0aCc6IFwidXJsKCNncmlkUmVjdE1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gY29uc3QgZGVmYXVsdEZpbHRlciA9IGVsLmZpbHRlcmVyXG5cblxuICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5ub3JtYWwuZmlsdGVyLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICBmaWx0ZXJzLmdldERlZmF1bHRGaWx0ZXIoZWwsIHcuY29uZmlnLnN0YXRlcy5ub3JtYWwuZmlsdGVyLnR5cGUsIHcuY29uZmlnLnN0YXRlcy5ub3JtYWwuZmlsdGVyLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoIXcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZFNlcmllcyB8fCB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmVuYWJsZWRTZXJpZXMgJiYgdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5lbmFibGVkU2VyaWVzLmluZGV4T2YocmVhbEluZGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBzaGFkb3cgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuICAgICAgICAgICAgZmlsdGVycy5kcm9wU2hhZG93KGVsLCBzaGFkb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYmluZEV2ZW50c09uUGF0aHMpIHtcbiAgICAgICAgZWwubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5wYXRoTW91c2VFbnRlci5iaW5kKHRoaXMsIGVsKSk7XG4gICAgICAgIGVsLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMucGF0aE1vdXNlTGVhdmUuYmluZCh0aGlzLCBlbCkpO1xuICAgICAgICBlbC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMucGF0aE1vdXNlRG93bi5iaW5kKHRoaXMsIGVsKSk7XG4gICAgICB9XG5cbiAgICAgIGVsLmF0dHIoe1xuICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tXG4gICAgICB9KTtcbiAgICAgIHZhciBkZWZhdWx0QW5pbWF0ZU9wdHMgPSB7XG4gICAgICAgIGVsOiBlbCxcbiAgICAgICAgajogaixcbiAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoXG4gICAgICB9O1xuXG4gICAgICBpZiAoaW5pdGlhbEFuaW0gJiYgIXcuZ2xvYmFscy5yZXNpemVkICYmICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgYW5pbS5hbmltYXRlUGF0aHNHcmFkdWFsbHkoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdEFuaW1hdGVPcHRzLCB7XG4gICAgICAgICAgc3BlZWQ6IGluaXRpYWxTcGVlZCxcbiAgICAgICAgICBkZWxheTogYW5pbWF0aW9uRGVsYXlcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5yZXNpemVkIHx8ICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICBhbmltLnNob3dEZWxheWVkRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkICYmIGR5bmFtaWNBbmltICYmIHNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgYW5pbS5hbmltYXRlUGF0aHNHcmFkdWFsbHkoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdEFuaW1hdGVPcHRzLCB7XG4gICAgICAgICAgc3BlZWQ6IGRhdGFDaGFuZ2VTcGVlZFxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1BhdHRlcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BhdHRlcm4oc3R5bGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBzdHJva2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICcjYThhOGE4JztcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHAgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnBhdHRlcm4od2lkdGgsIGhlaWdodCwgZnVuY3Rpb24gKGFkZCkge1xuICAgICAgICBpZiAoc3R5bGUgPT09ICdob3Jpem9udGFsTGluZXMnKSB7XG4gICAgICAgICAgYWRkLmxpbmUoMCwgMCwgaGVpZ2h0LCAwKS5zdHJva2Uoe1xuICAgICAgICAgICAgY29sb3I6IHN0cm9rZSxcbiAgICAgICAgICAgIHdpZHRoOiBzdHJva2VXaWR0aCArIDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ3ZlcnRpY2FsTGluZXMnKSB7XG4gICAgICAgICAgYWRkLmxpbmUoMCwgMCwgMCwgd2lkdGgpLnN0cm9rZSh7XG4gICAgICAgICAgICBjb2xvcjogc3Ryb2tlLFxuICAgICAgICAgICAgd2lkdGg6IHN0cm9rZVdpZHRoICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlID09PSAnc2xhbnRlZExpbmVzJykge1xuICAgICAgICAgIGFkZC5saW5lKDAsIDAsIHdpZHRoLCBoZWlnaHQpLnN0cm9rZSh7XG4gICAgICAgICAgICBjb2xvcjogc3Ryb2tlLFxuICAgICAgICAgICAgd2lkdGg6IHN0cm9rZVdpZHRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT09ICdzcXVhcmVzJykge1xuICAgICAgICAgIGFkZC5yZWN0KHdpZHRoLCBoZWlnaHQpLmZpbGwoJ25vbmUnKS5zdHJva2Uoe1xuICAgICAgICAgICAgY29sb3I6IHN0cm9rZSxcbiAgICAgICAgICAgIHdpZHRoOiBzdHJva2VXaWR0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlID09PSAnY2lyY2xlcycpIHtcbiAgICAgICAgICBhZGQuY2lyY2xlKHdpZHRoKS5maWxsKCdub25lJykuc3Ryb2tlKHtcbiAgICAgICAgICAgIGNvbG9yOiBzdHJva2UsXG4gICAgICAgICAgICB3aWR0aDogc3Ryb2tlV2lkdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0dyYWRpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdHcmFkaWVudChzdHlsZSwgZ2Zyb20sIGd0bywgb3BhY2l0eUZyb20sIG9wYWNpdHlUbykge1xuICAgICAgdmFyIHNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IG51bGw7XG4gICAgICB2YXIgc3RvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IG51bGw7XG4gICAgICB2YXIgY29sb3JTdG9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogbnVsbDtcbiAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCA+IDggJiYgYXJndW1lbnRzWzhdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOF0gOiAwO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZztcbiAgICAgIGdmcm9tID0gVXRpbHMuaGV4VG9SZ2JhKGdmcm9tLCBvcGFjaXR5RnJvbSk7XG4gICAgICBndG8gPSBVdGlscy5oZXhUb1JnYmEoZ3RvLCBvcGFjaXR5VG8pO1xuICAgICAgdmFyIHN0b3AxID0gMDtcbiAgICAgIHZhciBzdG9wMiA9IDE7XG4gICAgICB2YXIgc3RvcDMgPSAxO1xuICAgICAgdmFyIHN0b3A0ID0gbnVsbDtcblxuICAgICAgaWYgKHN0b3BzICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3AxID0gdHlwZW9mIHN0b3BzWzBdICE9PSAndW5kZWZpbmVkJyA/IHN0b3BzWzBdIC8gMTAwIDogMDtcbiAgICAgICAgc3RvcDIgPSB0eXBlb2Ygc3RvcHNbMV0gIT09ICd1bmRlZmluZWQnID8gc3RvcHNbMV0gLyAxMDAgOiAxO1xuICAgICAgICBzdG9wMyA9IHR5cGVvZiBzdG9wc1syXSAhPT0gJ3VuZGVmaW5lZCcgPyBzdG9wc1syXSAvIDEwMCA6IDE7XG4gICAgICAgIHN0b3A0ID0gdHlwZW9mIHN0b3BzWzNdICE9PSAndW5kZWZpbmVkJyA/IHN0b3BzWzNdIC8gMTAwIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhZGlhbCA9ICEhKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3BpZScgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2J1YmJsZScpO1xuXG4gICAgICBpZiAoY29sb3JTdG9wcyA9PT0gbnVsbCB8fCBjb2xvclN0b3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBnID0gdy5nbG9iYWxzLmRvbS5QYXBlci5ncmFkaWVudChyYWRpYWwgPyAncmFkaWFsJyA6ICdsaW5lYXInLCBmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICAgIHN0b3AuYXQoc3RvcDEsIGdmcm9tLCBvcGFjaXR5RnJvbSk7XG4gICAgICAgICAgc3RvcC5hdChzdG9wMiwgZ3RvLCBvcGFjaXR5VG8pO1xuICAgICAgICAgIHN0b3AuYXQoc3RvcDMsIGd0bywgb3BhY2l0eVRvKTtcblxuICAgICAgICAgIGlmIChzdG9wNCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcC5hdChzdG9wNCwgZ2Zyb20sIG9wYWNpdHlGcm9tKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuZ3JhZGllbnQocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJywgZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgICB2YXIgc3RvcHMgPSBBcnJheS5pc0FycmF5KGNvbG9yU3RvcHNbaV0pID8gY29sb3JTdG9wc1tpXSA6IGNvbG9yU3RvcHM7XG4gICAgICAgICAgc3RvcHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgc3RvcC5hdChzLm9mZnNldCAvIDEwMCwgcy5jb2xvciwgcy5vcGFjaXR5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmFkaWFsKSB7XG4gICAgICAgIGlmIChzdHlsZSA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgIGcuZnJvbSgwLCAwKS50bygwLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ2RpYWdvbmFsJykge1xuICAgICAgICAgIGcuZnJvbSgwLCAwKS50bygxLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgZy5mcm9tKDAsIDEpLnRvKDEsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlID09PSAnZGlhZ29uYWwyJykge1xuICAgICAgICAgIGcuZnJvbSgwLCAxKS50bygyLCAyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9mZnggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMjtcbiAgICAgICAgdmFyIG9mZnkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDI7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdidWJibGUnKSB7XG4gICAgICAgICAgZy5hdHRyKHtcbiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM6ICd1c2VyU3BhY2VPblVzZScsXG4gICAgICAgICAgICBjeDogb2ZmeCxcbiAgICAgICAgICAgIGN5OiBvZmZ5LFxuICAgICAgICAgICAgcjogc2l6ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGcuYXR0cih7XG4gICAgICAgICAgICBjeDogMC41LFxuICAgICAgICAgICAgY3k6IDAuNSxcbiAgICAgICAgICAgIHI6IDAuOCxcbiAgICAgICAgICAgIGZ4OiAwLjIsXG4gICAgICAgICAgICBmeTogMC4yXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdUZXh0KG9wdHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHggPSBvcHRzLngsXG4gICAgICAgICAgeSA9IG9wdHMueSxcbiAgICAgICAgICB0ZXh0ID0gb3B0cy50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3IgPSBvcHRzLnRleHRBbmNob3IsXG4gICAgICAgICAgZm9udFNpemUgPSBvcHRzLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHkgPSBvcHRzLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9yZUNvbG9yID0gb3B0cy5mb3JlQ29sb3IsXG4gICAgICAgICAgb3BhY2l0eSA9IG9wdHMub3BhY2l0eTtcblxuICAgICAgaWYgKCF0ZXh0QW5jaG9yKSB7XG4gICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZvcmVDb2xvcikge1xuICAgICAgICBmb3JlQ29sb3IgPSB3LmNvbmZpZy5jaGFydC5mb3JlQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGZvbnRGYW1pbHkgPSBmb250RmFtaWx5IHx8IHcuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICB2YXIgZWxUZXh0O1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0KSkge1xuICAgICAgICBlbFRleHQgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnRleHQoZnVuY3Rpb24gKGFkZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWRkLnRzcGFuKHRleHRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbFRleHQgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnBsYWluKHRleHQpO1xuICAgICAgfVxuXG4gICAgICBlbFRleHQuYXR0cih7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgICd0ZXh0LWFuY2hvcic6IHRleHRBbmNob3IsXG4gICAgICAgICdkb21pbmFudC1iYXNlbGluZSc6ICdjZW50cmFsJyxcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6IGZvbnRTaXplLFxuICAgICAgICAnZm9udC1mYW1pbHknOiBmb250RmFtaWx5LFxuICAgICAgICBmaWxsOiBmb3JlQ29sb3IsXG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy10ZXh0ICcgKyBvcHRzLmNzc0NsYXNzID8gb3B0cy5jc3NDbGFzcyA6ICcnXG4gICAgICB9KTtcbiAgICAgIGVsVGV4dC5ub2RlLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgZWxUZXh0Lm5vZGUuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICByZXR1cm4gZWxUZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUc3BhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUc3Bhbih0ZXh0RWwsIHRleHQsIGZvbnRGYW1pbHkpIHtcbiAgICAgIHZhciB0c3BhbiA9IHRleHRFbC50c3Bhbih0ZXh0KTtcblxuICAgICAgaWYgKCFmb250RmFtaWx5KSB7XG4gICAgICAgIGZvbnRGYW1pbHkgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICB9XG5cbiAgICAgIHRzcGFuLm5vZGUuc3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdNYXJrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd01hcmtlcih4LCB5LCBvcHRzKSB7XG4gICAgICB4ID0geCB8fCAwO1xuICAgICAgdmFyIHNpemUgPSBvcHRzLnBTaXplIHx8IDA7XG4gICAgICB2YXIgZWxQb2ludCA9IG51bGw7XG5cbiAgICAgIGlmIChvcHRzLnNoYXBlID09PSAnc3F1YXJlJykge1xuICAgICAgICB2YXIgcmFkaXVzID0gb3B0cy5wUmFkaXVzID09PSB1bmRlZmluZWQgPyBzaXplIC8gMiA6IG9wdHMucFJhZGl1cztcblxuICAgICAgICBpZiAoeSA9PT0gbnVsbCkge1xuICAgICAgICAgIHNpemUgPSAwO1xuICAgICAgICAgIHJhZGl1cyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgblNpemUgPSBzaXplICogMS4yICsgcmFkaXVzO1xuICAgICAgICB2YXIgcCA9IHRoaXMuZHJhd1JlY3QoblNpemUsIG5TaXplLCBuU2l6ZSwgblNpemUsIHJhZGl1cyk7XG4gICAgICAgIHAuYXR0cih7XG4gICAgICAgICAgeDogeCAtIG5TaXplIC8gMixcbiAgICAgICAgICB5OiB5IC0gblNpemUgLyAyLFxuICAgICAgICAgIGN4OiB4LFxuICAgICAgICAgIGN5OiB5LFxuICAgICAgICAgIGNsYXNzOiBvcHRzLmNsYXNzID8gb3B0cy5jbGFzcyA6ICcnLFxuICAgICAgICAgIGZpbGw6IG9wdHMucG9pbnRGaWxsQ29sb3IsXG4gICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IG9wdHMucG9pbnRGaWxsT3BhY2l0eSA/IG9wdHMucG9pbnRGaWxsT3BhY2l0eSA6IDEsXG4gICAgICAgICAgc3Ryb2tlOiBvcHRzLnBvaW50U3Ryb2tlQ29sb3IsXG4gICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IG9wdHMucFdpZHRoID8gb3B0cy5wV2lkdGggOiAwLFxuICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IG9wdHMucG9pbnRTdHJva2VPcGFjaXR5ID8gb3B0cy5wb2ludFN0cm9rZU9wYWNpdHkgOiAxXG4gICAgICAgIH0pO1xuICAgICAgICBlbFBvaW50ID0gcDtcbiAgICAgIH0gZWxzZSBpZiAob3B0cy5zaGFwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgaWYgKCFVdGlscy5pc051bWJlcih5KSkge1xuICAgICAgICAgIHNpemUgPSAwO1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9IC8vIGxldCBuU2l6ZSA9IHNpemUgLSBvcHRzLnBSYWRpdXMgLyAyIDwgMCA/IDAgOiBzaXplIC0gb3B0cy5wUmFkaXVzIC8gMlxuXG5cbiAgICAgICAgZWxQb2ludCA9IHRoaXMuZHJhd0NpcmNsZShzaXplLCB7XG4gICAgICAgICAgY3g6IHgsXG4gICAgICAgICAgY3k6IHksXG4gICAgICAgICAgY2xhc3M6IG9wdHMuY2xhc3MgPyBvcHRzLmNsYXNzIDogJycsXG4gICAgICAgICAgc3Ryb2tlOiBvcHRzLnBvaW50U3Ryb2tlQ29sb3IsXG4gICAgICAgICAgZmlsbDogb3B0cy5wb2ludEZpbGxDb2xvcixcbiAgICAgICAgICAnZmlsbC1vcGFjaXR5Jzogb3B0cy5wb2ludEZpbGxPcGFjaXR5ID8gb3B0cy5wb2ludEZpbGxPcGFjaXR5IDogMSxcbiAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogb3B0cy5wV2lkdGggPyBvcHRzLnBXaWR0aCA6IDAsXG4gICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5Jzogb3B0cy5wb2ludFN0cm9rZU9wYWNpdHkgPyBvcHRzLnBvaW50U3Ryb2tlT3BhY2l0eSA6IDFcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbFBvaW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoTW91c2VFbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTW91c2VFbnRlcihwYXRoLCBlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgdmFyIGkgPSBwYXJzZUludChwYXRoLm5vZGUuZ2V0QXR0cmlidXRlKCdpbmRleCcpKTtcbiAgICAgIHZhciBqID0gcGFyc2VJbnQocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnaicpKTtcblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuZGF0YVBvaW50TW91c2VFbnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuZGF0YVBvaW50TW91c2VFbnRlcihlLCB0aGlzLmN0eCwge1xuICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICAgIHc6IHdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LmZpcmVFdmVudCgnZGF0YVBvaW50TW91c2VFbnRlcicsIFtlLCB0aGlzLmN0eCwge1xuICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgIHc6IHdcbiAgICAgIH1dKTtcblxuICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5hY3RpdmUuZmlsdGVyLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICBpZiAocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMuaG92ZXIuZmlsdGVyLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICBpZiAody5jb25maWcuc3RhdGVzLmFjdGl2ZS5maWx0ZXIudHlwZSAhPT0gJ25vbmUnICYmICF3Lmdsb2JhbHMuaXNUb3VjaERldmljZSkge1xuICAgICAgICAgIHZhciBob3ZlckZpbHRlciA9IHcuY29uZmlnLnN0YXRlcy5ob3Zlci5maWx0ZXI7XG4gICAgICAgICAgZmlsdGVycy5hcHBseUZpbHRlcihwYXRoLCBob3ZlckZpbHRlci50eXBlLCBob3ZlckZpbHRlci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aE1vdXNlTGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aE1vdXNlTGVhdmUocGF0aCwgZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBpID0gcGFyc2VJbnQocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnaW5kZXgnKSk7XG4gICAgICB2YXIgaiA9IHBhcnNlSW50KHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ2onKSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLmRhdGFQb2ludE1vdXNlTGVhdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLmRhdGFQb2ludE1vdXNlTGVhdmUoZSwgdGhpcy5jdHgsIHtcbiAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5maXJlRXZlbnQoJ2RhdGFQb2ludE1vdXNlTGVhdmUnLCBbZSwgdGhpcy5jdHgsIHtcbiAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICB3OiB3XG4gICAgICB9XSk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5zdGF0ZXMuYWN0aXZlLmZpbHRlci50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgaWYgKHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgPT09ICd0cnVlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcuc3RhdGVzLmhvdmVyLmZpbHRlci50eXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgZmlsdGVycy5nZXREZWZhdWx0RmlsdGVyKHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoTW91c2VEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhNb3VzZURvd24ocGF0aCwgZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBpID0gcGFyc2VJbnQocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnaW5kZXgnKSk7XG4gICAgICB2YXIgaiA9IHBhcnNlSW50KHBhdGgubm9kZS5nZXRBdHRyaWJ1dGUoJ2onKSk7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSAnZmFsc2UnO1xuXG4gICAgICBpZiAocGF0aC5ub2RlLmdldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHBhdGgubm9kZS5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbaV0uaW5kZXhPZihqKSA+IC0xKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tpXS5pbmRleE9mKGopO1xuICAgICAgICAgIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbaV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF3LmNvbmZpZy5zdGF0ZXMuYWN0aXZlLmFsbG93TXVsdGlwbGVEYXRhUG9pbnRzU2VsZWN0aW9uICYmIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHMgPSBbXTtcbiAgICAgICAgICB2YXIgZWxQYXRocyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KCcuYXBleGNoYXJ0cy1zZXJpZXMgcGF0aCcpLm1lbWJlcnM7XG4gICAgICAgICAgdmFyIGVsQ2lyY2xlcyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KCcuYXBleGNoYXJ0cy1zZXJpZXMgY2lyY2xlLCAuYXBleGNoYXJ0cy1zZXJpZXMgcmVjdCcpLm1lbWJlcnM7XG4gICAgICAgICAgZWxQYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChlbFBhdGgpIHtcbiAgICAgICAgICAgIGVsUGF0aC5ub2RlLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIGZpbHRlcnMuZ2V0RGVmYXVsdEZpbHRlcihlbFBhdGgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsQ2lyY2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgICAgIGNpcmNsZS5ub2RlLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgICAgIGZpbHRlcnMuZ2V0RGVmYXVsdEZpbHRlcihjaXJjbGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aC5ub2RlLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICBzZWxlY3RlZCA9ICd0cnVlJztcblxuICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tpXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50c1tpXS5wdXNoKGopO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWQgPT09ICd0cnVlJykge1xuICAgICAgICB2YXIgYWN0aXZlRmlsdGVyID0gdy5jb25maWcuc3RhdGVzLmFjdGl2ZS5maWx0ZXI7XG5cbiAgICAgICAgaWYgKGFjdGl2ZUZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgZmlsdGVycy5hcHBseUZpbHRlcihwYXRoLCBhY3RpdmVGaWx0ZXIudHlwZSwgYWN0aXZlRmlsdGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnN0YXRlcy5hY3RpdmUuZmlsdGVyLnR5cGUgIT09ICdub25lJykge1xuICAgICAgICAgIGZpbHRlcnMuZ2V0RGVmYXVsdEZpbHRlcihwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5kYXRhUG9pbnRTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLmRhdGFQb2ludFNlbGVjdGlvbihlLCB0aGlzLmN0eCwge1xuICAgICAgICAgIHNlbGVjdGVkRGF0YVBvaW50czogdy5nbG9iYWxzLnNlbGVjdGVkRGF0YVBvaW50cyxcbiAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5maXJlRXZlbnQoJ2RhdGFQb2ludFNlbGVjdGlvbicsIFtlLCB0aGlzLmN0eCwge1xuICAgICAgICBzZWxlY3RlZERhdGFQb2ludHM6IHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHMsXG4gICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgdzogd1xuICAgICAgfV0pOyAvLyBpZiAodGhpcy53LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uc2VsZWN0ZWRQb2ludHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gICB0aGlzLncuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5zZWxlY3RlZFBvaW50cyh3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzKVxuICAgICAgLy8gfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVBcm91bmRDZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlQXJvdW5kQ2VudGVyKGVsKSB7XG4gICAgICB2YXIgY29vcmQgPSBlbC5nZXRCQm94KCk7XG4gICAgICB2YXIgeCA9IGNvb3JkLnggKyBjb29yZC53aWR0aCAvIDI7XG4gICAgICB2YXIgeSA9IGNvb3JkLnkgKyBjb29yZC5oZWlnaHQgLyAyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGV4dFJlY3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHRSZWN0cyh0ZXh0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgdXNlQkJveCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHZpcnR1YWxUZXh0ID0gdGhpcy5kcmF3VGV4dCh7XG4gICAgICAgIHg6IC0yMDAsXG4gICAgICAgIHk6IC0yMDAsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHRleHRBbmNob3I6ICdzdGFydCcsXG4gICAgICAgIGZvbnRTaXplOiBmb250U2l6ZSxcbiAgICAgICAgZm9udEZhbWlseTogZm9udEZhbWlseSxcbiAgICAgICAgZm9yZUNvbG9yOiAnI2ZmZicsXG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHZpcnR1YWxUZXh0LmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSk7XG4gICAgICB9XG5cbiAgICAgIHcuZ2xvYmFscy5kb20uUGFwZXIuYWRkKHZpcnR1YWxUZXh0KTtcbiAgICAgIHZhciByZWN0ID0gdmlydHVhbFRleHQuYmJveCgpO1xuXG4gICAgICBpZiAoIXVzZUJCb3gpIHtcbiAgICAgICAgcmVjdCA9IHZpcnR1YWxUZXh0Lm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHZpcnR1YWxUZXh0LnJlbW92ZSgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFwcGVuZCAuLi4gdG8gbG9uZyB0ZXh0XG4gICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85MjQxMzE1L3RyaW1taW5nLXRleHQtdG8tYS1naXZlbi1waXhlbC13aWR0aC1pbi1zdmdcbiAgICAgKiBAbWVtYmVyb2YgR3JhcGhpY3NcbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJwbGFjZVRleHRXaXRoRWxsaXBzaXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxhY2VUZXh0V2l0aEVsbGlwc2lzKHRleHRPYmosIHRleHRTdHJpbmcsIHdpZHRoKSB7XG4gICAgICB0ZXh0T2JqLnRleHRDb250ZW50ID0gdGV4dFN0cmluZztcblxuICAgICAgaWYgKHRleHRTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBlbGxpcHNpcyBpcyBuZWVkZWRcbiAgICAgICAgaWYgKHRleHRPYmouZ2V0U3ViU3RyaW5nTGVuZ3RoKDAsIHRleHRTdHJpbmcubGVuZ3RoKSA+PSB3aWR0aCkge1xuICAgICAgICAgIGZvciAodmFyIHggPSB0ZXh0U3RyaW5nLmxlbmd0aCAtIDM7IHggPiAwOyB4IC09IDMpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0T2JqLmdldFN1YlN0cmluZ0xlbmd0aCgwLCB4KSA8PSB3aWR0aCkge1xuICAgICAgICAgICAgICB0ZXh0T2JqLnRleHRDb250ZW50ID0gdGV4dFN0cmluZy5zdWJzdHJpbmcoMCwgeCkgKyAnLi4uJztcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRleHRPYmoudGV4dENvbnRlbnQgPSAnLi4uJzsgLy8gY2FuJ3QgcGxhY2UgYXQgYWxsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJzZXRBdHRyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRycyhlbCwgYXR0cnMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdyYXBoaWNzO1xufSgpO1xuXG5jb25zdCBuYW1lID0gXCJlblwiO1xuY29uc3Qgb3B0aW9ucyA9IHtcblx0bW9udGhzOiBbXG5cdFx0XCJKYW51YXJ5XCIsXG5cdFx0XCJGZWJydWFyeVwiLFxuXHRcdFwiTWFyY2hcIixcblx0XHRcIkFwcmlsXCIsXG5cdFx0XCJNYXlcIixcblx0XHRcIkp1bmVcIixcblx0XHRcIkp1bHlcIixcblx0XHRcIkF1Z3VzdFwiLFxuXHRcdFwiU2VwdGVtYmVyXCIsXG5cdFx0XCJPY3RvYmVyXCIsXG5cdFx0XCJOb3ZlbWJlclwiLFxuXHRcdFwiRGVjZW1iZXJcIlxuXHRdLFxuXHRzaG9ydE1vbnRoczogW1xuXHRcdFwiSmFuXCIsXG5cdFx0XCJGZWJcIixcblx0XHRcIk1hclwiLFxuXHRcdFwiQXByXCIsXG5cdFx0XCJNYXlcIixcblx0XHRcIkp1blwiLFxuXHRcdFwiSnVsXCIsXG5cdFx0XCJBdWdcIixcblx0XHRcIlNlcFwiLFxuXHRcdFwiT2N0XCIsXG5cdFx0XCJOb3ZcIixcblx0XHRcIkRlY1wiXG5cdF0sXG5cdGRheXM6IFtcblx0XHRcIlN1bmRheVwiLFxuXHRcdFwiTW9uZGF5XCIsXG5cdFx0XCJUdWVzZGF5XCIsXG5cdFx0XCJXZWRuZXNkYXlcIixcblx0XHRcIlRodXJzZGF5XCIsXG5cdFx0XCJGcmlkYXlcIixcblx0XHRcIlNhdHVyZGF5XCJcblx0XSxcblx0c2hvcnREYXlzOiBbXG5cdFx0XCJTdW5cIixcblx0XHRcIk1vblwiLFxuXHRcdFwiVHVlXCIsXG5cdFx0XCJXZWRcIixcblx0XHRcIlRodVwiLFxuXHRcdFwiRnJpXCIsXG5cdFx0XCJTYXRcIlxuXHRdLFxuXHR0b29sYmFyOiB7XG5cdFx0ZXhwb3J0VG9TVkc6IFwiRG93bmxvYWQgU1ZHXCIsXG5cdFx0ZXhwb3J0VG9QTkc6IFwiRG93bmxvYWQgUE5HXCIsXG5cdFx0bWVudTogXCJNZW51XCIsXG5cdFx0c2VsZWN0aW9uOiBcIlNlbGVjdGlvblwiLFxuXHRcdHNlbGVjdGlvblpvb206IFwiU2VsZWN0aW9uIFpvb21cIixcblx0XHR6b29tSW46IFwiWm9vbSBJblwiLFxuXHRcdHpvb21PdXQ6IFwiWm9vbSBPdXRcIixcblx0XHRwYW46IFwiUGFubmluZ1wiLFxuXHRcdHJlc2V0OiBcIlJlc2V0IFpvb21cIlxuXHR9XG59O1xudmFyIGVuID0ge1xuXHRuYW1lOiBuYW1lLFxuXHRvcHRpb25zOiBvcHRpb25zXG59O1xuXG52YXIgT3B0aW9ucyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9wdGlvbnMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdGlvbnMpO1xuXG4gICAgdGhpcy55QXhpcyA9IHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBzaG93QWx3YXlzOiBmYWxzZSxcbiAgICAgIHNlcmllc05hbWU6IHVuZGVmaW5lZCxcbiAgICAgIG9wcG9zaXRlOiBmYWxzZSxcbiAgICAgIHJldmVyc2VkOiBmYWxzZSxcbiAgICAgIGxvZ2FyaXRobWljOiBmYWxzZSxcbiAgICAgIHRpY2tBbW91bnQ6IHVuZGVmaW5lZCxcbiAgICAgIGZvcmNlTmljZVNjYWxlOiBmYWxzZSxcbiAgICAgIG1heDogdW5kZWZpbmVkLFxuICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICBmbG9hdGluZzogZmFsc2UsXG4gICAgICBkZWNpbWFsc0luRmxvYXQ6IDIsXG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgbWluV2lkdGg6IDAsXG4gICAgICAgIG1heFdpZHRoOiAxNjAsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgIHJvdGF0ZTogMCxcbiAgICAgICAgcGFkZGluZzogMjAsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICBmb250U2l6ZTogJzExcHgnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjc3NDbGFzczogJydcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICBheGlzQm9yZGVyOiB7XG4gICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJyM3ODkwOUMnLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwXG4gICAgICB9LFxuICAgICAgYXhpc1RpY2tzOiB7XG4gICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJyM3ODkwOUMnLFxuICAgICAgICB3aWR0aDogNixcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcm90YXRlOiA5MCxcbiAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvbnRTaXplOiAnMTFweCcsXG4gICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgIGNzc0NsYXNzOiAnJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0WDogMFxuICAgICAgfSxcbiAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246ICdmcm9udCcsXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIGNvbG9yOiAnI2I2YjZiNicsXG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgZGFzaEFycmF5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMueEF4aXNBbm5vdGF0aW9uID0ge1xuICAgICAgeDogMCxcbiAgICAgIHgyOiBudWxsLFxuICAgICAgc3Ryb2tlRGFzaEFycmF5OiAxLFxuICAgICAgZmlsbENvbG9yOiAnI2MyYzJjMicsXG4gICAgICBib3JkZXJDb2xvcjogJyNjMmMyYzInLFxuICAgICAgb3BhY2l0eTogMC4zLFxuICAgICAgb2Zmc2V0WDogMCxcbiAgICAgIG9mZnNldFk6IDAsXG4gICAgICBsYWJlbDoge1xuICAgICAgICBib3JkZXJDb2xvcjogJyNjMmMyYzInLFxuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgb3JpZW50YXRpb246ICd2ZXJ0aWNhbCcsXG4gICAgICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb250U2l6ZTogJzExcHgnLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjc3NDbGFzczogJycsXG4gICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgbGVmdDogNSxcbiAgICAgICAgICAgIHJpZ2h0OiA1LFxuICAgICAgICAgICAgdG9wOiAyLFxuICAgICAgICAgICAgYm90dG9tOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnlBeGlzQW5ub3RhdGlvbiA9IHtcbiAgICAgIHk6IDAsXG4gICAgICB5MjogbnVsbCxcbiAgICAgIHN0cm9rZURhc2hBcnJheTogMSxcbiAgICAgIGZpbGxDb2xvcjogJyNjMmMyYzInLFxuICAgICAgYm9yZGVyQ29sb3I6ICcjYzJjMmMyJyxcbiAgICAgIG9wYWNpdHk6IDAuMyxcbiAgICAgIG9mZnNldFg6IDAsXG4gICAgICBvZmZzZXRZOiAwLFxuICAgICAgeUF4aXNJbmRleDogMCxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiAnI2MyYzJjMicsXG4gICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIHRleHRBbmNob3I6ICdlbmQnLFxuICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogLTMsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogJyNmZmYnLFxuICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgZm9udFNpemU6ICcxMXB4JyxcbiAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgY3NzQ2xhc3M6ICcnLFxuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIGxlZnQ6IDUsXG4gICAgICAgICAgICByaWdodDogNSxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wb2ludEFubm90YXRpb24gPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogbnVsbCxcbiAgICAgIHlBeGlzSW5kZXg6IDAsXG4gICAgICBzZXJpZXNJbmRleDogMCxcbiAgICAgIG1hcmtlcjoge1xuICAgICAgICBzaXplOiAwLFxuICAgICAgICBmaWxsQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgIHN0cm9rZUNvbG9yOiAnIzMzMycsXG4gICAgICAgIHNoYXBlOiAnY2lyY2xlJyxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgcmFkaXVzOiAyLFxuICAgICAgICBjc3NDbGFzczogJydcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBib3JkZXJDb2xvcjogJyNjMmMyYzInLFxuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogLTE1LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgIGZvbnRTaXplOiAnMTFweCcsXG4gICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgIGNzc0NsYXNzOiAnJyxcbiAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICBsZWZ0OiA1LFxuICAgICAgICAgICAgcmlnaHQ6IDUsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBib3R0b206IDJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjdXN0b21TVkc6IHtcbiAgICAgICAgU1ZHOiB1bmRlZmluZWQsXG4gICAgICAgIGNzc0NsYXNzOiB1bmRlZmluZWQsXG4gICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgIG9mZnNldFk6IDBcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9wdGlvbnMsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFubm90YXRpb25zOiB7XG4gICAgICAgICAgcG9zaXRpb246ICdmcm9udCcsXG4gICAgICAgICAgeWF4aXM6IFt0aGlzLnlBeGlzQW5ub3RhdGlvbl0sXG4gICAgICAgICAgeGF4aXM6IFt0aGlzLnhBeGlzQW5ub3RhdGlvbl0sXG4gICAgICAgICAgcG9pbnRzOiBbdGhpcy5wb2ludEFubm90YXRpb25dXG4gICAgICAgIH0sXG4gICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2Vpbm91dCcsXG4gICAgICAgICAgICAvLyBsaW5lYXIsIGVhc2VvdXQsIGVhc2VpbiwgZWFzZWlub3V0LCBzd2luZywgYm91bmNlLCBlbGFzdGljXG4gICAgICAgICAgICBzcGVlZDogODAwLFxuICAgICAgICAgICAgYW5pbWF0ZUdyYWR1YWxseToge1xuICAgICAgICAgICAgICBkZWxheTogMTUwLFxuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHluYW1pY0FuaW1hdGlvbjoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICBzcGVlZDogMzUwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgIGxvY2FsZXM6IFtlbl0sXG4gICAgICAgICAgZGVmYXVsdExvY2FsZTogJ2VuJyxcbiAgICAgICAgICBkcm9wU2hhZG93OiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGVuYWJsZWRTZXJpZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRvcDogMixcbiAgICAgICAgICAgIGxlZnQ6IDIsXG4gICAgICAgICAgICBibHVyOiA0LFxuICAgICAgICAgICAgY29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMzVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgYW5pbWF0aW9uRW5kOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBiZWZvcmVNb3VudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbW91bnRlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdXBkYXRlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2xpY2s6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxlZ2VuZENsaWNrOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWxlY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGFQb2ludFNlbGVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YVBvaW50TW91c2VFbnRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGF0YVBvaW50TW91c2VMZWF2ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYmVmb3JlWm9vbTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgem9vbWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzY3JvbGxlZDogdW5kZWZpbmVkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JlQ29sb3I6ICcjMzczZDNmJyxcbiAgICAgICAgICBmb250RmFtaWx5OiAnSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZicsXG4gICAgICAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBncm91cDogdW5kZWZpbmVkLFxuICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdHlwZTogJ3gnLFxuICAgICAgICAgICAgLy8gc2VsZWN0ZWRQb2ludHM6IHVuZGVmaW5lZCwgLy8gZGVmYXVsdCBkYXRhcG9pbnRzIHRoYXQgc2hvdWxkIGJlIHNlbGVjdGVkIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgY29sb3I6ICcjMjQyOTJlJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC4xXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICBjb2xvcjogJyMyNDI5MmUnLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjQsXG4gICAgICAgICAgICAgIGRhc2hBcnJheTogM1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBtYXg6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHlheGlzOiB7XG4gICAgICAgICAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBtYXg6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3BhcmtsaW5lOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnJ1c2g6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgYXV0b1NjYWxlWWF4aXM6IGZhbHNlLFxuICAgICAgICAgICAgdGFyZ2V0OiB1bmRlZmluZWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgICAgICAgIHN0YWNrVHlwZTogJ25vcm1hbCcsXG4gICAgICAgICAgdG9vbGJhcjoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIHRvb2xzOiB7XG4gICAgICAgICAgICAgIGRvd25sb2FkOiB0cnVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb246IHRydWUsXG4gICAgICAgICAgICAgIHpvb206IHRydWUsXG4gICAgICAgICAgICAgIHpvb21pbjogdHJ1ZSxcbiAgICAgICAgICAgICAgem9vbW91dDogdHJ1ZSxcbiAgICAgICAgICAgICAgcGFuOiB0cnVlLFxuICAgICAgICAgICAgICByZXNldDogdHJ1ZSxcbiAgICAgICAgICAgICAgY3VzdG9tSWNvbnM6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXV0b1NlbGVjdGVkOiAnem9vbScgLy8gYWNjZXB0cyAtPiB6b29tLCBwYW4sIHNlbGVjdGlvblxuXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICB6b29tOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogJ3gnLFxuICAgICAgICAgICAgLy8gYXV0b1NjYWxlWWF4aXM6IGZhbHNlLCAvLyBUT0RPOiByZXdyaXRlIHRoZSBhdXRvU2NhbGVZIGZ1bmN0aW9uXG4gICAgICAgICAgICB6b29tZWRBcmVhOiB7XG4gICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyM5MENBRjknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMwRDQ3QTEnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwbG90T3B0aW9uczoge1xuICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgICAgICBlbmRpbmdTaGFwZTogJ2ZsYXQnLFxuICAgICAgICAgICAgLy8gVE9ETzogZGVwcmVjYXRlIGluIDQuMFxuICAgICAgICAgICAgY29sdW1uV2lkdGg6ICc3MCUnLFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGluIHBlcmNlbnQgMCAtIDEwMFxuICAgICAgICAgICAgYmFySGVpZ2h0OiAnNzAlJyxcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpbiBwZXJjZW50IDAgLSAxMDBcbiAgICAgICAgICAgIGRpc3RyaWJ1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICByYW5nZXM6IFtdLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQmFyQ29sb3JzOiBbXSxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZEJhck9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiAndG9wJyAvLyB0b3AsIGNlbnRlciwgYm90dG9tXG4gICAgICAgICAgICAgIC8vIFRPRE86IHByb3ZpZGUgc3RhY2tlZExhYmVscyBmb3Igc3RhY2tlZCBjaGFydHMgd2hpY2ggZ2l2ZXMgYWRkaXRpb25zIG9mIHZhbHVlc1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5kbGVzdGljazoge1xuICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgIHVwd2FyZDogJyMwMEI3NDYnLFxuICAgICAgICAgICAgICBkb3dud2FyZDogJyNFRjQwM0MnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2ljazoge1xuICAgICAgICAgICAgICB1c2VGaWxsQ29sb3I6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYXRtYXA6IHtcbiAgICAgICAgICAgIHJhZGl1czogMixcbiAgICAgICAgICAgIGVuYWJsZVNoYWRlczogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjUsXG4gICAgICAgICAgICBkaXN0cmlidXRlZDogZmFsc2UsXG4gICAgICAgICAgICBjb2xvclNjYWxlOiB7XG4gICAgICAgICAgICAgIGludmVyc2U6IGZhbHNlLFxuICAgICAgICAgICAgICByYW5nZXM6IFtdLFxuICAgICAgICAgICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgbWF4OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJhZGlhbEJhcjoge1xuICAgICAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW52ZXJzZU9yZGVyOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgICAgICAgICBlbmRBbmdsZTogMzYwLFxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICBob2xsb3c6IHtcbiAgICAgICAgICAgICAgbWFyZ2luOiA1LFxuICAgICAgICAgICAgICBzaXplOiAnNTAlJyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgaW1hZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgaW1hZ2VXaWR0aDogMTUwLFxuICAgICAgICAgICAgICBpbWFnZUhlaWdodDogMTUwLFxuICAgICAgICAgICAgICBpbWFnZU9mZnNldFg6IDAsXG4gICAgICAgICAgICAgIGltYWdlT2Zmc2V0WTogMCxcbiAgICAgICAgICAgICAgaW1hZ2VDbGlwcGVkOiB0cnVlLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Zyb250JyxcbiAgICAgICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIGJsdXI6IDMsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYWNrOiB7XG4gICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZW5kQW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogJyNmMmYyZjInLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogJzk3JScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgIG1hcmdpbjogNSxcbiAgICAgICAgICAgICAgLy8gbWFyZ2luIGlzIGluIHBpeGVsc1xuICAgICAgICAgICAgICBkcm9wU2hhZG93OiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgYmx1cjogMyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE2cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9mZnNldFk6IDBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0WTogMTYsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsICsgJyUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdG90YWw6IHtcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1RvdGFsJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMzNzNkM2YnLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3Lmdsb2JhbHMuc2VyaWVzVG90YWxzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgICAgICAgICAgICB9LCAwKSAvIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoICsgJyUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGllOiB7XG4gICAgICAgICAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdXN0b21TY2FsZTogMSxcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgZXhwYW5kT25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBwZXJjZW50YWdlIHZhbHVlcyB3aGljaCBhcmUgZGlzcGxheWVkIG9uIHNsaWNlXG4gICAgICAgICAgICAgIG9mZnNldDogMCAvLyBvZmZzZXQgYnkgd2hpY2ggbGFiZWxzIHdpbGwgbW92ZSBvdXRzaWRlXG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb251dDoge1xuICAgICAgICAgICAgICBzaXplOiAnNjUlJyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBpbm5lciBsYWJlbHMgYXBwZWFyaW5nIGluc2lkZSBkb251dFxuICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE2cHgnLFxuICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIG9mZnNldFk6IC0xMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzIwcHgnLFxuICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIG9mZnNldFk6IDEwLFxuICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b3RhbDoge1xuICAgICAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBsYWJlbDogJ1RvdGFsJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzM3M2QzZicsXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3Lmdsb2JhbHMuc2VyaWVzVG90YWxzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByYWRhcjoge1xuICAgICAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICBwb2x5Z29uczoge1xuICAgICAgICAgICAgICAvLyBzdHJva2VDb2xvcjogJyNlOGU4ZTgnLCAvLyBzaG91bGQgYmUgZGVwcmVjYXRlZCBpbiB0aGUgbWlub3IgdmVyc2lvbiBpLmUgMy4yXG4gICAgICAgICAgICAgIHN0cm9rZUNvbG9yczogJyNlOGU4ZTgnLFxuICAgICAgICAgICAgICBjb25uZWN0b3JDb2xvcnM6ICcjZThlOGU4JyxcbiAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBlbmFibGVkT25TZXJpZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB0b3A6IDEsXG4gICAgICAgICAgICBsZWZ0OiAxLFxuICAgICAgICAgICAgYmx1cjogMSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjQ1XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgdHlwZTogJ3NvbGlkJyxcbiAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAvLyBhcnJheSBvZiBjb2xvcnNcbiAgICAgICAgICBvcGFjaXR5OiAwLjg1LFxuICAgICAgICAgIGdyYWRpZW50OiB7XG4gICAgICAgICAgICBzaGFkZTogJ2RhcmsnLFxuICAgICAgICAgICAgdHlwZTogJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgc2hhZGVJbnRlbnNpdHk6IDAuNSxcbiAgICAgICAgICAgIGdyYWRpZW50VG9Db2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGludmVyc2VDb2xvcnM6IHRydWUsXG4gICAgICAgICAgICBvcGFjaXR5RnJvbTogMSxcbiAgICAgICAgICAgIG9wYWNpdHlUbzogMSxcbiAgICAgICAgICAgIHN0b3BzOiBbMCwgNTAsIDEwMF0sXG4gICAgICAgICAgICBjb2xvclN0b3BzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgIHNyYzogW10sXG4gICAgICAgICAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgIGhlaWdodDogdW5kZWZpbmVkIC8vIG9wdGlvbmFsXG5cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhdHRlcm46IHtcbiAgICAgICAgICAgIHN0eWxlOiAnc3FhdXJlcycsXG4gICAgICAgICAgICAvLyBTdHJpbmcgfCBBcnJheSBvZiBTdHJpbmdzXG4gICAgICAgICAgICB3aWR0aDogNixcbiAgICAgICAgICAgIGhlaWdodDogNixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICBib3JkZXJDb2xvcjogJyNlMGUwZTAnLFxuICAgICAgICAgIHN0cm9rZURhc2hBcnJheTogMCxcbiAgICAgICAgICBwb3NpdGlvbjogJ2JhY2snLFxuICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICBsaW5lczoge1xuICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgYW5pbWF0ZTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHlheGlzOiB7XG4gICAgICAgICAgICBsaW5lczoge1xuICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICBhbmltYXRlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByb3c6IHtcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gdGFrZXMgYXMgYXJyYXkgd2hpY2ggd2lsbCBiZSByZXBlYXRlZCBvbiByb3dzXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbHVtbjoge1xuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyB0YWtlcyBhbiBhcnJheSB3aGljaCB3aWxsIGJlIHJlcGVhdGVkIG9uIGNvbHVtbnNcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgcmlnaHQ6IDEwLFxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgbGVmdDogMTJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgc2hvd0ZvclNpbmdsZVNlcmllczogZmFsc2UsXG4gICAgICAgICAgc2hvd0Zvck51bGxTZXJpZXM6IHRydWUsXG4gICAgICAgICAgc2hvd0Zvclplcm9TZXJpZXM6IHRydWUsXG4gICAgICAgICAgZmxvYXRpbmc6IGZhbHNlLFxuICAgICAgICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcbiAgICAgICAgICAvLyB3aGV0aGVyIHRvIHBvc2l0aW9uIGxlZ2VuZHMgaW4gMSBvZiA0XG4gICAgICAgICAgLy8gZGlyZWN0aW9uIC0gdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0XG4gICAgICAgICAgaG9yaXpvbnRhbEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAvLyB3aGVuIHBvc2l0aW9uIHRvcC9ib3R0b20sIHlvdSBjYW4gc3BlY2lmeSB3aGV0aGVyIHRvIGFsaWduIGxlZ2VuZHMgbGVmdCwgcmlnaHQgb3IgY2VudGVyXG4gICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICBvZmZzZXRYOiAtMjAsXG4gICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdXNlU2VyaWVzQ29sb3JzOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgICAgd2lkdGg6IDEyLFxuICAgICAgICAgICAgaGVpZ2h0OiAxMixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIHJhZGl1czogMTIsXG4gICAgICAgICAgICBjdXN0b21IVE1MOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHVuZGVmaW5lZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXRlbU1hcmdpbjoge1xuICAgICAgICAgICAgaG9yaXpvbnRhbDogMCxcbiAgICAgICAgICAgIHZlcnRpY2FsOiA1XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkl0ZW1DbGljazoge1xuICAgICAgICAgICAgdG9nZ2xlRGF0YVNlcmllczogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25JdGVtSG92ZXI6IHtcbiAgICAgICAgICAgIGhpZ2hsaWdodERhdGFTZXJpZXM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICBkaXNjcmV0ZTogW10sXG4gICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAvL3N0cm9rZUNvbG9yOiAnI2ZmZicsIC8vIFRPRE86IGRlcHJlY2F0ZSBpbiBtYWpvciB2ZXJzaW9uIDQuMFxuICAgICAgICAgIHN0cm9rZUNvbG9yczogJyNmZmYnLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuOSxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgICAgICBzaGFwZTogJ2NpcmNsZScsXG4gICAgICAgICAgcmFkaXVzOiAyLFxuICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2l6ZU9mZnNldDogM1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9EYXRhOiB7XG4gICAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgZm9udEZhbWlseTogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXNwb25zaXZlOiBbXSxcbiAgICAgICAgLy8gYnJlYWtwb2ludHMgc2hvdWxkIGZvbGxvdyBhc2NlbmRpbmcgb3JkZXIgNDAwLCB0aGVuIDcwMCwgdGhlbiAxMDAwXG4gICAgICAgIHNlcmllczogdW5kZWZpbmVkLFxuICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICB0eXBlOiAnbm9uZScsXG4gICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdsaWdodGVuJyxcbiAgICAgICAgICAgICAgdmFsdWU6IDAuMTVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgYWxsb3dNdWx0aXBsZURhdGFQb2ludHNTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdkYXJrZW4nLFxuICAgICAgICAgICAgICB2YWx1ZTogMC42NVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgYWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICBtYXJnaW46IDEwLFxuICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICBmbG9hdGluZzogZmFsc2UsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdWJ0aXRsZToge1xuICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBhbGlnbjogJ2xlZnQnLFxuICAgICAgICAgIG1hcmdpbjogMTAsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAzMCxcbiAgICAgICAgICBmbG9hdGluZzogZmFsc2UsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgIGN1cnZlOiAnc21vb3RoJyxcbiAgICAgICAgICAvLyBcInNtb290aFwiIC8gXCJzdHJhaWdodFwiIC8gXCJzdGVwbGluZVwiXG4gICAgICAgICAgbGluZUNhcDogJ2J1dHQnLFxuICAgICAgICAgIC8vIHJvdW5kLCBidXR0ICwgc3F1YXJlXG4gICAgICAgICAgd2lkdGg6IDIsXG4gICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXG4gICAgICAgICAgLy8gYXJyYXkgb2YgY29sb3JzXG4gICAgICAgICAgZGFzaEFycmF5OiAwIC8vIHNpbmdsZSB2YWx1ZSBvciBhcnJheSBvZiB2YWx1ZXNcblxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBzaGFyZWQ6IHRydWUsXG4gICAgICAgICAgZm9sbG93Q3Vyc29yOiBmYWxzZSxcbiAgICAgICAgICAvLyB3aGVuIGRpc2FibGVkLCB0aGUgdG9vbHRpcCB3aWxsIHNob3cgb24gdG9wIG9mIHRoZSBzZXJpZXMgaW5zdGVhZCBvZiBtb3VzZSBwb3NpdGlvblxuICAgICAgICAgIGludGVyc2VjdDogZmFsc2UsXG4gICAgICAgICAgLy8gd2hlbiBlbmFibGVkLCB0b29sdGlwIHdpbGwgb25seSBzaG93IHdoZW4gdXNlciBkaXJlY3RseSBob3ZlcnMgb3ZlciBwb2ludFxuICAgICAgICAgIGludmVyc2VPcmRlcjogZmFsc2UsXG4gICAgICAgICAgY3VzdG9tOiB1bmRlZmluZWQsXG4gICAgICAgICAgZmlsbFNlcmllc0NvbG9yOiBmYWxzZSxcbiAgICAgICAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25EYXRhc2V0SG92ZXI6IHtcbiAgICAgICAgICAgIGhpZ2hsaWdodERhdGFTZXJpZXM6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4OiB7XG4gICAgICAgICAgICAvLyB4IHZhbHVlXG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgZm9ybWF0OiAnZGQgTU1NJyxcbiAgICAgICAgICAgIC8vIGRkL01NLCBkZCBNTU0geXksIGRkIE1NTSB5eXl5XG4gICAgICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCAvLyBhIGN1c3RvbSB1c2VyIHN1cHBsaWVkIGZvcm1hdHRlciBmdW5jdGlvblxuXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5OiB7XG4gICAgICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHNlcmllc05hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzTmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgejoge1xuICAgICAgICAgICAgZm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aXRsZTogJ1NpemU6ICdcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZml4ZWQ6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcG9zaXRpb246ICd0b3BSaWdodCcsXG4gICAgICAgICAgICAvLyB0b3BSaWdodCwgdG9wTGVmdCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnRcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB4YXhpczoge1xuICAgICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICAgICAgY2F0ZWdvcmllczogW10sXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIHJvdGF0ZTogLTQ1LFxuICAgICAgICAgICAgcm90YXRlQWx3YXlzOiBmYWxzZSxcbiAgICAgICAgICAgIGhpZGVPdmVybGFwcGluZ0xhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgIHRyaW06IHRydWUsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1heEhlaWdodDogMTIwLFxuICAgICAgICAgICAgc2hvd0R1cGxpY2F0ZXM6IHRydWUsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBjb2xvcnM6IFtdLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGNzc0NsYXNzOiAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgZm9ybWF0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIGN1c3RvbSBmb3JtYXR0ZXIgZnVuY3Rpb24gd2hpY2ggd2lsbCBvdmVycmlkZSBmb3JtYXRcbiAgICAgICAgICAgIGRhdGV0aW1lRm9ybWF0dGVyOiB7XG4gICAgICAgICAgICAgIHllYXI6ICd5eXl5JyxcbiAgICAgICAgICAgICAgbW9udGg6IFwiTU1NICd5eVwiLFxuICAgICAgICAgICAgICBkYXk6ICdkZCBNTU0nLFxuICAgICAgICAgICAgICBob3VyOiAnSEg6bW0nLFxuICAgICAgICAgICAgICBtaW51dGU6ICdISDptbTpzcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGF4aXNCb3JkZXI6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBjb2xvcjogJyM3ODkwOUMnLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgICBvZmZzZXRZOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBheGlzVGlja3M6IHtcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBjb2xvcjogJyM3ODkwOUMnLFxuICAgICAgICAgICAgaGVpZ2h0OiA2LFxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tBbW91bnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB0aWNrUGxhY2VtZW50OiAnb24nLFxuICAgICAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgICAgIG1heDogdW5kZWZpbmVkLFxuICAgICAgICAgIHJhbmdlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZmxvYXRpbmc6IGZhbHNlLFxuICAgICAgICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcbiAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgICBmb250RmFtaWx5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGNzc0NsYXNzOiAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3Jvc3NoYWlyczoge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgLy8gdGlja1dpZHRoL2JhcldpZHRoIG9yIGFuIGludGVnZXJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYmFjaycsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjksXG4gICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgY29sb3I6ICcjYjZiNmI2JyxcbiAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgIGRhc2hBcnJheTogM1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NvbGlkJyxcbiAgICAgICAgICAgICAgLy8gc29saWQsIGdyYWRpZW50XG4gICAgICAgICAgICAgIGNvbG9yOiAnI0IxQjlDNCcsXG4gICAgICAgICAgICAgIGdyYWRpZW50OiB7XG4gICAgICAgICAgICAgICAgY29sb3JGcm9tOiAnI0Q4RTNGMCcsXG4gICAgICAgICAgICAgICAgY29sb3JUbzogJyNCRUQxRTYnLFxuICAgICAgICAgICAgICAgIHN0b3BzOiBbMCwgMTAwXSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5RnJvbTogMC40LFxuICAgICAgICAgICAgICAgIG9wYWNpdHlUbzogMC41XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcm9wU2hhZG93OiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgIGJsdXI6IDEsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuNFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeWF4aXM6IHRoaXMueUF4aXMsXG4gICAgICAgIHRoZW1lOiB7XG4gICAgICAgICAgcGFsZXR0ZTogJ3BhbGV0dGUxJyxcbiAgICAgICAgICAvLyBJZiBkZWZpbmVkLCBpdCB3aWxsIG92ZXJ3cml0ZSBnbG9iYWxzLmNvbG9ycyB2YXJpYWJsZVxuICAgICAgICAgIG1vbm9jaHJvbWU6IHtcbiAgICAgICAgICAgIC8vIG1vbm9jaHJvbWUgYWxsb3dzIHlvdSB0byBzZWxlY3QganVzdCAxIGNvbG9yIGFuZCBmaWxsIG91dCB0aGUgcmVzdCB3aXRoIGxpZ2h0L2Rhcmsgc2hhZGUgKGludGVuc2l0eSBjYW4gYmUgc2VsZWN0ZWQpXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbG9yOiAnIzAwOEZGQicsXG4gICAgICAgICAgICBzaGFkZVRvOiAnbGlnaHQnLFxuICAgICAgICAgICAgc2hhZGVJbnRlbnNpdHk6IDAuNjVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9wdGlvbnM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBBbm5vdGF0aW9ucyBDbGFzcyBmb3IgZHJhd2luZyBsaW5lcy9yZWN0cyBvbiBib3RoIHhheGlzIGFuZCB5YXhpcy5cbiAqXG4gKiBAbW9kdWxlIEFubm90YXRpb25zXG4gKiovXG5cbnZhciBBbm5vdGF0aW9ucyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb25zKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbm5vdGF0aW9ucyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcblxuICAgIGlmICh0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIHRoaXMudy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwpIHtcbiAgICAgIHRoaXMuaW52ZXJ0QXhpcyA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy54RGl2aXNpb24gPSB0aGlzLncuZ2xvYmFscy5ncmlkV2lkdGggLyB0aGlzLncuZ2xvYmFscy5kYXRhUG9pbnRzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFubm90YXRpb25zLCBbe1xuICAgIGtleTogXCJkcmF3QW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0Fubm90YXRpb25zKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICB2YXIgeUFubm90YXRpb25zID0gdGhpcy5kcmF3WUF4aXNBbm5vdGF0aW9ucygpO1xuICAgICAgICB2YXIgeEFubm90YXRpb25zID0gdGhpcy5kcmF3WEF4aXNBbm5vdGF0aW9ucygpO1xuICAgICAgICB2YXIgcG9pbnRBbm5vdGF0aW9ucyA9IHRoaXMuZHJhd1BvaW50QW5ub3RhdGlvbnMoKTtcbiAgICAgICAgdmFyIGluaXRpYWxBbmltID0gdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkO1xuICAgICAgICB2YXIgYW5ub0FycmF5ID0gW3lBbm5vdGF0aW9ucywgeEFubm90YXRpb25zLCBwb2ludEFubm90YXRpb25zXTtcbiAgICAgICAgdmFyIGFubm9FbEFycmF5ID0gW3hBbm5vdGF0aW9ucy5ub2RlLCB5QW5ub3RhdGlvbnMubm9kZSwgcG9pbnRBbm5vdGF0aW9ucy5ub2RlXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKGFubm9BcnJheVtpXSk7XG5cbiAgICAgICAgICBpZiAoaW5pdGlhbEFuaW0gJiYgIXcuZ2xvYmFscy5yZXNpemVkICYmICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGFubm9FbEFycmF5W2ldLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy5kZWxheWVkRWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBlbDogYW5ub0VsQXJyYXlbaV0sXG4gICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIGFmdGVyIHBsYWNpbmcgdGhlIGFubm90YXRpb25zIG9uIHN2Zywgc2V0IGFueSB2ZXJ0aWNhbGx5IHBsYWNlZCBhbm5vdGF0aW9uc1xuXG5cbiAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbnMody5jb25maWcuYW5ub3RhdGlvbnMueGF4aXMpOyAvLyBiYWNrZ3JvdW5kIHNpemVzIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgYWZ0ZXIgdGV4dCBpcyBkcmF3biwgc28gY2FsbGluZyB0aGVtIGxhc3RcblxuICAgICAgICB0aGlzLmFubm90YXRpb25zQmFja2dyb3VuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRYYXhpc0Fubm90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWGF4aXNBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG1pbiA9IHRoaXMuaW52ZXJ0QXhpcyA/IHcuZ2xvYmFscy5taW5ZIDogdy5nbG9iYWxzLm1pblg7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmludmVydEF4aXMgPyB3Lmdsb2JhbHMueVJhbmdlWzBdIDogdy5nbG9iYWxzLnhSYW5nZTtcbiAgICAgIHZhciB4MSA9IChhbm5vLnggLSBtaW4pIC8gKHJhbmdlIC8gdy5nbG9iYWxzLmdyaWRXaWR0aCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50eXBlID09PSAnY2F0ZWdvcnknIHx8IHcuY29uZmlnLnhheGlzLmNvbnZlcnRlZENhdFRvTnVtZXJpYykge1xuICAgICAgICB2YXIgY2F0SW5kZXggPSB3Lmdsb2JhbHMubGFiZWxzLmluZGV4T2YoYW5uby54KTtcbiAgICAgICAgdmFyIHhMYWJlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXhheGlzLXRleHRzLWcgdGV4dDpudGgtY2hpbGQoJyArIChjYXRJbmRleCArIDEpICsgJyknKTtcblxuICAgICAgICBpZiAoeExhYmVsKSB7XG4gICAgICAgICAgeDEgPSBwYXJzZUZsb2F0KHhMYWJlbC5nZXRBdHRyaWJ1dGUoJ3gnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0cm9rZURhc2hBcnJheSA9IGFubm8uc3Ryb2tlRGFzaEFycmF5O1xuICAgICAgaWYgKHgxIDwgMCB8fCB4MSA+IHcuZ2xvYmFscy5ncmlkV2lkdGgpIHJldHVybjtcblxuICAgICAgaWYgKGFubm8ueDIgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdyYXBoaWNzLmRyYXdMaW5lKHgxICsgYW5uby5vZmZzZXRYLCAvLyB4MVxuICAgICAgICAwICsgYW5uby5vZmZzZXRZLCAvLyB5MVxuICAgICAgICB4MSArIGFubm8ub2Zmc2V0WCwgLy8geDJcbiAgICAgICAgdy5nbG9iYWxzLmdyaWRIZWlnaHQgKyBhbm5vLm9mZnNldFksIC8vIHkyXG4gICAgICAgIGFubm8uYm9yZGVyQ29sb3IsIC8vIGxpbmVDb2xvclxuICAgICAgICBzdHJva2VEYXNoQXJyYXkgLy9kYXNoQXJyYXlcbiAgICAgICAgKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxpbmUubm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeDIgPSAoYW5uby54MiAtIG1pbikgLyAocmFuZ2UgLyB3Lmdsb2JhbHMuZ3JpZFdpZHRoKTtcblxuICAgICAgICBpZiAoeDIgPCB4MSkge1xuICAgICAgICAgIHZhciB0ZW1wID0geDE7XG4gICAgICAgICAgeDEgPSB4MjtcbiAgICAgICAgICB4MiA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QoeDEgKyBhbm5vLm9mZnNldFgsIC8vIHgxXG4gICAgICAgIDAgKyBhbm5vLm9mZnNldFksIC8vIHkxXG4gICAgICAgIHgyIC0geDEsIC8vIHgyXG4gICAgICAgIHcuZ2xvYmFscy5ncmlkSGVpZ2h0ICsgYW5uby5vZmZzZXRZLCAvLyB5MlxuICAgICAgICAwLCAvLyByYWRpdXNcbiAgICAgICAgYW5uby5maWxsQ29sb3IsIC8vIGNvbG9yXG4gICAgICAgIGFubm8ub3BhY2l0eSwgLy8gb3BhY2l0eSxcbiAgICAgICAgMSwgLy8gc3Ryb2tlV2lkdGhcbiAgICAgICAgYW5uby5ib3JkZXJDb2xvciwgLy8gc3Ryb2tlQ29sb3JcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5IC8vIHN0b2tlRGFzaEFycmF5XG4gICAgICAgICk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZWN0Lm5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dFkgPSBhbm5vLmxhYmVsLnBvc2l0aW9uID09PSAndG9wJyA/IC0zIDogdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG4gICAgICB2YXIgdGV4dCA9IGFubm8ubGFiZWwudGV4dCA/IGFubm8ubGFiZWwudGV4dCA6ICcnO1xuICAgICAgdmFyIGVsVGV4dCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICB4OiB4MSArIGFubm8ubGFiZWwub2Zmc2V0WCxcbiAgICAgICAgeTogdGV4dFkgKyBhbm5vLmxhYmVsLm9mZnNldFksXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHRleHRBbmNob3I6IGFubm8ubGFiZWwudGV4dEFuY2hvcixcbiAgICAgICAgZm9udFNpemU6IGFubm8ubGFiZWwuc3R5bGUuZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHk6IGFubm8ubGFiZWwuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgZm9yZUNvbG9yOiBhbm5vLmxhYmVsLnN0eWxlLmNvbG9yLFxuICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteGF4aXMtYW5ub3RhdGlvbi1sYWJlbCAnICsgYW5uby5sYWJlbC5zdHlsZS5jc3NDbGFzc1xuICAgICAgfSk7XG4gICAgICBlbFRleHQuYXR0cih7XG4gICAgICAgIHJlbDogaW5kZXhcbiAgICAgIH0pO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsVGV4dC5ub2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1hBeGlzQW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1hBeGlzQW5ub3RhdGlvbnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBlbGcgPSB0aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLWFubm90YXRpb25zJ1xuICAgICAgfSk7XG4gICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy54YXhpcy5tYXAoZnVuY3Rpb24gKGFubm8sIGluZGV4KSB7XG4gICAgICAgIF90aGlzLmFkZFhheGlzQW5ub3RhdGlvbihhbm5vLCBlbGcubm9kZSwgaW5kZXgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRZYXhpc0Fubm90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWWF4aXNBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHN0cm9rZURhc2hBcnJheSA9IGFubm8uc3Ryb2tlRGFzaEFycmF5O1xuICAgICAgdmFyIHkxO1xuICAgICAgdmFyIHkyO1xuXG4gICAgICBpZiAodGhpcy5pbnZlcnRBeGlzKSB7XG4gICAgICAgIHZhciBjYXRJbmRleCA9IHcuZ2xvYmFscy5sYWJlbHMuaW5kZXhPZihhbm5vLnkpO1xuICAgICAgICB2YXIgeExhYmVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteWF4aXMtdGV4dHMtZyB0ZXh0Om50aC1jaGlsZCgnICsgKGNhdEluZGV4ICsgMSkgKyAnKScpO1xuXG4gICAgICAgIGlmICh4TGFiZWwpIHtcbiAgICAgICAgICB5MSA9IHBhcnNlRmxvYXQoeExhYmVsLmdldEF0dHJpYnV0ZSgneScpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIChhbm5vLnkgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW2Fubm8ueUF4aXNJbmRleF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgICB5MSA9IChhbm5vLnkgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSBhbm5vLmxhYmVsLnRleHQgPyBhbm5vLmxhYmVsLnRleHQgOiAnJztcblxuICAgICAgaWYgKGFubm8ueTIgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdyYXBoaWNzLmRyYXdMaW5lKDAgKyBhbm5vLm9mZnNldFgsIC8vIHgxXG4gICAgICAgIHkxICsgYW5uby5vZmZzZXRZLCAvLyB5MVxuICAgICAgICB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgYW5uby5vZmZzZXRYLCAvLyB4MlxuICAgICAgICB5MSArIGFubm8ub2Zmc2V0WSwgLy8geTJcbiAgICAgICAgYW5uby5ib3JkZXJDb2xvciwgLy8gbGluZUNvbG9yXG4gICAgICAgIHN0cm9rZURhc2hBcnJheSAvLyBkYXNoQXJyYXlcbiAgICAgICAgKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxpbmUubm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pbnZlcnRBeGlzKSB7XG4gICAgICAgICAgdmFyIF9jYXRJbmRleCA9IHcuZ2xvYmFscy5sYWJlbHMuaW5kZXhPZihhbm5vLnkyKTtcblxuICAgICAgICAgIHZhciBfeExhYmVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteWF4aXMtdGV4dHMtZyB0ZXh0Om50aC1jaGlsZCgnICsgKF9jYXRJbmRleCArIDEpICsgJyknKTtcblxuICAgICAgICAgIGlmIChfeExhYmVsKSB7XG4gICAgICAgICAgICB5MiA9IHBhcnNlRmxvYXQoX3hMYWJlbC5nZXRBdHRyaWJ1dGUoJ3knKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkyID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLSAoYW5uby55MiAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1thbm5vLnlBeGlzSW5kZXhdLnJldmVyc2VkKSB7XG4gICAgICAgICAgICB5MiA9IChhbm5vLnkyIC0gdy5nbG9iYWxzLm1pbllBcnJbYW5uby55QXhpc0luZGV4XSkgLyAody5nbG9iYWxzLnlSYW5nZVthbm5vLnlBeGlzSW5kZXhdIC8gdy5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5MiA+IHkxKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSB5MTtcbiAgICAgICAgICB5MSA9IHkyO1xuICAgICAgICAgIHkyID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCgwICsgYW5uby5vZmZzZXRYLCAvLyB4MVxuICAgICAgICB5MiArIGFubm8ub2Zmc2V0WSwgLy8geTFcbiAgICAgICAgdy5nbG9iYWxzLmdyaWRXaWR0aCArIGFubm8ub2Zmc2V0WCwgLy8geDJcbiAgICAgICAgeTEgLSB5MiwgLy8geTJcbiAgICAgICAgMCwgLy8gcmFkaXVzXG4gICAgICAgIGFubm8uZmlsbENvbG9yLCAvLyBjb2xvclxuICAgICAgICBhbm5vLm9wYWNpdHksIC8vIG9wYWNpdHksXG4gICAgICAgIDEsIC8vIHN0cm9rZVdpZHRoXG4gICAgICAgIGFubm8uYm9yZGVyQ29sb3IsIC8vIHN0cm9rZUNvbG9yXG4gICAgICAgIHN0cm9rZURhc2hBcnJheSAvLyBzdG9rZURhc2hBcnJheVxuICAgICAgICApO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQocmVjdC5ub2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRleHRYID0gYW5uby5sYWJlbC5wb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/IHcuZ2xvYmFscy5ncmlkV2lkdGggOiAwO1xuICAgICAgdmFyIGVsVGV4dCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICB4OiB0ZXh0WCArIGFubm8ubGFiZWwub2Zmc2V0WCxcbiAgICAgICAgeTogKHkyIHx8IHkxKSArIGFubm8ubGFiZWwub2Zmc2V0WSAtIDMsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHRleHRBbmNob3I6IGFubm8ubGFiZWwudGV4dEFuY2hvcixcbiAgICAgICAgZm9udFNpemU6IGFubm8ubGFiZWwuc3R5bGUuZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHk6IGFubm8ubGFiZWwuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgZm9yZUNvbG9yOiBhbm5vLmxhYmVsLnN0eWxlLmNvbG9yLFxuICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtYW5ub3RhdGlvbi1sYWJlbCAnICsgYW5uby5sYWJlbC5zdHlsZS5jc3NDbGFzc1xuICAgICAgfSk7XG4gICAgICBlbFRleHQuYXR0cih7XG4gICAgICAgIHJlbDogaW5kZXhcbiAgICAgIH0pO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsVGV4dC5ub2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1lBeGlzQW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lBeGlzQW5ub3RhdGlvbnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZWxnID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy1hbm5vdGF0aW9ucydcbiAgICAgIH0pO1xuICAgICAgdy5jb25maWcuYW5ub3RhdGlvbnMueWF4aXMubWFwKGZ1bmN0aW9uIChhbm5vLCBpbmRleCkge1xuICAgICAgICBfdGhpczIuYWRkWWF4aXNBbm5vdGF0aW9uKGFubm8sIGVsZy5ub2RlLCBpbmRleCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJBbm5vdGF0aW9ucyhjdHgpIHtcbiAgICAgIHZhciB3ID0gY3R4Lnc7XG4gICAgICB2YXIgYW5ub3MgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy15YXhpcy1hbm5vdGF0aW9ucywgLmFwZXhjaGFydHMteGF4aXMtYW5ub3RhdGlvbnMsIC5hcGV4Y2hhcnRzLXBvaW50LWFubm90YXRpb25zJyk7XG4gICAgICBhbm5vcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHdoaWxlIChhLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRQb2ludEFubm90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUG9pbnRBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHkgPSAwO1xuICAgICAgdmFyIHBvaW50WSA9IDA7XG5cbiAgICAgIGlmICh0aGlzLmludmVydEF4aXMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQb2ludCBhbm5vdGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gaG9yaXpvbnRhbCBiYXIgY2hhcnRzLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGFubm8ueCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGNhdEluZGV4ID0gdy5nbG9iYWxzLmxhYmVscy5pbmRleE9mKGFubm8ueCk7XG4gICAgICAgIHZhciB4TGFiZWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nIHRleHQ6bnRoLWNoaWxkKCcgKyAoY2F0SW5kZXggKyAxKSArICcpJyk7XG4gICAgICAgIHZhciB4UG9zID0gcGFyc2VGbG9hdCh4TGFiZWwuZ2V0QXR0cmlidXRlKCd4JykpO1xuICAgICAgICB4ID0geFBvcztcbiAgICAgICAgdmFyIGFubm9ZID0gYW5uby55O1xuXG4gICAgICAgIGlmIChhbm5vLnkgPT09IG51bGwpIHtcbiAgICAgICAgICBhbm5vWSA9IHcuZ2xvYmFscy5zZXJpZXNbYW5uby5zZXJpZXNJbmRleF1bY2F0SW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgeSA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gKGFubm9ZIC0gdy5nbG9iYWxzLm1pbllBcnJbYW5uby55QXhpc0luZGV4XSkgLyAody5nbG9iYWxzLnlSYW5nZVthbm5vLnlBeGlzSW5kZXhdIC8gdy5nbG9iYWxzLmdyaWRIZWlnaHQpIC0gcGFyc2VJbnQoYW5uby5sYWJlbC5zdHlsZS5mb250U2l6ZSkgLSBhbm5vLm1hcmtlci5zaXplO1xuICAgICAgICBwb2ludFkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIChhbm5vWSAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbYW5uby55QXhpc0luZGV4XS5yZXZlcnNlZCkge1xuICAgICAgICAgIHkgPSAoYW5ub1kgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkgKyBwYXJzZUludChhbm5vLmxhYmVsLnN0eWxlLmZvbnRTaXplKSArIGFubm8ubWFya2VyLnNpemU7XG4gICAgICAgICAgcG9pbnRZID0gKGFubm9ZIC0gdy5nbG9iYWxzLm1pbllBcnJbYW5uby55QXhpc0luZGV4XSkgLyAody5nbG9iYWxzLnlSYW5nZVthbm5vLnlBeGlzSW5kZXhdIC8gdy5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gKGFubm8ueCAtIHcuZ2xvYmFscy5taW5YKSAvICh3Lmdsb2JhbHMueFJhbmdlIC8gdy5nbG9iYWxzLmdyaWRXaWR0aCk7XG4gICAgICAgIHkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIChwYXJzZUZsb2F0KGFubm8ueSkgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkgLSBwYXJzZUludChhbm5vLmxhYmVsLnN0eWxlLmZvbnRTaXplKSAtIGFubm8ubWFya2VyLnNpemU7XG4gICAgICAgIHBvaW50WSA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gKGFubm8ueSAtIHcuZ2xvYmFscy5taW5ZQXJyW2Fubm8ueUF4aXNJbmRleF0pIC8gKHcuZ2xvYmFscy55UmFuZ2VbYW5uby55QXhpc0luZGV4XSAvIHcuZ2xvYmFscy5ncmlkSGVpZ2h0KTtcblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbYW5uby55QXhpc0luZGV4XS5yZXZlcnNlZCkge1xuICAgICAgICAgIHkgPSAocGFyc2VGbG9hdChhbm5vLnkpIC0gdy5nbG9iYWxzLm1pbllBcnJbYW5uby55QXhpc0luZGV4XSkgLyAody5nbG9iYWxzLnlSYW5nZVthbm5vLnlBeGlzSW5kZXhdIC8gdy5nbG9iYWxzLmdyaWRIZWlnaHQpIC0gcGFyc2VJbnQoYW5uby5sYWJlbC5zdHlsZS5mb250U2l6ZSkgLSBhbm5vLm1hcmtlci5zaXplO1xuICAgICAgICAgIHBvaW50WSA9IChhbm5vLnkgLSB3Lmdsb2JhbHMubWluWUFyclthbm5vLnlBeGlzSW5kZXhdKSAvICh3Lmdsb2JhbHMueVJhbmdlW2Fubm8ueUF4aXNJbmRleF0gLyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHggPCAwIHx8IHggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSByZXR1cm47XG4gICAgICB2YXIgb3B0c1BvaW50cyA9IHtcbiAgICAgICAgcFNpemU6IGFubm8ubWFya2VyLnNpemUsXG4gICAgICAgIHBXaWR0aDogYW5uby5tYXJrZXIuc3Ryb2tlV2lkdGgsXG4gICAgICAgIHBvaW50RmlsbENvbG9yOiBhbm5vLm1hcmtlci5maWxsQ29sb3IsXG4gICAgICAgIHBvaW50U3Ryb2tlQ29sb3I6IGFubm8ubWFya2VyLnN0cm9rZUNvbG9yLFxuICAgICAgICBzaGFwZTogYW5uby5tYXJrZXIuc2hhcGUsXG4gICAgICAgIHJhZGl1czogYW5uby5tYXJrZXIucmFkaXVzLFxuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtcG9pbnQtYW5ub3RhdGlvbi1tYXJrZXIgJyArIGFubm8ubWFya2VyLmNzc0NsYXNzXG4gICAgICB9O1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5ncmFwaGljcy5kcmF3TWFya2VyKHggKyBhbm5vLm1hcmtlci5vZmZzZXRYLCBwb2ludFkgKyBhbm5vLm1hcmtlci5vZmZzZXRZLCBvcHRzUG9pbnRzKTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChwb2ludC5ub2RlKTtcbiAgICAgIHZhciB0ZXh0ID0gYW5uby5sYWJlbC50ZXh0ID8gYW5uby5sYWJlbC50ZXh0IDogJyc7XG4gICAgICB2YXIgZWxUZXh0ID0gdGhpcy5ncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgIHg6IHggKyBhbm5vLmxhYmVsLm9mZnNldFgsXG4gICAgICAgIHk6IHkgKyBhbm5vLmxhYmVsLm9mZnNldFksXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHRleHRBbmNob3I6IGFubm8ubGFiZWwudGV4dEFuY2hvcixcbiAgICAgICAgZm9udFNpemU6IGFubm8ubGFiZWwuc3R5bGUuZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHk6IGFubm8ubGFiZWwuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgZm9yZUNvbG9yOiBhbm5vLmxhYmVsLnN0eWxlLmNvbG9yLFxuICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMtcG9pbnQtYW5ub3RhdGlvbi1sYWJlbCAnICsgYW5uby5sYWJlbC5zdHlsZS5jc3NDbGFzc1xuICAgICAgfSk7XG4gICAgICBlbFRleHQuYXR0cih7XG4gICAgICAgIHJlbDogaW5kZXhcbiAgICAgIH0pO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsVGV4dC5ub2RlKTtcblxuICAgICAgaWYgKGFubm8uY3VzdG9tU1ZHLlNWRykge1xuICAgICAgICB2YXIgZyA9IHRoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1wb2ludC1hbm5vdGF0aW9ucy1jdXN0b20tc3ZnICcgKyBhbm5vLmN1c3RvbVNWRy5jc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgICAgZy5hdHRyKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh4ICsgYW5uby5jdXN0b21TVkcub2Zmc2V0WCwgXCIsIFwiKS5jb25jYXQoeSArIGFubm8uY3VzdG9tU1ZHLm9mZnNldFksIFwiKVwiKVxuICAgICAgICB9KTtcbiAgICAgICAgZy5ub2RlLmlubmVySFRNTCA9IGFubm8uY3VzdG9tU1ZHLlNWRztcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGcubm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdQb2ludEFubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQb2ludEFubm90YXRpb25zKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGVsZyA9IHRoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtcG9pbnQtYW5ub3RhdGlvbnMnXG4gICAgICB9KTtcbiAgICAgIHcuY29uZmlnLmFubm90YXRpb25zLnBvaW50cy5tYXAoZnVuY3Rpb24gKGFubm8sIGluZGV4KSB7XG4gICAgICAgIF90aGlzMy5hZGRQb2ludEFubm90YXRpb24oYW5ubywgZWxnLm5vZGUsIGluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVsZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3JpZW50YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWVudGF0aW9ucyhhbm5vcykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBhbm5vSW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIGFubm9zLm1hcChmdW5jdGlvbiAoYW5ubywgaW5kZXgpIHtcbiAgICAgICAgaWYgKGFubm8ubGFiZWwub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICB2YXIgaSA9IGFubm9JbmRleCAhPT0gbnVsbCA/IGFubm9JbmRleCA6IGluZGV4O1xuICAgICAgICAgIHZhciB4QW5ubyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy14YXhpcy1hbm5vdGF0aW9ucyAuYXBleGNoYXJ0cy14YXhpcy1hbm5vdGF0aW9uLWxhYmVsW3JlbD0nXCIuY29uY2F0KGksIFwiJ11cIikpO1xuXG4gICAgICAgICAgaWYgKHhBbm5vICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgeEFubm9Db29yZCA9IHhBbm5vLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgeEFubm8uc2V0QXR0cmlidXRlKCd4JywgcGFyc2VGbG9hdCh4QW5uby5nZXRBdHRyaWJ1dGUoJ3gnKSkgLSB4QW5ub0Nvb3JkLmhlaWdodCArIDQpO1xuXG4gICAgICAgICAgICBpZiAoYW5uby5sYWJlbC5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgeEFubm8uc2V0QXR0cmlidXRlKCd5JywgcGFyc2VGbG9hdCh4QW5uby5nZXRBdHRyaWJ1dGUoJ3knKSkgKyB4QW5ub0Nvb3JkLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHhBbm5vLnNldEF0dHJpYnV0ZSgneScsIHBhcnNlRmxvYXQoeEFubm8uZ2V0QXR0cmlidXRlKCd5JykpIC0geEFubm9Db29yZC53aWR0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbm5vUm90YXRpbmdDZW50ZXIgPSBfdGhpczQuZ3JhcGhpY3Mucm90YXRlQXJvdW5kQ2VudGVyKHhBbm5vKTtcblxuICAgICAgICAgICAgdmFyIHggPSBhbm5vUm90YXRpbmdDZW50ZXIueDtcbiAgICAgICAgICAgIHZhciB5ID0gYW5ub1JvdGF0aW5nQ2VudGVyLnk7XG4gICAgICAgICAgICB4QW5uby5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwicm90YXRlKC05MCBcIi5jb25jYXQoeCwgXCIgXCIpLmNvbmNhdCh5LCBcIilcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEJhY2tncm91bmRUb0Fubm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQmFja2dyb3VuZFRvQW5ubyhhbm5vRWwsIGFubm8pIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGVsR3JpZFJlY3QgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1ncmlkJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgY29vcmRzID0gYW5ub0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHBsZWZ0ID0gYW5uby5sYWJlbC5zdHlsZS5wYWRkaW5nLmxlZnQ7XG4gICAgICB2YXIgcHJpZ2h0ID0gYW5uby5sYWJlbC5zdHlsZS5wYWRkaW5nLnJpZ2h0O1xuICAgICAgdmFyIHB0b3AgPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcudG9wO1xuICAgICAgdmFyIHBib3R0b20gPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcuYm90dG9tO1xuXG4gICAgICBpZiAoYW5uby5sYWJlbC5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBwdG9wID0gYW5uby5sYWJlbC5zdHlsZS5wYWRkaW5nLmxlZnQ7XG4gICAgICAgIHBib3R0b20gPSBhbm5vLmxhYmVsLnN0eWxlLnBhZGRpbmcucmlnaHQ7XG4gICAgICAgIHBsZWZ0ID0gYW5uby5sYWJlbC5zdHlsZS5wYWRkaW5nLnRvcDtcbiAgICAgICAgcHJpZ2h0ID0gYW5uby5sYWJlbC5zdHlsZS5wYWRkaW5nLmJvdHRvbTtcbiAgICAgIH1cblxuICAgICAgdmFyIHgxID0gY29vcmRzLmxlZnQgLSBlbEdyaWRSZWN0LmxlZnQgLSBwbGVmdDtcbiAgICAgIHZhciB5MSA9IGNvb3Jkcy50b3AgLSBlbEdyaWRSZWN0LnRvcCAtIHB0b3A7XG4gICAgICB2YXIgZWxSZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCh4MSwgeTEsIGNvb3Jkcy53aWR0aCArIHBsZWZ0ICsgcHJpZ2h0LCBjb29yZHMuaGVpZ2h0ICsgcHRvcCArIHBib3R0b20sIDAsIGFubm8ubGFiZWwuc3R5bGUuYmFja2dyb3VuZCwgMSwgYW5uby5sYWJlbC5ib3JkZXJXaWR0aCwgYW5uby5sYWJlbC5ib3JkZXJDb2xvciwgMCk7XG4gICAgICByZXR1cm4gZWxSZWN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbm5vdGF0aW9uc0JhY2tncm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5ub3RhdGlvbnNCYWNrZ3JvdW5kKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKGFubm8sIGksIHR5cGUpIHtcbiAgICAgICAgdmFyIGFubm9MYWJlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItYW5ub3RhdGlvbnMgLmFwZXhjaGFydHMtXCIpLmNvbmNhdCh0eXBlLCBcIi1hbm5vdGF0aW9uLWxhYmVsW3JlbD0nXCIpLmNvbmNhdChpLCBcIiddXCIpKTtcblxuICAgICAgICBpZiAoYW5ub0xhYmVsKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IGFubm9MYWJlbC5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgdmFyIGVsUmVjdCA9IF90aGlzNS5hZGRCYWNrZ3JvdW5kVG9Bbm5vKGFubm9MYWJlbCwgYW5ubyk7XG5cbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsUmVjdC5ub2RlLCBhbm5vTGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy54YXhpcy5tYXAoZnVuY3Rpb24gKGFubm8sIGkpIHtcbiAgICAgICAgYWRkKGFubm8sIGksICd4YXhpcycpO1xuICAgICAgfSk7XG4gICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy55YXhpcy5tYXAoZnVuY3Rpb24gKGFubm8sIGkpIHtcbiAgICAgICAgYWRkKGFubm8sIGksICd5YXhpcycpO1xuICAgICAgfSk7XG4gICAgICB3LmNvbmZpZy5hbm5vdGF0aW9ucy5wb2ludHMubWFwKGZ1bmN0aW9uIChhbm5vLCBpKSB7XG4gICAgICAgIGFkZChhbm5vLCBpLCAncG9pbnQnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRleHQocGFyYW1zLCBwdXNoVG9NZW1vcnksIGNvbnRleHQpIHtcbiAgICAgIHZhciB4ID0gcGFyYW1zLngsXG4gICAgICAgICAgeSA9IHBhcmFtcy55LFxuICAgICAgICAgIHRleHQgPSBwYXJhbXMudGV4dCxcbiAgICAgICAgICB0ZXh0QW5jaG9yID0gcGFyYW1zLnRleHRBbmNob3IsXG4gICAgICAgICAgX3BhcmFtcyRhcHBlbmRUbyA9IHBhcmFtcy5hcHBlbmRUbyxcbiAgICAgICAgICBhcHBlbmRUbyA9IF9wYXJhbXMkYXBwZW5kVG8gPT09IHZvaWQgMCA/ICcuYXBleGNoYXJ0cy1pbm5lcicgOiBfcGFyYW1zJGFwcGVuZFRvLFxuICAgICAgICAgIGZvcmVDb2xvciA9IHBhcmFtcy5mb3JlQ29sb3IsXG4gICAgICAgICAgZm9udFNpemUgPSBwYXJhbXMuZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseSA9IHBhcmFtcy5mb250RmFtaWx5LFxuICAgICAgICAgIGNzc0NsYXNzID0gcGFyYW1zLmNzc0NsYXNzLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IHBhcmFtcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgYm9yZGVyV2lkdGggPSBwYXJhbXMuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5ID0gcGFyYW1zLnN0cm9rZURhc2hBcnJheSxcbiAgICAgICAgICByYWRpdXMgPSBwYXJhbXMucmFkaXVzLFxuICAgICAgICAgIGJvcmRlckNvbG9yID0gcGFyYW1zLmJvcmRlckNvbG9yLFxuICAgICAgICAgIF9wYXJhbXMkcGFkZGluZ0xlZnQgPSBwYXJhbXMucGFkZGluZ0xlZnQsXG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBfcGFyYW1zJHBhZGRpbmdMZWZ0ID09PSB2b2lkIDAgPyA0IDogX3BhcmFtcyRwYWRkaW5nTGVmdCxcbiAgICAgICAgICBfcGFyYW1zJHBhZGRpbmdSaWdodCA9IHBhcmFtcy5wYWRkaW5nUmlnaHQsXG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gX3BhcmFtcyRwYWRkaW5nUmlnaHQgPT09IHZvaWQgMCA/IDQgOiBfcGFyYW1zJHBhZGRpbmdSaWdodCxcbiAgICAgICAgICBfcGFyYW1zJHBhZGRpbmdCb3R0b20gPSBwYXJhbXMucGFkZGluZ0JvdHRvbSxcbiAgICAgICAgICBwYWRkaW5nQm90dG9tID0gX3BhcmFtcyRwYWRkaW5nQm90dG9tID09PSB2b2lkIDAgPyAyIDogX3BhcmFtcyRwYWRkaW5nQm90dG9tLFxuICAgICAgICAgIF9wYXJhbXMkcGFkZGluZ1RvcCA9IHBhcmFtcy5wYWRkaW5nVG9wLFxuICAgICAgICAgIHBhZGRpbmdUb3AgPSBfcGFyYW1zJHBhZGRpbmdUb3AgPT09IHZvaWQgMCA/IDIgOiBfcGFyYW1zJHBhZGRpbmdUb3A7XG4gICAgICB2YXIgbWUgPSBjb250ZXh0O1xuICAgICAgdmFyIHcgPSBtZS53O1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKGFwcGVuZFRvKTtcbiAgICAgIHZhciBlbFRleHQgPSB0aGlzLmdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvciB8fCAnc3RhcnQnLFxuICAgICAgICBmb250U2l6ZTogZm9udFNpemUgfHwgJzEycHgnLFxuICAgICAgICBmb250RmFtaWx5OiBmb250RmFtaWx5IHx8IHcuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHksXG4gICAgICAgIGZvcmVDb2xvcjogZm9yZUNvbG9yIHx8IHcuY29uZmlnLmNoYXJ0LmZvcmVDb2xvcixcbiAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXRleHQgJyArIGNzc0NsYXNzID8gY3NzQ2xhc3MgOiAnJ1xuICAgICAgfSk7XG4gICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsVGV4dC5ub2RlKTtcbiAgICAgIHZhciB0ZXh0UmVjdCA9IGVsVGV4dC5iYm94KCk7XG4gICAgICB2YXIgZWxSZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCh0ZXh0UmVjdC54IC0gcGFkZGluZ0xlZnQsIHRleHRSZWN0LnkgLSBwYWRkaW5nVG9wLCB0ZXh0UmVjdC53aWR0aCArIHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0LCB0ZXh0UmVjdC5oZWlnaHQgKyBwYWRkaW5nQm90dG9tICsgcGFkZGluZ1RvcCwgcmFkaXVzLCBiYWNrZ3JvdW5kQ29sb3IsIDEsIGJvcmRlcldpZHRoLCBib3JkZXJDb2xvciwgc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGVsVGV4dC5iZWZvcmUoZWxSZWN0KTtcblxuICAgICAgaWYgKHB1c2hUb01lbW9yeSkge1xuICAgICAgICB3Lmdsb2JhbHMubWVtb3J5Lm1ldGhvZHNUb0V4ZWMucHVzaCh7XG4gICAgICAgICAgY29udGV4dDogbWUsXG4gICAgICAgICAgbWV0aG9kOiBtZS5hZGRUZXh0LFxuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvcixcbiAgICAgICAgICAgIGFwcGVuZFRvOiBhcHBlbmRUbyxcbiAgICAgICAgICAgIGZvcmVDb2xvcjogZm9yZUNvbG9yLFxuICAgICAgICAgICAgZm9udFNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgY3NzQ2xhc3M6IGNzc0NsYXNzLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICBzdHJva2VEYXNoQXJyYXk6IHN0cm9rZURhc2hBcnJheSxcbiAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IHBhZGRpbmdMZWZ0LFxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiBwYWRkaW5nQm90dG9tLFxuICAgICAgICAgICAgcGFkZGluZ1RvcDogcGFkZGluZ1RvcFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRQb2ludEFubm90YXRpb25FeHRlcm5hbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQb2ludEFubm90YXRpb25FeHRlcm5hbChwYXJhbXMsIHB1c2hUb01lbW9yeSwgY29udGV4dCkge1xuICAgICAgdGhpcy5hZGRBbm5vdGF0aW9uRXh0ZXJuYWwoe1xuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgcHVzaFRvTWVtb3J5OiBwdXNoVG9NZW1vcnksXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHR5cGU6ICdwb2ludCcsXG4gICAgICAgIGNvbnRleHRNZXRob2Q6IGNvbnRleHQuYWRkUG9pbnRBbm5vdGF0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRZYXhpc0Fubm90YXRpb25FeHRlcm5hbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRZYXhpc0Fubm90YXRpb25FeHRlcm5hbChwYXJhbXMsIHB1c2hUb01lbW9yeSwgY29udGV4dCkge1xuICAgICAgdGhpcy5hZGRBbm5vdGF0aW9uRXh0ZXJuYWwoe1xuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgcHVzaFRvTWVtb3J5OiBwdXNoVG9NZW1vcnksXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHR5cGU6ICd5YXhpcycsXG4gICAgICAgIGNvbnRleHRNZXRob2Q6IGNvbnRleHQuYWRkWWF4aXNBbm5vdGF0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH0gLy8gVGhlIGFkZFhheGlzQW5ub3RhdGlvbiBtZXRob2QgcmVxdWlyZXMgYSBwYXJlbnQgY2xhc3MsIGFuZCB1c2VyIGNhbGxpbmcgdGhpcyBtZXRob2QgZXh0ZXJuYWxseSBvbiB0aGUgY2hhcnQgaW5zdGFuY2UgbWF5IG5vdCBzcGVjaWZ5IHBhcmVudCwgaGVuY2UgYSBkaWZmZXJlbnQgbWV0aG9kXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRYYXhpc0Fubm90YXRpb25FeHRlcm5hbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRYYXhpc0Fubm90YXRpb25FeHRlcm5hbChwYXJhbXMsIHB1c2hUb01lbW9yeSwgY29udGV4dCkge1xuICAgICAgdGhpcy5hZGRBbm5vdGF0aW9uRXh0ZXJuYWwoe1xuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgcHVzaFRvTWVtb3J5OiBwdXNoVG9NZW1vcnksXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIHR5cGU6ICd4YXhpcycsXG4gICAgICAgIGNvbnRleHRNZXRob2Q6IGNvbnRleHQuYWRkWGF4aXNBbm5vdGF0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRBbm5vdGF0aW9uRXh0ZXJuYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQW5ub3RhdGlvbkV4dGVybmFsKF9yZWYpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBfcmVmLnBhcmFtcyxcbiAgICAgICAgICBwdXNoVG9NZW1vcnkgPSBfcmVmLnB1c2hUb01lbW9yeSxcbiAgICAgICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgICAgIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgICAgY29udGV4dE1ldGhvZCA9IF9yZWYuY29udGV4dE1ldGhvZDtcbiAgICAgIHZhciBtZSA9IGNvbnRleHQ7XG4gICAgICB2YXIgdyA9IG1lLnc7XG4gICAgICB2YXIgcGFyZW50ID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlLCBcIi1hbm5vdGF0aW9uc1wiKSk7XG4gICAgICB2YXIgaW5kZXggPSBwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggKyAxO1xuICAgICAgdmFyIG9wdCA9IG5ldyBPcHRpb25zKCk7XG4gICAgICB2YXIgYXhlc0Fubm8gPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlID09PSAneGF4aXMnID8gb3B0LnhBeGlzQW5ub3RhdGlvbiA6IHR5cGUgPT09ICd5YXhpcycgPyBvcHQueUF4aXNBbm5vdGF0aW9uIDogb3B0LnBvaW50QW5ub3RhdGlvbik7XG4gICAgICB2YXIgYW5ubyA9IFV0aWxzLmV4dGVuZChheGVzQW5ubywgcGFyYW1zKTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3hheGlzJzpcbiAgICAgICAgICB0aGlzLmFkZFhheGlzQW5ub3RhdGlvbihhbm5vLCBwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd5YXhpcyc6XG4gICAgICAgICAgdGhpcy5hZGRZYXhpc0Fubm90YXRpb24oYW5ubywgcGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncG9pbnQnOlxuICAgICAgICAgIHRoaXMuYWRkUG9pbnRBbm5vdGF0aW9uKGFubm8sIHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBhZGQgYmFja2dyb3VuZFxuXG5cbiAgICAgIHZhciBheGVzQW5ub0xhYmVsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLVwiLmNvbmNhdCh0eXBlLCBcIi1hbm5vdGF0aW9ucyAuYXBleGNoYXJ0cy1cIikuY29uY2F0KHR5cGUsIFwiLWFubm90YXRpb24tbGFiZWxbcmVsPSdcIikuY29uY2F0KGluZGV4LCBcIiddXCIpKTtcbiAgICAgIHZhciBlbFJlY3QgPSB0aGlzLmFkZEJhY2tncm91bmRUb0Fubm8oYXhlc0Fubm9MYWJlbCwgYW5ubyk7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsUmVjdC5ub2RlLCBheGVzQW5ub0xhYmVsKTtcblxuICAgICAgaWYgKHB1c2hUb01lbW9yeSkge1xuICAgICAgICB3Lmdsb2JhbHMubWVtb3J5Lm1ldGhvZHNUb0V4ZWMucHVzaCh7XG4gICAgICAgICAgY29udGV4dDogbWUsXG4gICAgICAgICAgbWV0aG9kOiBjb250ZXh0TWV0aG9kLFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQW5ub3RhdGlvbnM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBEZWZhdWx0IENsYXNzIGZvciBzZXR0aW5nIGRlZmF1bHQgb3B0aW9ucyBmb3IgYWxsIGNoYXJ0IHR5cGVzLlxuICpcbiAqIEBtb2R1bGUgRGVmYXVsdHNcbiAqKi9cblxudmFyIERlZmF1bHRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGVmYXVsdHMob3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWZhdWx0cyk7XG5cbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERlZmF1bHRzLCBbe1xuICAgIGtleTogXCJsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIGVhc2luZzogJ3N3aW5nJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIHdpZHRoOiA1LFxuICAgICAgICAgIGN1cnZlOiAnc3RyYWlnaHQnXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBzaXplT2Zmc2V0OiA2XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB4YXhpczoge1xuICAgICAgICAgIGNyb3NzaGFpcnM6IHtcbiAgICAgICAgICAgIHdpZHRoOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzcGFya2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BhcmtsaW5lKGRlZmF1bHRzKSB7XG4gICAgICB0aGlzLm9wdHMueWF4aXNbMF0ubGFiZWxzLnNob3cgPSBmYWxzZTtcbiAgICAgIHRoaXMub3B0cy55YXhpc1swXS5mbG9hdGluZyA9IHRydWU7XG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB4YXhpczoge1xuICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBheGlzQm9yZGVyOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgem9vbToge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZChkZWZhdWx0cywgcmV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhcigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgc3RhY2tlZDogZmFsc2UsXG4gICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgZWFzaW5nOiAnc3dpbmcnXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwbG90T3B0aW9uczoge1xuICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2NlbnRlcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3JzOiBbJyNmZmYnXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIG9wYWNpdHk6IDAuODVcbiAgICAgICAgfSxcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgICAgc2hhcGU6ICdzcXVhcmUnLFxuICAgICAgICAgICAgcmFkaXVzOiAyLFxuICAgICAgICAgICAgc2l6ZTogOFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHNoYXJlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3Jvc3NoYWlyczoge1xuICAgICAgICAgICAgd2lkdGg6ICdiYXJXaWR0aCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2JhY2snLFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICB0eXBlOiAnZ3JhZGllbnQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuZGxlc3RpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuZGxlc3RpY2soKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICBjb2xvcnM6IFsnIzMzMyddXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgc2hhcmVkOiB0cnVlLFxuICAgICAgICAgIGN1c3RvbTogZnVuY3Rpb24gY3VzdG9tKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBzZXJpZXNJbmRleCA9IF9yZWYuc2VyaWVzSW5kZXgsXG4gICAgICAgICAgICAgICAgZGF0YVBvaW50SW5kZXggPSBfcmVmLmRhdGFQb2ludEluZGV4LFxuICAgICAgICAgICAgICAgIHcgPSBfcmVmLnc7XG4gICAgICAgICAgICB2YXIgbyA9IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVPW3Nlcmllc0luZGV4XVtkYXRhUG9pbnRJbmRleF07XG4gICAgICAgICAgICB2YXIgaCA9IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVIW3Nlcmllc0luZGV4XVtkYXRhUG9pbnRJbmRleF07XG4gICAgICAgICAgICB2YXIgbCA9IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVMW3Nlcmllc0luZGV4XVtkYXRhUG9pbnRJbmRleF07XG4gICAgICAgICAgICB2YXIgYyA9IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVDW3Nlcmllc0luZGV4XVtkYXRhUG9pbnRJbmRleF07XG4gICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJhcGV4Y2hhcnRzLXRvb2x0aXAtY2FuZGxlc3RpY2tcIj4nICsgJzxkaXY+T3BlbjogPHNwYW4gY2xhc3M9XCJ2YWx1ZVwiPicgKyBvICsgJzwvc3Bhbj48L2Rpdj4nICsgJzxkaXY+SGlnaDogPHNwYW4gY2xhc3M9XCJ2YWx1ZVwiPicgKyBoICsgJzwvc3Bhbj48L2Rpdj4nICsgJzxkaXY+TG93OiA8c3BhbiBjbGFzcz1cInZhbHVlXCI+JyArIGwgKyAnPC9zcGFuPjwvZGl2PicgKyAnPGRpdj5DbG9zZTogPHNwYW4gY2xhc3M9XCJ2YWx1ZVwiPicgKyBjICsgJzwvc3Bhbj48L2Rpdj4nICsgJzwvZGl2Pic7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICB0eXBlOiAnbm9uZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgY3Jvc3NoYWlyczoge1xuICAgICAgICAgICAgd2lkdGg6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFyZWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXJlYSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIHdpZHRoOiA0XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICB0eXBlOiAnZ3JhZGllbnQnLFxuICAgICAgICAgIGdyYWRpZW50OiB7XG4gICAgICAgICAgICBpbnZlcnNlQ29sb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIHNoYWRlOiAnbGlnaHQnLFxuICAgICAgICAgICAgdHlwZTogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIG9wYWNpdHlGcm9tOiAwLjY1LFxuICAgICAgICAgICAgb3BhY2l0eVRvOiAwLjUsXG4gICAgICAgICAgICBzdG9wczogWzAsIDEwMCwgMTAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIHNpemVPZmZzZXQ6IDZcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBmb2xsb3dDdXJzb3I6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJydXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJydXNoKGRlZmF1bHRzKSB7XG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgIHRvb2xiYXI6IHtcbiAgICAgICAgICAgIGF1dG9TZWxlY3RlZDogJ3NlbGVjdGlvbicsXG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgem9vbToge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICB3aWR0aDogMVxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBVdGlscy5leHRlbmQoZGVmYXVsdHMsIHJldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YWNrZWQxMDBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhY2tlZDEwMCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMub3B0cy5kYXRhTGFiZWxzID0gdGhpcy5vcHRzLmRhdGFMYWJlbHMgfHwge307XG4gICAgICB0aGlzLm9wdHMuZGF0YUxhYmVscy5mb3JtYXR0ZXIgPSB0aGlzLm9wdHMuZGF0YUxhYmVscy5mb3JtYXR0ZXIgfHwgdW5kZWZpbmVkO1xuICAgICAgdmFyIGV4aXN0aW5nRGF0YUxhYmVsRm9ybWF0dGVyID0gdGhpcy5vcHRzLmRhdGFMYWJlbHMuZm9ybWF0dGVyO1xuICAgICAgdGhpcy5vcHRzLnlheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgIF90aGlzLm9wdHMueWF4aXNbaW5kZXhdLm1pbiA9IDA7XG4gICAgICAgIF90aGlzLm9wdHMueWF4aXNbaW5kZXhdLm1heCA9IDEwMDtcbiAgICAgIH0pO1xuICAgICAgdmFyIGlzQmFyID0gdGhpcy5vcHRzLmNoYXJ0LnR5cGUgPT09ICdiYXInO1xuXG4gICAgICBpZiAoaXNCYXIpIHtcbiAgICAgICAgdGhpcy5vcHRzLmRhdGFMYWJlbHMuZm9ybWF0dGVyID0gZXhpc3RpbmdEYXRhTGFiZWxGb3JtYXR0ZXIgfHwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCA/IHZhbC50b0ZpeGVkKDApICsgJyUnIDogdmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSAvLyBUaGlzIGZ1bmN0aW9uIHJlbW92ZXMgdGhlIGxlZnQgYW5kIHJpZ2h0IHNwYWNpbmcgaW4gY2hhcnQgZm9yIGxpbmUvYXJlYS9zY2F0dGVyIGlmIHhheGlzIHR5cGUgPSBjYXRlZ29yeSBmb3IgdGhvc2UgY2hhcnRzIGJ5IGNvbnZlcnRpbmcgeGF4aXMgPSBudW1lcmljLiBOdW1lcmljL0RhdGV0aW1lIHhheGlzIHByZXZlbnRzIHRoZSB1bm5lY2Vzc2FyeSBzcGFjaW5nIGluIHRoZSBsZWZ0L3JpZ2h0IG9mIHRoZSBjaGFydCBhcmVhXG5cbiAgfSwge1xuICAgIGtleTogXCJidWJibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcnM6IFsnI2ZmZiddXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgc2hhcmVkOiBmYWxzZSxcbiAgICAgICAgICBpbnRlcnNlY3Q6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIHR5cGU6ICdzb2xpZCcsXG4gICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgIHNoYWRlOiAnbGlnaHQnLFxuICAgICAgICAgICAgaW52ZXJzZTogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjU1LFxuICAgICAgICAgICAgb3BhY2l0eUZyb206IDAuNCxcbiAgICAgICAgICAgIG9wYWNpdHlUbzogMC44XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY2F0dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYXR0ZXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHNoYXJlZDogZmFsc2UsXG4gICAgICAgICAgaW50ZXJzZWN0OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICBzaXplOiA2LFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBzaXplT2Zmc2V0OiAyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWF0bWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlYXRtYXAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydDoge1xuICAgICAgICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgICAgICAgIHpvb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIGZvbGxvd0N1cnNvcjogdHJ1ZSxcbiAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB4OiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgIHNoYXBlOiAnc3F1YXJlJyxcbiAgICAgICAgICAgIHNpemU6IDEwLFxuICAgICAgICAgICAgb2Zmc2V0WTogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIHJpZ2h0OiAyMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGllXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBpZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgdG9vbGJhcjoge1xuICAgICAgICAgICAgc2hvdzogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBsb3RPcHRpb25zOiB7XG4gICAgICAgICAgcGllOiB7XG4gICAgICAgICAgICBkb251dDoge1xuICAgICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnRvRml4ZWQoMSkgKyAnJSc7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3JzOiBbJyNmZmYnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHJvcFNoYWRvdzoge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgY29sb3JzOiBbJyNmZmYnXVxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBncmFkaWVudDoge1xuICAgICAgICAgICAgc2hhZGU6ICdkYXJrJyxcbiAgICAgICAgICAgIHNoYWRlSW50ZW5zaXR5OiAwLjM1LFxuICAgICAgICAgICAgaW52ZXJzZUNvbG9yczogZmFsc2UsXG4gICAgICAgICAgICBzdG9wczogWzAsIDEwMCwgMTAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHRoZW1lOiAnZGFyaycsXG4gICAgICAgICAgZmlsbFNlcmllc0NvbG9yOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbnV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvbnV0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC50b0ZpeGVkKDEpICsgJyUnO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRyb3BTaGFkb3c6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIGNvbG9yczogWycjZmZmJ11cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgICAgIHNoYWRlOiAnZGFyaycsXG4gICAgICAgICAgICBzaGFkZUludGVuc2l0eTogMC40LFxuICAgICAgICAgICAgaW52ZXJzZUNvbG9yczogZmFsc2UsXG4gICAgICAgICAgICB0eXBlOiAndmVydGljYWwnLFxuICAgICAgICAgICAgb3BhY2l0eUZyb206IDEsXG4gICAgICAgICAgICBvcGFjaXR5VG86IDEsXG4gICAgICAgICAgICBzdG9wczogWzcwLCA5OCwgMTAwXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIHRoZW1lOiAnZGFyaycsXG4gICAgICAgICAgZmlsbFNlcmllc0NvbG9yOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhZGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhZGFyKCkge1xuICAgICAgdGhpcy5vcHRzLnlheGlzWzBdLmxhYmVscy5zdHlsZS5mb250U2l6ZSA9ICcxM3B4JztcbiAgICAgIHRoaXMub3B0cy55YXhpc1swXS5sYWJlbHMub2Zmc2V0WSA9IDY7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3JzOiBbJyNhOGE4YTgnXSxcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMTFweCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZToge1xuICAgICAgICAgIHdpZHRoOiAyXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDFcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIG9wYWNpdHk6IDAuMlxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgc2hhcmVkOiBmYWxzZSxcbiAgICAgICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICAgICAgZm9sbG93Q3Vyc29yOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB4YXhpczoge1xuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjcm9zc2hhaXJzOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFkaWFsQmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhZGlhbEJhcigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgZHluYW1pY0FuaW1hdGlvbjoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICBzcGVlZDogODAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIGdyYWRpZW50OiB7XG4gICAgICAgICAgICBzaGFkZTogJ2RhcmsnLFxuICAgICAgICAgICAgc2hhZGVJbnRlbnNpdHk6IDAuNCxcbiAgICAgICAgICAgIGludmVyc2VDb2xvcnM6IGZhbHNlLFxuICAgICAgICAgICAgdHlwZTogJ2RpYWdvbmFsMicsXG4gICAgICAgICAgICBvcGFjaXR5RnJvbTogMSxcbiAgICAgICAgICAgIG9wYWNpdHlUbzogMSxcbiAgICAgICAgICAgIHN0b3BzOiBbNzAsIDk4LCAxMDBdXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0J1xuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgZmlsbFNlcmllc0NvbG9yOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY29udmVydENhdFRvTnVtZXJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0Q2F0VG9OdW1lcmljKG9wdHMpIHtcbiAgICAgIG9wdHMueGF4aXMudHlwZSA9ICdudW1lcmljJztcbiAgICAgIG9wdHMueGF4aXMuY29udmVydGVkQ2F0VG9OdW1lcmljID0gdHJ1ZTtcbiAgICAgIG9wdHMueGF4aXMubGFiZWxzID0gb3B0cy54YXhpcy5sYWJlbHMgfHwge307XG5cbiAgICAgIG9wdHMueGF4aXMubGFiZWxzLmZvcm1hdHRlciA9IG9wdHMueGF4aXMubGFiZWxzLmZvcm1hdHRlciB8fCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9O1xuXG4gICAgICBvcHRzLmNoYXJ0ID0gb3B0cy5jaGFydCB8fCB7fTtcbiAgICAgIG9wdHMuY2hhcnQuem9vbSA9IG9wdHMuY2hhcnQuem9vbSB8fCB3aW5kb3cuQXBleC5jaGFydCAmJiB3aW5kb3cuQXBleC5jaGFydC56b29tIHx8IHt9O1xuICAgICAgdmFyIGRlZmF1bHRGb3JtYXR0ZXIgPSBvcHRzLnhheGlzLmxhYmVscy5mb3JtYXR0ZXI7XG4gICAgICB2YXIgbGFiZWxzID0gb3B0cy54YXhpcy5jYXRlZ29yaWVzICYmIG9wdHMueGF4aXMuY2F0ZWdvcmllcy5sZW5ndGggPyBvcHRzLnhheGlzLmNhdGVnb3JpZXMgOiBvcHRzLmxhYmVscztcblxuICAgICAgaWYgKGxhYmVscyAmJiBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgIG9wdHMueGF4aXMubGFiZWxzLmZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcihsYWJlbHNbdmFsIC0gMV0pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcHRzLnhheGlzLmNhdGVnb3JpZXMgPSBbXTtcbiAgICAgIG9wdHMubGFiZWxzID0gW107XG4gICAgICBvcHRzLmNoYXJ0Lnpvb20uZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERlZmF1bHRzO1xufSgpO1xuXG4vKlxuICoqIFV0aWwgZnVuY3Rpb25zIHdoaWNoIGFyZSBkZXBlbmRlbnQgb24gQXBleENoYXJ0cyBpbnN0YW5jZVxuICovXG52YXIgQ29yZVV0aWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29yZVV0aWxzKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb3JlVXRpbHMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29yZVV0aWxzLCBbe1xuICAgIGtleTogXCJnZXRTdGFja2VkU2VyaWVzVG90YWxzXCIsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVV0aWxzXG4gICAgICogcmV0dXJucyB0aGUgc3VtIG9mIGFsbCBpbmRpdmlkdWFsIHZhbHVlcyBpbiBhIG11bHRpcGxlIHN0YWNrZWQgc2VyaWVzXG4gICAgICogRWcuIHcuZ2xvYmFscy5zZXJpZXMgPSBbWzMyLDMzLDQzLDEyXSwgWzIsMyw1LDFdXVxuICAgICAqICBAcmV0dXJuIFszNCwzNiw0OCwxM11cbiAgICAgKiovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YWNrZWRTZXJpZXNUb3RhbHMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0b3RhbCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcuZ2xvYmFscy5zZXJpZXNbdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB0ICs9IHcuZ2xvYmFscy5zZXJpZXNbal1baV07XG4gICAgICAgIH1cblxuICAgICAgICB0b3RhbC5wdXNoKHQpO1xuICAgICAgfVxuXG4gICAgICB3Lmdsb2JhbHMuc3RhY2tlZFNlcmllc1RvdGFscyA9IHRvdGFsO1xuICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH0gLy8gZ2V0IHRvdGFsIG9mIHRoZSBhbGwgdmFsdWVzIGluc2lkZSBhbGwgc2VyaWVzXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNUb3RhbEJ5SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzVG90YWxCeUluZGV4KCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgLy8gbm9uLXBsb3QgY2hhcnQgdHlwZXMgLSBwaWUgLyBkb251dCAvIGNpcmNsZVxuICAgICAgICByZXR1cm4gdGhpcy53LmNvbmZpZy5zZXJpZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cikge1xuICAgICAgICAgIHJldHVybiBhY2MgKyBjdXI7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXhpcyBjaGFydHMgLSBzdXBwb3J0aW5nIG11bHRpcGxlIHNlcmllc1xuICAgICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuc2VyaWVzW2luZGV4XS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VyKSB7XG4gICAgICAgICAgcmV0dXJuIGFjYyArIGN1cjtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU2VyaWVzTnVsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Nlcmllc051bGwoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgciA9IFtdO1xuXG4gICAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgLy8gbm9uLXBsb3QgY2hhcnQgdHlwZXMgLSBwaWUgLyBkb251dCAvIGNpcmNsZVxuICAgICAgICByID0gdGhpcy53LmNvbmZpZy5zZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQgIT09IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXhpcyBjaGFydHMgLSBzdXBwb3J0aW5nIG11bHRpcGxlIHNlcmllc1xuICAgICAgICByID0gdGhpcy53Lmdsb2JhbHMuc2VyaWVzW2luZGV4XS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZCAhPT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWVzSGF2ZVNhbWVWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWVzSGF2ZVNhbWVWYWx1ZXMoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5zZXJpZXNbaW5kZXhdLmV2ZXJ5KGZ1bmN0aW9uICh2YWwsIGksIGFycikge1xuICAgICAgICByZXR1cm4gdmFsID09PSBhcnJbMF07XG4gICAgICB9KTtcbiAgICB9IC8vIG1heFZhbHNJbkFycmF5SW5kZXggaXMgdGhlIGluZGV4IG9mIHNlcmllc1tdIHdoaWNoIGhhcyB0aGUgbGFyZ2VzdCBudW1iZXIgb2YgaXRlbXNcblxuICB9LCB7XG4gICAga2V5OiBcImdldExhcmdlc3RTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFyZ2VzdFNlcmllcygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXggPSB3Lmdsb2JhbHMuc2VyaWVzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGg7XG4gICAgICB9KS5pbmRleE9mKE1hdGgubWF4LmFwcGx5KE1hdGgsIHcuZ2xvYmFscy5zZXJpZXMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aDtcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhcmdlc3RNYXJrZXJTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhcmdlc3RNYXJrZXJTaXplKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICB3Lmdsb2JhbHMubWFya2Vycy5zaXplLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIG0pO1xuICAgICAgfSk7XG4gICAgICB3Lmdsb2JhbHMubWFya2Vycy5sYXJnZXN0U2l6ZSA9IHNpemU7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIENvcmVcbiAgICAgKiByZXR1cm5zIHRoZSBzdW0gb2YgYWxsIHZhbHVlcyBpbiBhIHNlcmllc1xuICAgICAqIEVnLiB3Lmdsb2JhbHMuc2VyaWVzID0gW1szMiwzMyw0MywxMl0sIFsyLDMsNSwxXV1cbiAgICAgKiAgQHJldHVybiBbMTIwLCAxMV1cbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNUb3RhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VyaWVzVG90YWxzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB3Lmdsb2JhbHMuc2VyaWVzVG90YWxzID0gdy5nbG9iYWxzLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlciwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXIpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHRvdGFsICs9IHNlcltqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZm9yIHBpZS9kb251dHMvZ2F1Z2VzXG4gICAgICAgICAgdG90YWwgKz0gc2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlcmllc1RvdGFsc1hSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXJpZXNUb3RhbHNYUmFuZ2UobWluWCwgbWF4WCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgc2VyaWVzVG90YWxzWFJhbmdlID0gdy5nbG9iYWxzLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlciwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuc2VyaWVzWFtpbmRleF1bal0gPiBtaW5YICYmIHcuZ2xvYmFscy5zZXJpZXNYW2luZGV4XVtqXSA8IG1heFgpIHtcbiAgICAgICAgICAgIHRvdGFsICs9IHNlcltqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZXJpZXNUb3RhbHNYUmFuZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBDb3JlVXRpbHNcbiAgICAgKiByZXR1cm5zIHRoZSBwZXJjZW50YWdlIHZhbHVlIG9mIGFsbCBpbmRpdmlkdWFsIHZhbHVlcyB3aGljaCBjYW4gYmUgdXNlZCBpbiBhIDEwMCUgc3RhY2tlZCBzZXJpZXNcbiAgICAgKiBFZy4gdy5nbG9iYWxzLnNlcmllcyA9IFtbMzIsIDMzLCA0MywgMTJdLCBbMiwgMywgNSwgMV1dXG4gICAgICogIEByZXR1cm4gW1s5NC4xMSwgOTEuNjYsIDg5LjU4LCA5Mi4zMF0sIFs1Ljg4LCA4LjMzLCAxMC40MSwgNy43XV1cbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQZXJjZW50U2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBlcmNlbnRTZXJpZXMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHcuZ2xvYmFscy5zZXJpZXNQZXJjZW50ID0gdy5nbG9iYWxzLnNlcmllcy5tYXAoZnVuY3Rpb24gKHNlciwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlcmllc1BlcmNlbnQgPSBbXTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXIpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHcuZ2xvYmFscy5zdGFja2VkU2VyaWVzVG90YWxzW2pdO1xuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSAxMDAgKiBzZXJbal0gLyB0b3RhbDtcbiAgICAgICAgICAgIHNlcmllc1BlcmNlbnQucHVzaChwZXJjZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF90b3RhbCA9IHcuZ2xvYmFscy5zZXJpZXNUb3RhbHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIHZhbDtcbiAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgIHZhciBfcGVyY2VudCA9IDEwMCAqIHNlciAvIF90b3RhbDtcblxuICAgICAgICAgIHNlcmllc1BlcmNlbnQucHVzaChfcGVyY2VudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzUGVyY2VudDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWxjdWxhdGVkUmF0aW9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbGN1bGF0ZWRSYXRpb3MoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciB5UmF0aW8gPSBbXTtcbiAgICAgIHZhciBpbnZlcnRlZFlSYXRpbyA9IDA7XG4gICAgICB2YXIgeFJhdGlvID0gMDtcbiAgICAgIHZhciBpbml0aWFsWFJhdGlvID0gMDtcbiAgICAgIHZhciBpbnZlcnRlZFhSYXRpbyA9IDA7XG4gICAgICB2YXIgelJhdGlvID0gMDtcbiAgICAgIHZhciBiYXNlTGluZVkgPSBbXTtcbiAgICAgIHZhciBiYXNlTGluZUludmVydGVkWSA9IDAuMTtcbiAgICAgIHZhciBiYXNlTGluZVggPSAwO1xuICAgICAgZ2wueVJhbmdlID0gW107XG5cbiAgICAgIGlmIChnbC5pc011bHRpcGxlWUF4aXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbC5taW5ZQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZ2wueVJhbmdlLnB1c2goTWF0aC5hYnMoZ2wubWluWUFycltpXSAtIGdsLm1heFlBcnJbaV0pKTtcbiAgICAgICAgICBiYXNlTGluZVkucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wueVJhbmdlLnB1c2goTWF0aC5hYnMoZ2wubWluWSAtIGdsLm1heFkpKTtcbiAgICAgIH1cblxuICAgICAgZ2wueFJhbmdlID0gTWF0aC5hYnMoZ2wubWF4WCAtIGdsLm1pblgpO1xuICAgICAgZ2wuelJhbmdlID0gTWF0aC5hYnMoZ2wubWF4WiAtIGdsLm1pblopOyAvLyBtdWx0aXBsZSB5IGF4aXNcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGdsLnlSYW5nZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgeVJhdGlvLnB1c2goZ2wueVJhbmdlW19pXSAvIGdsLmdyaWRIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICB4UmF0aW8gPSBnbC54UmFuZ2UgLyBnbC5ncmlkV2lkdGg7XG4gICAgICBpbml0aWFsWFJhdGlvID0gTWF0aC5hYnMoZ2wuaW5pdGlhbG1heFggLSBnbC5pbml0aWFsbWluWCkgLyBnbC5ncmlkV2lkdGg7XG4gICAgICBpbnZlcnRlZFlSYXRpbyA9IGdsLnlSYW5nZSAvIGdsLmdyaWRXaWR0aDtcbiAgICAgIGludmVydGVkWFJhdGlvID0gZ2wueFJhbmdlIC8gZ2wuZ3JpZEhlaWdodDtcbiAgICAgIHpSYXRpbyA9IGdsLnpSYW5nZSAvIGdsLmdyaWRIZWlnaHQgKiAxNjtcblxuICAgICAgaWYgKGdsLm1pblkgIT09IE51bWJlci5NSU5fVkFMVUUgJiYgTWF0aC5hYnMoZ2wubWluWSkgIT09IDApIHtcbiAgICAgICAgLy8gTmVnYXRpdmUgbnVtYmVycyBwcmVzZW50IGluIHNlcmllc1xuICAgICAgICBnbC5oYXNOZWdzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdsLmlzTXVsdGlwbGVZQXhpcykge1xuICAgICAgICBiYXNlTGluZVkgPSBbXTsgLy8gYmFzZWxpbmUgdmFyaWFibGVzIGlzIHRoZSAwIG9mIHRoZSB5YXhpcyB3aGljaCB3aWxsIGJlIG5lZWRlZCB3aGVuIHRoZXJlIGFyZSBuZWdhdGl2ZXNcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB5UmF0aW8ubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIGJhc2VMaW5lWS5wdXNoKC1nbC5taW5ZQXJyW19pMl0gLyB5UmF0aW9bX2kyXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VMaW5lWS5wdXNoKC1nbC5taW5ZIC8geVJhdGlvWzBdKTtcblxuICAgICAgICBpZiAoZ2wubWluWSAhPT0gTnVtYmVyLk1JTl9WQUxVRSAmJiBNYXRoLmFicyhnbC5taW5ZKSAhPT0gMCkge1xuICAgICAgICAgIGJhc2VMaW5lSW52ZXJ0ZWRZID0gLWdsLm1pblkgLyBpbnZlcnRlZFlSYXRpbzsgLy8gdGhpcyBpcyBmb3IgYmFyIGNoYXJ0XG5cbiAgICAgICAgICBiYXNlTGluZVggPSBnbC5taW5YIC8geFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHlSYXRpbzogeVJhdGlvLFxuICAgICAgICBpbnZlcnRlZFlSYXRpbzogaW52ZXJ0ZWRZUmF0aW8sXG4gICAgICAgIHpSYXRpbzogelJhdGlvLFxuICAgICAgICB4UmF0aW86IHhSYXRpbyxcbiAgICAgICAgaW5pdGlhbFhSYXRpbzogaW5pdGlhbFhSYXRpbyxcbiAgICAgICAgaW52ZXJ0ZWRYUmF0aW86IGludmVydGVkWFJhdGlvLFxuICAgICAgICBiYXNlTGluZUludmVydGVkWTogYmFzZUxpbmVJbnZlcnRlZFksXG4gICAgICAgIGJhc2VMaW5lWTogYmFzZUxpbmVZLFxuICAgICAgICBiYXNlTGluZVg6IGJhc2VMaW5lWFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9nU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvZ1NlcmllcyhzZXJpZXMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLnNlcmllc0xvZyA9IHNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW2ldICYmIHcuY29uZmlnLnlheGlzW2ldLmxvZ2FyaXRobWljKSB7XG4gICAgICAgICAgcmV0dXJuIHMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBpZiAoZCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgbG9nVmFsID0gKE1hdGgubG9nKGQpIC0gTWF0aC5sb2cody5nbG9iYWxzLm1pbllBcnJbaV0pKSAvIChNYXRoLmxvZyh3Lmdsb2JhbHMubWF4WUFycltpXSkgLSBNYXRoLmxvZyh3Lmdsb2JhbHMubWluWUFycltpXSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxvZ1ZhbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdy5nbG9iYWxzLnNlcmllc0xvZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG9nWVJhdGlvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb2dZUmF0aW9zKHlSYXRpbykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIGdsLnlMb2dSYXRpbyA9IHlSYXRpby5zbGljZSgpO1xuICAgICAgZ2wubG9nWVJhbmdlID0gZ2wueVJhbmdlLm1hcChmdW5jdGlvbiAoeVJhbmdlLCBpKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tpXSAmJiBfdGhpcy53LmNvbmZpZy55YXhpc1tpXS5sb2dhcml0aG1pYykge1xuICAgICAgICAgIHZhciBtYXhZID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgdmFyIG1pblkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgICAgIHZhciByYW5nZSA9IDE7XG4gICAgICAgICAgZ2wuc2VyaWVzTG9nLmZvckVhY2goZnVuY3Rpb24gKHMsIHNpKSB7XG4gICAgICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3NpXSAmJiB3LmNvbmZpZy55YXhpc1tzaV0ubG9nYXJpdGhtaWMpIHtcbiAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgodiwgbWF4WSk7XG4gICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKHYsIG1pblkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByYW5nZSA9IE1hdGgucG93KGdsLnlSYW5nZVtpXSwgTWF0aC5hYnMobWluWSAtIG1heFkpIC8gZ2wueVJhbmdlW2ldKTtcbiAgICAgICAgICBnbC55TG9nUmF0aW9baV0gPSByYW5nZSAvIGdsLmdyaWRIZWlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBnbC55TG9nUmF0aW87XG4gICAgfSAvLyBTb21lIGNvbmZpZyBvYmplY3RzIGNhbiBiZSBhcnJheSAtIGFuZCB3ZSBuZWVkIHRvIGV4dGVuZCB0aGVtIGNvcnJlY3RseVxuXG4gIH1dLCBbe1xuICAgIGtleTogXCJjaGVja0NvbWJvU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQ29tYm9TZXJpZXMoc2VyaWVzKSB7XG4gICAgICB2YXIgY29tYm9DaGFydHMgPSBmYWxzZTtcbiAgICAgIHZhciBjb21ib0NoYXJ0c0hhc0JhcnMgPSBmYWxzZTsgLy8gaWYgdXNlciBzcGVjaWZpZWQgYSB0eXBlIGluIHNlcmllcyB0b28sIHR1cm4gb24gY29tYm9DaGFydHMgZmxhZ1xuXG4gICAgICBpZiAoc2VyaWVzLmxlbmd0aCAmJiB0eXBlb2Ygc2VyaWVzWzBdLnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbWJvQ2hhcnRzID0gdHJ1ZTtcbiAgICAgICAgc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICBpZiAocy50eXBlID09PSAnYmFyJyB8fCBzLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICBjb21ib0NoYXJ0c0hhc0JhcnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbWJvQ2hhcnRzOiBjb21ib0NoYXJ0cyxcbiAgICAgICAgY29tYm9DaGFydHNIYXNCYXJzOiBjb21ib0NoYXJ0c0hhc0JhcnNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dGVuZEFycmF5UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kQXJyYXlQcm9wcyhjb25maWdJbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMueWF4aXMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGNvbmZpZ0luc3RhbmNlLmV4dGVuZFlBeGlzKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbm5vdGF0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5hbm5vdGF0aW9ucy55YXhpcykge1xuICAgICAgICAgIG9wdGlvbnMgPSBjb25maWdJbnN0YW5jZS5leHRlbmRZQXhpc0Fubm90YXRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5ub3RhdGlvbnMueGF4aXMpIHtcbiAgICAgICAgICBvcHRpb25zID0gY29uZmlnSW5zdGFuY2UuZXh0ZW5kWEF4aXNBbm5vdGF0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFubm90YXRpb25zLnBvaW50cykge1xuICAgICAgICAgIG9wdGlvbnMgPSBjb25maWdJbnN0YW5jZS5leHRlbmRQb2ludEFubm90YXRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb3JlVXRpbHM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBDb25maWcgQ2xhc3MgZm9yIGV4dGVuZGluZyB1c2VyIG9wdGlvbnMgd2l0aCBwcmUtZGVmaW5lZCBBcGV4Q2hhcnRzIGNvbmZpZy5cbiAqXG4gKiBAbW9kdWxlIENvbmZpZ1xuICoqL1xuXG52YXIgQ29uZmlnID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZmlnKG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlnKTtcblxuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29uZmlnLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cztcbiAgICAgIHZhciBvcHRpb25zID0gbmV3IE9wdGlvbnMoKTtcbiAgICAgIHZhciBkZWZhdWx0cyA9IG5ldyBEZWZhdWx0cyhvcHRzKTtcbiAgICAgIHRoaXMuY2hhcnRUeXBlID0gb3B0cy5jaGFydC50eXBlO1xuXG4gICAgICBpZiAodGhpcy5jaGFydFR5cGUgPT09ICdoaXN0b2dyYW0nKSB7XG4gICAgICAgIC8vIHRlY2huaWNhbGx5LCBhIGhpc3RvZ3JhbSBjYW4gYmUgZHJhd24gYnkgYSBjb2x1bW4gY2hhcnQgd2l0aCBubyBzcGFjZXMgaW4gYmV0d2VlblxuICAgICAgICBvcHRzLmNoYXJ0LnR5cGUgPSAnYmFyJztcbiAgICAgICAgb3B0cyA9IFV0aWxzLmV4dGVuZCh7XG4gICAgICAgICAgcGxvdE9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICBjb2x1bW5XaWR0aDogJzk5Ljk5JSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgfVxuXG4gICAgICBvcHRzLnNlcmllcyA9IHRoaXMuY2hlY2tFbXB0eVNlcmllcyhvcHRzLnNlcmllcyk7XG4gICAgICBvcHRzID0gdGhpcy5leHRlbmRZQXhpcyhvcHRzKTtcbiAgICAgIG9wdHMgPSB0aGlzLmV4dGVuZEFubm90YXRpb25zKG9wdHMpO1xuICAgICAgdmFyIGNvbmZpZyA9IG9wdGlvbnMuaW5pdCgpO1xuICAgICAgdmFyIG5ld0RlZmF1bHRzID0ge307XG5cbiAgICAgIGlmIChvcHRzICYmIF90eXBlb2Yob3B0cykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBjaGFydERlZmF1bHRzID0ge307XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYXJ0VHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLmxpbmUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYXJlYSc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuYXJlYSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiYXInOlxuICAgICAgICAgICAgY2hhcnREZWZhdWx0cyA9IGRlZmF1bHRzLmJhcigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjYW5kbGVzdGljayc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuY2FuZGxlc3RpY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaGlzdG9ncmFtJzpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5iYXIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYnViYmxlJzpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5idWJibGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc2NhdHRlcic6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuc2NhdHRlcigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdoZWF0bWFwJzpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5oZWF0bWFwKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3BpZSc6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMucGllKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2RvbnV0JzpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5kb251dCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyYWRhcic6XG4gICAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMucmFkYXIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmFkaWFsQmFyJzpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5yYWRpYWxCYXIoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNoYXJ0RGVmYXVsdHMgPSBkZWZhdWx0cy5saW5lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5jaGFydC5icnVzaCAmJiBvcHRzLmNoYXJ0LmJydXNoLmVuYWJsZWQpIHtcbiAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuYnJ1c2goY2hhcnREZWZhdWx0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5jaGFydC5zdGFja2VkICYmIG9wdHMuY2hhcnQuc3RhY2tUeXBlID09PSAnMTAwJScpIHtcbiAgICAgICAgICBkZWZhdWx0cy5zdGFja2VkMTAwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzLnhheGlzID0gb3B0cy54YXhpcyB8fCB3aW5kb3cuQXBleC54YXhpcyB8fCB7fTtcbiAgICAgICAgdmFyIGNvbWJvID0gQ29yZVV0aWxzLmNoZWNrQ29tYm9TZXJpZXMob3B0cy5zZXJpZXMpO1xuXG4gICAgICAgIGlmICgob3B0cy5jaGFydC50eXBlID09PSAnbGluZScgfHwgb3B0cy5jaGFydC50eXBlID09PSAnYXJlYScgfHwgb3B0cy5jaGFydC50eXBlID09PSAnc2NhdHRlcicpICYmICFjb21iby5jb21ib0NoYXJ0c0hhc0JhcnMgJiYgb3B0cy54YXhpcy50eXBlICE9PSAnZGF0ZXRpbWUnICYmIG9wdHMueGF4aXMudGlja1BsYWNlbWVudCAhPT0gJ2JldHdlZW4nKSB7XG4gICAgICAgICAgb3B0cyA9IERlZmF1bHRzLmNvbnZlcnRDYXRUb051bWVyaWMob3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5jaGFydC5zcGFya2xpbmUgJiYgb3B0cy5jaGFydC5zcGFya2xpbmUuZW5hYmxlZCB8fCB3aW5kb3cuQXBleC5jaGFydCAmJiB3aW5kb3cuQXBleC5jaGFydC5zcGFya2xpbmUgJiYgd2luZG93LkFwZXguY2hhcnQuc3BhcmtsaW5lLmVuYWJsZWQpIHtcbiAgICAgICAgICBjaGFydERlZmF1bHRzID0gZGVmYXVsdHMuc3BhcmtsaW5lKGNoYXJ0RGVmYXVsdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGVmYXVsdHMgPSBVdGlscy5leHRlbmQoY29uZmlnLCBjaGFydERlZmF1bHRzKTtcbiAgICAgIH0gLy8gY29uZmlnIHNob3VsZCBjYXNjYWRlIGluIHRoaXMgZmFzaGlvblxuICAgICAgLy8gZGVmYXVsdC1jb25maWcgPCBnbG9iYWwtYXBleC12YXJpYWJsZS1jb25maWcgPCB1c2VyLWRlZmluZWQtY29uZmlnXG4gICAgICAvLyBnZXQgR0xPQkFMTFkgZGVmaW5lZCBvcHRpb25zIGFuZCBtZXJnZSB3aXRoIHRoZSBkZWZhdWx0IGNvbmZpZ1xuXG5cbiAgICAgIHZhciBtZXJnZWRXaXRoRGVmYXVsdENvbmZpZyA9IFV0aWxzLmV4dGVuZChuZXdEZWZhdWx0cywgd2luZG93LkFwZXgpOyAvLyBnZXQgdGhlIG1lcmdlZCBjb25maWcgYW5kIGV4dGVuZCB3aXRoIHVzZXIgZGVmaW5lZCBjb25maWdcblxuICAgICAgY29uZmlnID0gVXRpbHMuZXh0ZW5kKG1lcmdlZFdpdGhEZWZhdWx0Q29uZmlnLCBvcHRzKTsgLy8gc29tZSBmZWF0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC4gdGhvc2UgbWlzbWF0Y2hlcyBzaG91bGQgYmUgaGFuZGxlZFxuXG4gICAgICBjb25maWcgPSB0aGlzLmhhbmRsZVVzZXJJbnB1dEVycm9ycyhjb25maWcpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kWUF4aXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kWUF4aXMob3B0cykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdHMueWF4aXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdHMueWF4aXMgPSB7fTtcbiAgICAgIH0gLy8gZXh0ZW5kIGdsb2JhbCB5YXhpcyBjb25maWcgKG9ubHkgaWYgb2JqZWN0IGlzIHByb3ZpZGVkIC8gbm90IGFuIGFycmF5KVxuXG5cbiAgICAgIGlmIChvcHRzLnlheGlzLmNvbnN0cnVjdG9yICE9PSBBcnJheSAmJiB3aW5kb3cuQXBleC55YXhpcyAmJiB3aW5kb3cuQXBleC55YXhpcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgb3B0cy55YXhpcyA9IFV0aWxzLmV4dGVuZChvcHRzLnlheGlzLCB3aW5kb3cuQXBleC55YXhpcyk7XG4gICAgICB9IC8vIGFzIHdlIGNhbid0IGV4dGVuZCBuZXN0ZWQgb2JqZWN0J3MgYXJyYXkgd2l0aCBleHRlbmQsIHdlIG5lZWQgdG8gZG8gaXQgZmlyc3RcbiAgICAgIC8vIHVzZXIgY2FuIHByb3ZpZGUgZWl0aGVyIGFuIGFycmF5IG9yIG9iamVjdCBpbiB5YXhpcyBjb25maWdcblxuXG4gICAgICBpZiAob3B0cy55YXhpcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgLy8gY29udmVydCB0aGUgeWF4aXMgdG8gYXJyYXkgaWYgdXNlciBzdXBwbGllZCBvYmplY3RcbiAgICAgICAgb3B0cy55YXhpcyA9IFtVdGlscy5leHRlbmQob3B0aW9ucy55QXhpcywgb3B0cy55YXhpcyldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0cy55YXhpcyA9IFV0aWxzLmV4dGVuZEFycmF5KG9wdHMueWF4aXMsIG9wdGlvbnMueUF4aXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9IC8vIGFubm90YXRpb25zIGFsc28gYWNjZXB0cyBhcnJheSwgc28gd2UgbmVlZCB0byBleHRlbmQgdGhlbSBtYW51YWxseVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kQW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kQW5ub3RhdGlvbnMob3B0cykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLmFubm90YXRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRzLmFubm90YXRpb25zID0ge307XG4gICAgICAgIG9wdHMuYW5ub3RhdGlvbnMueWF4aXMgPSBbXTtcbiAgICAgICAgb3B0cy5hbm5vdGF0aW9ucy54YXhpcyA9IFtdO1xuICAgICAgICBvcHRzLmFubm90YXRpb25zLnBvaW50cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBvcHRzID0gdGhpcy5leHRlbmRZQXhpc0Fubm90YXRpb25zKG9wdHMpO1xuICAgICAgb3B0cyA9IHRoaXMuZXh0ZW5kWEF4aXNBbm5vdGF0aW9ucyhvcHRzKTtcbiAgICAgIG9wdHMgPSB0aGlzLmV4dGVuZFBvaW50QW5ub3RhdGlvbnMob3B0cyk7XG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0ZW5kWUF4aXNBbm5vdGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRZQXhpc0Fubm90YXRpb25zKG9wdHMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gbmV3IE9wdGlvbnMoKTtcbiAgICAgIG9wdHMuYW5ub3RhdGlvbnMueWF4aXMgPSBVdGlscy5leHRlbmRBcnJheSh0eXBlb2Ygb3B0cy5hbm5vdGF0aW9ucy55YXhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmFubm90YXRpb25zLnlheGlzIDogW10sIG9wdGlvbnMueUF4aXNBbm5vdGF0aW9uKTtcbiAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRlbmRYQXhpc0Fubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZFhBeGlzQW5ub3RhdGlvbnMob3B0cykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucygpO1xuICAgICAgb3B0cy5hbm5vdGF0aW9ucy54YXhpcyA9IFV0aWxzLmV4dGVuZEFycmF5KHR5cGVvZiBvcHRzLmFubm90YXRpb25zLnhheGlzICE9PSAndW5kZWZpbmVkJyA/IG9wdHMuYW5ub3RhdGlvbnMueGF4aXMgOiBbXSwgb3B0aW9ucy54QXhpc0Fubm90YXRpb24pO1xuICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dGVuZFBvaW50QW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kUG9pbnRBbm5vdGF0aW9ucyhvcHRzKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IG5ldyBPcHRpb25zKCk7XG4gICAgICBvcHRzLmFubm90YXRpb25zLnBvaW50cyA9IFV0aWxzLmV4dGVuZEFycmF5KHR5cGVvZiBvcHRzLmFubm90YXRpb25zLnBvaW50cyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmFubm90YXRpb25zLnBvaW50cyA6IFtdLCBvcHRpb25zLnBvaW50QW5ub3RhdGlvbik7XG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tFbXB0eVNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VtcHR5U2VyaWVzKHNlcikge1xuICAgICAgaWYgKHNlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgZGF0YTogW11cbiAgICAgICAgfV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVVzZXJJbnB1dEVycm9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVVc2VySW5wdXRFcnJvcnMob3B0cykge1xuICAgICAgdmFyIGNvbmZpZyA9IG9wdHM7IC8vIGNvbmZsaWN0aW5nIHRvb2x0aXAgb3B0aW9uLiBpbnRlcnNlY3QgbWFrZXMgc3VyZSB0byBmb2N1cyBvbiAxIHBvaW50IGF0IGEgdGltZS4gU2hhcmVkIGNhbm5vdCBiZSB1c2VkIGFsb25nIHdpdGggaXRcblxuICAgICAgaWYgKGNvbmZpZy50b29sdGlwLnNoYXJlZCAmJiBjb25maWcudG9vbHRpcC5pbnRlcnNlY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29sdGlwLnNoYXJlZCBjYW5ub3QgYmUgZW5hYmxlZCB3aGVuIHRvb2x0aXAuaW50ZXJzZWN0IGlzIHRydWUuIFR1cm4gb2ZmIGFueSBvdGhlciBvcHRpb24gYnkgc2V0dGluZyBpdCB0byBmYWxzZS4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5jaGFydC5zY3JvbGxlcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Njcm9sbGVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdjIuMC4wLiBQbGVhc2UgcmVtb3ZlIHRoZSBjb25maWd1cmF0aW9uIGZvciBjaGFydC5zY3JvbGxlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIGNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBObyB0aW1lIHNlcmllcyBmb3IgaG9yaXpvbnRhbCBiYXJzXG4gICAgICAgIGlmIChjb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGltZWxpbmVzIG9uIGJhcnMgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0LiBTd2l0Y2ggdG8gY29sdW1uIGNoYXJ0IGJ5IHNldHRpbmcgcGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWw9ZmFsc2UnKTtcbiAgICAgICAgfSAvLyBObyBtdWx0aXBsZSB5YXhpcyBmb3IgYmFyc1xuXG5cbiAgICAgICAgaWYgKGNvbmZpZy55YXhpcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBZIEF4aXMgZm9yIGJhcnMgYXJlIG5vdCBzdXBwb3J0ZWQuIFN3aXRjaCB0byBjb2x1bW4gY2hhcnQgYnkgc2V0dGluZyBwbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbD1mYWxzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy55YXhpc1swXS5yZXZlcnNlZCkge1xuICAgICAgICAgIGNvbmZpZy55YXhpc1swXS5vcHBvc2l0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcueGF4aXMudG9vbHRpcC5lbmFibGVkID0gZmFsc2U7IC8vIG5vIHhheGlzIHRvb2x0aXAgZm9yIGhvcml6b250YWwgYmFyXG5cbiAgICAgICAgY29uZmlnLnlheGlzWzBdLnRvb2x0aXAuZW5hYmxlZCA9IGZhbHNlOyAvLyBubyB4YXhpcyB0b29sdGlwIGZvciBob3Jpem9udGFsIGJhclxuXG4gICAgICAgIGNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQgPSBmYWxzZTsgLy8gbm8gem9vbWluZyBmb3IgaG9yeiBiYXJzXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgICAgaWYgKGNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICAgIGlmIChjb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJyAmJiBjb25maWcuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignY3Jvc3NoYWlycy53aWR0aCA9IFwiYmFyV2lkdGhcIiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBzaW5nbGUgc2VyaWVzLCBub3QgaW4gYSBtdWx0aS1zZXJpZXMgYmFyQ2hhcnQuJyk7XG4gICAgICAgICAgICBjb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9ICd0aWNrV2lkdGgnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zdGF0ZXMuaG92ZXIudHlwZSA9ICdub25lJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdmb2xsb3dDdXJzb3Igb3B0aW9uIGluIHNoYXJlZCBjb2x1bW5zIGNhbm5vdCBiZSB0dXJuZWQgb2ZmLicpO1xuICAgICAgICAgICAgY29uZmlnLnRvb2x0aXAuZm9sbG93Q3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5jaGFydC50eXBlID09PSAnY2FuZGxlc3RpY2snKSB7XG4gICAgICAgIGlmIChjb25maWcueWF4aXNbMF0ucmV2ZXJzZWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1JldmVyc2VkIHktYXhpcyBpbiBjYW5kbGVzdGljayBjaGFydCBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgIGNvbmZpZy55YXhpc1swXS5yZXZlcnNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuY2hhcnQuZ3JvdXAgJiYgY29uZmlnLnlheGlzWzBdLmxhYmVscy5taW5XaWR0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0l0IGxvb2tzIGxpa2UgeW91IGhhdmUgbXVsdGlwbGUgY2hhcnRzIGluIHN5bmNocm9uaXphdGlvbi4gWW91IG11c3QgcHJvdmlkZSB5YXhpcy5sYWJlbHMubWluV2lkdGggd2hpY2ggbXVzdCBiZSBFUVVBTCBmb3IgYWxsIGdyb3VwZWQgY2hhcnRzIHRvIHByZXZlbnQgaW5jb3JyZWN0IGJlaGF2aW91ci4nKTtcbiAgICAgIH0gLy8gaWYgdXNlciBzdXBwbGllZCBhcnJheSBmb3Igc3Ryb2tlIHdpZHRoLCBpdCB3aWxsIG9ubHkgYmUgYXBwbGljYWJsZSB0byBsaW5lL2FyZWEgY2hhcnRzLCBmb3IgYW55IG90aGVyIGNoYXJ0cywgcmV2ZXJ0IGJhY2sgdG8gTnVtYmVyXG5cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnN0cm9rZS53aWR0aCkpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5jaGFydC50eXBlICE9PSAnbGluZScgJiYgY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdhcmVhJykge1xuICAgICAgICAgIGNvbnNvbGUud2Fybignc3Ryb2tlLndpZHRoIG9wdGlvbiBhY2NlcHRzIGFycmF5IG9ubHkgZm9yIGxpbmUgYW5kIGFyZWEgY2hhcnRzLiBSZXZlcnRlZCBiYWNrIHRvIE51bWJlcicpO1xuICAgICAgICAgIGNvbmZpZy5zdHJva2Uud2lkdGggPSBjb25maWcuc3Ryb2tlLndpZHRoWzBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbmZpZztcbn0oKTtcblxudmFyIEdsb2JhbHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHbG9iYWxzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHbG9iYWxzLCBbe1xuICAgIGtleTogXCJnbG9iYWxWYXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdsb2JhbFZhcnMoY29uZmlnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydElEOiBudWxsLFxuICAgICAgICAvLyBjaGFydCBJRCAtIGFwZXhjaGFydHMtY3VpZFxuICAgICAgICBjdWlkOiBudWxsLFxuICAgICAgICAvLyBjaGFydCBJRCAtIHJhbmRvbSBudW1iZXJzIGV4Y2x1ZGluZyBcImFwZXhjaGFydHNcIiBwYXJ0XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIGJlZm9yZU1vdW50OiBbXSxcbiAgICAgICAgICBtb3VudGVkOiBbXSxcbiAgICAgICAgICB1cGRhdGVkOiBbXSxcbiAgICAgICAgICBjbGlja2VkOiBbXSxcbiAgICAgICAgICBzZWxlY3Rpb246IFtdLFxuICAgICAgICAgIGRhdGFQb2ludFNlbGVjdGlvbjogW10sXG4gICAgICAgICAgem9vbWVkOiBbXSxcbiAgICAgICAgICBzY3JvbGxlZDogW11cbiAgICAgICAgfSxcbiAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgIGNvbG9yczogW11cbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgY29sb3JzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yczogW11cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJhZGFyUG9seWdvbnM6IHtcbiAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICBjb2xvcnM6IFtdXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtYXJrZXJzOiB7XG4gICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICBzaXplOiBjb25maWcubWFya2Vycy5zaXplLFxuICAgICAgICAgIGxhcmdlc3RTaXplOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1hdGlvbkVuZGVkOiBmYWxzZSxcbiAgICAgICAgaXNUb3VjaERldmljZTogJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzLFxuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgLy8gY2hhcnQgaGFzIGJlZW4gdXBkYXRlZCBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXIuIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gZGF0YUNoYW5nZWQgcHJvcGVydHkuIGlzRGlydHkgbWVhbnMgdXNlciBtYW51YWxseSBjYWxsZWQgc29tZSBtZXRob2QgdG8gdXBkYXRlXG4gICAgICAgIGluaXRpYWxDb25maWc6IG51bGwsXG4gICAgICAgIC8vIHdlIHdpbGwgc3RvcmUgdGhlIGZpcnN0IGNvbmZpZyB1c2VyIGhhcyBzZXQgdG8gZ28gYmFjayB3aGVuIHVzZXIgZmluaXNoZXMgaW50ZXJhY3Rpb25zIGxpa2Ugem9vbWluZyBhbmQgY29tZSBvdXQgb2YgaXRcbiAgICAgICAgbGFzdFhBeGlzOiBbXSxcbiAgICAgICAgbGFzdFlBeGlzOiBbXSxcbiAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgLy8gdGhlIE1BSU4gc2VyaWVzIGFycmF5ICh5IHZhbHVlcylcbiAgICAgICAgc2VyaWVzUGVyY2VudDogW10sXG4gICAgICAgIC8vIHRoZSBwZXJjZW50YWdlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gc2VyaWVzXG4gICAgICAgIHNlcmllc1RvdGFsczogW10sXG4gICAgICAgIHN0YWNrZWRTZXJpZXNUb3RhbHM6IFtdLFxuICAgICAgICBzZXJpZXNYOiBbXSxcbiAgICAgICAgLy8gc3RvcmUgdGhlIG51bWVyaWMgeCB2YWx1ZXMgaW4gdGhpcyBhcnJheSAoeCB2YWx1ZXMpXG4gICAgICAgIHNlcmllc1o6IFtdLFxuICAgICAgICAvLyBUaGUgM3JkIFwiWlwiIGRpbWVuc2lvbiBmb3IgYnViYmxlcyBjaGFydCAoeiB2YWx1ZXMpXG4gICAgICAgIGxhYmVsczogW10sXG4gICAgICAgIC8vIHN0b3JlIHRoZSB0ZXh0IHRvIGRyYXcgb24geCBheGlzXG4gICAgICAgIC8vIERvbid0IG11dGF0ZSB0aGUgbGFiZWxzLCBtYW55IHRoaW5ncyBpbmNsdWRpbmcgdG9vbHRpcHMgZGVwZW5kcyBvbiBpdCFcbiAgICAgICAgdGltZWxpbmVMYWJlbHM6IFtdLFxuICAgICAgICAvLyBzdG9yZSB0aGUgdGltZWxpbmUgTGFiZWxzIGluIGFub3RoZXIgdmFyaWFibGVcbiAgICAgICAgc2VyaWVzTmFtZXM6IFtdLFxuICAgICAgICAvLyBzYW1lIGFzIGxhYmVscywgdXNlZCBpbiBub24gYXhpcyBjaGFydHNcbiAgICAgICAgbm9MYWJlbHNQcm92aWRlZDogZmFsc2UsXG4gICAgICAgIC8vIGlmIHVzZXIgZGlkbid0IHByb3ZpZGUgYW55IGNhdGVnb3JpZXMvbGFiZWxzIG9yIHggdmFsdWVzLCBmYWxsYmFjayB0byAxLDIsMyw0Li4uXG4gICAgICAgIGFsbFNlcmllc0NvbGxhcHNlZDogZmFsc2UsXG4gICAgICAgIGNvbGxhcHNlZFNlcmllczogW10sXG4gICAgICAgIC8vIHdoZW4gdXNlciBjb2xsYXBzZXMgYSBzZXJpZXMsIGl0IGdvZXMgaW50byB0aGlzIGFycmF5XG4gICAgICAgIGNvbGxhcHNlZFNlcmllc0luZGljZXM6IFtdLFxuICAgICAgICAvLyB0aGlzIHN0b3JlcyB0aGUgaW5kZXggb2YgdGhlIGNvbGxhcHNlZFNlcmllcyBpbnN0ZWFkIG9mIHdob2xlIG9iamVjdCBmb3IgcXVpY2sgYWNjZXNzXG4gICAgICAgIGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllczogW10sXG4gICAgICAgIC8vIHdoZW4gdXNlciBjb2xsYXBzZXMgYW4gXCJhbHdheXNWaXNpYmxlXCIgc2VyaWVzLCBpdCBnb2VzIGludG8gdGhpcyBhcnJheVxuICAgICAgICBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzOiBbXSxcbiAgICAgICAgLy8gdGhpcyBzdG9yZXMgdGhlIGluZGV4IG9mIHRoZSBjb2xsYXBzZWRTZXJpZXMgd2hvc2UgeS1heGlzIGlzIGFsd2F5cyB2aXNpYmxlXG4gICAgICAgIHJpc2luZ1NlcmllczogW10sXG4gICAgICAgIC8vIHdoZW4gdXNlciByZS1vcGVucyBhIGNvbGxhcHNlZCBzZXJpZXMsIGl0IGdvZXMgaGVyZVxuICAgICAgICBzZWxlY3RlZERhdGFQb2ludHM6IFtdLFxuICAgICAgICBpZ25vcmVZQXhpc0luZGV4ZXM6IFtdLFxuICAgICAgICAvLyB3aGVuIHNlcmllcyBhcmUgYmVpbmcgY29sbGFwc2VkIGluIG11bHRpcGxlIHkgYXhlcywgaWdub3JlIGNlcnRhaW4gaW5kZXhcbiAgICAgICAgcGFkSG9yaXpvbnRhbDogMCxcbiAgICAgICAgbWF4VmFsc0luQXJyYXlJbmRleDogMCxcbiAgICAgICAgem9vbUVuYWJsZWQ6IGNvbmZpZy5jaGFydC50b29sYmFyLmF1dG9TZWxlY3RlZCA9PT0gJ3pvb20nICYmIGNvbmZpZy5jaGFydC50b29sYmFyLnRvb2xzLnpvb20gJiYgY29uZmlnLmNoYXJ0Lnpvb20uZW5hYmxlZCxcbiAgICAgICAgcGFuRW5hYmxlZDogY29uZmlnLmNoYXJ0LnRvb2xiYXIuYXV0b1NlbGVjdGVkID09PSAncGFuJyAmJiBjb25maWcuY2hhcnQudG9vbGJhci50b29scy5wYW4sXG4gICAgICAgIHNlbGVjdGlvbkVuYWJsZWQ6IGNvbmZpZy5jaGFydC50b29sYmFyLmF1dG9TZWxlY3RlZCA9PT0gJ3NlbGVjdGlvbicgJiYgY29uZmlnLmNoYXJ0LnRvb2xiYXIudG9vbHMuc2VsZWN0aW9uLFxuICAgICAgICB5YXhpczogbnVsbCxcbiAgICAgICAgbWluWTogTnVtYmVyLk1JTl9WQUxVRSxcbiAgICAgICAgLy8gIGlzIDVlLTMyNCwgaS5lLiB0aGUgc21hbGxlc3QgcG9zaXRpdmUgbnVtYmVyXG4gICAgICAgIC8vIE5PVEU6IElmIHRoZXJlIGFyZSBtdWx0aXBsZSB5IGF4aXMsIHRoZSBmaXJzdCB5YXhpcyBhcnJheSBlbGVtZW50IHdpbGwgYmUgY29uc2lkZXJlZCBmb3IgYWxsIHkgdmFsdWVzIGNhbGN1bGF0aW9ucy4gUmVzdCBhbGwgd2lsbCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoYXRcbiAgICAgICAgbWF4WTogLU51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIC8vIGlzIC0xLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAgICAvLyBOT1RFOiBUaGUgYWJvdmUgbm90ZSBmb3IgbWluWSBhcHBsaWVzIGhlcmUgYXMgd2VsbFxuICAgICAgICBtaW5ZQXJyOiBbXSxcbiAgICAgICAgbWF4WUFycjogW10sXG4gICAgICAgIG1heFg6IC1OdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAvLyBpcyAtMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgICAgaW5pdGlhbG1heFg6IC1OdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICBtaW5YOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgICAgICAvLyAgaXMgNWUtMzI0LCBpLmUuIHRoZSBzbWFsbGVzdCBwb3NpdGl2ZSBudW1iZXJcbiAgICAgICAgaW5pdGlhbG1pblg6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgIG1pblo6IE51bWJlci5NSU5fVkFMVUUsXG4gICAgICAgIC8vIE1heCBaIHZhbHVlIGluIGNoYXJ0cyB3aXRoIFogYXhpc1xuICAgICAgICBtYXhaOiAtTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgLy8gTWF4IFogdmFsdWUgaW4gY2hhcnRzIHdpdGggWiBheGlzXG4gICAgICAgIG1vdXNlZG93bjogZmFsc2UsXG4gICAgICAgIGxhc3RDbGllbnRQb3NpdGlvbjoge30sXG4gICAgICAgIC8vIGRvbid0IHJlc2V0IHRoaXMgdmFyaWFibGUgdGhpcyB0aGUgY2hhcnQgaXMgZGVzdHJveWVkLiBJdCBpcyB1c2VkIHRvIGRldGVjdCByaWdodCBvciBsZWZ0IG1vdXNlbW92ZSBpbiBwYW5uaW5nXG4gICAgICAgIHZpc2libGVYUmFuZ2U6IHVuZGVmaW5lZCxcbiAgICAgICAgeVJhbmdlOiBbXSxcbiAgICAgICAgLy8gdGhpcyBwcm9wZXJ0eSBpcyB0aGUgYWJzb2x1dGUgc3VtIG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgW2VnICgtMTAwICsgMjAwID0gMzAwKV0gLSB5QXhpc1xuICAgICAgICB6UmFuZ2U6IDAsXG4gICAgICAgIC8vIHpBeGlzIFJhbmdlIChmb3IgYnViYmxlIGNoYXJ0cylcbiAgICAgICAgeFJhbmdlOiAwLFxuICAgICAgICAvLyB4QXhpcyByYW5nZVxuICAgICAgICB5VmFsdWVEZWNpbWFsOiAwLFxuICAgICAgICAvLyBhcmUgdGhlcmUgZmxvYXRpbmcgbnVtYmVycyBpbiB0aGUgc2VyaWVzLiBJZiB5ZXMsIHRoaXMgcmVwcmVzZW50IHRoZSBsZW4gb2YgdGhlIGRlY2ltYWxzXG4gICAgICAgIHRvdGFsOiAwLFxuICAgICAgICBTVkdOUzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgLy8gc3ZnIG5hbWVzcGFjZVxuICAgICAgICBzdmdXaWR0aDogMCxcbiAgICAgICAgLy8gdGhlIHdob2xlIHN2ZyB3aWR0aFxuICAgICAgICBzdmdIZWlnaHQ6IDAsXG4gICAgICAgIC8vIHRoZSB3aG9sZSBzdmcgaGVpZ2h0XG4gICAgICAgIG5vRGF0YTogZmFsc2UsXG4gICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgaXMgYW55IGRhdGEgdG8gZGlzcGxheSBvciBub3RcbiAgICAgICAgbG9jYWxlOiB7fSxcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgbG9jYWxlIHZhbHVlcyB3aWxsIGJlIHByZXNlcnZlZCBoZXJlIGZvciBnbG9iYWwgYWNjZXNzXG4gICAgICAgIGRvbToge30sXG4gICAgICAgIC8vIGZvciBzdG9yaW5nIGFsbCBkb20gbm9kZXMgaW4gdGhpcyBwYXJ0aWN1bGFyIHByb3BlcnR5XG4gICAgICAgIC8vIGVsV3JhcDogbnVsbCwgLy8gdGhlIGVsZW1lbnQgdGhhdCB3cmFwcyBldmVyeXRoaW5nXG4gICAgICAgIC8vIGVsR3JhcGhpY2FsOiBudWxsLCAvLyB0aGlzIGNvbnRhaW5zIGxpbmVzL2FyZWFzL2JhcnMvcGllc1xuICAgICAgICAvLyBlbEdyaWRSZWN0OiBudWxsLCAvLyBwYXRocyBnb2luZyBvdXRzaWRlIHRoaXMgYXJlYSB3aWxsIGJlIGNsaXBwZWRcbiAgICAgICAgLy8gZWxHcmlkUmVjdE1hc2s6IG51bGwsIC8vIGNsaXBwaW5nIHdpbGwgaGFwcGVuIHdpdGggdGhpcyBtYXNrXG4gICAgICAgIC8vIGVsR3JpZFJlY3RNYXJrZXJNYXNrOiBudWxsLCAvLyBjbGlwcGluZyB3aWxsIGhhcHBlbiB3aXRoIHRoaXMgbWFza1xuICAgICAgICAvLyBlbExlZ2VuZFdyYXA6IG51bGwsIC8vIHRoZSB3aG9sZSBsZWdlbmQgYXJlYVxuICAgICAgICAvLyBlbERlZnM6IG51bGwsIC8vIFtkZWZzXSBlbGVtZW50XG4gICAgICAgIG1lbW9yeToge1xuICAgICAgICAgIG1ldGhvZHNUb0V4ZWM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZEFuaW1hdGU6IHRydWUsXG4gICAgICAgIGRlbGF5ZWRFbGVtZW50czogW10sXG4gICAgICAgIC8vIGVsZW1lbnQgd2hpY2ggYXBwZWFyIGFmdGVyIGFuaW1hdGlvbiBoYXMgZmluaXNoZWRcbiAgICAgICAgYXhpc0NoYXJ0czogdHJ1ZSxcbiAgICAgICAgLy8gY2hhcnQgdHlwZSA9IGxpbmUgb3IgYXJlYSBvciBiYXJcbiAgICAgICAgLy8gKHJlZmVyIHRoZW0gYWxzbyBhcyBwbG90IGNoYXJ0cyBpbiB0aGUgY29kZSlcbiAgICAgICAgaXNYTnVtZXJpYzogZmFsc2UsXG4gICAgICAgIC8vIGJvb2w6IGRhdGEgd2FzIHByb3ZpZGVkIGluIGEge1t4LHldLCBbeCx5XX0gcGF0dGVyblxuICAgICAgICBpc0RhdGFYWVo6IGZhbHNlLFxuICAgICAgICAvLyBib29sOiBkYXRhIHdhcyBwcm92aWRlZCBpbiBhIHtbeCx5LHpdfSBwYXR0ZXJuXG4gICAgICAgIHJlc2l6ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBib29sOiB1c2VyIGhhcyByZXNpemVkXG4gICAgICAgIHJlc2l6ZVRpbWVyOiBudWxsLFxuICAgICAgICAvLyB0aW1lb3V0IGZ1bmN0aW9uIHRvIG1ha2UgYSBzbWFsbCBkZWxheSBiZWZvcmVcbiAgICAgICAgLy8gZHJhd2luZyB3aGVuIHVzZXIgcmVzaXplZFxuICAgICAgICBjb21ib0NoYXJ0czogZmFsc2UsXG4gICAgICAgIC8vIGJvb2w6IHdoZXRoZXIgaXQncyBhIGNvbWJpbmF0aW9uIG9mIGxpbmUvY29sdW1uXG4gICAgICAgIGNvbWJvQ2hhcnRzSGFzQmFyczogZmFsc2UsXG4gICAgICAgIC8vIGJvb2w6IHdoZXRoZXIgaXQncyBhIGNvbWJpbmF0aW9uIG9mIGxpbmUvY29sdW1uXG4gICAgICAgIGRhdGFDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgLy8gYm9vbDogaGFzIGRhdGEgY2hhbmdlZCBkeW5hbWljYWxseVxuICAgICAgICBwcmV2aW91c1BhdGhzOiBbXSxcbiAgICAgICAgLy8gYXJyYXk6IHdoZW4gZGF0YSBpcyBjaGFuZ2VkLCBpdCB3aWxsIGFuaW1hdGUgZnJvbVxuICAgICAgICAvLyBwcmV2aW91cyBwYXRoc1xuICAgICAgICBzZXJpZXNYdmFsdWVzOiBbXSxcbiAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRoaXMgaW4gdG9vbHRpcCAoaXQncyB4IHBvc2l0aW9uKVxuICAgICAgICAvLyB3aGVuIHdlIHdpbGwgaGF2ZSB1bmVxdWFsIHggdmFsdWVzLCB3ZSB3aWxsIG5lZWRcbiAgICAgICAgLy8gc29tZSB3YXkgdG8gZ2V0IHggdmFsdWUgZGVwZW5kaW5nIG9uIG1vdXNlIHBvaW50ZXJcbiAgICAgICAgc2VyaWVzWXZhbHVlczogW10sXG4gICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0aGlzIHdoZW4gZGVjaWRpbmcgd2hpY2ggc2VyaWVzXG4gICAgICAgIC8vIHVzZXIgaG92ZXJlZCBvblxuICAgICAgICBzZXJpZXNDYW5kbGVPOiBbXSxcbiAgICAgICAgLy8gY2FuZGxlIHN0aWNrIG9wZW4gdmFsdWVzXG4gICAgICAgIHNlcmllc0NhbmRsZUg6IFtdLFxuICAgICAgICAvLyBjYW5kbGUgc3RpY2sgaGlnaCB2YWx1ZXNcbiAgICAgICAgc2VyaWVzQ2FuZGxlTDogW10sXG4gICAgICAgIC8vIGNhbmRsZSBzdGljayBsb3cgdmFsdWVzXG4gICAgICAgIHNlcmllc0NhbmRsZUM6IFtdLFxuICAgICAgICAvLyBjYW5kbGUgc3RpY2sgY2xvc2UgdmFsdWVzXG4gICAgICAgIGFsbFNlcmllc0hhc0VxdWFsWDogdHJ1ZSxcbiAgICAgICAgZGF0YVBvaW50czogMCxcbiAgICAgICAgLy8gdGhlIGxvbmdlc3Qgc2VyaWVzIGxlbmd0aFxuICAgICAgICBwb2ludHNBcnJheTogW10sXG4gICAgICAgIC8vIHN0b3JlIHRoZSBwb2ludHMgcG9zaXRpb25zIGhlcmUgdG8gZHJhdyBsYXRlciBvbiBob3ZlclxuICAgICAgICAvLyBmb3JtYXQgaXMgLSBbW3gseV0sW3gseV0uLi4gW3gseV1dXG4gICAgICAgIGRhdGFMYWJlbHNSZWN0czogW10sXG4gICAgICAgIC8vIHN0b3JlIHRoZSBwb3NpdGlvbnMgb2YgZGF0YWxhYmVscyB0byBwcmV2ZW50IGNvbGxpc2lvblxuICAgICAgICBsYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlczogW10sXG4gICAgICAgIGhhc051bGxWYWx1ZXM6IGZhbHNlLFxuICAgICAgICAvLyBib29sOiB3aGV0aGVyIHNlcmllcyBjb250YWlucyBudWxsIHZhbHVlc1xuICAgICAgICBlYXNpbmc6IG51bGwsXG4gICAgICAgIC8vIGZ1bmN0aW9uOiBhbmltYXRpb24gZWZmZWN0IHRvIGFwcGx5XG4gICAgICAgIHpvb21lZDogZmFsc2UsXG4gICAgICAgIC8vIHdoZXRoZXIgdXNlciBoYXMgem9vbWVkIG9yIG5vdFxuICAgICAgICBncmlkV2lkdGg6IDAsXG4gICAgICAgIC8vIGRyYXdhYmxlIHdpZHRoIG9mIGFjdHVhbCBncmFwaHMgKHNlcmllcyBwYXRocylcbiAgICAgICAgZ3JpZEhlaWdodDogMCxcbiAgICAgICAgLy8gZHJhd2FibGUgaGVpZ2h0IG9mIGFjdHVhbCBncmFwaHMgKHNlcmllcyBwYXRocylcbiAgICAgICAgeUF4aXNTY2FsZTogW10sXG4gICAgICAgIHhBeGlzU2NhbGU6IG51bGwsXG4gICAgICAgIHhBeGlzVGlja3NQb3NpdGlvbnM6IFtdLFxuICAgICAgICB0aW1lc2NhbGVUaWNrczogW10sXG4gICAgICAgIHJvdGF0ZVhMYWJlbHM6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0TGFiZWxzOiBmYWxzZSxcbiAgICAgICAgeExhYmVsRm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIGZvcm1hdHRlciBmb3IgeCBheGlzIGxhYmVsc1xuICAgICAgICB5TGFiZWxGb3JtYXR0ZXJzOiBbXSxcbiAgICAgICAgeGF4aXNUb29sdGlwRm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIGZvcm1hdHRlciBmb3IgeCBheGlzIHRvb2x0aXBcbiAgICAgICAgdHRLZXlGb3JtYXR0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgdHRWYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgdHRaRm9ybWF0dGVyOiB1bmRlZmluZWQsXG4gICAgICAgIExJTkVfSEVJR0hUX1JBVElPOiAxLjYxOCxcbiAgICAgICAgeEF4aXNMYWJlbHNIZWlnaHQ6IDAsXG4gICAgICAgIHlBeGlzTGFiZWxzV2lkdGg6IDAsXG4gICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgc2NhbGVZOiAxLFxuICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICB0cmFuc2xhdGVZOiAwLFxuICAgICAgICB0cmFuc2xhdGVZQXhpc1g6IFtdLFxuICAgICAgICB5TGFiZWxzQ29vcmRzOiBbXSxcbiAgICAgICAgeVRpdGxlQ29vcmRzOiBbXSxcbiAgICAgICAgeUF4aXNXaWR0aHM6IFtdLFxuICAgICAgICB0cmFuc2xhdGVYQXhpc1k6IDAsXG4gICAgICAgIHRyYW5zbGF0ZVhBeGlzWDogMCxcbiAgICAgICAgdG9vbHRpcDogbnVsbCxcbiAgICAgICAgdG9vbHRpcE9wdHM6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChjb25maWcpIHtcbiAgICAgIHZhciBnbG9iYWxzID0gdGhpcy5nbG9iYWxWYXJzKGNvbmZpZyk7XG4gICAgICBnbG9iYWxzLmluaXRpYWxDb25maWcgPSBVdGlscy5leHRlbmQoe30sIGNvbmZpZyk7XG4gICAgICBnbG9iYWxzLmluaXRpYWxTZXJpZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdsb2JhbHMuaW5pdGlhbENvbmZpZy5zZXJpZXMpKTtcbiAgICAgIGdsb2JhbHMubGFzdFhBeGlzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnbG9iYWxzLmluaXRpYWxDb25maWcueGF4aXMpKTtcbiAgICAgIGdsb2JhbHMubGFzdFlBeGlzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnbG9iYWxzLmluaXRpYWxDb25maWcueWF4aXMpKTtcbiAgICAgIHJldHVybiBnbG9iYWxzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHbG9iYWxzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgQmFzZSBDbGFzcyBmb3IgZXh0ZW5kaW5nIHVzZXIgb3B0aW9ucyB3aXRoIHByZS1kZWZpbmVkIEFwZXhDaGFydHMgY29uZmlnLlxuICpcbiAqIEBtb2R1bGUgQmFzZVxuICoqL1xuXG52YXIgQmFzZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2Uob3B0cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlKTtcblxuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIGNvbmZpZyA9IG5ldyBDb25maWcodGhpcy5vcHRzKS5pbml0KCk7XG4gICAgICB2YXIgZ2xvYmFscyA9IG5ldyBHbG9iYWxzKCkuaW5pdChjb25maWcpO1xuICAgICAgdmFyIHcgPSB7XG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICBnbG9iYWxzOiBnbG9iYWxzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2U7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBGaWxsIENsYXNzIGZvciBzZXR0aW5nIGZpbGwgb3B0aW9ucyBvZiB0aGUgcGF0aHMuXG4gKlxuICogQG1vZHVsZSBGaWxsXG4gKiovXG5cbnZhciBGaWxsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmlsbChjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsbCk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLm9wdHMgPSBudWxsO1xuICAgIHRoaXMuc2VyaWVzSW5kZXggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGwsIFt7XG4gICAga2V5OiBcImNsaXBwZWRJbWdBcmVhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsaXBwZWRJbWdBcmVhKHBhcmFtcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgY25mID0gdy5jb25maWc7XG4gICAgICB2YXIgc3ZnVyA9IHBhcnNlSW50KHcuZ2xvYmFscy5ncmlkV2lkdGgpO1xuICAgICAgdmFyIHN2Z0ggPSBwYXJzZUludCh3Lmdsb2JhbHMuZ3JpZEhlaWdodCk7XG4gICAgICB2YXIgc2l6ZSA9IHN2Z1cgPiBzdmdIID8gc3ZnVyA6IHN2Z0g7XG4gICAgICB2YXIgZmlsbEltZyA9IHBhcmFtcy5pbWFnZTtcbiAgICAgIHZhciBpbWdXaWR0aCA9IDA7XG4gICAgICB2YXIgaW1nSGVpZ2h0ID0gMDtcblxuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMud2lkdGggPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXJhbXMuaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoY25mLmZpbGwuaW1hZ2Uud2lkdGggIT09IHVuZGVmaW5lZCAmJiBjbmYuZmlsbC5pbWFnZS5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGltZ1dpZHRoID0gY25mLmZpbGwuaW1hZ2Uud2lkdGggKyAxO1xuICAgICAgICAgIGltZ0hlaWdodCA9IGNuZi5maWxsLmltYWdlLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbWdXaWR0aCA9IHNpemUgKyAxO1xuICAgICAgICAgIGltZ0hlaWdodCA9IHNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltZ1dpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgICBpbWdIZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxQYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ3BhdHRlcm4nKTtcbiAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGVsUGF0dGVybiwge1xuICAgICAgICBpZDogcGFyYW1zLnBhdHRlcm5JRCxcbiAgICAgICAgcGF0dGVyblVuaXRzOiBwYXJhbXMucGF0dGVyblVuaXRzID8gcGFyYW1zLnBhdHRlcm5Vbml0cyA6ICd1c2VyU3BhY2VPblVzZScsXG4gICAgICAgIHdpZHRoOiBpbWdXaWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogaW1nSGVpZ2h0ICsgJ3B4J1xuICAgICAgfSk7XG4gICAgICB2YXIgZWxJbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh3Lmdsb2JhbHMuU1ZHTlMsICdpbWFnZScpO1xuICAgICAgZWxQYXR0ZXJuLmFwcGVuZENoaWxkKGVsSW1hZ2UpO1xuICAgICAgZWxJbWFnZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgZmlsbEltZyk7XG4gICAgICBHcmFwaGljcy5zZXRBdHRycyhlbEltYWdlLCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86ICdub25lJyxcbiAgICAgICAgd2lkdGg6IGltZ1dpZHRoICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiBpbWdIZWlnaHQgKyAncHgnXG4gICAgICB9KTtcbiAgICAgIGVsSW1hZ2Uuc3R5bGUub3BhY2l0eSA9IHBhcmFtcy5vcGFjaXR5O1xuICAgICAgdy5nbG9iYWxzLmRvbS5lbERlZnMubm9kZS5hcHBlbmRDaGlsZChlbFBhdHRlcm4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXJpZXNJbmRleChvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kaXN0cmlidXRlZCB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IG9wdHMuc2VyaWVzTnVtYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IG9wdHMuc2VyaWVzTnVtYmVyICUgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNlcmllc0luZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWxsUGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsUGF0aChvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBwYXRoRmlsbDtcbiAgICAgIHZhciBwYXR0ZXJuRmlsbCwgZ3JhZGllbnRGaWxsO1xuICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IHRoaXMuZ2V0U2VyaWVzSW5kZXgob3B0cyk7XG4gICAgICB2YXIgZmlsbENvbG9ycyA9IHRoaXMuZ2V0RmlsbENvbG9ycygpO1xuICAgICAgdmFyIGZpbGxDb2xvciA9IGZpbGxDb2xvcnNbdGhpcy5zZXJpZXNJbmRleF07XG4gICAgICB2YXIgZmlsbFR5cGUgPSB0aGlzLmdldEZpbGxUeXBlKHRoaXMuc2VyaWVzSW5kZXgpO1xuICAgICAgdmFyIGZpbGxPcGFjaXR5ID0gQXJyYXkuaXNBcnJheShjbmYuZmlsbC5vcGFjaXR5KSA/IGNuZi5maWxsLm9wYWNpdHlbdGhpcy5zZXJpZXNJbmRleF0gOiBjbmYuZmlsbC5vcGFjaXR5O1xuICAgICAgdmFyIGRlZmF1bHRDb2xvciA9IGZpbGxDb2xvcjtcblxuICAgICAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICAgICAgZmlsbENvbG9yID0gb3B0cy5jb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGxDb2xvci5pbmRleE9mKCdyZ2InKSA9PT0gLTEpIHtcbiAgICAgICAgZGVmYXVsdENvbG9yID0gVXRpbHMuaGV4VG9SZ2JhKGZpbGxDb2xvciwgZmlsbE9wYWNpdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZpbGxDb2xvci5pbmRleE9mKCdyZ2JhJykgPiAtMSkge1xuICAgICAgICAgIGZpbGxPcGFjaXR5ID0gMCArICcuJyArIFV0aWxzLmdldE9wYWNpdHlGcm9tUkdCQShmaWxsQ29sb3JzW3RoaXMuc2VyaWVzSW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlsbFR5cGUgPT09ICdwYXR0ZXJuJykge1xuICAgICAgICBwYXR0ZXJuRmlsbCA9IHRoaXMuaGFuZGxlUGF0dGVybkZpbGwocGF0dGVybkZpbGwsIGZpbGxDb2xvciwgZmlsbE9wYWNpdHksIGRlZmF1bHRDb2xvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWxsVHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuICAgICAgICBncmFkaWVudEZpbGwgPSB0aGlzLmhhbmRsZUdyYWRpZW50RmlsbChncmFkaWVudEZpbGwsIGZpbGxDb2xvciwgZmlsbE9wYWNpdHksIHRoaXMuc2VyaWVzSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY25mLmZpbGwuaW1hZ2Uuc3JjLmxlbmd0aCA+IDAgJiYgZmlsbFR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgICAgaWYgKG9wdHMuc2VyaWVzTnVtYmVyIDwgY25mLmZpbGwuaW1hZ2Uuc3JjLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuY2xpcHBlZEltZ0FyZWEoe1xuICAgICAgICAgICAgb3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgICAgICAgICBpbWFnZTogY25mLmZpbGwuaW1hZ2Uuc3JjW29wdHMuc2VyaWVzTnVtYmVyXSxcbiAgICAgICAgICAgIHBhdHRlcm5Vbml0czogb3B0cy5wYXR0ZXJuVW5pdHMsXG4gICAgICAgICAgICBwYXR0ZXJuSUQ6IFwicGF0dGVyblwiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCkuY29uY2F0KG9wdHMuc2VyaWVzTnVtYmVyICsgMSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXRoRmlsbCA9IFwidXJsKCNwYXR0ZXJuXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkKS5jb25jYXQob3B0cy5zZXJpZXNOdW1iZXIgKyAxLCBcIilcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aEZpbGwgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlsbFR5cGUgPT09ICdncmFkaWVudCcpIHtcbiAgICAgICAgcGF0aEZpbGwgPSBncmFkaWVudEZpbGw7XG4gICAgICB9IGVsc2UgaWYgKGZpbGxUeXBlID09PSAncGF0dGVybicpIHtcbiAgICAgICAgcGF0aEZpbGwgPSBwYXR0ZXJuRmlsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGhGaWxsID0gZGVmYXVsdENvbG9yO1xuICAgICAgfSAvLyBvdmVycmlkZSBwYXR0ZXJuL2dyYWRpZW50IGlmIG9wdHMuc29saWQgaXMgdHJ1ZVxuXG5cbiAgICAgIGlmIChvcHRzLnNvbGlkKSB7XG4gICAgICAgIHBhdGhGaWxsID0gZGVmYXVsdENvbG9yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aEZpbGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpbGxUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbGxUeXBlKHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcuZmlsbC50eXBlKSkge1xuICAgICAgICByZXR1cm4gdy5jb25maWcuZmlsbC50eXBlW3Nlcmllc0luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3LmNvbmZpZy5maWxsLnR5cGU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpbGxDb2xvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsbENvbG9ycygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGNuZiA9IHcuY29uZmlnO1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICB2YXIgZmlsbENvbG9ycyA9IFtdO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5zZXJpZXNbdGhpcy5zZXJpZXNJbmRleF0udHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5zdHJva2UuY29sb3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZpbGxDb2xvcnMgPSB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsbENvbG9ycy5wdXNoKHcuZ2xvYmFscy5zdHJva2UuY29sb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5maWxsLmNvbG9ycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzID0gdy5nbG9iYWxzLmZpbGwuY29sb3JzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzLnB1c2gody5nbG9iYWxzLmZpbGwuY29sb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjbmYuY2hhcnQudHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5zdHJva2UuY29sb3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGZpbGxDb2xvcnMgPSB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsbENvbG9ycy5wdXNoKHcuZ2xvYmFscy5zdHJva2UuY29sb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5maWxsLmNvbG9ycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzID0gdy5nbG9iYWxzLmZpbGwuY29sb3JzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxsQ29sb3JzLnB1c2gody5nbG9iYWxzLmZpbGwuY29sb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY29sb3JzIHBhc3NlZCBpbiBhcmd1bWVudHNcblxuXG4gICAgICBpZiAodHlwZW9mIG9wdHMuZmlsbENvbG9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmlsbENvbG9ycyA9IFtdO1xuXG4gICAgICAgIGlmIChvcHRzLmZpbGxDb2xvcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIGZpbGxDb2xvcnMgPSBvcHRzLmZpbGxDb2xvcnMuc2xpY2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWxsQ29sb3JzLnB1c2gob3B0cy5maWxsQ29sb3JzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsbENvbG9ycztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlUGF0dGVybkZpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUGF0dGVybkZpbGwocGF0dGVybkZpbGwsIGZpbGxDb2xvciwgZmlsbE9wYWNpdHksIGRlZmF1bHRDb2xvcikge1xuICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0cztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgcGF0dGVyblN0cm9rZVdpZHRoID0gY25mLmZpbGwucGF0dGVybi5zdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gQXJyYXkuaXNBcnJheShjbmYuc3Ryb2tlLndpZHRoKSA/IGNuZi5zdHJva2Uud2lkdGhbdGhpcy5zZXJpZXNJbmRleF0gOiBjbmYuc3Ryb2tlLndpZHRoIDogQXJyYXkuaXNBcnJheShjbmYuZmlsbC5wYXR0ZXJuLnN0cm9rZVdpZHRoKSA/IGNuZi5maWxsLnBhdHRlcm4uc3Ryb2tlV2lkdGhbdGhpcy5zZXJpZXNJbmRleF0gOiBjbmYuZmlsbC5wYXR0ZXJuLnN0cm9rZVdpZHRoO1xuICAgICAgdmFyIHBhdHRlcm5MaW5lQ29sb3IgPSBmaWxsQ29sb3I7XG5cbiAgICAgIGlmIChjbmYuZmlsbC5wYXR0ZXJuLnN0eWxlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbmYuZmlsbC5wYXR0ZXJuLnN0eWxlW29wdHMuc2VyaWVzTnVtYmVyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgcGYgPSBncmFwaGljcy5kcmF3UGF0dGVybihjbmYuZmlsbC5wYXR0ZXJuLnN0eWxlW29wdHMuc2VyaWVzTnVtYmVyXSwgY25mLmZpbGwucGF0dGVybi53aWR0aCwgY25mLmZpbGwucGF0dGVybi5oZWlnaHQsIHBhdHRlcm5MaW5lQ29sb3IsIHBhdHRlcm5TdHJva2VXaWR0aCwgZmlsbE9wYWNpdHkpO1xuICAgICAgICAgIHBhdHRlcm5GaWxsID0gcGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0dGVybkZpbGwgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm5GaWxsID0gZ3JhcGhpY3MuZHJhd1BhdHRlcm4oY25mLmZpbGwucGF0dGVybi5zdHlsZSwgY25mLmZpbGwucGF0dGVybi53aWR0aCwgY25mLmZpbGwucGF0dGVybi5oZWlnaHQsIHBhdHRlcm5MaW5lQ29sb3IsIHBhdHRlcm5TdHJva2VXaWR0aCwgZmlsbE9wYWNpdHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0dGVybkZpbGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUdyYWRpZW50RmlsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVHcmFkaWVudEZpbGwoZ3JhZGllbnRGaWxsLCBmaWxsQ29sb3IsIGZpbGxPcGFjaXR5LCBpKSB7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciB1dGlscyA9IG5ldyBVdGlscygpO1xuICAgICAgdmFyIHR5cGUgPSBjbmYuZmlsbC5ncmFkaWVudC50eXBlO1xuICAgICAgdmFyIGdyYWRpZW50RnJvbSwgZ3JhZGllbnRUbztcbiAgICAgIHZhciBvcGFjaXR5RnJvbSA9IGNuZi5maWxsLmdyYWRpZW50Lm9wYWNpdHlGcm9tID09PSB1bmRlZmluZWQgPyBmaWxsT3BhY2l0eSA6IEFycmF5LmlzQXJyYXkoY25mLmZpbGwuZ3JhZGllbnQub3BhY2l0eUZyb20pID8gY25mLmZpbGwuZ3JhZGllbnQub3BhY2l0eUZyb21baV0gOiBjbmYuZmlsbC5ncmFkaWVudC5vcGFjaXR5RnJvbTtcbiAgICAgIHZhciBvcGFjaXR5VG8gPSBjbmYuZmlsbC5ncmFkaWVudC5vcGFjaXR5VG8gPT09IHVuZGVmaW5lZCA/IGZpbGxPcGFjaXR5IDogQXJyYXkuaXNBcnJheShjbmYuZmlsbC5ncmFkaWVudC5vcGFjaXR5VG8pID8gY25mLmZpbGwuZ3JhZGllbnQub3BhY2l0eVRvW2ldIDogY25mLmZpbGwuZ3JhZGllbnQub3BhY2l0eVRvO1xuICAgICAgZ3JhZGllbnRGcm9tID0gZmlsbENvbG9yO1xuXG4gICAgICBpZiAoY25mLmZpbGwuZ3JhZGllbnQuZ3JhZGllbnRUb0NvbG9ycyA9PT0gdW5kZWZpbmVkIHx8IGNuZi5maWxsLmdyYWRpZW50LmdyYWRpZW50VG9Db2xvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChjbmYuZmlsbC5ncmFkaWVudC5zaGFkZSA9PT0gJ2RhcmsnKSB7XG4gICAgICAgICAgZ3JhZGllbnRUbyA9IHV0aWxzLnNoYWRlQ29sb3IocGFyc2VGbG9hdChjbmYuZmlsbC5ncmFkaWVudC5zaGFkZUludGVuc2l0eSkgKiAtMSwgZmlsbENvbG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmFkaWVudFRvID0gdXRpbHMuc2hhZGVDb2xvcihwYXJzZUZsb2F0KGNuZi5maWxsLmdyYWRpZW50LnNoYWRlSW50ZW5zaXR5KSwgZmlsbENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JhZGllbnRUbyA9IGNuZi5maWxsLmdyYWRpZW50LmdyYWRpZW50VG9Db2xvcnNbb3B0cy5zZXJpZXNOdW1iZXJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY25mLmZpbGwuZ3JhZGllbnQuaW52ZXJzZUNvbG9ycykge1xuICAgICAgICB2YXIgdCA9IGdyYWRpZW50RnJvbTtcbiAgICAgICAgZ3JhZGllbnRGcm9tID0gZ3JhZGllbnRUbztcbiAgICAgICAgZ3JhZGllbnRUbyA9IHQ7XG4gICAgICB9XG5cbiAgICAgIGdyYWRpZW50RmlsbCA9IGdyYXBoaWNzLmRyYXdHcmFkaWVudCh0eXBlLCBncmFkaWVudEZyb20sIGdyYWRpZW50VG8sIG9wYWNpdHlGcm9tLCBvcGFjaXR5VG8sIG9wdHMuc2l6ZSwgY25mLmZpbGwuZ3JhZGllbnQuc3RvcHMsIGNuZi5maWxsLmdyYWRpZW50LmNvbG9yU3RvcHMsIGkpO1xuICAgICAgcmV0dXJuIGdyYWRpZW50RmlsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsbDtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIE1hcmtlcnMgQ2xhc3MgZm9yIGRyYXdpbmcgcG9pbnRzIG9uIHkgdmFsdWVzIGluIGF4ZXMgY2hhcnRzLlxuICpcbiAqIEBtb2R1bGUgTWFya2Vyc1xuICoqL1xuXG52YXIgTWFya2VycyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcmtlcnMoY3R4LCBvcHRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmtlcnMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWFya2VycywgW3tcbiAgICBrZXk6IFwic2V0R2xvYmFsTWFya2VyU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRHbG9iYWxNYXJrZXJTaXplKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB3Lmdsb2JhbHMubWFya2Vycy5zaXplID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5tYXJrZXJzLnNpemUpID8gdy5jb25maWcubWFya2Vycy5zaXplIDogW3cuY29uZmlnLm1hcmtlcnMuc2l6ZV07XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMubWFya2Vycy5zaXplLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5tYXJrZXJzLnNpemUubGVuZ3RoIDwgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB3Lmdsb2JhbHMubWFya2Vycy5zaXplLnB1c2gody5nbG9iYWxzLm1hcmtlcnMuc2l6ZVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lmdsb2JhbHMubWFya2Vycy5zaXplID0gdy5jb25maWcuc2VyaWVzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgIHJldHVybiB3LmNvbmZpZy5tYXJrZXJzLnNpemU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbG90Q2hhcnRNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsb3RDaGFydE1hcmtlcnMocG9pbnRzUG9zLCBzZXJpZXNJbmRleCwgaikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcCA9IHBvaW50c1BvcztcbiAgICAgIHZhciBlbFBvaW50c1dyYXAgPSBudWxsO1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBwb2ludDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbc2VyaWVzSW5kZXhdID4gMCkge1xuICAgICAgICBlbFBvaW50c1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzJ1xuICAgICAgICB9KTtcbiAgICAgICAgZWxQb2ludHNXcmFwLmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNncmlkUmVjdE1hcmtlck1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwLnggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChxKSB7XG4gICAgICAgICAgdmFyIGRhdGFQb2ludEluZGV4ID0gajsgLy8gYSBzbWFsbCBoYWNrIGFzIHdlIGhhdmUgMiBwb2ludHMgZm9yIHRoZSBmaXJzdCB2YWwgdG8gY29ubmVjdCBpdFxuXG4gICAgICAgICAgaWYgKGogPT09IDEgJiYgcSA9PT0gMCkgZGF0YVBvaW50SW5kZXggPSAwO1xuICAgICAgICAgIGlmIChqID09PSAxICYmIHEgPT09IDEpIGRhdGFQb2ludEluZGV4ID0gMTtcbiAgICAgICAgICB2YXIgUG9pbnRDbGFzc2VzID0gJ2FwZXhjaGFydHMtbWFya2VyJztcblxuICAgICAgICAgIGlmICgody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2xpbmUnIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdhcmVhJykgJiYgIXcuZ2xvYmFscy5jb21ib0NoYXJ0cyAmJiAhdy5jb25maWcudG9vbHRpcC5pbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIFBvaW50Q2xhc3NlcyArPSAnIG5vLXBvaW50ZXItZXZlbnRzJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2hvdWxkTWFya2VyRHJhdyA9IEFycmF5LmlzQXJyYXkody5jb25maWcubWFya2Vycy5zaXplKSA/IHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbc2VyaWVzSW5kZXhdID4gMCA6IHcuY29uZmlnLm1hcmtlcnMuc2l6ZSA+IDA7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkTWFya2VyRHJhdykge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKHAueVtxXSkpIHtcbiAgICAgICAgICAgICAgUG9pbnRDbGFzc2VzICs9IFwiIHdcIi5jb25jYXQoKE1hdGgucmFuZG9tKCkgKyAxKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFBvaW50Q2xhc3NlcyA9ICdhcGV4Y2hhcnRzLW51bGxwb2ludCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcHRzID0gX3RoaXMuZ2V0TWFya2VyQ29uZmlnKFBvaW50Q2xhc3Nlcywgc2VyaWVzSW5kZXgpOyAvLyBkaXNjcmV0ZSBtYXJrZXJzIGlzIGFuIG9wdGlvbiB3aGVyZSB1c2VyIGNhbiBzcGVjaWZ5IGEgcGFydGljdWxhciBtYXJrZXIgd2l0aCBkaWZmZXJlbnQgc2l6ZSBhbmQgY29sb3JcblxuXG4gICAgICAgICAgICB3LmNvbmZpZy5tYXJrZXJzLmRpc2NyZXRlLm1hcChmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgICAgICAgIGlmIChtYXJrZXIuc2VyaWVzSW5kZXggPT09IHNlcmllc0luZGV4ICYmIG1hcmtlci5kYXRhUG9pbnRJbmRleCA9PT0gZGF0YVBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBvaW50U3Ryb2tlQ29sb3IgPSBtYXJrZXIuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICAgICAgb3B0cy5wb2ludEZpbGxDb2xvciA9IG1hcmtlci5maWxsQ29sb3I7XG4gICAgICAgICAgICAgICAgb3B0cy5wU2l6ZSA9IG1hcmtlci5zaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvaW50ID0gZ3JhcGhpY3MuZHJhd01hcmtlcihwLnhbcV0sIHAueVtxXSwgb3B0cyk7XG4gICAgICAgICAgICBwb2ludC5hdHRyKCdyZWwnLCBkYXRhUG9pbnRJbmRleCk7XG4gICAgICAgICAgICBwb2ludC5hdHRyKCdqJywgZGF0YVBvaW50SW5kZXgpO1xuICAgICAgICAgICAgcG9pbnQuYXR0cignaW5kZXgnLCBzZXJpZXNJbmRleCk7XG4gICAgICAgICAgICBwb2ludC5ub2RlLnNldEF0dHJpYnV0ZSgnZGVmYXVsdC1tYXJrZXItc2l6ZScsIG9wdHMucFNpemUpO1xuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyhfdGhpcy5jdHgpO1xuICAgICAgICAgICAgZmlsdGVycy5zZXRTZWxlY3Rpb25GaWx0ZXIocG9pbnQsIHNlcmllc0luZGV4LCBkYXRhUG9pbnRJbmRleCk7XG5cbiAgICAgICAgICAgIF90aGlzLmFkZEV2ZW50cyhwb2ludCk7XG5cbiAgICAgICAgICAgIGlmIChlbFBvaW50c1dyYXApIHtcbiAgICAgICAgICAgICAgZWxQb2ludHNXcmFwLmFkZChwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgYXJyYXkgY3JlYXRpb24gLSBtdWx0aWRpbWVuc2lvbmFsXG4gICAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5wb2ludHNBcnJheVtzZXJpZXNJbmRleF0gPT09ICd1bmRlZmluZWQnKSB3Lmdsb2JhbHMucG9pbnRzQXJyYXlbc2VyaWVzSW5kZXhdID0gW107XG4gICAgICAgICAgICB3Lmdsb2JhbHMucG9pbnRzQXJyYXlbc2VyaWVzSW5kZXhdLnB1c2goW3AueFtxXSwgcC55W3FdXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgcC54Lmxlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgX2xvb3AocSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsUG9pbnRzV3JhcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFya2VyQ29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlckNvbmZpZyhjc3NDbGFzcywgc2VyaWVzSW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHBTdHlsZSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUoc2VyaWVzSW5kZXgpO1xuICAgICAgdmFyIHBTaXplID0gdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZVtzZXJpZXNJbmRleF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwU2l6ZTogcFNpemUsXG4gICAgICAgIHBSYWRpdXM6IHcuY29uZmlnLm1hcmtlcnMucmFkaXVzLFxuICAgICAgICBwV2lkdGg6IHcuY29uZmlnLm1hcmtlcnMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIHBvaW50U3Ryb2tlQ29sb3I6IHBTdHlsZS5wb2ludFN0cm9rZUNvbG9yLFxuICAgICAgICBwb2ludEZpbGxDb2xvcjogcFN0eWxlLnBvaW50RmlsbENvbG9yLFxuICAgICAgICBzaGFwZTogdy5jb25maWcubWFya2Vycy5zaGFwZSBpbnN0YW5jZW9mIEFycmF5ID8gdy5jb25maWcubWFya2Vycy5zaGFwZVtzZXJpZXNJbmRleF0gOiB3LmNvbmZpZy5tYXJrZXJzLnNoYXBlLFxuICAgICAgICBjbGFzczogY3NzQ2xhc3MsXG4gICAgICAgIHBvaW50U3Ryb2tlT3BhY2l0eTogdy5jb25maWcubWFya2Vycy5zdHJva2VPcGFjaXR5LFxuICAgICAgICBwb2ludEZpbGxPcGFjaXR5OiB3LmNvbmZpZy5tYXJrZXJzLmZpbGxPcGFjaXR5LFxuICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudHMoY2lyY2xlKSB7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgY2lyY2xlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGdyYXBoaWNzLnBhdGhNb3VzZUVudGVyLmJpbmQodGhpcy5jdHgsIGNpcmNsZSkpO1xuICAgICAgY2lyY2xlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGdyYXBoaWNzLnBhdGhNb3VzZUxlYXZlLmJpbmQodGhpcy5jdHgsIGNpcmNsZSkpO1xuICAgICAgY2lyY2xlLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZ3JhcGhpY3MucGF0aE1vdXNlRG93bi5iaW5kKHRoaXMuY3R4LCBjaXJjbGUpKTtcbiAgICAgIGNpcmNsZS5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBncmFwaGljcy5wYXRoTW91c2VEb3duLmJpbmQodGhpcy5jdHgsIGNpcmNsZSksIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcmtlclN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlclN0eWxlKHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBjb2xvcnMgPSB3Lmdsb2JhbHMubWFya2Vycy5jb2xvcnM7XG4gICAgICB2YXIgc3Ryb2tlQ29sb3JzID0gdy5jb25maWcubWFya2Vycy5zdHJva2VDb2xvciB8fCB3LmNvbmZpZy5tYXJrZXJzLnN0cm9rZUNvbG9ycztcbiAgICAgIHZhciBwb2ludFN0cm9rZUNvbG9yID0gc3Ryb2tlQ29sb3JzIGluc3RhbmNlb2YgQXJyYXkgPyBzdHJva2VDb2xvcnNbc2VyaWVzSW5kZXhdIDogc3Ryb2tlQ29sb3JzO1xuICAgICAgdmFyIHBvaW50RmlsbENvbG9yID0gY29sb3JzIGluc3RhbmNlb2YgQXJyYXkgPyBjb2xvcnNbc2VyaWVzSW5kZXhdIDogY29sb3JzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnRTdHJva2VDb2xvcjogcG9pbnRTdHJva2VDb2xvcixcbiAgICAgICAgcG9pbnRGaWxsQ29sb3I6IHBvaW50RmlsbENvbG9yXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXJrZXJzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgU2NhdHRlciBDbGFzcy5cbiAqIFRoaXMgQ2xhc3MgYWxzbyBoYW5kbGVzIGJ1YmJsZXMgY2hhcnQgYXMgY3VycmVudGx5IHRoZXJlIGlzIG5vIG1ham9yIGRpZmZlcmVuY2UgaW4gZHJhd2luZyB0aGVtLFxuICogQG1vZHVsZSBTY2F0dGVyXG4gKiovXG5cbnZhciBTY2F0dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NhdHRlcihjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NhdHRlcik7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmluaXRpYWxBbmltID0gdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmVuYWJsZWQ7XG4gICAgdGhpcy5keW5hbWljQW5pbSA9IHRoaXMuaW5pdGlhbEFuaW0gJiYgdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZDsgLy8gdGhpcyBhcnJheSB3aWxsIGhlbHAgaW4gY2VudGVyaW5nIHRoZSBsYWJlbCBpbiBidWJibGVzXG5cbiAgICB0aGlzLnJhZGl1c1NpemVzID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2NhdHRlciwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGVsU2VyaWVzLCBqLCBvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgcmVhbEluZGV4ID0gb3B0cy5yZWFsSW5kZXg7XG4gICAgICB2YXIgcG9pbnRzUG9zID0gb3B0cy5wb2ludHNQb3M7XG4gICAgICB2YXIgelJhdGlvID0gb3B0cy56UmF0aW87XG4gICAgICB2YXIgZWxQb2ludHNNYWluID0gb3B0cy5lbFBhcmVudDtcbiAgICAgIHZhciBlbFBvaW50c1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMgYXBleGNoYXJ0cy1zZXJpZXMtXCIuY29uY2F0KHcuY29uZmlnLmNoYXJ0LnR5cGUpXG4gICAgICB9KTtcbiAgICAgIGVsUG9pbnRzV3JhcC5hdHRyKCdjbGlwLXBhdGgnLCBcInVybCgjZ3JpZFJlY3RNYXJrZXJNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIikpO1xuXG4gICAgICBpZiAocG9pbnRzUG9zLnggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IHBvaW50c1Bvcy54Lmxlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgdmFyIGRhdGFQb2ludEluZGV4ID0gaiArIDE7XG4gICAgICAgICAgdmFyIHNob3VsZERyYXcgPSB0cnVlOyAvLyBhIHNtYWxsIGhhY2sgYXMgd2UgaGF2ZSAyIHBvaW50cyBmb3IgdGhlIGZpcnN0IHZhbCB0byBjb25uZWN0IGl0XG5cbiAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBxID09PSAwKSBkYXRhUG9pbnRJbmRleCA9IDA7XG4gICAgICAgICAgaWYgKGogPT09IDAgJiYgcSA9PT0gMSkgZGF0YVBvaW50SW5kZXggPSAxO1xuICAgICAgICAgIHZhciByYWRpdXMgPSAwO1xuICAgICAgICAgIHZhciBmaW5pc2hSYWRpdXMgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW3JlYWxJbmRleF07XG5cbiAgICAgICAgICBpZiAoelJhdGlvICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgLy8gbWVhbnMgd2UgaGF2ZSBhIGJ1YmJsZVxuICAgICAgICAgICAgZmluaXNoUmFkaXVzID0gdy5nbG9iYWxzLnNlcmllc1pbcmVhbEluZGV4XVtkYXRhUG9pbnRJbmRleF0gLyB6UmF0aW87XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5yYWRpdXNTaXplc1tyZWFsSW5kZXhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB0aGlzLnJhZGl1c1NpemVzLnB1c2goW10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJhZGl1c1NpemVzW3JlYWxJbmRleF0ucHVzaChmaW5pc2hSYWRpdXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICByYWRpdXMgPSBmaW5pc2hSYWRpdXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHggPSBwb2ludHNQb3MueFtxXTtcbiAgICAgICAgICB2YXIgeSA9IHBvaW50c1Bvcy55W3FdO1xuICAgICAgICAgIHJhZGl1cyA9IHJhZGl1cyB8fCAwO1xuXG4gICAgICAgICAgaWYgKHggPT09IDAgJiYgeSA9PT0gMCB8fCB5ID09PSBudWxsIHx8IHR5cGVvZiB3Lmdsb2JhbHMuc2VyaWVzW3JlYWxJbmRleF1bZGF0YVBvaW50SW5kZXhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2hvdWxkRHJhdyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGREcmF3KSB7XG4gICAgICAgICAgICB2YXIgY2lyY2xlID0gdGhpcy5kcmF3UG9pbnQoeCwgeSwgcmFkaXVzLCBmaW5pc2hSYWRpdXMsIHJlYWxJbmRleCwgZGF0YVBvaW50SW5kZXgsIGopO1xuICAgICAgICAgICAgZWxQb2ludHNXcmFwLmFkZChjaXJjbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsUG9pbnRzTWFpbi5hZGQoZWxQb2ludHNXcmFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BvaW50KHgsIHksIHJhZGl1cywgZmluaXNoUmFkaXVzLCByZWFsSW5kZXgsIGRhdGFQb2ludEluZGV4LCBqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBhbmltID0gbmV3IEFuaW1hdGlvbnModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgcGF0aEZpbGxDaXJjbGUgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgc2VyaWVzTnVtYmVyOiByZWFsSW5kZXgsXG4gICAgICAgIHBhdHRlcm5Vbml0czogJ29iamVjdEJvdW5kaW5nQm94J1xuICAgICAgfSk7XG4gICAgICB2YXIgY2lyY2xlID0gZ3JhcGhpY3MuZHJhd0NpcmNsZShyYWRpdXMpO1xuICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICBjeDogeCxcbiAgICAgICAgY3k6IHksXG4gICAgICAgIGZpbGw6IHBhdGhGaWxsQ2lyY2xlXG4gICAgICB9KTtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coY2lyY2xlLCB7XG4gICAgICAgICAgdG9wOiB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LnRvcCxcbiAgICAgICAgICBsZWZ0OiB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmxlZnQsXG4gICAgICAgICAgYmx1cjogdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5ibHVyLFxuICAgICAgICAgIGNvbG9yOiB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93LmNvbG9yLFxuICAgICAgICAgIG9wYWNpdHk6IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cub3BhY2l0eVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW5pdGlhbEFuaW0gJiYgIXcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICB2YXIgc3BlZWQgPSAxO1xuXG4gICAgICAgIGlmICghdy5nbG9iYWxzLnJlc2l6ZWQpIHtcbiAgICAgICAgICBzcGVlZCA9IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBhbmltLmFuaW1hdGVDaXJjbGVSYWRpdXMoY2lyY2xlLCAwLCBmaW5pc2hSYWRpdXMsIHNwZWVkLCB3Lmdsb2JhbHMuZWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICBpZiAodGhpcy5keW5hbWljQW5pbSkge1xuICAgICAgICAgIHZhciBfc3BlZWQgPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uc3BlZWQ7XG4gICAgICAgICAgdmFyIHByZXZYLCBwcmV2WSwgcHJldlI7XG4gICAgICAgICAgdmFyIHByZXZQYXRoSiA9IG51bGw7XG4gICAgICAgICAgcHJldlBhdGhKID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcmVhbEluZGV4XSAmJiB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1tyZWFsSW5kZXhdW2pdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcmV2UGF0aEogIT09ICd1bmRlZmluZWQnICYmIHByZXZQYXRoSiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gc2VyaWVzIGNvbnRhaW5pbmcgbGVzcyBlbGVtZW50cyB3aWxsIGlnbm9yZSB0aGVzZSB2YWx1ZXMgYW5kIHJldmVydCB0byAwXG4gICAgICAgICAgICBwcmV2WCA9IHByZXZQYXRoSi54O1xuICAgICAgICAgICAgcHJldlkgPSBwcmV2UGF0aEoueTtcbiAgICAgICAgICAgIHByZXZSID0gdHlwZW9mIHByZXZQYXRoSi5yICE9PSAndW5kZWZpbmVkJyA/IHByZXZQYXRoSi5yIDogZmluaXNoUmFkaXVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGNzID0gMDsgY3MgPCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aDsgY3MrKykge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNbY3NdLmluZGV4ID09PSByZWFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgX3NwZWVkID0gMTtcbiAgICAgICAgICAgICAgZmluaXNoUmFkaXVzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSBmaW5pc2hSYWRpdXMgPSAwO1xuICAgICAgICAgIGFuaW0uYW5pbWF0ZUNpcmNsZShjaXJjbGUsIHtcbiAgICAgICAgICAgIGN4OiBwcmV2WCxcbiAgICAgICAgICAgIGN5OiBwcmV2WSxcbiAgICAgICAgICAgIHI6IHByZXZSXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgY3g6IHgsXG4gICAgICAgICAgICBjeTogeSxcbiAgICAgICAgICAgIHI6IGZpbmlzaFJhZGl1c1xuICAgICAgICAgIH0sIF9zcGVlZCwgdy5nbG9iYWxzLmVhc2luZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICAgICAgcjogZmluaXNoUmFkaXVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICByZWw6IGRhdGFQb2ludEluZGV4LFxuICAgICAgICBqOiBkYXRhUG9pbnRJbmRleCxcbiAgICAgICAgaW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgJ2RlZmF1bHQtbWFya2VyLXNpemUnOiBmaW5pc2hSYWRpdXNcbiAgICAgIH0pO1xuICAgICAgdmFyIG1hcmtlcnMgPSBuZXcgTWFya2Vycyh0aGlzLmN0eCk7XG4gICAgICBmaWx0ZXJzLnNldFNlbGVjdGlvbkZpbHRlcihjaXJjbGUsIHJlYWxJbmRleCwgZGF0YVBvaW50SW5kZXgpO1xuICAgICAgbWFya2Vycy5hZGRFdmVudHMoY2lyY2xlKTtcbiAgICAgIGNpcmNsZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtbWFya2VyJyk7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjZW50ZXJUZXh0SW5CdWJibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2VudGVyVGV4dEluQnViYmxlKHkpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgeSA9IHkgKyBwYXJzZUludCh3LmNvbmZpZy5kYXRhTGFiZWxzLnN0eWxlLmZvbnRTaXplKSAvIDQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY2F0dGVyO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgRGF0YUxhYmVscyBDbGFzcyBmb3IgZHJhd2luZyBkYXRhTGFiZWxzIG9uIEF4ZXMgYmFzZWQgQ2hhcnRzLlxuICpcbiAqIEBtb2R1bGUgRGF0YUxhYmVsc1xuICoqL1xuXG52YXIgRGF0YUxhYmVscyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFMYWJlbHMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFMYWJlbHMpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH0gLy8gV2hlbiB0aGVyZSBhcmUgbWFueSBkYXRhbGFiZWxzIHRvIGJlIHByaW50ZWQsIGFuZCBzb21lIG9mIHRoZW0gb3ZlcmxhcHMgZWFjaCBvdGhlciBpbiB0aGUgc2FtZSBzZXJpZXMsIHRoaXMgbWV0aG9kIHdpbGwgdGFrZSBjYXJlIG9mIHRoYXRcbiAgLy8gQWxzbywgd2hlbiBkYXRhbGFiZWxzIGV4Y2VlZHMgdGhlIGRyYXdhYmxlIGFyZWEgYW5kIGdldCBjbGlwcGVkIG9mZiwgd2UgbmVlZCB0byBhZGp1c3QgYW5kIG1vdmUgc29tZSBwaXhlbHMgdG8gbWFrZSB0aGVtIHZpc2libGUgYWdhaW5cblxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhTGFiZWxzLCBbe1xuICAgIGtleTogXCJkYXRhTGFiZWxzQ29ycmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhTGFiZWxzQ29ycmVjdGlvbih4LCB5LCB2YWwsIGksIGRhdGFQb2ludEluZGV4LCBhbHdheXNEcmF3RGF0YUxhYmVsLCBmb250U2l6ZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGRyYXduZXh0TGFiZWwgPSBmYWxzZTsgLy9cblxuICAgICAgdmFyIHRleHRSZWN0cyA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWwsIGZvbnRTaXplKTtcbiAgICAgIHZhciB3aWR0aCA9IHRleHRSZWN0cy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0ZXh0UmVjdHMuaGVpZ2h0OyAvLyBmaXJzdCB2YWx1ZSBpbiBzZXJpZXMsIHNvIHB1c2ggYW4gZW1wdHkgYXJyYXlcblxuICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuZGF0YUxhYmVsc1JlY3RzW2ldID09PSAndW5kZWZpbmVkJykgdy5nbG9iYWxzLmRhdGFMYWJlbHNSZWN0c1tpXSA9IFtdOyAvLyB0aGVuIHN0YXJ0IHB1c2hpbmcgYWN0dWFsIHJlY3RzIGluIHRoYXQgc3ViLWFycmF5XG5cbiAgICAgIHcuZ2xvYmFscy5kYXRhTGFiZWxzUmVjdHNbaV0ucHVzaCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuICAgICAgdmFyIGxlbiA9IHcuZ2xvYmFscy5kYXRhTGFiZWxzUmVjdHNbaV0ubGVuZ3RoIC0gMjtcbiAgICAgIHZhciBsYXN0RHJhd25JbmRleCA9IHR5cGVvZiB3Lmdsb2JhbHMubGFzdERyYXduRGF0YUxhYmVsc0luZGV4ZXNbaV0gIT09ICd1bmRlZmluZWQnID8gdy5nbG9iYWxzLmxhc3REcmF3bkRhdGFMYWJlbHNJbmRleGVzW2ldW3cuZ2xvYmFscy5sYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlc1tpXS5sZW5ndGggLSAxXSA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLmRhdGFMYWJlbHNSZWN0c1tpXVtsZW5dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgbGFzdERhdGFMYWJlbFJlY3QgPSB3Lmdsb2JhbHMuZGF0YUxhYmVsc1JlY3RzW2ldW2xhc3REcmF3bkluZGV4XTtcblxuICAgICAgICBpZiAoIC8vIG5leHQgbGFiZWwgZm9yd2FyZCBhbmQgeCBub3QgaW50ZXJzZWN0aW5nXG4gICAgICAgIHggPiBsYXN0RGF0YUxhYmVsUmVjdC54ICsgbGFzdERhdGFMYWJlbFJlY3Qud2lkdGggKyAyIHx8IHkgPiBsYXN0RGF0YUxhYmVsUmVjdC55ICsgbGFzdERhdGFMYWJlbFJlY3QuaGVpZ2h0ICsgMiB8fCB4ICsgd2lkdGggPCBsYXN0RGF0YUxhYmVsUmVjdC54IC8vIG5leHQgbGFiZWwgaXMgZ29pbmcgdG8gYmUgZHJhd24gYmFja3dhcmRzXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gdGhlIDIgaW5kZXhlcyBkb24ndCBvdmVycmlkZSwgc28gT0sgdG8gZHJhdyBuZXh0IGxhYmVsXG4gICAgICAgICAgICBkcmF3bmV4dExhYmVsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhUG9pbnRJbmRleCA9PT0gMCB8fCBhbHdheXNEcmF3RGF0YUxhYmVsKSB7XG4gICAgICAgIGRyYXduZXh0TGFiZWwgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBkcmF3bmV4dExhYmVsOiBkcmF3bmV4dExhYmVsXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3RGF0YUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdEYXRhTGFiZWwocG9zLCBpLCBqKSB7XG4gICAgICAvLyB0aGlzIG1ldGhvZCBoYW5kbGVzIGxpbmUsIGFyZWEsIGJ1YmJsZSwgc2NhdHRlciBjaGFydHMgYXMgdGhvc2UgY2hhcnRzIGNvbnRhaW5zIG1hcmtlcnMvcG9pbnRzIHdoaWNoIGhhdmUgcHJlLWRlZmluZWQgeC95IHBvc2l0aW9uc1xuICAgICAgLy8gYWxsIG90aGVyIGNoYXJ0cyBsaWtlIGJhcnMgLyBoZWF0bWFwcyB3aWxsIGRlZmluZSB0aGVpciBvd24gZHJhd0RhdGFMYWJlbCByb3V0aW5lXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZGF0YUxhYmVsc0NvbmZpZyA9IHcuY29uZmlnLmRhdGFMYWJlbHM7XG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgeSA9IDA7XG4gICAgICB2YXIgZGF0YVBvaW50SW5kZXggPSBqO1xuICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSBudWxsO1xuXG4gICAgICBpZiAoIWRhdGFMYWJlbHNDb25maWcuZW5hYmxlZCB8fCBwb3MueCBpbnN0YW5jZW9mIEFycmF5ICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBlbERhdGFMYWJlbHNXcmFwO1xuICAgICAgfVxuXG4gICAgICBlbERhdGFMYWJlbHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YS1sYWJlbHMnXG4gICAgICB9KTtcbiAgICAgIGVsRGF0YUxhYmVsc1dyYXAuYXR0cignY2xpcC1wYXRoJywgXCJ1cmwoI2dyaWRSZWN0TWFya2VyTWFza1wiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCwgXCIpXCIpKTtcblxuICAgICAgZm9yICh2YXIgcSA9IDA7IHEgPCBwb3MueC5sZW5ndGg7IHErKykge1xuICAgICAgICB4ID0gcG9zLnhbcV0gKyBkYXRhTGFiZWxzQ29uZmlnLm9mZnNldFg7XG4gICAgICAgIHkgPSBwb3MueVtxXSArIGRhdGFMYWJlbHNDb25maWcub2Zmc2V0WSAtIHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbaV0gLSA1O1xuXG4gICAgICAgIGlmICghaXNOYU4oeCkpIHtcbiAgICAgICAgICAvLyBhIHNtYWxsIGhhY2sgYXMgd2UgaGF2ZSAyIHBvaW50cyBmb3IgdGhlIGZpcnN0IHZhbCB0byBjb25uZWN0IGl0XG4gICAgICAgICAgaWYgKGogPT09IDEgJiYgcSA9PT0gMCkgZGF0YVBvaW50SW5kZXggPSAwO1xuICAgICAgICAgIGlmIChqID09PSAxICYmIHEgPT09IDEpIGRhdGFQb2ludEluZGV4ID0gMTtcbiAgICAgICAgICB2YXIgdmFsID0gdy5nbG9iYWxzLnNlcmllc1tpXVtkYXRhUG9pbnRJbmRleF07XG4gICAgICAgICAgdmFyIHRleHQgPSAnJztcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYnViYmxlJykge1xuICAgICAgICAgICAgdGV4dCA9IHcuZ2xvYmFscy5zZXJpZXNaW2ldW2RhdGFQb2ludEluZGV4XTtcbiAgICAgICAgICAgIHkgPSBwb3MueVtxXSArIHcuY29uZmlnLmRhdGFMYWJlbHMub2Zmc2V0WTtcbiAgICAgICAgICAgIHZhciBzY2F0dGVyID0gbmV3IFNjYXR0ZXIodGhpcy5jdHgpO1xuICAgICAgICAgICAgdmFyIGNlbnRlclRleHRJbkJ1YmJsZUNvb3JkcyA9IHNjYXR0ZXIuY2VudGVyVGV4dEluQnViYmxlKHksIGksIGRhdGFQb2ludEluZGV4KTtcbiAgICAgICAgICAgIHkgPSBjZW50ZXJUZXh0SW5CdWJibGVDb29yZHMueTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRleHQgPSB3LmNvbmZpZy5kYXRhTGFiZWxzLmZvcm1hdHRlcih2YWwsIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgICAgICAgdzogd1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBsb3REYXRhTGFiZWxzVGV4dCh7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgajogZGF0YVBvaW50SW5kZXgsXG4gICAgICAgICAgICBwYXJlbnQ6IGVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICBvZmZzZXRDb3JyZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgZGF0YUxhYmVsc0NvbmZpZzogdy5jb25maWcuZGF0YUxhYmVsc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbERhdGFMYWJlbHNXcmFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbG90RGF0YUxhYmVsc1RleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxvdERhdGFMYWJlbHNUZXh0KG9wdHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciB4ID0gb3B0cy54LFxuICAgICAgICAgIHkgPSBvcHRzLnksXG4gICAgICAgICAgaSA9IG9wdHMuaSxcbiAgICAgICAgICBqID0gb3B0cy5qLFxuICAgICAgICAgIHRleHQgPSBvcHRzLnRleHQsXG4gICAgICAgICAgdGV4dEFuY2hvciA9IG9wdHMudGV4dEFuY2hvcixcbiAgICAgICAgICBwYXJlbnQgPSBvcHRzLnBhcmVudCxcbiAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnID0gb3B0cy5kYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIGFsd2F5c0RyYXdEYXRhTGFiZWwgPSBvcHRzLmFsd2F5c0RyYXdEYXRhTGFiZWwsXG4gICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbiA9IG9wdHMub2Zmc2V0Q29ycmVjdGlvbjtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkody5jb25maWcuZGF0YUxhYmVscy5lbmFibGVkT25TZXJpZXMpKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5kYXRhTGFiZWxzLmVuYWJsZWRPblNlcmllcy5pbmRleE9mKGkpID4gLTEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvcnJlY3RlZExhYmVscyA9IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgZHJhd25leHRMYWJlbDogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgaWYgKG9mZnNldENvcnJlY3Rpb24pIHtcbiAgICAgICAgY29ycmVjdGVkTGFiZWxzID0gdGhpcy5kYXRhTGFiZWxzQ29ycmVjdGlvbih4LCB5LCB0ZXh0LCBpLCBqLCBhbHdheXNEcmF3RGF0YUxhYmVsLCBwYXJzZUludChkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplKSk7XG4gICAgICB9IC8vIHdoZW4gem9vbWVkLCB3ZSBkb24ndCBuZWVkIHRvIGNvcnJlY3QgbGFiZWxzIG9mZnNldHMsXG4gICAgICAvLyBidXQgaWYgbm9ybWFsbHksIGxhYmVscyBnZXQgY3JvcHBlZCwgY29ycmVjdCB0aGVtXG5cblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuem9vbWVkKSB7XG4gICAgICAgIHggPSBjb3JyZWN0ZWRMYWJlbHMueDtcbiAgICAgICAgeSA9IGNvcnJlY3RlZExhYmVscy55O1xuICAgICAgfVxuXG4gICAgICBpZiAoY29ycmVjdGVkTGFiZWxzLmRyYXduZXh0TGFiZWwpIHtcbiAgICAgICAgdmFyIGRhdGFMYWJlbFRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgd2lkdGg6IDEwMCxcbiAgICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGRhdGFMYWJlbHNDb25maWcuc3R5bGUuZm9udFNpemUpLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBmb3JlQ29sb3I6IHcuZ2xvYmFscy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9yc1tpXSxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yIHx8IGRhdGFMYWJlbHNDb25maWcudGV4dEFuY2hvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGZvbnRTaXplOiBkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IGRhdGFMYWJlbHNDb25maWcuc3R5bGUuZm9udEZhbWlseVxuICAgICAgICB9KTtcbiAgICAgICAgZGF0YUxhYmVsVGV4dC5hdHRyKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YWxhYmVsJyxcbiAgICAgICAgICBjeDogeCxcbiAgICAgICAgICBjeTogeVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5kcm9wU2hhZG93LmVuYWJsZWQpIHtcbiAgICAgICAgICB2YXIgdGV4dFNoYWRvdyA9IGRhdGFMYWJlbHNDb25maWcuZHJvcFNoYWRvdztcbiAgICAgICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coZGF0YUxhYmVsVGV4dCwgdGV4dFNoYWRvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQuYWRkKGRhdGFMYWJlbFRleHQpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLmxhc3REcmF3bkRhdGFMYWJlbHNJbmRleGVzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHcuZ2xvYmFscy5sYXN0RHJhd25EYXRhTGFiZWxzSW5kZXhlc1tpXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdy5nbG9iYWxzLmxhc3REcmF3bkRhdGFMYWJlbHNJbmRleGVzW2ldLnB1c2goaik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGFMYWJlbHM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBCYXIgQ2xhc3MgcmVzcG9uc2libGUgZm9yIGRyYXdpbmcgYm90aCBDb2x1bW5zIGFuZCBCYXJzLlxuICpcbiAqIEBtb2R1bGUgQmFyXG4gKiovXG5cbnZhciBEQVRBX0xBQkVMU19XQVJOSU5HX1RIUkVTSE9MRCA9IDUwO1xuXG52YXIgQmFyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFyKGN0eCwgeHlSYXRpb3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFyKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMuYmFyT3B0aW9ucyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhcjtcbiAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IHRoaXMuYmFyT3B0aW9ucy5ob3Jpem9udGFsO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSB3LmNvbmZpZy5zdHJva2Uud2lkdGg7XG4gICAgdGhpcy5pc051bGxWYWx1ZSA9IGZhbHNlO1xuICAgIHRoaXMueHlSYXRpb3MgPSB4eVJhdGlvcztcblxuICAgIGlmICh0aGlzLnh5UmF0aW9zICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnhSYXRpbyA9IHh5UmF0aW9zLnhSYXRpbztcbiAgICAgIHRoaXMueVJhdGlvID0geHlSYXRpb3MueVJhdGlvO1xuICAgICAgdGhpcy5pbnZlcnRlZFhSYXRpbyA9IHh5UmF0aW9zLmludmVydGVkWFJhdGlvO1xuICAgICAgdGhpcy5pbnZlcnRlZFlSYXRpbyA9IHh5UmF0aW9zLmludmVydGVkWVJhdGlvO1xuICAgICAgdGhpcy5iYXNlTGluZVkgPSB4eVJhdGlvcy5iYXNlTGluZVk7XG4gICAgICB0aGlzLmJhc2VMaW5lSW52ZXJ0ZWRZID0geHlSYXRpb3MuYmFzZUxpbmVJbnZlcnRlZFk7XG4gICAgfVxuXG4gICAgdGhpcy5taW5YRGlmZiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdGhpcy55YXhpc0luZGV4ID0gMDtcbiAgICB0aGlzLnNlcmllc0xlbiA9IDA7XG4gIH1cbiAgLyoqIHByaW1hcnkgZHJhdyBtZXRob2Qgd2hpY2ggaXMgY2FsbGVkIG9uIGJhciBvYmplY3RcbiAgICogQG1lbWJlcm9mIEJhclxuICAgKiBAcGFyYW0ge2FycmF5fSBzZXJpZXMgLSB1c2VyIHN1cHBsaWVkIHNlcmllcyB2YWx1ZXNcbiAgICogQHBhcmFtIHtpbnR9IHNlcmllc0luZGV4IC0gdGhlIGluZGV4IGJ5IHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduIG9uIHRoZSBzdmdcbiAgICogQHJldHVybiB7bm9kZX0gZWxlbWVudCB3aGljaCBpcyBzdXBwbGllZCB0byBwYXJlbnQgY2hhcnQgZHJhdyBtZXRob2QgZm9yIGFwcGVuZGluZ1xuICAgKiovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmFyLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzLCBzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCwgdyk7XG4gICAgICB0aGlzLnNlcmllcyA9IGNvcmVVdGlscy5nZXRMb2dTZXJpZXMoc2VyaWVzKTtcbiAgICAgIHNlcmllcyA9IHRoaXMuc2VyaWVzO1xuICAgICAgdGhpcy55UmF0aW8gPSBjb3JlVXRpbHMuZ2V0TG9nWVJhdGlvcyh0aGlzLnlSYXRpbyk7XG4gICAgICB0aGlzLmluaXRWYXJpYWJsZXMoc2VyaWVzKTtcbiAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1iYXItc2VyaWVzIGFwZXhjaGFydHMtcGxvdC1zZXJpZXMnXG4gICAgICB9KTtcbiAgICAgIHJldC5hdHRyKCdjbGlwLXBhdGgnLCBcInVybCgjZ3JpZFJlY3RNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIikpO1xuXG4gICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5lbmFibGVkKSB7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsSXRlbXMgPiBEQVRBX0xBQkVMU19XQVJOSU5HX1RIUkVTSE9MRCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogRGF0YUxhYmVscyBhcmUgZW5hYmxlZCBidXQgdGhlcmUgYXJlIHRvbyBtYW55IHRvIGRpc3BsYXkuIFRoaXMgbWF5IGNhdXNlIHBlcmZvcm1hbmNlIGlzc3VlIHdoZW4gcmVuZGVyaW5nLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGksIGJjKSB7XG4gICAgICAgIHZhciBwYXRoVG8gPSB2b2lkIDAsXG4gICAgICAgICAgICBwYXRoRnJvbSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHggPSB2b2lkIDAsXG4gICAgICAgICAgICB5ID0gdm9pZCAwLFxuICAgICAgICAgICAgeERpdmlzaW9uID0gdm9pZCAwLFxuICAgICAgICAgICAgLy8geERpdmlzaW9uIGlzIHRoZSBHUklEV0lEVEggZGl2aWRlZCBieSBudW1iZXIgb2YgZGF0YXBvaW50cyAoY29sdW1ucylcbiAgICAgICAgeURpdmlzaW9uID0gdm9pZCAwLFxuICAgICAgICAgICAgLy8geURpdmlzaW9uIGlzIHRoZSBHUklESEVJR0hUIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGJhcnMpXG4gICAgICAgIHplcm9IID0gdm9pZCAwLFxuICAgICAgICAgICAgLy8gemVyb0ggaXMgdGhlIGJhc2VsaW5lIHdoZXJlIDAgbWVldHMgeSBheGlzXG4gICAgICAgIHplcm9XID0gdm9pZCAwOyAvLyB6ZXJvVyBpcyB0aGUgYmFzZWxpbmUgd2hlcmUgMCBtZWV0cyB4IGF4aXNcblxuICAgICAgICB2YXIgeUFycmogPSBbXTsgLy8gaG9sZCB5IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICB2YXIgeEFycmogPSBbXTsgLy8gaG9sZCB4IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICB2YXIgcmVhbEluZGV4ID0gdy5nbG9iYWxzLmNvbWJvQ2hhcnRzID8gc2VyaWVzSW5kZXhbaV0gOiBpOyAvLyBlbCB0byB3aGljaCBzZXJpZXMgd2lsbCBiZSBkcmF3blxuXG4gICAgICAgIHZhciBlbFNlcmllcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tyZWFsSW5kZXhdKSksXG4gICAgICAgICAgcmVsOiBpICsgMSxcbiAgICAgICAgICAnZGF0YTpyZWFsSW5kZXgnOiByZWFsSW5kZXhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuY3R4LnNlcmllcy5hZGRDb2xsYXBzZWRDbGFzc1RvU2VyaWVzKGVsU2VyaWVzLCByZWFsSW5kZXgpO1xuXG4gICAgICAgIGlmIChzZXJpZXNbaV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIF90aGlzLnZpc2libGVJID0gX3RoaXMudmlzaWJsZUkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIGJhckhlaWdodCA9IDA7XG4gICAgICAgIHZhciBiYXJXaWR0aCA9IDA7XG5cbiAgICAgICAgaWYgKF90aGlzLnlSYXRpby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgX3RoaXMueWF4aXNJbmRleCA9IHJlYWxJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmlzUmV2ZXJzZWQgPSB3LmNvbmZpZy55YXhpc1tfdGhpcy55YXhpc0luZGV4XSAmJiB3LmNvbmZpZy55YXhpc1tfdGhpcy55YXhpc0luZGV4XS5yZXZlcnNlZDtcblxuICAgICAgICB2YXIgaW5pdFBvc2l0aW9ucyA9IF90aGlzLmluaXRpYWxQb3NpdGlvbnMoKTtcblxuICAgICAgICB5ID0gaW5pdFBvc2l0aW9ucy55O1xuICAgICAgICBiYXJIZWlnaHQgPSBpbml0UG9zaXRpb25zLmJhckhlaWdodDtcbiAgICAgICAgeURpdmlzaW9uID0gaW5pdFBvc2l0aW9ucy55RGl2aXNpb247XG4gICAgICAgIHplcm9XID0gaW5pdFBvc2l0aW9ucy56ZXJvVztcbiAgICAgICAgeCA9IGluaXRQb3NpdGlvbnMueDtcbiAgICAgICAgYmFyV2lkdGggPSBpbml0UG9zaXRpb25zLmJhcldpZHRoO1xuICAgICAgICB4RGl2aXNpb24gPSBpbml0UG9zaXRpb25zLnhEaXZpc2lvbjtcbiAgICAgICAgemVyb0ggPSBpbml0UG9zaXRpb25zLnplcm9IO1xuXG4gICAgICAgIGlmICghX3RoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHhBcnJqLnB1c2goeCArIGJhcldpZHRoIC8gMik7XG4gICAgICAgIH0gLy8gZWxkYXRhbGFiZWxzXG5cblxuICAgICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YWxhYmVscydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihqLCB0aikge1xuICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMuc2VyaWVzW2ldW2pdID09PSAndW5kZWZpbmVkJyB8fCBzZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLmlzTnVsbFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuaXNOdWxsVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5jb25maWcuc3Ryb2tlLnNob3cpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc051bGxWYWx1ZSkge1xuICAgICAgICAgICAgICBzdHJva2VXaWR0aCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJva2VXaWR0aCA9IEFycmF5LmlzQXJyYXkoX3RoaXMuc3Ryb2tlV2lkdGgpID8gX3RoaXMuc3Ryb2tlV2lkdGhbcmVhbEluZGV4XSA6IF90aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXRocyA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoX3RoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBwYXRocyA9IF90aGlzLmRyYXdCYXJQYXRocyh7XG4gICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgICAgYmM6IGJjXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICAgIHplcm9XOiB6ZXJvVyxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgeURpdmlzaW9uOiB5RGl2aXNpb24sXG4gICAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGhzID0gX3RoaXMuZHJhd0NvbHVtblBhdGhzKHtcbiAgICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgICBiYzogYmNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgeERpdmlzaW9uOiB4RGl2aXNpb24sXG4gICAgICAgICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgemVyb0g6IHplcm9ILFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aFRvID0gcGF0aHMucGF0aFRvO1xuICAgICAgICAgIHBhdGhGcm9tID0gcGF0aHMucGF0aEZyb207XG4gICAgICAgICAgeSA9IHBhdGhzLnk7XG4gICAgICAgICAgeCA9IHBhdGhzLng7IC8vIHB1c2ggY3VycmVudCBYXG5cbiAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgIHhBcnJqLnB1c2goeCArIGJhcldpZHRoIC8gMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeUFycmoucHVzaCh5KTtcbiAgICAgICAgICB2YXIgc2VyaWVzTnVtYmVyID0gX3RoaXMuYmFyT3B0aW9ucy5kaXN0cmlidXRlZCA/IGogOiBpO1xuICAgICAgICAgIHZhciBmaWxsQ29sb3IgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKF90aGlzLmJhck9wdGlvbnMuY29sb3JzLnJhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgY29sb3JSYW5nZSA9IF90aGlzLmJhck9wdGlvbnMuY29sb3JzLnJhbmdlcztcbiAgICAgICAgICAgIGNvbG9yUmFuZ2UubWFwKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAoc2VyaWVzW2ldW2pdID49IHJhbmdlLmZyb20gJiYgc2VyaWVzW2ldW2pdIDw9IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICAgICAgZmlsbENvbG9yID0gcmFuZ2UuY29sb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXRoRmlsbCA9IGZpbGwuZmlsbFBhdGgoe1xuICAgICAgICAgICAgc2VyaWVzTnVtYmVyOiBfdGhpcy5iYXJPcHRpb25zLmRpc3RyaWJ1dGVkID8gc2VyaWVzTnVtYmVyIDogcmVhbEluZGV4LFxuICAgICAgICAgICAgY29sb3I6IGZpbGxDb2xvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsU2VyaWVzID0gX3RoaXMucmVuZGVyU2VyaWVzKHtcbiAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgcGF0aEZpbGw6IHBhdGhGaWxsLFxuICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgIGVsU2VyaWVzOiBlbFNlcmllcyxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgIGVsRGF0YUxhYmVsc1dyYXA6IGVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICB2aXNpYmxlU2VyaWVzOiBfdGhpcy52aXNpYmxlSSxcbiAgICAgICAgICAgIHR5cGU6ICdiYXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIHRqID0gdy5nbG9iYWxzLmRhdGFQb2ludHM7IGogPCB3Lmdsb2JhbHMuZGF0YVBvaW50czsgaisrLCB0ai0tKSB7XG4gICAgICAgICAgX2xvb3AyKGosIHRqKTtcbiAgICAgICAgfSAvLyBwdXNoIGFsbCB4IHZhbCBhcnJheXMgaW50byBtYWluIHhBcnJcblxuXG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3JlYWxJbmRleF0gPSB4QXJyajtcbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1l2YWx1ZXNbcmVhbEluZGV4XSA9IHlBcnJqO1xuICAgICAgICByZXQuYWRkKGVsU2VyaWVzKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBiYyA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyssIGJjKyspIHtcbiAgICAgICAgX2xvb3AoaSwgYmMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU2VyaWVzKF9yZWYpIHtcbiAgICAgIHZhciByZWFsSW5kZXggPSBfcmVmLnJlYWxJbmRleCxcbiAgICAgICAgICBwYXRoRmlsbCA9IF9yZWYucGF0aEZpbGwsXG4gICAgICAgICAgbGluZUZpbGwgPSBfcmVmLmxpbmVGaWxsLFxuICAgICAgICAgIGogPSBfcmVmLmosXG4gICAgICAgICAgaSA9IF9yZWYuaSxcbiAgICAgICAgICBwYXRoRnJvbSA9IF9yZWYucGF0aEZyb20sXG4gICAgICAgICAgcGF0aFRvID0gX3JlZi5wYXRoVG8sXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIGVsU2VyaWVzID0gX3JlZi5lbFNlcmllcyxcbiAgICAgICAgICB4ID0gX3JlZi54LFxuICAgICAgICAgIHkgPSBfcmVmLnksXG4gICAgICAgICAgc2VyaWVzID0gX3JlZi5zZXJpZXMsXG4gICAgICAgICAgYmFySGVpZ2h0ID0gX3JlZi5iYXJIZWlnaHQsXG4gICAgICAgICAgYmFyV2lkdGggPSBfcmVmLmJhcldpZHRoLFxuICAgICAgICAgIGVsRGF0YUxhYmVsc1dyYXAgPSBfcmVmLmVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgdmlzaWJsZVNlcmllcyA9IF9yZWYudmlzaWJsZVNlcmllcyxcbiAgICAgICAgICB0eXBlID0gX3JlZi50eXBlO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuXG4gICAgICBpZiAoIWxpbmVGaWxsKSB7XG4gICAgICAgIC8qIGZpeCBhcGV4Y2hhcnRzIzM0MSAqL1xuICAgICAgICBsaW5lRmlsbCA9IHRoaXMuYmFyT3B0aW9ucy5kaXN0cmlidXRlZCA/IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzW2pdIDogdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnNbcmVhbEluZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNOdWxsVmFsdWUpIHtcbiAgICAgICAgcGF0aEZpbGwgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWxheSA9IGogLyB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmFuaW1hdGVHcmFkdWFsbHkuZGVsYXkgKiAody5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzKSAvIDIuNDtcbiAgICAgIHZhciByZW5kZXJlZFBhdGggPSBncmFwaGljcy5yZW5kZXJQYXRocyh7XG4gICAgICAgIGk6IGksXG4gICAgICAgIGo6IGosXG4gICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBzdHJva2U6IGxpbmVGaWxsLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZUxpbmVDYXA6IHcuY29uZmlnLnN0cm9rZS5saW5lQ2FwLFxuICAgICAgICBmaWxsOiBwYXRoRmlsbCxcbiAgICAgICAgYW5pbWF0aW9uRGVsYXk6IGRlbGF5LFxuICAgICAgICBpbml0aWFsU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQsXG4gICAgICAgIGRhdGFDaGFuZ2VTcGVlZDogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLnNwZWVkLFxuICAgICAgICBjbGFzc05hbWU6IFwiYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItYXJlYVwiKSxcbiAgICAgICAgaWQ6IFwiYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItYXJlYVwiKVxuICAgICAgfSk7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIGZpbHRlcnMuc2V0U2VsZWN0aW9uRmlsdGVyKHJlbmRlcmVkUGF0aCwgcmVhbEluZGV4LCBqKTtcbiAgICAgIGVsU2VyaWVzLmFkZChyZW5kZXJlZFBhdGgpO1xuICAgICAgdmFyIGRhdGFMYWJlbHMgPSB0aGlzLmNhbGN1bGF0ZURhdGFMYWJlbHNQb3Moe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBpOiBpLFxuICAgICAgICBqOiBqLFxuICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgIHJlbmRlcmVkUGF0aDogcmVuZGVyZWRQYXRoLFxuICAgICAgICB2aXNpYmxlU2VyaWVzOiB2aXNpYmxlU2VyaWVzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGRhdGFMYWJlbHMgIT09IG51bGwpIHtcbiAgICAgICAgZWxEYXRhTGFiZWxzV3JhcC5hZGQoZGF0YUxhYmVscyk7XG4gICAgICB9XG5cbiAgICAgIGVsU2VyaWVzLmFkZChlbERhdGFMYWJlbHNXcmFwKTtcbiAgICAgIHJldHVybiBlbFNlcmllcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFZhcmlhYmxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0VmFyaWFibGVzKHNlcmllcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgICB0aGlzLnRvdGFsSXRlbXMgPSAwO1xuICAgICAgdGhpcy5zZXJpZXNMZW4gPSAwO1xuICAgICAgdGhpcy52aXNpYmxlSSA9IC0xO1xuICAgICAgdGhpcy52aXNpYmxlSXRlbXMgPSAxOyAvLyBudW1iZXIgb2YgdmlzaWJsZSBiYXJzIGFmdGVyIHVzZXIgem9vbWVkIGluL291dFxuXG4gICAgICBmb3IgKHZhciBzbCA9IDA7IHNsIDwgc2VyaWVzLmxlbmd0aDsgc2wrKykge1xuICAgICAgICBpZiAoc2VyaWVzW3NsXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5zZXJpZXNMZW4gPSB0aGlzLnNlcmllc0xlbiArIDE7XG4gICAgICAgICAgdGhpcy50b3RhbEl0ZW1zICs9IHNlcmllc1tzbF0ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgLy8gZ2V0IHRoZSBsZWFzdCB4IGRpZmYgaWYgbnVtZXJpYyB4IGF4aXMgaXMgcHJlc2VudFxuICAgICAgICAgIHcuZ2xvYmFscy5zZXJpZXNYLmZvckVhY2goZnVuY3Rpb24gKHNYLCBpKSB7XG4gICAgICAgICAgICBzWC5mb3JFYWNoKGZ1bmN0aW9uIChzLCBqKSB7XG4gICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciB4RGlmZiA9IHMgLSB3Lmdsb2JhbHMuc2VyaWVzWFtpXVtqIC0gMV07XG4gICAgICAgICAgICAgICAgX3RoaXMyLm1pblhEaWZmID0gTWF0aC5taW4oeERpZmYsIF90aGlzMi5taW5YRGlmZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pOyAvLyBnZXQgbWF4IHZpc2libGUgaXRlbXNcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VyaWVzW3NsXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXNYW3NsXVtqXSA+IHcuZ2xvYmFscy5taW5YICYmIHcuZ2xvYmFscy5zZXJpZXNYW3NsXVtqXSA8IHcuZ2xvYmFscy5tYXhYKSB7XG4gICAgICAgICAgICAgIHRoaXMudmlzaWJsZUl0ZW1zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2VyaWVzTGVuID09PSAwKSB7XG4gICAgICAgIC8vIEEgc21hbGwgYWRqdXN0bWVudCB3aGVuIGNvbWJvIGNoYXJ0cyBhcmUgdXNlZFxuICAgICAgICB0aGlzLnNlcmllc0xlbiA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxQb3NpdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbFBvc2l0aW9ucygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHgsIHksIHlEaXZpc2lvbiwgeERpdmlzaW9uLCBiYXJIZWlnaHQsIGJhcldpZHRoLCB6ZXJvSCwgemVyb1c7XG5cbiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBoZWlnaHQgZGl2aWRlZCBpbnRvIGVxdWFsIHBhcnRzXG4gICAgICAgIHlEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIGJhckhlaWdodCA9IHlEaXZpc2lvbiAvIHRoaXMuc2VyaWVzTGVuO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIHlEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdGhpcy50b3RhbEl0ZW1zO1xuICAgICAgICAgIGJhckhlaWdodCA9IHlEaXZpc2lvbiAvIHRoaXMuc2VyaWVzTGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFySGVpZ2h0ID0gYmFySGVpZ2h0ICogcGFyc2VJbnQodGhpcy5iYXJPcHRpb25zLmJhckhlaWdodCkgLyAxMDA7XG4gICAgICAgIHplcm9XID0gdGhpcy5iYXNlTGluZUludmVydGVkWSArIHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgKHRoaXMuaXNSZXZlcnNlZCA/IHcuZ2xvYmFscy5ncmlkV2lkdGggOiAwKSAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLmJhc2VMaW5lSW52ZXJ0ZWRZICogMiA6IDApO1xuICAgICAgICB5ID0gKHlEaXZpc2lvbiAtIGJhckhlaWdodCAqIHRoaXMuc2VyaWVzTGVuKSAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aWR0aCBkaXZpZGVkIGludG8gZXF1YWwgcGFydHNcbiAgICAgICAgeERpdmlzaW9uID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHRoaXMudmlzaWJsZUl0ZW1zO1xuICAgICAgICBiYXJXaWR0aCA9IHhEaXZpc2lvbiAvIHRoaXMuc2VyaWVzTGVuICogcGFyc2VJbnQodGhpcy5iYXJPcHRpb25zLmNvbHVtbldpZHRoKSAvIDEwMDtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAvLyBtYXggYmFyd2lkdGggc2hvdWxkIGJlIGVxdWFsIHRvIG1pblhEaWZmIHRvIGF2b2lkIG92ZXJsYXBcbiAgICAgICAgICBpZiAodGhpcy5taW5YRGlmZiA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgLy8gcG9zc2libHkgYSBzaW5nbGUgZGF0YVBvaW50IChmaXhlcyByZWFjdC1hcGV4Y2hhcnRzL2lzc3VlIzM0KVxuICAgICAgICAgICAgdmFyIGxlbiA9IHcuZ2xvYmFscy5sYWJlbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgbGVuID0gdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbiA8IDMpIHtcbiAgICAgICAgICAgICAgbGVuID0gMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5taW5YRGlmZiA9ICh3Lmdsb2JhbHMubWF4WCAtIHcuZ2xvYmFscy5taW5YKSAvIGxlbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4RGl2aXNpb24gPSB0aGlzLm1pblhEaWZmIC8gdGhpcy54UmF0aW87XG4gICAgICAgICAgYmFyV2lkdGggPSB4RGl2aXNpb24gLyB0aGlzLnNlcmllc0xlbiAqIHBhcnNlSW50KHRoaXMuYmFyT3B0aW9ucy5jb2x1bW5XaWR0aCkgLyAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICB6ZXJvSCA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gdGhpcy5iYXNlTGluZVlbdGhpcy55YXhpc0luZGV4XSAtICh0aGlzLmlzUmV2ZXJzZWQgPyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCA6IDApICsgKHRoaXMuaXNSZXZlcnNlZCA/IHRoaXMuYmFzZUxpbmVZW3RoaXMueWF4aXNJbmRleF0gKiAyIDogMCk7XG4gICAgICAgIHggPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArICh4RGl2aXNpb24gLSBiYXJXaWR0aCAqIHRoaXMuc2VyaWVzTGVuKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHlEaXZpc2lvbjogeURpdmlzaW9uLFxuICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgemVyb0g6IHplcm9ILFxuICAgICAgICB6ZXJvVzogemVyb1dcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdCYXJQYXRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFyUGF0aHMoX3JlZjIpIHtcbiAgICAgIHZhciBpbmRleGVzID0gX3JlZjIuaW5kZXhlcyxcbiAgICAgICAgICBiYXJIZWlnaHQgPSBfcmVmMi5iYXJIZWlnaHQsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmMi5zdHJva2VXaWR0aCxcbiAgICAgICAgICBwYXRoVG8gPSBfcmVmMi5wYXRoVG8sXG4gICAgICAgICAgcGF0aEZyb20gPSBfcmVmMi5wYXRoRnJvbSxcbiAgICAgICAgICB6ZXJvVyA9IF9yZWYyLnplcm9XLFxuICAgICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgICAgIHlEaXZpc2lvbiA9IF9yZWYyLnlEaXZpc2lvbixcbiAgICAgICAgICBlbFNlcmllcyA9IF9yZWYyLmVsU2VyaWVzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGkgPSBpbmRleGVzLmk7XG4gICAgICB2YXIgaiA9IGluZGV4ZXMuajtcbiAgICAgIHZhciByZWFsSW5kZXggPSBpbmRleGVzLnJlYWxJbmRleDtcbiAgICAgIHZhciBiYyA9IGluZGV4ZXMuYmM7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICB5ID0gKHcuZ2xvYmFscy5zZXJpZXNYW2ldW2pdIC0gdy5nbG9iYWxzLm1pblgpIC8gdGhpcy5pbnZlcnRlZFhSYXRpbyAtIGJhckhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhcllQb3NpdGlvbiA9IHkgKyBiYXJIZWlnaHQgKiB0aGlzLnZpc2libGVJO1xuICAgICAgcGF0aFRvID0gZ3JhcGhpY3MubW92ZSh6ZXJvVywgYmFyWVBvc2l0aW9uKTtcbiAgICAgIHBhdGhGcm9tID0gZ3JhcGhpY3MubW92ZSh6ZXJvVywgYmFyWVBvc2l0aW9uKTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGF0aEZyb20gPSB0aGlzLmdldFBhdGhGcm9tKHJlYWxJbmRleCwgaik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXJpZXNbaV1bal0gPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuc2VyaWVzW2ldW2pdID09PSBudWxsKSB7XG4gICAgICAgIHggPSB6ZXJvVztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB6ZXJvVyArIHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy5pbnZlcnRlZFlSYXRpbyAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW8gOiAwKSAqIDI7XG4gICAgICB9XG5cbiAgICAgIHBhdGhUbyA9IHBhdGhUbyArIGdyYXBoaWNzLmxpbmUoeCwgYmFyWVBvc2l0aW9uKSArIGdyYXBoaWNzLmxpbmUoeCwgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uKTtcbiAgICAgIHBhdGhGcm9tID0gcGF0aEZyb20gKyBncmFwaGljcy5saW5lKHplcm9XLCBiYXJZUG9zaXRpb24pICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uICsgYmFySGVpZ2h0IC0gc3Ryb2tlV2lkdGgpICsgZ3JhcGhpY3MubGluZSh6ZXJvVywgYmFyWVBvc2l0aW9uKTtcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICB5ID0geSArIHlEaXZpc2lvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFyT3B0aW9ucy5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9ycy5sZW5ndGggPiAwICYmIGkgPT09IDApIHtcbiAgICAgICAgaWYgKGJjID49IHRoaXMuYmFyT3B0aW9ucy5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBiYyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmNvbG9yID0gdGhpcy5iYXJPcHRpb25zLmNvbG9ycy5iYWNrZ3JvdW5kQmFyQ29sb3JzW2JjXTtcbiAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5kcmF3UmVjdCgwLCBiYXJZUG9zaXRpb24gLSBiYXJIZWlnaHQgKiB0aGlzLnZpc2libGVJLCB3Lmdsb2JhbHMuZ3JpZFdpZHRoLCBiYXJIZWlnaHQgKiB0aGlzLnNlcmllc0xlbiwgMCwgYmNvbG9yLCB0aGlzLmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJPcGFjaXR5KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGJhcllQb3NpdGlvbjogYmFyWVBvc2l0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q29sdW1uUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NvbHVtblBhdGhzKF9yZWYzKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IF9yZWYzLmluZGV4ZXMsXG4gICAgICAgICAgeCA9IF9yZWYzLngsXG4gICAgICAgICAgeSA9IF9yZWYzLnksXG4gICAgICAgICAgeERpdmlzaW9uID0gX3JlZjMueERpdmlzaW9uLFxuICAgICAgICAgIHBhdGhUbyA9IF9yZWYzLnBhdGhUbyxcbiAgICAgICAgICBwYXRoRnJvbSA9IF9yZWYzLnBhdGhGcm9tLFxuICAgICAgICAgIGJhcldpZHRoID0gX3JlZjMuYmFyV2lkdGgsXG4gICAgICAgICAgemVyb0ggPSBfcmVmMy56ZXJvSCxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IF9yZWYzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIGVsU2VyaWVzID0gX3JlZjMuZWxTZXJpZXM7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgaSA9IGluZGV4ZXMuaTtcbiAgICAgIHZhciBqID0gaW5kZXhlcy5qO1xuICAgICAgdmFyIHJlYWxJbmRleCA9IGluZGV4ZXMucmVhbEluZGV4O1xuICAgICAgdmFyIGJjID0gaW5kZXhlcy5iYztcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIHggPSAody5nbG9iYWxzLnNlcmllc1hbaV1bal0gLSB3Lmdsb2JhbHMubWluWCkgLyB0aGlzLnhSYXRpbyAtIGJhcldpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhclhQb3NpdGlvbiA9IHggKyBiYXJXaWR0aCAqIHRoaXMudmlzaWJsZUk7XG4gICAgICBwYXRoVG8gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgemVyb0gpO1xuICAgICAgcGF0aEZyb20gPSBncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgemVyb0gpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXRoRnJvbSA9IHRoaXMuZ2V0UGF0aEZyb20ocmVhbEluZGV4LCBqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc1tpXVtqXSA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5zZXJpZXNbaV1bal0gPT09IG51bGwpIHtcbiAgICAgICAgeSA9IHplcm9IO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHplcm9IIC0gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdICsgKHRoaXMuaXNSZXZlcnNlZCA/IHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XSA6IDApICogMjtcbiAgICAgIH1cblxuICAgICAgcGF0aFRvID0gcGF0aFRvICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIHkpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAtIHN0cm9rZVdpZHRoLCB5KSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgemVyb0gpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIHplcm9IKTtcbiAgICAgIHBhdGhGcm9tID0gcGF0aEZyb20gKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgemVyb0gpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAtIHN0cm9rZVdpZHRoLCB6ZXJvSCkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC0gc3Ryb2tlV2lkdGgsIHplcm9IKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uLCB6ZXJvSCk7XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgeCA9IHggKyB4RGl2aXNpb247XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoID4gMCAmJiBpID09PSAwKSB7XG4gICAgICAgIGlmIChiYyA+PSB0aGlzLmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgYmMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJjb2xvciA9IHRoaXMuYmFyT3B0aW9ucy5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9yc1tiY107XG4gICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZHJhd1JlY3QoYmFyWFBvc2l0aW9uIC0gYmFyV2lkdGggKiB0aGlzLnZpc2libGVJLCAwLCBiYXJXaWR0aCAqIHRoaXMuc2VyaWVzTGVuLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCwgMCwgYmNvbG9yLCB0aGlzLmJhck9wdGlvbnMuY29sb3JzLmJhY2tncm91bmRCYXJPcGFjaXR5KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogZ2V0UGF0aEZyb20gaXMgYSBjb21tb24gZnVuY3Rpb24gZm9yIGJhcnMvY29sdW1ucyB3aGljaCBpcyB1c2VkIHRvIGdldCBwcmV2aW91cyBwYXRocyB3aGVuIGRhdGEgY2hhbmdlcy5cbiAgICAgKiBAbWVtYmVyb2YgQmFyXG4gICAgICogQHBhcmFtIHtpbnR9IHJlYWxJbmRleCAtIGN1cnJlbnQgaXRlcmF0aW5nIGlcbiAgICAgKiBAcGFyYW0ge2ludH0gaiAtIGN1cnJlbnQgaXRlcmF0aW5nIHNlcmllcydzIGogaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHBhdGhGcm9tIGlzIHRoZSBzdHJpbmcgd2hpY2ggd2lsbCBiZSBhcHBlbmRlZCBpbiBhbmltYXRpb25zXG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGF0aEZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aEZyb20ocmVhbEluZGV4LCBqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwYXRoRnJvbTtcblxuICAgICAgZm9yICh2YXIgcHAgPSAwOyBwcCA8IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aDsgcHArKykge1xuICAgICAgICB2YXIgZ3BwID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdO1xuXG4gICAgICAgIGlmIChncHAucGF0aHMubGVuZ3RoID4gMCAmJiBwYXJzZUludChncHAucmVhbEluZGV4KSA9PT0gcGFyc2VJbnQocmVhbEluZGV4KSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF0aEZyb20gPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF0ucGF0aHNbal0uZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhGcm9tO1xuICAgIH1cbiAgICAvKiogY2FsY3VsYXRlQmFyRGF0YUxhYmVscyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb25zIGZvciB0aGUgZGF0YS1sYWJlbHNcbiAgICAgKiBJdCBhbHNvIHNldHMgdGhlIGVsZW1lbnQncyBkYXRhIGF0dHIgZm9yIGJhcnMgYW5kIGNhbGxzIGRyYXdDYWxjdWxhdGVkQmFyRGF0YUxhYmVscygpXG4gICAgICogQG1lbWJlcm9mIEJhclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB7YmFyUHJvcHN9IG1vc3Qgb2YgdGhlIGJhciBwcm9wZXJ0aWVzIHVzZWQgdGhyb3VnaG91dCB0aGUgYmFyXG4gICAgICogZHJhd2luZyBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge29iamVjdH0gZGF0YUxhYmVscyBub2RlLWVsZW1lbnQgd2hpY2ggeW91IGNhbiBhcHBlbmQgbGF0ZXJcbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVEYXRhTGFiZWxzUG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZURhdGFMYWJlbHNQb3MoX3JlZjQpIHtcbiAgICAgIHZhciB4ID0gX3JlZjQueCxcbiAgICAgICAgICB5ID0gX3JlZjQueSxcbiAgICAgICAgICBpID0gX3JlZjQuaSxcbiAgICAgICAgICBqID0gX3JlZjQuaixcbiAgICAgICAgICByZWFsSW5kZXggPSBfcmVmNC5yZWFsSW5kZXgsXG4gICAgICAgICAgc2VyaWVzID0gX3JlZjQuc2VyaWVzLFxuICAgICAgICAgIGJhckhlaWdodCA9IF9yZWY0LmJhckhlaWdodCxcbiAgICAgICAgICBiYXJXaWR0aCA9IF9yZWY0LmJhcldpZHRoLFxuICAgICAgICAgIHZpc2libGVTZXJpZXMgPSBfcmVmNC52aXNpYmxlU2VyaWVzLFxuICAgICAgICAgIHJlbmRlcmVkUGF0aCA9IF9yZWY0LnJlbmRlcmVkUGF0aDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IEFycmF5LmlzQXJyYXkodGhpcy5zdHJva2VXaWR0aCkgPyB0aGlzLnN0cm9rZVdpZHRoW3JlYWxJbmRleF0gOiB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgdmFyIGJjeCA9IHggKyBwYXJzZUZsb2F0KGJhcldpZHRoICogdmlzaWJsZVNlcmllcyk7XG4gICAgICB2YXIgYmN5ID0geSArIHBhcnNlRmxvYXQoYmFySGVpZ2h0ICogdmlzaWJsZVNlcmllcyk7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICBiY3ggPSB4ICsgcGFyc2VGbG9hdChiYXJXaWR0aCAqICh2aXNpYmxlU2VyaWVzICsgMSkpIC0gc3Ryb2tlV2lkdGg7XG4gICAgICAgIGJjeSA9IHkgKyBwYXJzZUZsb2F0KGJhckhlaWdodCAqICh2aXNpYmxlU2VyaWVzICsgMSkpIC0gc3Ryb2tlV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhTGFiZWxzID0gbnVsbDtcbiAgICAgIHZhciBkYXRhTGFiZWxzWCA9IHg7XG4gICAgICB2YXIgZGF0YUxhYmVsc1kgPSB5O1xuICAgICAgdmFyIGRhdGFMYWJlbHNQb3MgPSB7fTtcbiAgICAgIHZhciBkYXRhTGFiZWxzQ29uZmlnID0gdy5jb25maWcuZGF0YUxhYmVscztcbiAgICAgIHZhciBiYXJEYXRhTGFiZWxzQ29uZmlnID0gdGhpcy5iYXJPcHRpb25zLmRhdGFMYWJlbHM7XG4gICAgICB2YXIgb2ZmWCA9IGRhdGFMYWJlbHNDb25maWcub2Zmc2V0WDtcbiAgICAgIHZhciBvZmZZID0gZGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRZO1xuICAgICAgdmFyIHRleHRSZWN0cyA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcblxuICAgICAgaWYgKHcuY29uZmlnLmRhdGFMYWJlbHMuZW5hYmxlZCkge1xuICAgICAgICB0ZXh0UmVjdHMgPSBncmFwaGljcy5nZXRUZXh0UmVjdHMody5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbMF0ody5nbG9iYWxzLm1heFkpLCBwYXJzZUludChkYXRhTGFiZWxzQ29uZmlnLnN0eWxlLmZvbnRTaXplKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICBkYXRhTGFiZWxzUG9zID0gdGhpcy5jYWxjdWxhdGVCYXJzRGF0YUxhYmVsc1Bvc2l0aW9uKHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHJlbmRlcmVkUGF0aDogcmVuZGVyZWRQYXRoLFxuICAgICAgICAgIGJjeTogYmN5LFxuICAgICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgIHRleHRSZWN0czogdGV4dFJlY3RzLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICBkYXRhTGFiZWxzWDogZGF0YUxhYmVsc1gsXG4gICAgICAgICAgZGF0YUxhYmVsc1k6IGRhdGFMYWJlbHNZLFxuICAgICAgICAgIGJhckRhdGFMYWJlbHNDb25maWc6IGJhckRhdGFMYWJlbHNDb25maWcsXG4gICAgICAgICAgb2ZmWDogb2ZmWCxcbiAgICAgICAgICBvZmZZOiBvZmZZXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YUxhYmVsc1BvcyA9IHRoaXMuY2FsY3VsYXRlQ29sdW1uc0RhdGFMYWJlbHNQb3NpdGlvbih7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgajogaixcbiAgICAgICAgICByZW5kZXJlZFBhdGg6IHJlbmRlcmVkUGF0aCxcbiAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICBiY3g6IGJjeCxcbiAgICAgICAgICBiY3k6IGJjeSxcbiAgICAgICAgICBiYXJIZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgdGV4dFJlY3RzOiB0ZXh0UmVjdHMsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGRhdGFMYWJlbHNZOiBkYXRhTGFiZWxzWSxcbiAgICAgICAgICBiYXJEYXRhTGFiZWxzQ29uZmlnOiBiYXJEYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIG9mZlg6IG9mZlgsXG4gICAgICAgICAgb2ZmWTogb2ZmWVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZWRQYXRoLmF0dHIoe1xuICAgICAgICBjeTogZGF0YUxhYmVsc1Bvcy5iY3ksXG4gICAgICAgIGN4OiBkYXRhTGFiZWxzUG9zLmJjeCxcbiAgICAgICAgajogaixcbiAgICAgICAgdmFsOiBzZXJpZXNbaV1bal0sXG4gICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGhcbiAgICAgIH0pO1xuICAgICAgZGF0YUxhYmVscyA9IHRoaXMuZHJhd0NhbGN1bGF0ZWREYXRhTGFiZWxzKHtcbiAgICAgICAgeDogZGF0YUxhYmVsc1Bvcy5kYXRhTGFiZWxzWCxcbiAgICAgICAgeTogZGF0YUxhYmVsc1Bvcy5kYXRhTGFiZWxzWSxcbiAgICAgICAgdmFsOiBzZXJpZXNbaV1bal0sXG4gICAgICAgIGk6IHJlYWxJbmRleCxcbiAgICAgICAgajogaixcbiAgICAgICAgZGF0YUxhYmVsc0NvbmZpZzogZGF0YUxhYmVsc0NvbmZpZ1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGF0YUxhYmVscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlQ29sdW1uc0RhdGFMYWJlbHNQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVDb2x1bW5zRGF0YUxhYmVsc1Bvc2l0aW9uKG9wdHMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGkgPSBvcHRzLmksXG4gICAgICAgICAgaiA9IG9wdHMuaixcbiAgICAgICAgICByZWFsSW5kZXggPSBvcHRzLnJlYWxJbmRleCxcbiAgICAgICAgICB5ID0gb3B0cy55LFxuICAgICAgICAgIGJjeCA9IG9wdHMuYmN4LFxuICAgICAgICAgIGJhcldpZHRoID0gb3B0cy5iYXJXaWR0aCxcbiAgICAgICAgICB0ZXh0UmVjdHMgPSBvcHRzLnRleHRSZWN0cyxcbiAgICAgICAgICBkYXRhTGFiZWxzWSA9IG9wdHMuZGF0YUxhYmVsc1ksXG4gICAgICAgICAgYmFyRGF0YUxhYmVsc0NvbmZpZyA9IG9wdHMuYmFyRGF0YUxhYmVsc0NvbmZpZyxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgb2ZmWCA9IG9wdHMub2ZmWCxcbiAgICAgICAgICBvZmZZID0gb3B0cy5vZmZZO1xuICAgICAgdmFyIGRhdGFMYWJlbHNYO1xuICAgICAgdmFyIGJhckhlaWdodCA9IHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy55UmF0aW9bdGhpcy55YXhpc0luZGV4XTtcbiAgICAgIHZhciBkYXRhUG9pbnRzRGl2aWRlZFdpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuICAgICAgYmN4ID0gYmN4IC0gc3Ryb2tlV2lkdGggLyAyO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgZGF0YUxhYmVsc1ggPSBiY3ggLSBiYXJXaWR0aCAvIDIgKyBvZmZYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YUxhYmVsc1ggPSBiY3ggLSBkYXRhUG9pbnRzRGl2aWRlZFdpZHRoICsgYmFyV2lkdGggLyAyICsgb2ZmWDtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbElzTmVnYXRpdmUgPSB0aGlzLnNlcmllc1tpXVtqXSA8PSAwO1xuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbdGhpcy55YXhpc0luZGV4XS5yZXZlcnNlZCkge1xuICAgICAgICB5ID0geSAtIGJhckhlaWdodDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChiYXJEYXRhTGFiZWxzQ29uZmlnLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNZID0geSArIGJhckhlaWdodCAvIDIgKyB0ZXh0UmVjdHMuaGVpZ2h0IC8gMiArIG9mZlk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNZID0geSArIGJhckhlaWdodCAvIDIgKyB0ZXh0UmVjdHMuaGVpZ2h0IC8gMiAtIG9mZlk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICBpZiAodmFsSXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSB5ICsgYmFySGVpZ2h0ICsgdGV4dFJlY3RzLmhlaWdodCArIHN0cm9rZVdpZHRoICsgb2ZmWTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSB5ICsgYmFySGVpZ2h0IC0gdGV4dFJlY3RzLmhlaWdodCAvIDIgKyBzdHJva2VXaWR0aCAtIG9mZlk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICBpZiAodmFsSXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1kgPSB5IC0gdGV4dFJlY3RzLmhlaWdodCAvIDIgLSBvZmZZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWSA9IHkgKyB0ZXh0UmVjdHMuaGVpZ2h0ICsgb2ZmWTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmN4OiBiY3gsXG4gICAgICAgIGJjeTogeSxcbiAgICAgICAgZGF0YUxhYmVsc1g6IGRhdGFMYWJlbHNYLFxuICAgICAgICBkYXRhTGFiZWxzWTogZGF0YUxhYmVsc1lcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUJhcnNEYXRhTGFiZWxzUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlQmFyc0RhdGFMYWJlbHNQb3NpdGlvbihvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4ID0gb3B0cy54LFxuICAgICAgICAgIGkgPSBvcHRzLmksXG4gICAgICAgICAgaiA9IG9wdHMuaixcbiAgICAgICAgICBiY3kgPSBvcHRzLmJjeSxcbiAgICAgICAgICBiYXJIZWlnaHQgPSBvcHRzLmJhckhlaWdodCxcbiAgICAgICAgICB0ZXh0UmVjdHMgPSBvcHRzLnRleHRSZWN0cyxcbiAgICAgICAgICBkYXRhTGFiZWxzWCA9IG9wdHMuZGF0YUxhYmVsc1gsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIGJhckRhdGFMYWJlbHNDb25maWcgPSBvcHRzLmJhckRhdGFMYWJlbHNDb25maWcsXG4gICAgICAgICAgb2ZmWCA9IG9wdHMub2ZmWCxcbiAgICAgICAgICBvZmZZID0gb3B0cy5vZmZZO1xuICAgICAgdmFyIGRhdGFQb2ludHNEaXZpZGVkSGVpZ2h0ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB3Lmdsb2JhbHMuZGF0YVBvaW50cztcbiAgICAgIHZhciBkYXRhTGFiZWxzWSA9IGJjeSAtIGRhdGFQb2ludHNEaXZpZGVkSGVpZ2h0ICsgYmFySGVpZ2h0IC8gMiArIHRleHRSZWN0cy5oZWlnaHQgLyAyICsgb2ZmWSAtIDM7XG4gICAgICB2YXIgYmFyV2lkdGggPSB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW87XG4gICAgICB2YXIgdmFsSXNOZWdhdGl2ZSA9IHRoaXMuc2VyaWVzW2ldW2pdIDw9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1t0aGlzLnlheGlzSW5kZXhdLnJldmVyc2VkKSB7XG4gICAgICAgIHggPSB4ICsgYmFyV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoYmFyRGF0YUxhYmVsc0NvbmZpZy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGlmICh2YWxJc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWCA9IHggLSBiYXJXaWR0aCAvIDIgLSBvZmZYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhTGFiZWxzWCA9IHggLSBiYXJXaWR0aCAvIDIgKyBvZmZYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNYID0geCAtIGJhcldpZHRoIC0gc3Ryb2tlV2lkdGggLSBNYXRoLnJvdW5kKHRleHRSZWN0cy53aWR0aCAvIDIpIC0gb2ZmWDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUxhYmVsc1ggPSB4IC0gYmFyV2lkdGggKyBzdHJva2VXaWR0aCArIE1hdGgucm91bmQodGV4dFJlY3RzLndpZHRoIC8gMikgKyBvZmZYO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgaWYgKHZhbElzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNYID0geCAtIHN0cm9rZVdpZHRoICsgTWF0aC5yb3VuZCh0ZXh0UmVjdHMud2lkdGggLyAyKSAtIG9mZlg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbHNYID0geCAtIHN0cm9rZVdpZHRoIC0gTWF0aC5yb3VuZCh0ZXh0UmVjdHMud2lkdGggLyAyKSArIG9mZlg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhTGFiZWxzWCA8IDApIHtcbiAgICAgICAgZGF0YUxhYmVsc1ggPSB0ZXh0UmVjdHMud2lkdGggKyBzdHJva2VXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YUxhYmVsc1ggKyB0ZXh0UmVjdHMud2lkdGggLyAyID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkge1xuICAgICAgICBkYXRhTGFiZWxzWCA9IGRhdGFMYWJlbHNYIC0gdGV4dFJlY3RzLndpZHRoIC0gc3Ryb2tlV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJjeDogeCxcbiAgICAgICAgYmN5OiBiY3ksXG4gICAgICAgIGRhdGFMYWJlbHNYOiBkYXRhTGFiZWxzWCxcbiAgICAgICAgZGF0YUxhYmVsc1k6IGRhdGFMYWJlbHNZXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Q2FsY3VsYXRlZERhdGFMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NhbGN1bGF0ZWREYXRhTGFiZWxzKF9yZWY1KSB7XG4gICAgICB2YXIgeCA9IF9yZWY1LngsXG4gICAgICAgICAgeSA9IF9yZWY1LnksXG4gICAgICAgICAgdmFsID0gX3JlZjUudmFsLFxuICAgICAgICAgIGkgPSBfcmVmNS5pLFxuICAgICAgICAgIGogPSBfcmVmNS5qLFxuICAgICAgICAgIGRhdGFMYWJlbHNDb25maWcgPSBfcmVmNS5kYXRhTGFiZWxzQ29uZmlnO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZGF0YUxhYmVscyA9IG5ldyBEYXRhTGFiZWxzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZGF0YUxhYmVsc0NvbmZpZy5mb3JtYXR0ZXI7XG4gICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IG51bGw7XG4gICAgICB2YXIgaXNTZXJpZXNOb3RDb2xsYXBzZWQgPSB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID4gLTE7XG5cbiAgICAgIGlmIChkYXRhTGFiZWxzQ29uZmlnLmVuYWJsZWQgJiYgIWlzU2VyaWVzTm90Q29sbGFwc2VkKSB7XG4gICAgICAgIGVsRGF0YUxhYmVsc1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGEtbGFiZWxzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRleHQgPSAnJztcblxuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgdGV4dCA9IGZvcm1hdHRlcih2YWwsIHtcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgICAgICB3OiB3XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhTGFiZWxzLnBsb3REYXRhTGFiZWxzVGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHBhcmVudDogZWxEYXRhTGFiZWxzV3JhcCxcbiAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBkYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgIGFsd2F5c0RyYXdEYXRhTGFiZWw6IHRydWUsXG4gICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsRGF0YUxhYmVsc1dyYXA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhcjtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIEJhclN0YWNrZWQgQ2xhc3MgcmVzcG9uc2libGUgZm9yIGRyYXdpbmcgYm90aCBTdGFja2VkIENvbHVtbnMgYW5kIEJhcnMuXG4gKlxuICogQG1vZHVsZSBCYXJTdGFja2VkXG4gKiBUaGUgd2hvbGUgY2FsY3VsYXRpb24gZm9yIHN0YWNrZWQgYmFyL2NvbHVtbiBpcyBkaWZmZXJlbnQgZnJvbSBub3JtYWwgYmFyL2NvbHVtbixcbiAqIGhlbmNlIGl0IG1ha2VzIHNlbnNlIHRvIGRlcml2ZSBhIG5ldyBjbGFzcyBmb3IgaXQgZXh0ZW5kaW5nIG1vc3Qgb2YgdGhlIHByb3BzIG9mIFBhcmVudCBCYXJcbiAqKi9cblxudmFyIEJhclN0YWNrZWQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXIpIHtcbiAgX2luaGVyaXRzKEJhclN0YWNrZWQsIF9CYXIpO1xuXG4gIGZ1bmN0aW9uIEJhclN0YWNrZWQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhclN0YWNrZWQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihCYXJTdGFja2VkKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXJTdGFja2VkLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzLCBzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB0aGlzLmdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuYmFyID0gbmV3IEJhcih0aGlzLmN0eCwgdGhpcy54eVJhdGlvcyk7XG4gICAgICB2YXIgY29yZVV0aWxzID0gbmV3IENvcmVVdGlscyh0aGlzLmN0eCwgdyk7XG4gICAgICB0aGlzLnNlcmllcyA9IGNvcmVVdGlscy5nZXRMb2dTZXJpZXMoc2VyaWVzKTtcbiAgICAgIHNlcmllcyA9IHRoaXMuc2VyaWVzO1xuICAgICAgdGhpcy55UmF0aW8gPSBjb3JlVXRpbHMuZ2V0TG9nWVJhdGlvcyh0aGlzLnlSYXRpbyk7XG4gICAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICAgIHRoaXMuaW5pdFZhcmlhYmxlcyhzZXJpZXMpO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQuc3RhY2tUeXBlID09PSAnMTAwJScpIHtcbiAgICAgICAgdGhpcy5zZXJpZXMgPSB3Lmdsb2JhbHMuc2VyaWVzUGVyY2VudC5zbGljZSgpO1xuICAgICAgICBzZXJpZXMgPSB0aGlzLnNlcmllcztcbiAgICAgIH1cblxuICAgICAgdGhpcy50b3RhbEl0ZW1zID0gMDtcbiAgICAgIHRoaXMucHJldlkgPSBbXTsgLy8geSBwb3NpdGlvbiBvbiBjaGFydFxuXG4gICAgICB0aGlzLnByZXZYID0gW107IC8vIHggcG9zaXRpb24gb24gY2hhcnRcblxuICAgICAgdGhpcy5wcmV2WUYgPSBbXTsgLy8geSBwb3NpdGlvbiBpbmNsdWRpbmcgc2hhcGVzIG9uIGNoYXJ0XG5cbiAgICAgIHRoaXMucHJldlhGID0gW107IC8vIHggcG9zaXRpb24gaW5jbHVkaW5nIHNoYXBlcyBvbiBjaGFydFxuXG4gICAgICB0aGlzLnByZXZZVmFsID0gW107IC8vIHkgdmFsdWVzIChzZXJpZXNbaV1bal0pIGluIGNvbHVtbnNcblxuICAgICAgdGhpcy5wcmV2WFZhbCA9IFtdOyAvLyB4IHZhbHVlcyAoc2VyaWVzW2ldW2pdKSBpbiBiYXJzXG5cbiAgICAgIHRoaXMueEFycmogPSBbXTsgLy8geGogaW5kaWNhdGVzIHggcG9zaXRpb24gb24gZ3JhcGggaW4gYmFyc1xuXG4gICAgICB0aGlzLnhBcnJqRiA9IFtdOyAvLyB4akYgaW5kaWNhdGVzIGJhcidzIHggcG9zaXRpb24gKyBlbmRpbmdzaGFwZSdzIHBvc2l0aW9ucyBpbiBiYXJzXG5cbiAgICAgIHRoaXMueEFycmpWYWwgPSBbXTsgLy8geCB2YWwgbWVhbnMgdGhlIGFjdHVhbCBzZXJpZXMncyB5IHZhbHVlcyBpbiBob3Jpem9udGFsL2JhcnNcblxuICAgICAgdGhpcy55QXJyaiA9IFtdOyAvLyB5aiBpbmRpY2F0ZXMgeSBwb3NpdGlvbiBvbiBncmFwaCBpbiBjb2x1bW5zXG5cbiAgICAgIHRoaXMueUFycmpGID0gW107IC8vIHlqRiBpbmRpY2F0ZXMgYmFyJ3MgeSBwb3NpdGlvbiArIGVuZGluZ3NoYXBlJ3MgcG9zaXRpb25zIGluIGNvbHVtbnNcblxuICAgICAgdGhpcy55QXJyalZhbCA9IFtdOyAvLyB5IHZhbCBtZWFucyB0aGUgYWN0dWFsIHNlcmllcydzIHkgdmFsdWVzIGluIGNvbHVtbnNcblxuICAgICAgZm9yICh2YXIgc2wgPSAwOyBzbCA8IHNlcmllcy5sZW5ndGg7IHNsKyspIHtcbiAgICAgICAgaWYgKHNlcmllc1tzbF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMudG90YWxJdGVtcyArPSBzZXJpZXNbc2xdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1iYXItc2VyaWVzIGFwZXhjaGFydHMtcGxvdC1zZXJpZXMnXG4gICAgICB9KTtcbiAgICAgIHJldC5hdHRyKCdjbGlwLXBhdGgnLCBcInVybCgjZ3JpZFJlY3RNYXNrXCIuY29uY2F0KHcuZ2xvYmFscy5jdWlkLCBcIilcIikpO1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHkgPSAwO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpLCBiYykge1xuICAgICAgICB2YXIgcGF0aFRvID0gdm9pZCAwLFxuICAgICAgICAgICAgcGF0aEZyb20gPSB2b2lkIDA7XG4gICAgICAgIHZhciB4RGl2aXNpb24gPSB2b2lkIDA7IC8vIHhEaXZpc2lvbiBpcyB0aGUgR1JJRFdJRFRIIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGNvbHVtbnMpXG5cbiAgICAgICAgdmFyIHlEaXZpc2lvbiA9IHZvaWQgMDsgLy8geURpdmlzaW9uIGlzIHRoZSBHUklESEVJR0hUIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGJhcnMpXG5cbiAgICAgICAgdmFyIHplcm9IID0gdm9pZCAwOyAvLyB6ZXJvSCBpcyB0aGUgYmFzZWxpbmUgd2hlcmUgMCBtZWV0cyB5IGF4aXNcblxuICAgICAgICB2YXIgemVyb1cgPSB2b2lkIDA7IC8vIHplcm9XIGlzIHRoZSBiYXNlbGluZSB3aGVyZSAwIG1lZXRzIHggYXhpc1xuXG4gICAgICAgIHZhciB4QXJyVmFsdWVzID0gW107XG4gICAgICAgIHZhciB5QXJyVmFsdWVzID0gW107XG4gICAgICAgIHZhciByZWFsSW5kZXggPSB3Lmdsb2JhbHMuY29tYm9DaGFydHMgPyBzZXJpZXNJbmRleFtpXSA6IGk7XG5cbiAgICAgICAgaWYgKF90aGlzLnlSYXRpby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgX3RoaXMueWF4aXNJbmRleCA9IHJlYWxJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmlzUmV2ZXJzZWQgPSB3LmNvbmZpZy55YXhpc1tfdGhpcy55YXhpc0luZGV4XSAmJiB3LmNvbmZpZy55YXhpc1tfdGhpcy55YXhpc0luZGV4XS5yZXZlcnNlZDsgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cblxuICAgICAgICB2YXIgZWxTZXJpZXMgPSBfdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1zZXJpZXMgXCIuY29uY2F0KFV0aWxzLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbcmVhbEluZGV4XSkpLFxuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgIH0pOyAvLyBlbGRhdGFsYWJlbHNcblxuXG4gICAgICAgIHZhciBlbERhdGFMYWJlbHNXcmFwID0gX3RoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhbGFiZWxzJ1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSAwO1xuICAgICAgICB2YXIgYmFySGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGJhcldpZHRoID0gMDtcblxuICAgICAgICB2YXIgaW5pdFBvc2l0aW9ucyA9IF90aGlzLmluaXRpYWxQb3NpdGlvbnMoeCwgeSwgeERpdmlzaW9uLCB5RGl2aXNpb24sIHplcm9ILCB6ZXJvVyk7XG5cbiAgICAgICAgeSA9IGluaXRQb3NpdGlvbnMueTtcbiAgICAgICAgYmFySGVpZ2h0ID0gaW5pdFBvc2l0aW9ucy5iYXJIZWlnaHQ7XG4gICAgICAgIHlEaXZpc2lvbiA9IGluaXRQb3NpdGlvbnMueURpdmlzaW9uO1xuICAgICAgICB6ZXJvVyA9IGluaXRQb3NpdGlvbnMuemVyb1c7XG4gICAgICAgIHggPSBpbml0UG9zaXRpb25zLng7XG4gICAgICAgIGJhcldpZHRoID0gaW5pdFBvc2l0aW9ucy5iYXJXaWR0aDtcbiAgICAgICAgeERpdmlzaW9uID0gaW5pdFBvc2l0aW9ucy54RGl2aXNpb247XG4gICAgICAgIHplcm9IID0gaW5pdFBvc2l0aW9ucy56ZXJvSDtcbiAgICAgICAgX3RoaXMueUFycmogPSBbXTtcbiAgICAgICAgX3RoaXMueUFycmpGID0gW107XG4gICAgICAgIF90aGlzLnlBcnJqVmFsID0gW107XG4gICAgICAgIF90aGlzLnhBcnJqID0gW107XG4gICAgICAgIF90aGlzLnhBcnJqRiA9IFtdO1xuICAgICAgICBfdGhpcy54QXJyalZhbCA9IFtdOyAvLyBpZiAoIXRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICAvLyB0aGlzLnhBcnJqLnB1c2goeCArIGJhcldpZHRoIC8gMilcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoaikge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2Uuc2hvdykge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzTnVsbFZhbHVlKSB7XG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gQXJyYXkuaXNBcnJheShfdGhpcy5zdHJva2VXaWR0aCkgPyBfdGhpcy5zdHJva2VXaWR0aFtyZWFsSW5kZXhdIDogX3RoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhdGhzID0gbnVsbDtcblxuICAgICAgICAgIGlmIChfdGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHBhdGhzID0gX3RoaXMuZHJhd0JhclBhdGhzKHtcbiAgICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgajogaixcbiAgICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgICBiYzogYmNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgICAgICAgemVyb1c6IHplcm9XLFxuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICB5RGl2aXNpb246IHlEaXZpc2lvbixcbiAgICAgICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aHMgPSBfdGhpcy5kcmF3Q29sdW1uUGF0aHMoe1xuICAgICAgICAgICAgICBpbmRleGVzOiB7XG4gICAgICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICAgIGJjOiBiY1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgICAgICAgYmFyV2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgICB6ZXJvSDogemVyb0gsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgZWxTZXJpZXM6IGVsU2VyaWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoVG8gPSBwYXRocy5wYXRoVG87XG4gICAgICAgICAgcGF0aEZyb20gPSBwYXRocy5wYXRoRnJvbTtcbiAgICAgICAgICB5ID0gcGF0aHMueTtcbiAgICAgICAgICB4ID0gcGF0aHMueDtcbiAgICAgICAgICB4QXJyVmFsdWVzLnB1c2goeCk7XG4gICAgICAgICAgeUFyclZhbHVlcy5wdXNoKHkpO1xuICAgICAgICAgIHZhciBzZXJpZXNOdW1iZXIgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGlzdHJpYnV0ZWQgPyBqIDogaTtcbiAgICAgICAgICB2YXIgZmlsbENvbG9yID0gbnVsbDtcblxuICAgICAgICAgIGlmIChfdGhpcy5iYXJPcHRpb25zLmNvbG9ycy5yYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yUmFuZ2UgPSBfdGhpcy5iYXJPcHRpb25zLmNvbG9ycy5yYW5nZXM7XG4gICAgICAgICAgICBjb2xvclJhbmdlLm1hcChmdW5jdGlvbiAocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgICAgICAgIGlmIChzZXJpZXNbaV1bal0gPj0gcmFuZ2UuZnJvbSAmJiBzZXJpZXNbaV1bal0gPD0gcmFuZ2UudG8pIHtcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3IgPSByYW5nZS5jb2xvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhdGhGaWxsID0gX3RoaXMuZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICBzZXJpZXNOdW1iZXI6IF90aGlzLmJhck9wdGlvbnMuZGlzdHJpYnV0ZWQgPyBzZXJpZXNOdW1iZXIgOiByZWFsSW5kZXgsXG4gICAgICAgICAgICBjb2xvcjogZmlsbENvbG9yXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBlbFNlcmllcyA9IF90aGlzLnJlbmRlclNlcmllcyh7XG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIHBhdGhGaWxsOiBwYXRoRmlsbCxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXMsXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwOiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgICAgdHlwZTogJ2JhcicsXG4gICAgICAgICAgICB2aXNpYmxlU2VyaWVzOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3Lmdsb2JhbHMuZGF0YVBvaW50czsgaisrKSB7XG4gICAgICAgICAgX2xvb3AyKGopO1xuICAgICAgICB9IC8vIHB1c2ggYWxsIHggdmFsIGFycmF5cyBpbnRvIG1haW4geEFyclxuXG5cbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1h2YWx1ZXNbcmVhbEluZGV4XSA9IHhBcnJWYWx1ZXM7XG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNZdmFsdWVzW3JlYWxJbmRleF0gPSB5QXJyVmFsdWVzOyAvLyBwdXNoIGFsbCBjdXJyZW50IHkgdmFsdWVzIGFycmF5IHRvIG1haW4gUHJldlkgQXJyYXlcblxuICAgICAgICBfdGhpcy5wcmV2WS5wdXNoKF90aGlzLnlBcnJqKTtcblxuICAgICAgICBfdGhpcy5wcmV2WUYucHVzaChfdGhpcy55QXJyakYpO1xuXG4gICAgICAgIF90aGlzLnByZXZZVmFsLnB1c2goX3RoaXMueUFycmpWYWwpO1xuXG4gICAgICAgIF90aGlzLnByZXZYLnB1c2goX3RoaXMueEFycmopO1xuXG4gICAgICAgIF90aGlzLnByZXZYRi5wdXNoKF90aGlzLnhBcnJqRik7XG5cbiAgICAgICAgX3RoaXMucHJldlhWYWwucHVzaChfdGhpcy54QXJyalZhbCk7XG5cbiAgICAgICAgcmV0LmFkZChlbFNlcmllcyk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgYmMgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrLCBiYysrKSB7XG4gICAgICAgIF9sb29wKGksIGJjKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbFBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsUG9zaXRpb25zKHgsIHksIHhEaXZpc2lvbiwgeURpdmlzaW9uLCB6ZXJvSCwgemVyb1cpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGJhckhlaWdodCwgYmFyV2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBoZWlnaHQgZGl2aWRlZCBpbnRvIGVxdWFsIHBhcnRzXG4gICAgICAgIHlEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIGJhckhlaWdodCA9IHlEaXZpc2lvbjtcbiAgICAgICAgYmFySGVpZ2h0ID0gYmFySGVpZ2h0ICogcGFyc2VJbnQody5jb25maWcucGxvdE9wdGlvbnMuYmFyLmJhckhlaWdodCkgLyAxMDA7XG4gICAgICAgIHplcm9XID0gdGhpcy5iYXNlTGluZUludmVydGVkWSArIHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgKHRoaXMuaXNSZXZlcnNlZCA/IHcuZ2xvYmFscy5ncmlkV2lkdGggOiAwKSAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLmJhc2VMaW5lSW52ZXJ0ZWRZICogMiA6IDApOyAvLyBpbml0aWFsIHkgcG9zaXRpb24gaXMgaGFsZiBvZiBiYXJIZWlnaHQgKiBoYWxmIG9mIG51bWJlciBvZiBCYXJzXG5cbiAgICAgICAgeSA9ICh5RGl2aXNpb24gLSBiYXJIZWlnaHQpIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdpZHRoIGRpdmlkZWQgaW50byBlcXVhbCBwYXJ0c1xuICAgICAgICB4RGl2aXNpb24gPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIGJhcldpZHRoID0geERpdmlzaW9uO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIC8vIG1heCBiYXJ3aWR0aCBzaG91bGQgYmUgZXF1YWwgdG8gbWluWERpZmYgdG8gYXZvaWQgb3ZlcmxhcFxuICAgICAgICAgIHhEaXZpc2lvbiA9IHRoaXMubWluWERpZmYgLyB0aGlzLnhSYXRpbztcbiAgICAgICAgICBiYXJXaWR0aCA9IHhEaXZpc2lvbiAqIHBhcnNlSW50KHRoaXMuYmFyT3B0aW9ucy5jb2x1bW5XaWR0aCkgLyAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFyV2lkdGggPSBiYXJXaWR0aCAqIHBhcnNlSW50KHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5jb2x1bW5XaWR0aCkgLyAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICB6ZXJvSCA9IHRoaXMuYmFzZUxpbmVZW3RoaXMueWF4aXNJbmRleF0gKyAodGhpcy5pc1JldmVyc2VkID8gdy5nbG9iYWxzLmdyaWRIZWlnaHQgOiAwKSAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLmJhc2VMaW5lWVt0aGlzLnlheGlzSW5kZXhdICogMiA6IDApOyAvLyBpbml0aWFsIHggcG9zaXRpb24gaXMgb25lIHRoaXJkIG9mIGJhcldpZHRoXG5cbiAgICAgICAgeCA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgKHhEaXZpc2lvbiAtIGJhcldpZHRoKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHlEaXZpc2lvbjogeURpdmlzaW9uLFxuICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgIGJhcldpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgemVyb0g6IHplcm9ILFxuICAgICAgICB6ZXJvVzogemVyb1dcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdCYXJQYXRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QmFyUGF0aHMoX3JlZikge1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmLmluZGV4ZXMsXG4gICAgICAgICAgYmFySGVpZ2h0ID0gX3JlZi5iYXJIZWlnaHQsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIHBhdGhUbyA9IF9yZWYucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tID0gX3JlZi5wYXRoRnJvbSxcbiAgICAgICAgICB6ZXJvVyA9IF9yZWYuemVyb1csXG4gICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgIHlEaXZpc2lvbiA9IF9yZWYueURpdmlzaW9uLFxuICAgICAgICAgIGVsU2VyaWVzID0gX3JlZi5lbFNlcmllcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGJhcllQb3NpdGlvbiA9IHk7XG4gICAgICB2YXIgYmFyWFBvc2l0aW9uO1xuICAgICAgdmFyIGkgPSBpbmRleGVzLmk7XG4gICAgICB2YXIgaiA9IGluZGV4ZXMuajtcbiAgICAgIHZhciByZWFsSW5kZXggPSBpbmRleGVzLnJlYWxJbmRleDtcbiAgICAgIHZhciBiYyA9IGluZGV4ZXMuYmM7XG4gICAgICB2YXIgcHJldkJhclcgPSAwO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMucHJldlhGLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHByZXZCYXJXID0gcHJldkJhclcgKyB0aGlzLnByZXZYRltrXVtqXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHZhciBiWFAgPSB6ZXJvVztcblxuICAgICAgICBpZiAodGhpcy5wcmV2WFZhbFtpIC0gMV1bal0gPCAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2ldW2pdID49IDApIHtcbiAgICAgICAgICAgIGJYUCA9IHRoaXMucHJldlhbaSAtIDFdW2pdICsgcHJldkJhclcgLSAodGhpcy5pc1JldmVyc2VkID8gcHJldkJhclcgOiAwKSAqIDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJYUCA9IHRoaXMucHJldlhbaSAtIDFdW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXZYVmFsW2kgLSAxXVtqXSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2ldW2pdID49IDApIHtcbiAgICAgICAgICAgIGJYUCA9IHRoaXMucHJldlhbaSAtIDFdW2pdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiWFAgPSB0aGlzLnByZXZYW2kgLSAxXVtqXSAtIHByZXZCYXJXICsgKHRoaXMuaXNSZXZlcnNlZCA/IHByZXZCYXJXIDogMCkgKiAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJhclhQb3NpdGlvbiA9IGJYUDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBzZXJpZXMgd2lsbCBub3QgaGF2ZSBwcmV2WCB2YWx1ZXNcbiAgICAgICAgYmFyWFBvc2l0aW9uID0gemVyb1c7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNlcmllc1tpXVtqXSA9PT0gbnVsbCkge1xuICAgICAgICB4ID0gYmFyWFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGJhclhQb3NpdGlvbiArIHRoaXMuc2VyaWVzW2ldW2pdIC8gdGhpcy5pbnZlcnRlZFlSYXRpbyAtICh0aGlzLmlzUmV2ZXJzZWQgPyB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMuaW52ZXJ0ZWRZUmF0aW8gOiAwKSAqIDI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueEFycmoucHVzaCh4KTtcbiAgICAgIHRoaXMueEFycmpGLnB1c2goTWF0aC5hYnMoYmFyWFBvc2l0aW9uIC0geCkpO1xuICAgICAgdGhpcy54QXJyalZhbC5wdXNoKHRoaXMuc2VyaWVzW2ldW2pdKTtcbiAgICAgIHBhdGhUbyA9IHRoaXMuZ3JhcGhpY3MubW92ZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG4gICAgICBwYXRoRnJvbSA9IHRoaXMuZ3JhcGhpY3MubW92ZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhdGhGcm9tID0gdGhpcy5iYXIuZ2V0UGF0aEZyb20ocmVhbEluZGV4LCBqLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHBhdGhUbyA9IHBhdGhUbyArIHRoaXMuZ3JhcGhpY3MubGluZSh4LCBiYXJZUG9zaXRpb24pICsgdGhpcy5ncmFwaGljcy5saW5lKHgsIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAtIHN0cm9rZVdpZHRoKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAtIHN0cm9rZVdpZHRoKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG4gICAgICBwYXRoRnJvbSA9IHBhdGhGcm9tICsgdGhpcy5ncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAtIHN0cm9rZVdpZHRoKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAtIHN0cm9rZVdpZHRoKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbiArIGJhckhlaWdodCAtIHN0cm9rZVdpZHRoKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoID4gMCAmJiBpID09PSAwKSB7XG4gICAgICAgIGlmIChiYyA+PSB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgYmMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJjb2xvciA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9yc1tiY107XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCgwLCBiYXJZUG9zaXRpb24sIHcuZ2xvYmFscy5ncmlkV2lkdGgsIGJhckhlaWdodCwgMCwgYmNvbG9yLCB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJPcGFjaXR5KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICB9XG5cbiAgICAgIHkgPSB5ICsgeURpdmlzaW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0NvbHVtblBhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdDb2x1bW5QYXRocyhfcmVmMikge1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmMi5pbmRleGVzLFxuICAgICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgICAgIHhEaXZpc2lvbiA9IF9yZWYyLnhEaXZpc2lvbixcbiAgICAgICAgICBwYXRoVG8gPSBfcmVmMi5wYXRoVG8sXG4gICAgICAgICAgcGF0aEZyb20gPSBfcmVmMi5wYXRoRnJvbSxcbiAgICAgICAgICBiYXJXaWR0aCA9IF9yZWYyLmJhcldpZHRoLFxuICAgICAgICAgIHplcm9IID0gX3JlZjIuemVyb0gsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmMi5zdHJva2VXaWR0aCxcbiAgICAgICAgICBlbFNlcmllcyA9IF9yZWYyLmVsU2VyaWVzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgaSA9IGluZGV4ZXMuaTtcbiAgICAgIHZhciBqID0gaW5kZXhlcy5qO1xuICAgICAgdmFyIHJlYWxJbmRleCA9IGluZGV4ZXMucmVhbEluZGV4O1xuICAgICAgdmFyIGJjID0gaW5kZXhlcy5iYztcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIHZhciBzZXJpZXNWYWwgPSB3Lmdsb2JhbHMuc2VyaWVzWFtpXVtqXTtcbiAgICAgICAgaWYgKCFzZXJpZXNWYWwpIHNlcmllc1ZhbCA9IDA7XG4gICAgICAgIHggPSAoc2VyaWVzVmFsIC0gdy5nbG9iYWxzLm1pblgpIC8gdGhpcy54UmF0aW8gLSBiYXJXaWR0aCAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYXJYUG9zaXRpb24gPSB4O1xuICAgICAgdmFyIGJhcllQb3NpdGlvbjtcbiAgICAgIHZhciBwcmV2QmFySCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5wcmV2WUYubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgcHJldkJhckggPSBwcmV2QmFySCArIHRoaXMucHJldllGW2tdW2pdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+IDAgJiYgIXcuZ2xvYmFscy5pc1hOdW1lcmljIHx8IGkgPiAwICYmIHcuZ2xvYmFscy5pc1hOdW1lcmljICYmIHcuZ2xvYmFscy5zZXJpZXNYW2kgLSAxXVtqXSA9PT0gdy5nbG9iYWxzLnNlcmllc1hbaV1bal0pIHtcbiAgICAgICAgdmFyIGJZUDtcbiAgICAgICAgdmFyIHByZXZZVmFsdWUgPSB0aGlzLnByZXZZW2kgLSAxXVtqXTtcblxuICAgICAgICBpZiAodGhpcy5wcmV2WVZhbFtpIC0gMV1bal0gPCAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2ldW2pdID49IDApIHtcbiAgICAgICAgICAgIGJZUCA9IHByZXZZVmFsdWUgLSBwcmV2QmFySCArICh0aGlzLmlzUmV2ZXJzZWQgPyBwcmV2QmFySCA6IDApICogMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYllQID0gcHJldllWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2VyaWVzW2ldW2pdID49IDApIHtcbiAgICAgICAgICAgIGJZUCA9IHByZXZZVmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJZUCA9IHByZXZZVmFsdWUgKyBwcmV2QmFySCAtICh0aGlzLmlzUmV2ZXJzZWQgPyBwcmV2QmFySCA6IDApICogMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBiYXJZUG9zaXRpb24gPSBiWVA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgZmlyc3Qgc2VyaWVzIHdpbGwgbm90IGhhdmUgcHJldlkgdmFsdWVzLCBhbHNvIGlmIHRoZSBwcmV2IGluZGV4J3Mgc2VyaWVzIFggZG9lc24ndCBtYXRjaGVzIHRoZSBjdXJyZW50IGluZGV4J3Mgc2VyaWVzIFgsIHRoZW4gc3RhcnQgZnJvbSB6ZXJvXG4gICAgICAgIGJhcllQb3NpdGlvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC0gemVyb0g7XG4gICAgICB9XG5cbiAgICAgIHkgPSBiYXJZUG9zaXRpb24gLSB0aGlzLnNlcmllc1tpXVtqXSAvIHRoaXMueVJhdGlvW3RoaXMueWF4aXNJbmRleF0gKyAodGhpcy5pc1JldmVyc2VkID8gdGhpcy5zZXJpZXNbaV1bal0gLyB0aGlzLnlSYXRpb1t0aGlzLnlheGlzSW5kZXhdIDogMCkgKiAyO1xuICAgICAgdGhpcy55QXJyai5wdXNoKHkpO1xuICAgICAgdGhpcy55QXJyakYucHVzaChNYXRoLmFicyhiYXJZUG9zaXRpb24gLSB5KSk7XG4gICAgICB0aGlzLnlBcnJqVmFsLnB1c2godGhpcy5zZXJpZXNbaV1bal0pO1xuICAgICAgcGF0aFRvID0gdGhpcy5ncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgYmFyWVBvc2l0aW9uKTtcbiAgICAgIHBhdGhGcm9tID0gdGhpcy5ncmFwaGljcy5tb3ZlKGJhclhQb3NpdGlvbiwgYmFyWVBvc2l0aW9uKTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGF0aEZyb20gPSB0aGlzLmJhci5nZXRQYXRoRnJvbShyZWFsSW5kZXgsIGosIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcGF0aFRvID0gcGF0aFRvICsgdGhpcy5ncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgeSkgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgeSkgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG4gICAgICBwYXRoRnJvbSA9IHBhdGhGcm9tICsgdGhpcy5ncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAtIHN0cm9rZVdpZHRoLCBiYXJZUG9zaXRpb24pICsgdGhpcy5ncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC0gc3Ryb2tlV2lkdGgsIGJhcllQb3NpdGlvbikgKyB0aGlzLmdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLSBzdHJva2VXaWR0aCwgYmFyWVBvc2l0aW9uKSArIHRoaXMuZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIGJhcllQb3NpdGlvbik7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoID4gMCAmJiBpID09PSAwKSB7XG4gICAgICAgIGlmIChiYyA+PSB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJDb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgYmMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJjb2xvciA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5jb2xvcnMuYmFja2dyb3VuZEJhckNvbG9yc1tiY107XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdChiYXJYUG9zaXRpb24sIDAsIGJhcldpZHRoLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCwgMCwgYmNvbG9yLCB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuY29sb3JzLmJhY2tncm91bmRCYXJPcGFjaXR5KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICByZWN0Lm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1iYWNrZ3JvdW5kQmFyJyk7XG4gICAgICB9XG5cbiAgICAgIHggPSB4ICsgeERpdmlzaW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgeDogdy5nbG9iYWxzLmlzWE51bWVyaWMgPyB4IC0geERpdmlzaW9uIDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFyU3RhY2tlZDtcbn0oQmFyKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIENhbmRsZVN0aWNrIENsYXNzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIGJvdGggU3RhY2tlZCBDb2x1bW5zIGFuZCBCYXJzLlxuICpcbiAqIEBtb2R1bGUgQ2FuZGxlU3RpY2tcbiAqIFRoZSB3aG9sZSBjYWxjdWxhdGlvbiBmb3Igc3RhY2tlZCBiYXIvY29sdW1uIGlzIGRpZmZlcmVudCBmcm9tIG5vcm1hbCBiYXIvY29sdW1uLFxuICogaGVuY2UgaXQgbWFrZXMgc2Vuc2UgdG8gZGVyaXZlIGEgbmV3IGNsYXNzIGZvciBpdCBleHRlbmRpbmcgbW9zdCBvZiB0aGUgcHJvcHMgb2YgUGFyZW50IEJhclxuICoqL1xuXG52YXIgQ2FuZGxlU3RpY2sgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXIpIHtcbiAgX2luaGVyaXRzKENhbmRsZVN0aWNrLCBfQmFyKTtcblxuICBmdW5jdGlvbiBDYW5kbGVTdGljaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FuZGxlU3RpY2spO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihDYW5kbGVTdGljaykuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2FuZGxlU3RpY2ssIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMsIHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuY2FuZGxlc3RpY2tPcHRpb25zID0gdGhpcy53LmNvbmZpZy5wbG90T3B0aW9ucy5jYW5kbGVzdGljaztcbiAgICAgIHZhciBjb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4LCB3KTtcbiAgICAgIHRoaXMuc2VyaWVzID0gY29yZVV0aWxzLmdldExvZ1NlcmllcyhzZXJpZXMpO1xuICAgICAgc2VyaWVzID0gdGhpcy5zZXJpZXM7XG4gICAgICB0aGlzLnlSYXRpbyA9IGNvcmVVdGlscy5nZXRMb2dZUmF0aW9zKHRoaXMueVJhdGlvKTtcbiAgICAgIHRoaXMuaW5pdFZhcmlhYmxlcyhzZXJpZXMpO1xuICAgICAgdmFyIHJldCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLXNlcmllcyBhcGV4Y2hhcnRzLXBsb3Qtc2VyaWVzJ1xuICAgICAgfSk7XG4gICAgICByZXQuYXR0cignY2xpcC1wYXRoJywgXCJ1cmwoI2dyaWRSZWN0TWFza1wiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCwgXCIpXCIpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGJjID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKywgYmMrKykge1xuICAgICAgICB2YXIgcGF0aFRvID0gdm9pZCAwLFxuICAgICAgICAgICAgcGF0aEZyb20gPSB2b2lkIDA7XG4gICAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgICAgeSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHhEaXZpc2lvbiA9IHZvaWQgMCxcbiAgICAgICAgICAgIC8vIHhEaXZpc2lvbiBpcyB0aGUgR1JJRFdJRFRIIGRpdmlkZWQgYnkgbnVtYmVyIG9mIGRhdGFwb2ludHMgKGNvbHVtbnMpXG4gICAgICAgIHplcm9IID0gdm9pZCAwOyAvLyB6ZXJvSCBpcyB0aGUgYmFzZWxpbmUgd2hlcmUgMCBtZWV0cyB5IGF4aXNcblxuICAgICAgICB2YXIgeUFycmogPSBbXTsgLy8gaG9sZCB5IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICB2YXIgeEFycmogPSBbXTsgLy8gaG9sZCB4IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICB2YXIgcmVhbEluZGV4ID0gdy5nbG9iYWxzLmNvbWJvQ2hhcnRzID8gc2VyaWVzSW5kZXhbaV0gOiBpOyAvLyBlbCB0byB3aGljaCBzZXJpZXMgd2lsbCBiZSBkcmF3blxuXG4gICAgICAgIHZhciBlbFNlcmllcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tyZWFsSW5kZXhdKSksXG4gICAgICAgICAgcmVsOiBpICsgMSxcbiAgICAgICAgICAnZGF0YTpyZWFsSW5kZXgnOiByZWFsSW5kZXhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNlcmllc1tpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy52aXNpYmxlSSA9IHRoaXMudmlzaWJsZUkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gMDtcbiAgICAgICAgdmFyIGJhckhlaWdodCA9IDA7XG4gICAgICAgIHZhciBiYXJXaWR0aCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMueVJhdGlvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLnlheGlzSW5kZXggPSByZWFsSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5pdFBvc2l0aW9ucyA9IHRoaXMuaW5pdGlhbFBvc2l0aW9ucygpO1xuICAgICAgICB5ID0gaW5pdFBvc2l0aW9ucy55O1xuICAgICAgICBiYXJIZWlnaHQgPSBpbml0UG9zaXRpb25zLmJhckhlaWdodDtcbiAgICAgICAgeCA9IGluaXRQb3NpdGlvbnMueDtcbiAgICAgICAgYmFyV2lkdGggPSBpbml0UG9zaXRpb25zLmJhcldpZHRoO1xuICAgICAgICB4RGl2aXNpb24gPSBpbml0UG9zaXRpb25zLnhEaXZpc2lvbjtcbiAgICAgICAgemVyb0ggPSBpbml0UG9zaXRpb25zLnplcm9IO1xuICAgICAgICB4QXJyai5wdXNoKHggKyBiYXJXaWR0aCAvIDIpOyAvLyBlbGRhdGFsYWJlbHNcblxuICAgICAgICB2YXIgZWxEYXRhTGFiZWxzV3JhcCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtZGF0YWxhYmVscydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIHRqID0gdy5nbG9iYWxzLmRhdGFQb2ludHM7IGogPCB3Lmdsb2JhbHMuZGF0YVBvaW50czsgaisrLCB0ai0tKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNlcmllc1tpXVtqXSA9PT0gJ3VuZGVmaW5lZCcgfHwgc2VyaWVzW2ldW2pdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlzTnVsbFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc051bGxWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2Uuc2hvdykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOdWxsVmFsdWUpIHtcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSBBcnJheS5pc0FycmF5KHRoaXMuc3Ryb2tlV2lkdGgpID8gdGhpcy5zdHJva2VXaWR0aFtyZWFsSW5kZXhdIDogdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29sb3IgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5kcmF3Q2FuZGxlU3RpY2tQYXRocyh7XG4gICAgICAgICAgICBpbmRleGVzOiB7XG4gICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICBiYzogYmNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHhEaXZpc2lvbjogeERpdmlzaW9uLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICBwYXRoRnJvbTogcGF0aEZyb20sXG4gICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICB6ZXJvSDogemVyb0gsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXRoVG8gPSBwYXRocy5wYXRoVG87XG4gICAgICAgICAgcGF0aEZyb20gPSBwYXRocy5wYXRoRnJvbTtcbiAgICAgICAgICB5ID0gcGF0aHMueTtcbiAgICAgICAgICB4ID0gcGF0aHMueDtcbiAgICAgICAgICBjb2xvciA9IHBhdGhzLmNvbG9yOyAvLyBwdXNoIGN1cnJlbnQgWFxuXG4gICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICB4QXJyai5wdXNoKHggKyBiYXJXaWR0aCAvIDIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHlBcnJqLnB1c2goeSk7XG4gICAgICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICBzZXJpZXNOdW1iZXI6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBsaW5lRmlsbCA9IHRoaXMuY2FuZGxlc3RpY2tPcHRpb25zLndpY2sudXNlRmlsbENvbG9yID8gY29sb3IgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZWxTZXJpZXMgPSB0aGlzLnJlbmRlclNlcmllcyh7XG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgIHBhdGhGaWxsOiBwYXRoRmlsbCxcbiAgICAgICAgICAgIGxpbmVGaWxsOiBsaW5lRmlsbCxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICBlbFNlcmllczogZWxTZXJpZXMsXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgYmFySGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICBlbERhdGFMYWJlbHNXcmFwOiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgICAgdmlzaWJsZVNlcmllczogdGhpcy52aXNpYmxlSSxcbiAgICAgICAgICAgIHR5cGU6ICdjYW5kbGVzdGljaydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBwdXNoIGFsbCB4IHZhbCBhcnJheXMgaW50byBtYWluIHhBcnJcblxuXG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNYdmFsdWVzW3JlYWxJbmRleF0gPSB4QXJyajtcbiAgICAgICAgdy5nbG9iYWxzLnNlcmllc1l2YWx1ZXNbcmVhbEluZGV4XSA9IHlBcnJqO1xuICAgICAgICByZXQuYWRkKGVsU2VyaWVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0NhbmRsZVN0aWNrUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NhbmRsZVN0aWNrUGF0aHMoX3JlZikge1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcmVmLmluZGV4ZXMsXG4gICAgICAgICAgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgIHhEaXZpc2lvbiA9IF9yZWYueERpdmlzaW9uLFxuICAgICAgICAgIHBhdGhUbyA9IF9yZWYucGF0aFRvLFxuICAgICAgICAgIHBhdGhGcm9tID0gX3JlZi5wYXRoRnJvbSxcbiAgICAgICAgICBiYXJXaWR0aCA9IF9yZWYuYmFyV2lkdGgsXG4gICAgICAgICAgemVyb0ggPSBfcmVmLnplcm9ILFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBpID0gaW5kZXhlcy5pO1xuICAgICAgdmFyIGogPSBpbmRleGVzLmo7XG4gICAgICB2YXIgaXNQb3NpdGl2ZSA9IHRydWU7XG4gICAgICB2YXIgY29sb3JQb3MgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5jYW5kbGVzdGljay5jb2xvcnMudXB3YXJkO1xuICAgICAgdmFyIGNvbG9yTmVnID0gdy5jb25maWcucGxvdE9wdGlvbnMuY2FuZGxlc3RpY2suY29sb3JzLmRvd253YXJkO1xuICAgICAgdmFyIHlSYXRpbyA9IHRoaXMueVJhdGlvW3RoaXMueWF4aXNJbmRleF07XG4gICAgICB2YXIgcmVhbEluZGV4ID0gaW5kZXhlcy5yZWFsSW5kZXg7XG4gICAgICB2YXIgb2hsYyA9IHRoaXMuZ2V0T0hMQ1ZhbHVlKHJlYWxJbmRleCwgaik7XG4gICAgICB2YXIgbDEgPSB6ZXJvSDtcbiAgICAgIHZhciBsMiA9IHplcm9IO1xuXG4gICAgICBpZiAob2hsYy5vID4gb2hsYy5jKSB7XG4gICAgICAgIGlzUG9zaXRpdmUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHkxID0gTWF0aC5taW4ob2hsYy5vLCBvaGxjLmMpO1xuICAgICAgdmFyIHkyID0gTWF0aC5tYXgob2hsYy5vLCBvaGxjLmMpO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgeCA9ICh3Lmdsb2JhbHMuc2VyaWVzWFtpXVtqXSAtIHcuZ2xvYmFscy5taW5YKSAvIHRoaXMueFJhdGlvIC0gYmFyV2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFyWFBvc2l0aW9uID0geCArIGJhcldpZHRoICogdGhpcy52aXNpYmxlSTtcbiAgICAgIHBhdGhUbyA9IGdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCB6ZXJvSCk7XG4gICAgICBwYXRoRnJvbSA9IGdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCB6ZXJvSCk7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhdGhGcm9tID0gdGhpcy5nZXRQYXRoRnJvbShyZWFsSW5kZXgsIGosIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2VyaWVzW2ldW2pdID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLnNlcmllc1tpXVtqXSA9PT0gbnVsbCkge1xuICAgICAgICB5MSA9IHplcm9IO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSB6ZXJvSCAtIHkxIC8geVJhdGlvO1xuICAgICAgICB5MiA9IHplcm9IIC0geTIgLyB5UmF0aW87XG4gICAgICAgIGwxID0gemVyb0ggLSBvaGxjLmggLyB5UmF0aW87XG4gICAgICAgIGwyID0gemVyb0ggLSBvaGxjLmwgLyB5UmF0aW87XG4gICAgICB9XG5cbiAgICAgIHBhdGhUbyA9IGdyYXBoaWNzLm1vdmUoYmFyWFBvc2l0aW9uLCB5MikgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgeTIpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAvIDIsIGwxKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCB5MikgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoLCB5MikgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoLCB5MSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiArIGJhcldpZHRoIC8gMiwgeTEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24gKyBiYXJXaWR0aCAvIDIsIGwyKSArIGdyYXBoaWNzLmxpbmUoYmFyWFBvc2l0aW9uICsgYmFyV2lkdGggLyAyLCB5MSkgKyBncmFwaGljcy5saW5lKGJhclhQb3NpdGlvbiwgeTEpICsgZ3JhcGhpY3MubGluZShiYXJYUG9zaXRpb24sIHkyIC0gc3Ryb2tlV2lkdGggLyAyKTtcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICB4ID0geCArIHhEaXZpc2lvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeTIsXG4gICAgICAgIGJhclhQb3NpdGlvbjogYmFyWFBvc2l0aW9uLFxuICAgICAgICBjb2xvcjogaXNQb3NpdGl2ZSA/IGNvbG9yUG9zIDogY29sb3JOZWdcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9ITENWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPSExDVmFsdWUoaSwgaikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvOiB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlT1tpXVtqXSxcbiAgICAgICAgaDogdy5nbG9iYWxzLnNlcmllc0NhbmRsZUhbaV1bal0sXG4gICAgICAgIGw6IHcuZ2xvYmFscy5zZXJpZXNDYW5kbGVMW2ldW2pdLFxuICAgICAgICBjOiB3Lmdsb2JhbHMuc2VyaWVzQ2FuZGxlQ1tpXVtqXVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FuZGxlU3RpY2s7XG59KEJhcik7XG5cbnZhciBDcm9zc2hhaXJzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3Jvc3NoYWlycyhjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3Jvc3NoYWlycyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDcm9zc2hhaXJzLCBbe1xuICAgIGtleTogXCJkcmF3WENyb3NzaGFpcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1hDcm9zc2hhaXJzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgY3Jvc3NoYWlyR3JhZGllbnQgPSB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLmZpbGwuZ3JhZGllbnQ7XG4gICAgICB2YXIgY3Jvc3NoYWlyU2hhZG93ID0gdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5kcm9wU2hhZG93O1xuICAgICAgdmFyIGZpbGxUeXBlID0gdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5maWxsLnR5cGU7XG4gICAgICB2YXIgZ3JhZGllbnRGcm9tID0gY3Jvc3NoYWlyR3JhZGllbnQuY29sb3JGcm9tO1xuICAgICAgdmFyIGdyYWRpZW50VG8gPSBjcm9zc2hhaXJHcmFkaWVudC5jb2xvclRvO1xuICAgICAgdmFyIG9wYWNpdHlGcm9tID0gY3Jvc3NoYWlyR3JhZGllbnQub3BhY2l0eUZyb207XG4gICAgICB2YXIgb3BhY2l0eVRvID0gY3Jvc3NoYWlyR3JhZGllbnQub3BhY2l0eVRvO1xuICAgICAgdmFyIHN0b3BzID0gY3Jvc3NoYWlyR3JhZGllbnQuc3RvcHM7XG4gICAgICB2YXIgc2hhZG93ID0gJ25vbmUnO1xuICAgICAgdmFyIGRyb3BTaGFkb3cgPSBjcm9zc2hhaXJTaGFkb3cuZW5hYmxlZDtcbiAgICAgIHZhciBzaGFkb3dMZWZ0ID0gY3Jvc3NoYWlyU2hhZG93LmxlZnQ7XG4gICAgICB2YXIgc2hhZG93VG9wID0gY3Jvc3NoYWlyU2hhZG93LnRvcDtcbiAgICAgIHZhciBzaGFkb3dCbHVyID0gY3Jvc3NoYWlyU2hhZG93LmJsdXI7XG4gICAgICB2YXIgc2hhZG93Q29sb3IgPSBjcm9zc2hhaXJTaGFkb3cuY29sb3I7XG4gICAgICB2YXIgc2hhZG93T3BhY2l0eSA9IGNyb3NzaGFpclNoYWRvdy5vcGFjaXR5O1xuICAgICAgdmFyIHhjcm9zc2hhaXJzRmlsbCA9IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuZmlsbC5jb2xvcjtcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMuc2hvdykge1xuICAgICAgICBpZiAoZmlsbFR5cGUgPT09ICdncmFkaWVudCcpIHtcbiAgICAgICAgICB4Y3Jvc3NoYWlyc0ZpbGwgPSBncmFwaGljcy5kcmF3R3JhZGllbnQoJ3ZlcnRpY2FsJywgZ3JhZGllbnRGcm9tLCBncmFkaWVudFRvLCBvcGFjaXR5RnJvbSwgb3BhY2l0eVRvLCBudWxsLCBzdG9wcywgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeGNyb3NzaGFpcnMgPSBncmFwaGljcy5kcmF3UmVjdCgpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoID09PSAxKSB7XG4gICAgICAgICAgLy8gdG8gcHJldmVudCBkcmF3aW5nIDIgbGluZXMsIGNvbnZlcnQgcmVjdCB0byBsaW5lXG4gICAgICAgICAgeGNyb3NzaGFpcnMgPSBncmFwaGljcy5kcmF3TGluZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGNyb3NzaGFpcnMuYXR0cih7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhjcm9zc2hhaXJzJyxcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgeTI6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBVdGlscy5pc051bWJlcih3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoKSA/IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggOiAwLFxuICAgICAgICAgIGhlaWdodDogdy5nbG9iYWxzLmdyaWRIZWlnaHQsXG4gICAgICAgICAgZmlsbDogeGNyb3NzaGFpcnNGaWxsLFxuICAgICAgICAgIGZpbHRlcjogc2hhZG93LFxuICAgICAgICAgICdmaWxsLW9wYWNpdHknOiB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLm9wYWNpdHksXG4gICAgICAgICAgc3Ryb2tlOiB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLnN0cm9rZS5jb2xvcixcbiAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy5zdHJva2Uud2lkdGgsXG4gICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiB3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLnN0cm9rZS5kYXNoQXJyYXlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRyb3BTaGFkb3cpIHtcbiAgICAgICAgICB4Y3Jvc3NoYWlycyA9IGZpbHRlcnMuZHJvcFNoYWRvdyh4Y3Jvc3NoYWlycywge1xuICAgICAgICAgICAgbGVmdDogc2hhZG93TGVmdCxcbiAgICAgICAgICAgIHRvcDogc2hhZG93VG9wLFxuICAgICAgICAgICAgYmx1cjogc2hhZG93Qmx1cixcbiAgICAgICAgICAgIGNvbG9yOiBzaGFkb3dDb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IHNoYWRvd09wYWNpdHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKHhjcm9zc2hhaXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1lDcm9zc2hhaXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdZQ3Jvc3NoYWlycygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBjcm9zc2hhaXIgPSB3LmNvbmZpZy55YXhpc1swXS5jcm9zc2hhaXJzO1xuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbMF0uY3Jvc3NoYWlycy5zaG93KSB7XG4gICAgICAgIHZhciB5Y3Jvc3NoYWlycyA9IGdyYXBoaWNzLmRyYXdMaW5lKDAsIDAsIHcuZ2xvYmFscy5ncmlkV2lkdGgsIDAsIGNyb3NzaGFpci5zdHJva2UuY29sb3IsIGNyb3NzaGFpci5zdHJva2UuZGFzaEFycmF5LCBjcm9zc2hhaXIuc3Ryb2tlLndpZHRoKTtcbiAgICAgICAgeWNyb3NzaGFpcnMuYXR0cih7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXljcm9zc2hhaXJzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQoeWNyb3NzaGFpcnMpO1xuICAgICAgfSAvLyBkcmF3IGFuIGludmlzaWJsZSBjcm9zc2hhaXIgdG8gaGVscCBpbiBwb3NpdGlvbmluZyB0aGUgeWF4aXMgdG9vbHRpcFxuXG5cbiAgICAgIHZhciB5Y3Jvc3NoYWlyc0hpZGRlbiA9IGdyYXBoaWNzLmRyYXdMaW5lKDAsIDAsIHcuZ2xvYmFscy5ncmlkV2lkdGgsIDAsIGNyb3NzaGFpci5zdHJva2UuY29sb3IsIDAsIDApO1xuICAgICAgeWNyb3NzaGFpcnNIaWRkZW4uYXR0cih7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15Y3Jvc3NoYWlycy1oaWRkZW4nXG4gICAgICB9KTtcbiAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKHljcm9zc2hhaXJzSGlkZGVuKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3Jvc3NoYWlycztcbn0oKTtcblxuLyoqXG4gKiBEYXRlVGltZSBDbGFzcyB0byBtYW5pcHVsYXRlIGRhdGV0aW1lIHZhbHVlcy5cbiAqXG4gKiBAbW9kdWxlIERhdGVUaW1lXG4gKiovXG5cbnZhciBEYXRlVGltZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGVUaW1lKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlVGltZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLm1vbnRoczMxID0gWzEsIDMsIDUsIDcsIDgsIDEwLCAxMl07XG4gICAgdGhpcy5tb250aHMzMCA9IFsyLCA0LCA2LCA5LCAxMV07XG4gICAgdGhpcy5kYXlzQ250T2ZZZWFyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEYXRlVGltZSwgW3tcbiAgICBrZXk6IFwiaXNWYWxpZERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZERhdGUoZGF0ZSkge1xuICAgICAgcmV0dXJuICFpc05hTih0aGlzLnBhcnNlRGF0ZShkYXRlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVUQ1RpbWVTdGFtcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVVENUaW1lU3RhbXAoZGF0ZVN0cikge1xuICAgICAgaWYgKCFEYXRlLnBhcnNlKGRhdGVTdHIpKSB7XG4gICAgICAgIHJldHVybiBkYXRlU3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUobmV3IERhdGUoZGF0ZVN0cikudG9JU09TdHJpbmcoKS5zdWJzdHIoMCwgMjUpKS5nZXRUaW1lKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cikge1xuICAgICAgdmFyIHBhcnNlZCA9IERhdGUucGFyc2UoZGF0ZVN0cik7XG5cbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRVVENUaW1lU3RhbXAoZGF0ZVN0cik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRwdXQgPSBEYXRlLnBhcnNlKGRhdGVTdHIucmVwbGFjZSgvLS9nLCAnLycpLnJlcGxhY2UoL1thLXpdKy9naSwgJyAnKSk7XG4gICAgICBvdXRwdXQgPSB0aGlzLmdldFVUQ1RpbWVTdGFtcChvdXRwdXQpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTI1MjE2Ny82NDk1MDQzXG5cbiAgfSwge1xuICAgIGtleTogXCJ0cmVhdEFzVXRjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyZWF0QXNVdGMoZGF0ZVN0cikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKGRhdGVTdHIpO1xuICAgICAgcmVzdWx0LnNldE1pbnV0ZXMocmVzdWx0LmdldE1pbnV0ZXMoKSAtIHJlc3VsdC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0NjM4MDE4L2N1cnJlbnQtdGltZS1mb3JtYXR0aW5nLXdpdGgtamF2YXNjcmlwdCNhbnN3ZXItMTQ2MzgxOTFcblxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQpIHtcbiAgICAgIHZhciB1dGMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICB2YXIgY29udmVydFRvVVRDID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgICAgdmFyIGxvY2FsZSA9IHRoaXMudy5nbG9iYWxzLmxvY2FsZTtcbiAgICAgIHZhciBNTU1NID0gWydcXHgwMCddLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobG9jYWxlLm1vbnRocykpO1xuICAgICAgdmFyIE1NTSA9IFsnXFx4MDEnXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2FsZS5zaG9ydE1vbnRocykpO1xuICAgICAgdmFyIGRkZGQgPSBbJ1xceDAyJ10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsb2NhbGUuZGF5cykpO1xuICAgICAgdmFyIGRkZCA9IFsnXFx4MDMnXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2FsZS5zaG9ydERheXMpKTtcblxuICAgICAgZnVuY3Rpb24gaWkoaSwgbGVuKSB7XG4gICAgICAgIHZhciBzID0gaSArICcnO1xuICAgICAgICBsZW4gPSBsZW4gfHwgMjtcblxuICAgICAgICB3aGlsZSAocy5sZW5ndGggPCBsZW4pIHtcbiAgICAgICAgICBzID0gJzAnICsgcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udmVydFRvVVRDKSB7XG4gICAgICAgIGRhdGUgPSB0aGlzLnRyZWF0QXNVdGMoZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ID0gdXRjID8gZGF0ZS5nZXRVVENGdWxsWWVhcigpIDogZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0peXl5eSsvZywgJyQxJyArIHkpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0peXkvZywgJyQxJyArIHkudG9TdHJpbmcoKS5zdWJzdHIoMiwgMikpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0peS9nLCAnJDEnICsgeSk7XG4gICAgICB2YXIgTSA9ICh1dGMgPyBkYXRlLmdldFVUQ01vbnRoKCkgOiBkYXRlLmdldE1vbnRoKCkpICsgMTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKU1NTU0rL2csICckMScgKyBNTU1NWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKU1NTS9nLCAnJDEnICsgTU1NWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKU1NL2csICckMScgKyBpaShNKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlNL2csICckMScgKyBNKTtcbiAgICAgIHZhciBkID0gdXRjID8gZGF0ZS5nZXRVVENEYXRlKCkgOiBkYXRlLmdldERhdGUoKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWRkZGQrL2csICckMScgKyBkZGRkWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWRkZC9nLCAnJDEnICsgZGRkWzBdKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWRkL2csICckMScgKyBpaShkKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlkL2csICckMScgKyBkKTtcbiAgICAgIHZhciBIID0gdXRjID8gZGF0ZS5nZXRVVENIb3VycygpIDogZGF0ZS5nZXRIb3VycygpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pSEgrL2csICckMScgKyBpaShIKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlIL2csICckMScgKyBIKTtcbiAgICAgIHZhciBoID0gSCA+IDEyID8gSCAtIDEyIDogSCA9PT0gMCA/IDEyIDogSDtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKWhoKy9nLCAnJDEnICsgaWkoaCkpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0paC9nLCAnJDEnICsgaCk7XG4gICAgICB2YXIgbSA9IHV0YyA/IGRhdGUuZ2V0VVRDTWludXRlcygpIDogZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSltbSsvZywgJyQxJyArIGlpKG0pKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC8oXnxbXlxcXFxdKW0vZywgJyQxJyArIG0pO1xuICAgICAgdmFyIHMgPSB1dGMgPyBkYXRlLmdldFVUQ1NlY29uZHMoKSA6IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pc3MrL2csICckMScgKyBpaShzKSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlzL2csICckMScgKyBzKTtcbiAgICAgIHZhciBmID0gdXRjID8gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSA6IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlmZmYrL2csICckMScgKyBpaShmLCAzKSk7XG4gICAgICBmID0gTWF0aC5yb3VuZChmIC8gMTApO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pZmYvZywgJyQxJyArIGlpKGYpKTtcbiAgICAgIGYgPSBNYXRoLnJvdW5kKGYgLyAxMCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlmL2csICckMScgKyBmKTtcbiAgICAgIHZhciBUID0gSCA8IDEyID8gJ0FNJyA6ICdQTSc7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlUVCsvZywgJyQxJyArIFQpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pVC9nLCAnJDEnICsgVC5jaGFyQXQoMCkpO1xuICAgICAgdmFyIHQgPSBULnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSl0dCsvZywgJyQxJyArIHQpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyhefFteXFxcXF0pdC9nLCAnJDEnICsgdC5jaGFyQXQoMCkpO1xuICAgICAgdmFyIHR6ID0gLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBLID0gdXRjIHx8ICF0eiA/ICdaJyA6IHR6ID4gMCA/ICcrJyA6ICctJztcblxuICAgICAgaWYgKCF1dGMpIHtcbiAgICAgICAgdHogPSBNYXRoLmFicyh0eik7XG4gICAgICAgIHZhciB0ekhycyA9IE1hdGguZmxvb3IodHogLyA2MCk7XG4gICAgICAgIHZhciB0ek1pbiA9IHR6ICUgNjA7XG4gICAgICAgIEsgKz0gaWkodHpIcnMpICsgJzonICsgaWkodHpNaW4pO1xuICAgICAgfVxuXG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvKF58W15cXFxcXSlLL2csICckMScgKyBLKTtcbiAgICAgIHZhciBkYXkgPSAodXRjID8gZGF0ZS5nZXRVVENEYXkoKSA6IGRhdGUuZ2V0RGF5KCkpICsgMTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKG5ldyBSZWdFeHAoZGRkZFswXSwgJ2cnKSwgZGRkZFtkYXldKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKG5ldyBSZWdFeHAoZGRkWzBdLCAnZycpLCBkZGRbZGF5XSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShuZXcgUmVnRXhwKE1NTU1bMF0sICdnJyksIE1NTU1bTV0pO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobmV3IFJlZ0V4cChNTU1bMF0sICdnJyksIE1NTVtNXSk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxcXCguKS9nLCAnJDEnKTtcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRpbWVVbml0c2Zyb21UaW1lc3RhbXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGltZVVuaXRzZnJvbVRpbWVzdGFtcChtaW5YLCBtYXhYKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pblggPSB3LmNvbmZpZy54YXhpcy5taW47XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXhYID0gdy5jb25maWcueGF4aXMubWF4O1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluWWVhciA9IG5ldyBEYXRlKG1pblgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgbWF4WWVhciA9IG5ldyBEYXRlKG1heFgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgbWluTW9udGggPSBuZXcgRGF0ZShtaW5YKS5nZXRNb250aCgpO1xuICAgICAgdmFyIG1heE1vbnRoID0gbmV3IERhdGUobWF4WCkuZ2V0TW9udGgoKTtcbiAgICAgIHZhciBtaW5EYXRlID0gbmV3IERhdGUobWluWCkuZ2V0RGF0ZSgpO1xuICAgICAgdmFyIG1heERhdGUgPSBuZXcgRGF0ZShtYXhYKS5nZXREYXRlKCk7XG4gICAgICB2YXIgbWluSG91ciA9IG5ldyBEYXRlKG1pblgpLmdldEhvdXJzKCk7XG4gICAgICB2YXIgbWF4SG91ciA9IG5ldyBEYXRlKG1heFgpLmdldEhvdXJzKCk7XG4gICAgICB2YXIgbWluTWludXRlID0gbmV3IERhdGUobWluWCkuZ2V0TWludXRlcygpO1xuICAgICAgdmFyIG1heE1pbnV0ZSA9IG5ldyBEYXRlKG1heFgpLmdldE1pbnV0ZXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbk1pbnV0ZTogbWluTWludXRlLFxuICAgICAgICBtYXhNaW51dGU6IG1heE1pbnV0ZSxcbiAgICAgICAgbWluSG91cjogbWluSG91cixcbiAgICAgICAgbWF4SG91cjogbWF4SG91cixcbiAgICAgICAgbWluRGF0ZTogbWluRGF0ZSxcbiAgICAgICAgbWF4RGF0ZTogbWF4RGF0ZSxcbiAgICAgICAgbWluTW9udGg6IG1pbk1vbnRoLFxuICAgICAgICBtYXhNb250aDogbWF4TW9udGgsXG4gICAgICAgIG1pblllYXI6IG1pblllYXIsXG4gICAgICAgIG1heFllYXI6IG1heFllYXJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTGVhcFllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxjYXRlTGFzdERheXNPZk1vbnRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGNhdGVMYXN0RGF5c09mTW9udGgobW9udGgsIHllYXIsIHN1YnRyYWN0KSB7XG4gICAgICB2YXIgZGF5cyA9IHRoaXMuZGV0ZXJtaW5lRGF5c09mTW9udGhzKG1vbnRoLCB5ZWFyKTsgLy8gd2hhdGV2ZXIgZGF5cyB3ZSBnZXQsIHN1YnRyYWN0IHRoZSBudW1iZXIgb2YgZGF5cyBhc2tlZFxuXG4gICAgICByZXR1cm4gZGF5cyAtIHN1YnRyYWN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVEYXlzT2ZZZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZURheXNPZlllYXIoeWVhcikge1xuICAgICAgdmFyIGRheXMgPSAzNjU7XG5cbiAgICAgIGlmICh0aGlzLmlzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgICAgZGF5cyA9IDM2NjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRheXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZVJlbWFpbmluZ0RheXNPZlllYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lUmVtYWluaW5nRGF5c09mWWVhcih5ZWFyLCBtb250aCwgZGF0ZSkge1xuICAgICAgdmFyIGRheU9mWWVhciA9IHRoaXMuZGF5c0NudE9mWWVhclttb250aF0gKyBkYXRlO1xuICAgICAgaWYgKG1vbnRoID4gMSAmJiB0aGlzLmlzTGVhcFllYXIoKSkgZGF5T2ZZZWFyKys7XG4gICAgICByZXR1cm4gZGF5T2ZZZWFyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVEYXlzT2ZNb250aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lRGF5c09mTW9udGhzKG1vbnRoLCB5ZWFyKSB7XG4gICAgICB2YXIgZGF5cyA9IDMwO1xuICAgICAgbW9udGggPSBVdGlscy5tb250aE1vZChtb250aCk7XG5cbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIHRoaXMubW9udGhzMzAuaW5kZXhPZihtb250aCkgPiAtMTpcbiAgICAgICAgICBpZiAobW9udGggPT09IDIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgICAgICAgICAgZGF5cyA9IDI5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF5cyA9IDI4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdGhpcy5tb250aHMzMS5pbmRleE9mKG1vbnRoKSA+IC0xOlxuICAgICAgICAgIGRheXMgPSAzMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRheXMgPSAzMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRheXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGVUaW1lO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgSGVhdE1hcCBDbGFzcy5cbiAqIEBtb2R1bGUgSGVhdE1hcFxuICoqL1xuXG52YXIgSGVhdE1hcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhlYXRNYXAoY3R4LCB4eVJhdGlvcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZWF0TWFwKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMueFJhdGlvID0geHlSYXRpb3MueFJhdGlvO1xuICAgIHRoaXMueVJhdGlvID0geHlSYXRpb3MueVJhdGlvO1xuICAgIHRoaXMuZHluYW1pY0FuaW0gPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbjtcbiAgICB0aGlzLnJlY3RSYWRpdXMgPSB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAucmFkaXVzO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSB0aGlzLncuY29uZmlnLnN0cm9rZS53aWR0aDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIZWF0TWFwLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoc2VyaWVzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgcmV0ID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtaGVhdG1hcCdcbiAgICAgIH0pO1xuICAgICAgcmV0LmF0dHIoJ2NsaXAtcGF0aCcsIFwidXJsKCNncmlkUmVjdE1hc2tcIi5jb25jYXQody5nbG9iYWxzLmN1aWQsIFwiKVwiKSk7IC8vIHdpZHRoIGRpdmlkZWQgaW50byBlcXVhbCBwYXJ0c1xuXG4gICAgICB2YXIgeERpdmlzaW9uID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuICAgICAgdmFyIHlEaXZpc2lvbiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG4gICAgICB2YXIgeTEgPSAwO1xuICAgICAgdmFyIHJldiA9IGZhbHNlO1xuICAgICAgdmFyIGhlYXRTZXJpZXMgPSBzZXJpZXMuc2xpY2UoKTtcblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLnJldmVyc2VkKSB7XG4gICAgICAgIHJldiA9IHRydWU7XG4gICAgICAgIGhlYXRTZXJpZXMucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gcmV2ID8gMCA6IGhlYXRTZXJpZXMubGVuZ3RoIC0gMTsgcmV2ID8gaSA8IGhlYXRTZXJpZXMubGVuZ3RoIDogaSA+PSAwOyByZXYgPyBpKysgOiBpLS0pIHtcbiAgICAgICAgLy8gZWwgdG8gd2hpY2ggc2VyaWVzIHdpbGwgYmUgZHJhd25cbiAgICAgICAgdmFyIGVsU2VyaWVzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIGFwZXhjaGFydHMtaGVhdG1hcC1zZXJpZXMgXCIuY29uY2F0KFV0aWxzLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbaV0pKSxcbiAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IGlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBzaGFkb3cgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuICAgICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcy5jdHgpO1xuICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbFNlcmllcywgc2hhZG93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoZWF0U2VyaWVzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGNvbG9yU2hhZGVQZXJjZW50ID0gMTtcbiAgICAgICAgICB2YXIgaGVhdENvbG9yUHJvcHMgPSB0aGlzLmRldGVybWluZUhlYXRDb2xvcihpLCBqKTtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaGFzTmVncykge1xuICAgICAgICAgICAgdmFyIHNoYWRlSW50ZW5zaXR5ID0gdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcC5zaGFkZUludGVuc2l0eTtcblxuICAgICAgICAgICAgaWYgKGhlYXRDb2xvclByb3BzLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbG9yU2hhZGVQZXJjZW50ID0gMSAtICgxICsgaGVhdENvbG9yUHJvcHMucGVyY2VudCAvIDEwMCkgKiBzaGFkZUludGVuc2l0eTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbG9yU2hhZGVQZXJjZW50ID0gKDEgLSBoZWF0Q29sb3JQcm9wcy5wZXJjZW50IC8gMTAwKSAqIHNoYWRlSW50ZW5zaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xvclNoYWRlUGVyY2VudCA9IDEgLSBoZWF0Q29sb3JQcm9wcy5wZXJjZW50IC8gMTAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb2xvciA9IGhlYXRDb2xvclByb3BzLmNvbG9yO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAuZW5hYmxlU2hhZGVzKSB7XG4gICAgICAgICAgICB2YXIgdXRpbHMgPSBuZXcgVXRpbHMoKTtcbiAgICAgICAgICAgIGNvbG9yID0gVXRpbHMuaGV4VG9SZ2JhKHV0aWxzLnNoYWRlQ29sb3IoY29sb3JTaGFkZVBlcmNlbnQsIGhlYXRDb2xvclByb3BzLmNvbG9yKSwgdy5jb25maWcuZmlsbC5vcGFjaXR5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5yZWN0UmFkaXVzO1xuICAgICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZHJhd1JlY3QoeDEsIHkxLCB4RGl2aXNpb24sIHlEaXZpc2lvbiwgcmFkaXVzKTtcbiAgICAgICAgICByZWN0LmF0dHIoe1xuICAgICAgICAgICAgY3g6IHgxLFxuICAgICAgICAgICAgY3k6IHkxXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtaGVhdG1hcC1yZWN0Jyk7XG4gICAgICAgICAgZWxTZXJpZXMuYWRkKHJlY3QpO1xuICAgICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICB2YWw6IGhlYXRTZXJpZXNbaV1bal0sXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgIHN0cm9rZTogdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnNbMF0sXG4gICAgICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWN0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGdyYXBoaWNzLnBhdGhNb3VzZUVudGVyLmJpbmQodGhpcywgcmVjdCkpO1xuICAgICAgICAgIHJlY3Qubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZ3JhcGhpY3MucGF0aE1vdXNlTGVhdmUuYmluZCh0aGlzLCByZWN0KSk7XG4gICAgICAgICAgcmVjdC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGdyYXBoaWNzLnBhdGhNb3VzZURvd24uYmluZCh0aGlzLCByZWN0KSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5lbmFibGVkICYmICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBzcGVlZCA9IDE7XG5cbiAgICAgICAgICAgIGlmICghdy5nbG9iYWxzLnJlc2l6ZWQpIHtcbiAgICAgICAgICAgICAgc3BlZWQgPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLnNwZWVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVIZWF0TWFwKHJlY3QsIHgxLCB5MSwgeERpdmlzaW9uLCB5RGl2aXNpb24sIHNwZWVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgICB2YXIgX3NwZWVkID0gMTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZHluYW1pY0FuaW0uZW5hYmxlZCAmJiB3Lmdsb2JhbHMuc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICAgICAgICBfc3BlZWQgPSB0aGlzLmR5bmFtaWNBbmltLnNwZWVkO1xuICAgICAgICAgICAgICB2YXIgY29sb3JGcm9tID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV0gJiYgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV1bal0gJiYgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV1bal0uY29sb3I7XG4gICAgICAgICAgICAgIGlmICghY29sb3JGcm9tKSBjb2xvckZyb20gPSAncmdiYSgyNTUsIDI1NSwgMjU1LCAwKSc7XG4gICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUhlYXRDb2xvcihyZWN0LCBVdGlscy5pc0NvbG9ySGV4KGNvbG9yRnJvbSkgPyBjb2xvckZyb20gOiBVdGlscy5yZ2IyaGV4KGNvbG9yRnJvbSksIFV0aWxzLmlzQ29sb3JIZXgoY29sb3IpID8gY29sb3IgOiBVdGlscy5yZ2IyaGV4KGNvbG9yKSwgX3NwZWVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGF0YUxhYmVscyA9IHRoaXMuY2FsY3VsYXRlSGVhdG1hcERhdGFMYWJlbHMoe1xuICAgICAgICAgICAgeDogeDEsXG4gICAgICAgICAgICB5OiB5MSxcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgc2VyaWVzOiBoZWF0U2VyaWVzLFxuICAgICAgICAgICAgcmVjdEhlaWdodDogeURpdmlzaW9uLFxuICAgICAgICAgICAgcmVjdFdpZHRoOiB4RGl2aXNpb25cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChkYXRhTGFiZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbFNlcmllcy5hZGQoZGF0YUxhYmVscyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEgPSB4MSArIHhEaXZpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHkxID0geTEgKyB5RGl2aXNpb247XG4gICAgICAgIHJldC5hZGQoZWxTZXJpZXMpO1xuICAgICAgfSAvLyBhZGp1c3QgeWF4aXMgbGFiZWxzIGZvciBoZWF0bWFwXG5cblxuICAgICAgdmFyIHlBeGlzU2NhbGUgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQuc2xpY2UoKTtcblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLnJldmVyc2VkKSB7XG4gICAgICAgIHlBeGlzU2NhbGUudW5zaGlmdCgnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5QXhpc1NjYWxlLnB1c2goJycpO1xuICAgICAgfVxuXG4gICAgICB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQgPSB5QXhpc1NjYWxlO1xuICAgICAgdmFyIGRpdmlzb3IgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuICAgICAgdy5jb25maWcueWF4aXNbMF0ubGFiZWxzLm9mZnNldFkgPSAtKGRpdmlzb3IgLyAyKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZUhlYXRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVIZWF0Q29sb3IoaSwgaikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdmFsID0gdy5nbG9iYWxzLnNlcmllc1tpXVtqXTtcbiAgICAgIHZhciBoZWF0bWFwID0gdy5jb25maWcucGxvdE9wdGlvbnMuaGVhdG1hcDtcbiAgICAgIHZhciBzZXJpZXNOdW1iZXIgPSBoZWF0bWFwLmNvbG9yU2NhbGUuaW52ZXJzZSA/IGogOiBpO1xuICAgICAgdmFyIGNvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1tzZXJpZXNOdW1iZXJdO1xuICAgICAgdmFyIG1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh3Lmdsb2JhbHMuc2VyaWVzW2ldKSk7XG4gICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHcuZ2xvYmFscy5zZXJpZXNbaV0pKTtcblxuICAgICAgaWYgKCFoZWF0bWFwLmRpc3RyaWJ1dGVkKSB7XG4gICAgICAgIG1pbiA9IHcuZ2xvYmFscy5taW5ZO1xuICAgICAgICBtYXggPSB3Lmdsb2JhbHMubWF4WTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoZWF0bWFwLmNvbG9yU2NhbGUubWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtaW4gPSBoZWF0bWFwLmNvbG9yU2NhbGUubWluIDwgdy5nbG9iYWxzLm1pblkgPyBoZWF0bWFwLmNvbG9yU2NhbGUubWluIDogdy5nbG9iYWxzLm1pblk7XG4gICAgICAgIG1heCA9IGhlYXRtYXAuY29sb3JTY2FsZS5tYXggPiB3Lmdsb2JhbHMubWF4WSA/IGhlYXRtYXAuY29sb3JTY2FsZS5tYXggOiB3Lmdsb2JhbHMubWF4WTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsID0gTWF0aC5hYnMobWF4KSArIE1hdGguYWJzKG1pbik7XG4gICAgICB2YXIgcGVyY2VudCA9IDEwMCAqIHZhbCAvICh0b3RhbCA9PT0gMCA/IHRvdGFsIC0gMC4wMDAwMDEgOiB0b3RhbCk7XG5cbiAgICAgIGlmIChoZWF0bWFwLmNvbG9yU2NhbGUucmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGNvbG9yUmFuZ2UgPSBoZWF0bWFwLmNvbG9yU2NhbGUucmFuZ2VzO1xuICAgICAgICBjb2xvclJhbmdlLm1hcChmdW5jdGlvbiAocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKHZhbCA+PSByYW5nZS5mcm9tICYmIHZhbCA8PSByYW5nZS50bykge1xuICAgICAgICAgICAgY29sb3IgPSByYW5nZS5jb2xvcjtcbiAgICAgICAgICAgIG1pbiA9IHJhbmdlLmZyb207XG4gICAgICAgICAgICBtYXggPSByYW5nZS50bztcbiAgICAgICAgICAgIHRvdGFsID0gTWF0aC5hYnMobWF4KSArIE1hdGguYWJzKG1pbik7XG4gICAgICAgICAgICBwZXJjZW50ID0gMTAwICogdmFsIC8gdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBwZXJjZW50OiBwZXJjZW50XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVIZWF0bWFwRGF0YUxhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVIZWF0bWFwRGF0YUxhYmVscyhfcmVmKSB7XG4gICAgICB2YXIgeCA9IF9yZWYueCxcbiAgICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICAgIGkgPSBfcmVmLmksXG4gICAgICAgICAgaiA9IF9yZWYuaixcbiAgICAgICAgICBzZXJpZXMgPSBfcmVmLnNlcmllcyxcbiAgICAgICAgICByZWN0SGVpZ2h0ID0gX3JlZi5yZWN0SGVpZ2h0LFxuICAgICAgICAgIHJlY3RXaWR0aCA9IF9yZWYucmVjdFdpZHRoO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIGxldCBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eClcblxuICAgICAgdmFyIGRhdGFMYWJlbHNDb25maWcgPSB3LmNvbmZpZy5kYXRhTGFiZWxzO1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBkYXRhTGFiZWxzID0gbmV3IERhdGFMYWJlbHModGhpcy5jdHgpO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGRhdGFMYWJlbHNDb25maWcuZm9ybWF0dGVyO1xuICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSBudWxsO1xuXG4gICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5lbmFibGVkKSB7XG4gICAgICAgIGVsRGF0YUxhYmVsc1dyYXAgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGEtbGFiZWxzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9mZlggPSBkYXRhTGFiZWxzQ29uZmlnLm9mZnNldFg7XG4gICAgICAgIHZhciBvZmZZID0gZGF0YUxhYmVsc0NvbmZpZy5vZmZzZXRZO1xuICAgICAgICB2YXIgZGF0YUxhYmVsc1ggPSB4ICsgcmVjdFdpZHRoIC8gMiArIG9mZlg7XG4gICAgICAgIHZhciBkYXRhTGFiZWxzWSA9IHkgKyByZWN0SGVpZ2h0IC8gMiArIHBhcnNlSW50KGRhdGFMYWJlbHNDb25maWcuc3R5bGUuZm9udFNpemUpIC8gMyArIG9mZlk7XG4gICAgICAgIHZhciB0ZXh0ID0gZm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNbaV1bal0sIHtcbiAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhTGFiZWxzLnBsb3REYXRhTGFiZWxzVGV4dCh7XG4gICAgICAgICAgeDogZGF0YUxhYmVsc1gsXG4gICAgICAgICAgeTogZGF0YUxhYmVsc1ksXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGosXG4gICAgICAgICAgcGFyZW50OiBlbERhdGFMYWJlbHNXcmFwLFxuICAgICAgICAgIGRhdGFMYWJlbHNDb25maWc6IGRhdGFMYWJlbHNDb25maWdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbERhdGFMYWJlbHNXcmFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlSGVhdE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlSGVhdE1hcChlbCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc3BlZWQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jdHgpO1xuICAgICAgYW5pbWF0aW9ucy5hbmltYXRlUmVjdChlbCwge1xuICAgICAgICB4OiB4ICsgd2lkdGggLyAyLFxuICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMixcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSwge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9LCBzcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy53Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVIZWF0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZUhlYXRDb2xvcihlbCwgY29sb3JGcm9tLCBjb2xvclRvLCBzcGVlZCkge1xuICAgICAgZWwuYXR0cih7XG4gICAgICAgIGZpbGw6IGNvbG9yRnJvbVxuICAgICAgfSkuYW5pbWF0ZShzcGVlZCkuYXR0cih7XG4gICAgICAgIGZpbGw6IGNvbG9yVG9cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIZWF0TWFwO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgUGllIENsYXNzIGZvciBkcmF3aW5nIFBpZSAvIERvbnV0IENoYXJ0cy5cbiAqIEBtb2R1bGUgUGllXG4gKiovXG5cbnZhciBQaWUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQaWUoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBpZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmNoYXJ0VHlwZSA9IHRoaXMudy5jb25maWcuY2hhcnQudHlwZTtcbiAgICB0aGlzLmluaXRpYWxBbmltID0gdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmVuYWJsZWQ7XG4gICAgdGhpcy5keW5hbWljQW5pbSA9IHRoaXMuaW5pdGlhbEFuaW0gJiYgdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZDtcbiAgICB0aGlzLmFuaW1CZWdpbkFyciA9IFswXTtcbiAgICB0aGlzLmFuaW1EdXIgPSAwO1xuICAgIHRoaXMuZG9udXREYXRhTGFiZWxzID0gdGhpcy53LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQubGFiZWxzO1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMubGluZUNvbG9yQXJyID0gdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnMgIT09IHVuZGVmaW5lZCA/IHcuZ2xvYmFscy5zdHJva2UuY29sb3JzIDogdy5nbG9iYWxzLmNvbG9ycztcbiAgICB0aGlzLmRlZmF1bHRTaXplID0gdy5nbG9iYWxzLnN2Z0hlaWdodCA8IHcuZ2xvYmFscy5zdmdXaWR0aCA/IHcuZ2xvYmFscy5zdmdIZWlnaHQgLSAzNSA6IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG4gICAgdGhpcy5jZW50ZXJZID0gdGhpcy5kZWZhdWx0U2l6ZSAvIDI7XG4gICAgdGhpcy5jZW50ZXJYID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDI7XG4gICAgdGhpcy5mdWxsQW5nbGUgPSAzNjA7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLmRvbnV0U2l6ZSA9IDA7XG4gICAgdGhpcy5zbGljZUxhYmVscyA9IFtdO1xuICAgIHRoaXMucHJldlNlY3RvckFuZ2xlQXJyID0gW107IC8vIGZvciBkeW5hbWljIGFuaW1hdGlvbnNcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQaWUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1waWUnXG4gICAgICB9KTtcbiAgICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2VyaWVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIC8vIENBTENVTEFURSBUSEUgVE9UQUxcbiAgICAgICAgdG90YWwgKz0gVXRpbHMubmVnVG9aZXJvKHNlcmllc1trXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWN0b3JBbmdsZUFyciA9IFtdOyAvLyBlbCB0byB3aGljaCBzZXJpZXMgd2lsbCBiZSBkcmF3blxuXG4gICAgICB2YXIgZWxTZXJpZXMgPSBncmFwaGljcy5ncm91cCgpOyAvLyBwcmV2ZW50IGRpdmlzaW9uIGJ5IHplcm8gZXJyb3IgaWYgdGhlcmUgaXMgbm8gZGF0YVxuXG4gICAgICBpZiAodG90YWwgPT09IDApIHtcbiAgICAgICAgdG90YWwgPSAwLjAwMDAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDQUxDVUxBVEUgVEhFIEFOR0xFU1xuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmZ1bGxBbmdsZSAqIFV0aWxzLm5lZ1RvWmVybyhzZXJpZXNbaV0pIC8gdG90YWw7XG4gICAgICAgIHNlY3RvckFuZ2xlQXJyLnB1c2goYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBwcmV2VG90YWwgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGg7IF9rKyspIHtcbiAgICAgICAgICAvLyBDQUxDVUxBVEUgVEhFIFBSRVYgVE9UQUxcbiAgICAgICAgICBwcmV2VG90YWwgKz0gVXRpbHMubmVnVG9aZXJvKHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW19rXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldmlvdXNBbmdsZTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgLy8gQ0FMQ1VMQVRFIFRIRSBQUkVWSU9VUyBBTkdMRVNcbiAgICAgICAgICBwcmV2aW91c0FuZ2xlID0gdGhpcy5mdWxsQW5nbGUgKiBVdGlscy5uZWdUb1plcm8ody5nbG9iYWxzLnByZXZpb3VzUGF0aHNbX2ldKSAvIHByZXZUb3RhbDtcbiAgICAgICAgICB0aGlzLnByZXZTZWN0b3JBbmdsZUFyci5wdXNoKHByZXZpb3VzQW5nbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuZGVmYXVsdFNpemUgLyAyLjA1IC0gdy5jb25maWcuc3Ryb2tlLndpZHRoIC0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdy5ibHVyO1xuXG4gICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucGllLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNpemUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuc2l6ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb251dFNpemUgPSB0aGlzLnNpemUgKiBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQuc2l6ZSkgLyAxMDA7XG4gICAgICB2YXIgc2NhbGVTaXplID0gdy5jb25maWcucGxvdE9wdGlvbnMucGllLmN1c3RvbVNjYWxlO1xuICAgICAgdmFyIGhhbGZXID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDI7XG4gICAgICB2YXIgaGFsZkggPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDI7XG4gICAgICB2YXIgdHJhbnNsYXRlWCA9IGhhbGZXIC0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDIgKiBzY2FsZVNpemU7XG4gICAgICB2YXIgdHJhbnNsYXRlWSA9IGhhbGZIIC0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyICogc2NhbGVTaXplO1xuXG4gICAgICBpZiAodGhpcy5kb251dERhdGFMYWJlbHMuc2hvdykge1xuICAgICAgICB2YXIgZGF0YUxhYmVscyA9IHRoaXMucmVuZGVySW5uZXJEYXRhTGFiZWxzKHRoaXMuZG9udXREYXRhTGFiZWxzLCB7XG4gICAgICAgICAgaG9sbG93U2l6ZTogdGhpcy5kb251dFNpemUsXG4gICAgICAgICAgY2VudGVyWDogdGhpcy5jZW50ZXJYLFxuICAgICAgICAgIGNlbnRlclk6IHRoaXMuY2VudGVyWSxcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmRvbnV0RGF0YUxhYmVscy5zaG93LFxuICAgICAgICAgIHRyYW5zbGF0ZVg6IHRyYW5zbGF0ZVgsXG4gICAgICAgICAgdHJhbnNsYXRlWTogdHJhbnNsYXRlWVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0LmFkZChkYXRhTGFiZWxzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgLy8gZHJhdyB0aGUgaW5uZXIgY2lyY2xlIGFuZCBhZGQgc29tZSB0ZXh0IHRvIGl0XG4gICAgICAgIHZhciBjaXJjbGUgPSBncmFwaGljcy5kcmF3Q2lyY2xlKHRoaXMuZG9udXRTaXplKTtcbiAgICAgICAgY2lyY2xlLmF0dHIoe1xuICAgICAgICAgIGN4OiB0aGlzLmNlbnRlclgsXG4gICAgICAgICAgY3k6IHRoaXMuY2VudGVyWSxcbiAgICAgICAgICBmaWxsOiB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZG9udXQuYmFja2dyb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKGNpcmNsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbEcgPSBzZWxmLmRyYXdBcmNzKHNlY3RvckFuZ2xlQXJyLCBzZXJpZXMpOyAvLyBhZGQgc2xpY2UgZGF0YUxhYmVscyBhdCB0aGUgZW5kXG5cbiAgICAgIHRoaXMuc2xpY2VMYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICBlbEcuYWRkKHMpO1xuICAgICAgfSk7XG4gICAgICBlbFNlcmllcy5hdHRyKHtcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQodHJhbnNsYXRlWCwgXCIsIFwiKS5jb25jYXQodHJhbnNsYXRlWSAtIDUsIFwiKSBzY2FsZShcIikuY29uY2F0KHNjYWxlU2l6ZSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIHJldC5hdHRyKHtcbiAgICAgICAgJ2RhdGE6aW5uZXJUcmFuc2xhdGVYJzogdHJhbnNsYXRlWCxcbiAgICAgICAgJ2RhdGE6aW5uZXJUcmFuc2xhdGVZJzogdHJhbnNsYXRlWSAtIDI1XG4gICAgICB9KTtcbiAgICAgIGVsU2VyaWVzLmFkZChlbEcpO1xuICAgICAgcmV0LmFkZChlbFNlcmllcyk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gY29yZSBmdW5jdGlvbiBmb3IgZHJhd2luZyBwaWUgYXJjc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0FyY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0FyY3Moc2VjdG9yQW5nbGVBcnIsIHNlcmllcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciBnID0gZ3JhcGhpY3MuZ3JvdXAoKTtcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gMDtcbiAgICAgIHZhciBwcmV2U3RhcnRBbmdsZSA9IDA7XG4gICAgICB2YXIgZW5kQW5nbGUgPSAwO1xuICAgICAgdmFyIHByZXZFbmRBbmdsZSA9IDA7XG4gICAgICB0aGlzLnN0cm9rZVdpZHRoID0gdy5jb25maWcuc3Ryb2tlLnNob3cgPyB3LmNvbmZpZy5zdHJva2Uud2lkdGggOiAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlY3RvckFuZ2xlQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGlmKHNlY3RvckFuZ2xlQXJyW2ldPjApIHtcbiAgICAgICAgdmFyIGVsUGllQXJjID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIGFwZXhjaGFydHMtcGllLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tpXSkpLFxuICAgICAgICAgIGlkOiAnYXBleGNoYXJ0cy1zZXJpZXMtJyArIGksXG4gICAgICAgICAgcmVsOiBpICsgMVxuICAgICAgICB9KTtcbiAgICAgICAgZy5hZGQoZWxQaWVBcmMpO1xuICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgIHByZXZTdGFydEFuZ2xlID0gcHJldkVuZEFuZ2xlO1xuICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzZWN0b3JBbmdsZUFycltpXTtcbiAgICAgICAgcHJldkVuZEFuZ2xlID0gcHJldlN0YXJ0QW5nbGUgKyB0aGlzLnByZXZTZWN0b3JBbmdsZUFycltpXTtcbiAgICAgICAgdmFyIGFuZ2xlID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICBzZXJpZXNOdW1iZXI6IGksXG4gICAgICAgICAgc2l6ZTogdGhpcy5zaXplXG4gICAgICAgIH0pOyAvLyBhZGRpdGlvbmFseSwgcGFzcyBzaXplIGZvciBncmFkaWVudCBkcmF3aW5nIGluIHRoZSBmaWxsUGF0aCBmdW5jdGlvblxuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5nZXRDaGFuZ2VkUGF0aChwcmV2U3RhcnRBbmdsZSwgcHJldkVuZEFuZ2xlKTtcbiAgICAgICAgdmFyIGVsUGF0aCA9IGdyYXBoaWNzLmRyYXdQYXRoKHtcbiAgICAgICAgICBkOiBwYXRoLFxuICAgICAgICAgIHN0cm9rZTogdGhpcy5saW5lQ29sb3JBcnIgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMubGluZUNvbG9yQXJyW2ldIDogdGhpcy5saW5lQ29sb3JBcnIsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZmlsbDogcGF0aEZpbGwsXG4gICAgICAgICAgZmlsbE9wYWNpdHk6IHcuY29uZmlnLmZpbGwub3BhY2l0eSxcbiAgICAgICAgICBjbGFzc2VzOiAnYXBleGNoYXJ0cy1waWUtYXJlYSdcbiAgICAgICAgfSk7XG4gICAgICAgIGVsUGF0aC5hdHRyKHtcbiAgICAgICAgICBpZDogXCJhcGV4Y2hhcnRzLVwiLmNvbmNhdCh3LmNvbmZpZy5jaGFydC50eXBlLCBcIi1zbGljZS1cIikuY29uY2F0KGkpLFxuICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgIGo6IGlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBzaGFkb3cgPSB3LmNvbmZpZy5jaGFydC5kcm9wU2hhZG93O1xuICAgICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbFBhdGgsIHNoYWRvdyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZExpc3RlbmVycyhlbFBhdGgsIHRoaXMuZG9udXREYXRhTGFiZWxzKTtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZWxQYXRoLm5vZGUsIHtcbiAgICAgICAgICAnZGF0YTphbmdsZSc6IGFuZ2xlLFxuICAgICAgICAgICdkYXRhOnN0YXJ0QW5nbGUnOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICdkYXRhOnN0cm9rZVdpZHRoJzogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAnZGF0YTp2YWx1ZSc6IHNlcmllc1tpXVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdwaWUnKSB7XG4gICAgICAgICAgbGFiZWxQb3NpdGlvbiA9IFV0aWxzLnBvbGFyVG9DYXJ0ZXNpYW4odGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIHRoaXMuc2l6ZSAvIDEuMjUgKyB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZGF0YUxhYmVscy5vZmZzZXQsIHN0YXJ0QW5nbGUgKyAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgICBsYWJlbFBvc2l0aW9uID0gVXRpbHMucG9sYXJUb0NhcnRlc2lhbih0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgKHRoaXMuc2l6ZSArIHRoaXMuZG9udXRTaXplKSAvIDIgKyB3LmNvbmZpZy5wbG90T3B0aW9ucy5waWUuZGF0YUxhYmVscy5vZmZzZXQsIHN0YXJ0QW5nbGUgKyAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxQaWVBcmMuYWRkKGVsUGF0aCk7IC8vIEFuaW1hdGlvbiBjb2RlIHN0YXJ0c1xuXG4gICAgICAgIHZhciBkdXIgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxBbmltICYmICF3Lmdsb2JhbHMucmVzaXplZCAmJiAhdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgZHVyID0gKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyB0aGlzLmZ1bGxBbmdsZSAqIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQ7XG4gICAgICAgICAgdGhpcy5hbmltRHVyID0gZHVyICsgdGhpcy5hbmltRHVyO1xuICAgICAgICAgIHRoaXMuYW5pbUJlZ2luQXJyLnB1c2godGhpcy5hbmltRHVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFuaW1CZWdpbkFyci5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY0FuaW0gJiYgdy5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRlUGF0aHMoZWxQYXRoLCB7XG4gICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgcHJldlN0YXJ0QW5nbGU6IHByZXZTdGFydEFuZ2xlLFxuICAgICAgICAgICAgcHJldkVuZEFuZ2xlOiBwcmV2RW5kQW5nbGUsXG4gICAgICAgICAgICBhbmltYXRlU3RhcnRpbmdQb3M6IHRydWUsXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgYW5pbUJlZ2luQXJyOiB0aGlzLmFuaW1CZWdpbkFycixcbiAgICAgICAgICAgIGR1cjogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLnNwZWVkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRlUGF0aHMoZWxQYXRoLCB7XG4gICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIHRvdGFsSXRlbXM6IHNlY3RvckFuZ2xlQXJyLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBhbmltQmVnaW5BcnI6IHRoaXMuYW5pbUJlZ2luQXJyLFxuICAgICAgICAgICAgZHVyOiBkdXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBhbmltYXRpb24gY29kZSBlbmRzXG5cblxuICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucGllLmV4cGFuZE9uQ2xpY2spIHtcbiAgICAgICAgICBlbFBhdGguY2xpY2sodGhpcy5waWVDbGlja2VkLmJpbmQodGhpcywgaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmRhdGFMYWJlbHMuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciB4UG9zID0gbGFiZWxQb3NpdGlvbi54O1xuICAgICAgICAgIHZhciB5UG9zID0gbGFiZWxQb3NpdGlvbi55O1xuICAgICAgICAgIHZhciB0ZXh0ID0gMTAwICogKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAzNjAgKyAnJSc7XG5cbiAgICAgICAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSB3LmNvbmZpZy5kYXRhTGFiZWxzLmZvcm1hdHRlcjtcblxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRleHQgPSBmb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1BlcmNlbnRbaV1bMF0sIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICAgICAgICB3OiB3XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZm9yZUNvbG9yID0gdy5nbG9iYWxzLmRhdGFMYWJlbHMuc3R5bGUuY29sb3JzW2ldO1xuICAgICAgICAgICAgdmFyIGVsUGllTGFiZWwgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgICAgIHg6IHhQb3MsXG4gICAgICAgICAgICAgIHk6IHlQb3MsXG4gICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogdy5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogdy5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgICAgICBmb3JlQ29sb3I6IGZvcmVDb2xvclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5kYXRhTGFiZWxzLmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgICAgICB2YXIgdGV4dFNoYWRvdyA9IHcuY29uZmlnLmRhdGFMYWJlbHMuZHJvcFNoYWRvdztcblxuICAgICAgICAgICAgICB2YXIgX2ZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICAgICAgX2ZpbHRlcnMuZHJvcFNoYWRvdyhlbFBpZUxhYmVsLCB0ZXh0U2hhZG93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxQaWVMYWJlbC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtcGllLWxhYmVsJyk7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmFuaW1hdGUgJiYgdy5nbG9iYWxzLnJlc2l6ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGVsUGllTGFiZWwubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXBpZS1sYWJlbC1kZWxheScpO1xuICAgICAgICAgICAgICBlbFBpZUxhYmVsLm5vZGUuc3R5bGUuYW5pbWF0aW9uRGVsYXkgPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLnNwZWVkIC8gOTQwICsgJ3MnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNsaWNlTGFiZWxzLnB1c2goZWxQaWVMYWJlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZExpc3RlbmVycyhlbFBhdGgsIGRhdGFMYWJlbHMpIHtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7IC8vIGFwcGVuZCBmaWx0ZXJzIG9uIG1vdXNlZW50ZXIgYW5kIG1vdXNlbGVhdmVcblxuICAgICAgZWxQYXRoLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGdyYXBoaWNzLnBhdGhNb3VzZUVudGVyLmJpbmQodGhpcywgZWxQYXRoKSk7XG4gICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5wcmludERhdGFMYWJlbHNJbm5lci5iaW5kKHRoaXMsIGVsUGF0aC5ub2RlLCBkYXRhTGFiZWxzKSk7XG4gICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZ3JhcGhpY3MucGF0aE1vdXNlTGVhdmUuYmluZCh0aGlzLCBlbFBhdGgpKTtcbiAgICAgIGVsUGF0aC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLnJldmVydERhdGFMYWJlbHNJbm5lci5iaW5kKHRoaXMsIGVsUGF0aC5ub2RlLCBkYXRhTGFiZWxzKSk7XG4gICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBncmFwaGljcy5wYXRoTW91c2VEb3duLmJpbmQodGhpcywgZWxQYXRoKSk7XG4gICAgICBlbFBhdGgubm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnByaW50RGF0YUxhYmVsc0lubmVyLmJpbmQodGhpcywgZWxQYXRoLm5vZGUsIGRhdGFMYWJlbHMpKTtcbiAgICB9IC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgZm9yIG90aGVyIGNpcmNsZSBjaGFydHMgdG9vXG5cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZVBhdGhzKGVsLCBvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgYW5nbGUgPSBvcHRzLmVuZEFuZ2xlIC0gb3B0cy5zdGFydEFuZ2xlO1xuICAgICAgdmFyIHByZXZBbmdsZSA9IGFuZ2xlO1xuICAgICAgdmFyIGZyb21TdGFydEFuZ2xlID0gb3B0cy5zdGFydEFuZ2xlO1xuICAgICAgdmFyIHRvU3RhcnRBbmdsZSA9IG9wdHMuc3RhcnRBbmdsZTtcblxuICAgICAgaWYgKG9wdHMucHJldlN0YXJ0QW5nbGUgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnByZXZFbmRBbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZyb21TdGFydEFuZ2xlID0gb3B0cy5wcmV2RW5kQW5nbGU7XG4gICAgICAgIHByZXZBbmdsZSA9IG9wdHMucHJldkVuZEFuZ2xlIC0gb3B0cy5wcmV2U3RhcnRBbmdsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMuaSA9PT0gdy5jb25maWcuc2VyaWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gc29tZSBhZGp1c3RtZW50cyBmb3IgdGhlIGxhc3Qgb3ZlcmxhcHBpbmcgcGF0aHNcbiAgICAgICAgaWYgKGFuZ2xlICsgdG9TdGFydEFuZ2xlID4gdGhpcy5mdWxsQW5nbGUpIHtcbiAgICAgICAgICBvcHRzLmVuZEFuZ2xlID0gb3B0cy5lbmRBbmdsZSAtIChhbmdsZSArIHRvU3RhcnRBbmdsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5nbGUgKyB0b1N0YXJ0QW5nbGUgPCB0aGlzLmZ1bGxBbmdsZSkge1xuICAgICAgICAgIG9wdHMuZW5kQW5nbGUgPSBvcHRzLmVuZEFuZ2xlICsgKHRoaXMuZnVsbEFuZ2xlIC0gKGFuZ2xlICsgdG9TdGFydEFuZ2xlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFuZ2xlID09PSB0aGlzLmZ1bGxBbmdsZSkgYW5nbGUgPSB0aGlzLmZ1bGxBbmdsZSAtIDAuMDE7XG4gICAgICBtZS5hbmltYXRlQXJjKGVsLCBmcm9tU3RhcnRBbmdsZSwgdG9TdGFydEFuZ2xlLCBhbmdsZSwgcHJldkFuZ2xlLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZUFyY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlQXJjKGVsLCBmcm9tU3RhcnRBbmdsZSwgdG9TdGFydEFuZ2xlLCBhbmdsZSwgcHJldkFuZ2xlLCBvcHRzKSB7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgc2l6ZSA9IG1lLnNpemU7XG5cbiAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICBzaXplID0gb3B0cy5zaXplO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aDtcblxuICAgICAgaWYgKGlzTmFOKGZyb21TdGFydEFuZ2xlKSB8fCBpc05hTihwcmV2QW5nbGUpKSB7XG4gICAgICAgIGZyb21TdGFydEFuZ2xlID0gdG9TdGFydEFuZ2xlO1xuICAgICAgICBwcmV2QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgb3B0cy5kdXIgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VyckFuZ2xlID0gYW5nbGU7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHRvU3RhcnRBbmdsZTtcbiAgICAgIHZhciBmcm9tQW5nbGUgPSBmcm9tU3RhcnRBbmdsZSAtIHRvU3RhcnRBbmdsZTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCAmJiBvcHRzLnNob3VsZFNldFByZXZQYXRocykge1xuICAgICAgICAvLyB0byBhdm9pZCBmbGlja2VyaW5nLCBzZXQgcHJldiBwYXRoIGZpcnN0IGFuZCB0aGVuIHdlIHdpbGwgYW5pbWF0ZSBmcm9tIHRoZXJlXG4gICAgICAgIHBhdGggPSBtZS5nZXRQaWVQYXRoKHtcbiAgICAgICAgICBtZTogbWUsXG4gICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICBhbmdsZTogcHJldkFuZ2xlLFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLmF0dHIoe1xuICAgICAgICAgIGQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmR1ciAhPT0gMCkge1xuICAgICAgICBlbC5hbmltYXRlKG9wdHMuZHVyLCB3Lmdsb2JhbHMuZWFzaW5nLCBvcHRzLmFuaW1CZWdpbkFycltvcHRzLmldKS5hZnRlckFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdwaWUnIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZSgzMDApLmF0dHIoe1xuICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdy5jb25maWcuc3Ryb2tlLndpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgICB9KS5kdXJpbmcoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgIGN1cnJBbmdsZSA9IGZyb21BbmdsZSArIChhbmdsZSAtIGZyb21BbmdsZSkgKiBwb3M7XG5cbiAgICAgICAgICBpZiAob3B0cy5hbmltYXRlU3RhcnRpbmdQb3MpIHtcbiAgICAgICAgICAgIGN1cnJBbmdsZSA9IHByZXZBbmdsZSArIChhbmdsZSAtIHByZXZBbmdsZSkgKiBwb3M7XG4gICAgICAgICAgICBzdGFydEFuZ2xlID0gZnJvbVN0YXJ0QW5nbGUgLSBwcmV2QW5nbGUgKyAodG9TdGFydEFuZ2xlIC0gKGZyb21TdGFydEFuZ2xlIC0gcHJldkFuZ2xlKSkgKiBwb3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCA9IG1lLmdldFBpZVBhdGgoe1xuICAgICAgICAgICAgbWU6IG1lLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICAgIGFuZ2xlOiBjdXJyQW5nbGUsXG4gICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWwubm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGE6cGF0aE9yaWcnLCBwYXRoKTtcbiAgICAgICAgICBlbC5hdHRyKHtcbiAgICAgICAgICAgIGQ6IHBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gbWUuZ2V0UGllUGF0aCh7XG4gICAgICAgICAgbWU6IG1lLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFvcHRzLmlzVHJhY2spIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwubm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGE6cGF0aE9yaWcnLCBwYXRoKTtcbiAgICAgICAgZWwuYXR0cih7XG4gICAgICAgICAgZDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGllQ2xpY2tlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaWVDbGlja2VkKGkpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBwYXRoO1xuICAgICAgdmFyIHNpemUgPSBtZS5zaXplICsgNDtcbiAgICAgIHZhciBlbFBhdGggPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnNlbGVjdChcIiNhcGV4Y2hhcnRzLVwiLmNvbmNhdCh3LmNvbmZpZy5jaGFydC50eXBlLnRvTG93ZXJDYXNlKCksIFwiLXNsaWNlLVwiKS5jb25jYXQoaSkpLm1lbWJlcnNbMF07XG4gICAgICB2YXIgcGF0aEZyb20gPSBlbFBhdGguYXR0cignZCcpO1xuXG4gICAgICBpZiAoZWxQYXRoLmF0dHIoJ2RhdGE6cGllQ2xpY2tlZCcpID09PSAndHJ1ZScpIHtcbiAgICAgICAgZWxQYXRoLmF0dHIoe1xuICAgICAgICAgICdkYXRhOnBpZUNsaWNrZWQnOiAnZmFsc2UnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb3JpZ1BhdGggPSBlbFBhdGguYXR0cignZGF0YTpwYXRoT3JpZycpO1xuICAgICAgICBlbFBhdGguYXR0cih7XG4gICAgICAgICAgZDogb3JpZ1BhdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc2V0IGFsbCBlbGVtc1xuICAgICAgICB2YXIgYWxsRWxzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtcGllLWFyZWEnKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhbGxFbHMsIGZ1bmN0aW9uIChwaWVTbGljZSkge1xuICAgICAgICAgIHBpZVNsaWNlLnNldEF0dHJpYnV0ZSgnZGF0YTpwaWVDbGlja2VkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgdmFyIG9yaWdQYXRoID0gcGllU2xpY2UuZ2V0QXR0cmlidXRlKCdkYXRhOnBhdGhPcmlnJyk7XG4gICAgICAgICAgcGllU2xpY2Uuc2V0QXR0cmlidXRlKCdkJywgb3JpZ1BhdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxQYXRoLmF0dHIoJ2RhdGE6cGllQ2xpY2tlZCcsICd0cnVlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEFuZ2xlID0gcGFyc2VJbnQoZWxQYXRoLmF0dHIoJ2RhdGE6c3RhcnRBbmdsZScpKTtcbiAgICAgIHZhciBhbmdsZSA9IHBhcnNlSW50KGVsUGF0aC5hdHRyKCdkYXRhOmFuZ2xlJykpO1xuICAgICAgcGF0aCA9IG1lLmdldFBpZVBhdGgoe1xuICAgICAgICBtZTogbWUsXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgfSk7XG4gICAgICBpZiAoYW5nbGUgPT09IDM2MCkgcmV0dXJuO1xuICAgICAgZWxQYXRoLnBsb3QocGF0aCkuYW5pbWF0ZSgxKS5wbG90KHBhdGhGcm9tKS5hbmltYXRlKDEwMCkucGxvdChwYXRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2hhbmdlZFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhbmdlZFBhdGgocHJldlN0YXJ0QW5nbGUsIHByZXZFbmRBbmdsZSkge1xuICAgICAgdmFyIHBhdGggPSAnJztcblxuICAgICAgaWYgKHRoaXMuZHluYW1pY0FuaW0gJiYgdGhpcy53Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgcGF0aCA9IHRoaXMuZ2V0UGllUGF0aCh7XG4gICAgICAgICAgbWU6IHRoaXMsXG4gICAgICAgICAgc3RhcnRBbmdsZTogcHJldlN0YXJ0QW5nbGUsXG4gICAgICAgICAgYW5nbGU6IHByZXZFbmRBbmdsZSAtIHByZXZTdGFydEFuZ2xlLFxuICAgICAgICAgIHNpemU6IHRoaXMuc2l6ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBpZVBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGllUGF0aChfcmVmKSB7XG4gICAgICB2YXIgbWUgPSBfcmVmLm1lLFxuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBfcmVmLnN0YXJ0QW5nbGUsXG4gICAgICAgICAgYW5nbGUgPSBfcmVmLmFuZ2xlLFxuICAgICAgICAgIHNpemUgPSBfcmVmLnNpemU7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwYXRoO1xuICAgICAgdmFyIHN0YXJ0RGVnID0gc3RhcnRBbmdsZTtcbiAgICAgIHZhciBzdGFydFJhZGlhbnMgPSBNYXRoLlBJICogKHN0YXJ0RGVnIC0gOTApIC8gMTgwO1xuICAgICAgdmFyIGVuZERlZyA9IGFuZ2xlICsgc3RhcnRBbmdsZTtcbiAgICAgIGlmIChNYXRoLmNlaWwoZW5kRGVnKSA+PSAzNjApIGVuZERlZyA9IDM1OS45OTtcbiAgICAgIHZhciBlbmRSYWRpYW5zID0gTWF0aC5QSSAqIChlbmREZWcgLSA5MCkgLyAxODA7XG4gICAgICB2YXIgeDEgPSBtZS5jZW50ZXJYICsgc2l6ZSAqIE1hdGguY29zKHN0YXJ0UmFkaWFucyk7XG4gICAgICB2YXIgeTEgPSBtZS5jZW50ZXJZICsgc2l6ZSAqIE1hdGguc2luKHN0YXJ0UmFkaWFucyk7XG4gICAgICB2YXIgeDIgPSBtZS5jZW50ZXJYICsgc2l6ZSAqIE1hdGguY29zKGVuZFJhZGlhbnMpO1xuICAgICAgdmFyIHkyID0gbWUuY2VudGVyWSArIHNpemUgKiBNYXRoLnNpbihlbmRSYWRpYW5zKTtcbiAgICAgIHZhciBzdGFydElubmVyID0gVXRpbHMucG9sYXJUb0NhcnRlc2lhbihtZS5jZW50ZXJYLCBtZS5jZW50ZXJZLCBtZS5kb251dFNpemUsIGVuZERlZyk7XG4gICAgICB2YXIgZW5kSW5uZXIgPSBVdGlscy5wb2xhclRvQ2FydGVzaWFuKG1lLmNlbnRlclgsIG1lLmNlbnRlclksIG1lLmRvbnV0U2l6ZSwgc3RhcnREZWcpO1xuICAgICAgdmFyIGxhcmdlQXJjID0gYW5nbGUgPiAxODAgPyAxIDogMDtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdkb251dCcpIHtcbiAgICAgICAgcGF0aCA9IFsnTScsIHgxLCB5MSwgJ0EnLCBzaXplLCBzaXplLCAwLCBsYXJnZUFyYywgMSwgeDIsIHkyLCAnTCcsIHN0YXJ0SW5uZXIueCwgc3RhcnRJbm5lci55LCAnQScsIG1lLmRvbnV0U2l6ZSwgbWUuZG9udXRTaXplLCAwLCBsYXJnZUFyYywgMCwgZW5kSW5uZXIueCwgZW5kSW5uZXIueSwgJ0wnLCB4MSwgeTEsICd6J10uam9pbignICcpO1xuICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAncGllJykge1xuICAgICAgICBwYXRoID0gWydNJywgeDEsIHkxLCAnQScsIHNpemUsIHNpemUsIDAsIGxhcmdlQXJjLCAxLCB4MiwgeTIsICdMJywgbWUuY2VudGVyWCwgbWUuY2VudGVyWSwgJ0wnLCB4MSwgeTFdLmpvaW4oJyAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBbJ00nLCB4MSwgeTEsICdBJywgc2l6ZSwgc2l6ZSwgMCwgbGFyZ2VBcmMsIDEsIHgyLCB5Ml0uam9pbignICcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVySW5uZXJEYXRhTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcklubmVyRGF0YUxhYmVscyhkYXRhTGFiZWxzQ29uZmlnLCBvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGFsYWJlbHMtZ3JvdXAnLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiLmNvbmNhdChvcHRzLnRyYW5zbGF0ZVggPyBvcHRzLnRyYW5zbGF0ZVggOiAwLCBcIiwgXCIpLmNvbmNhdChvcHRzLnRyYW5zbGF0ZVkgPyBvcHRzLnRyYW5zbGF0ZVkgOiAwLCBcIilcIilcbiAgICAgIH0pO1xuICAgICAgdmFyIHNob3dUb3RhbCA9IGRhdGFMYWJlbHNDb25maWcudG90YWwuc2hvdztcbiAgICAgIGcubm9kZS5zdHlsZS5vcGFjaXR5ID0gb3B0cy5vcGFjaXR5O1xuICAgICAgdmFyIHggPSBvcHRzLmNlbnRlclg7XG4gICAgICB2YXIgeSA9IG9wdHMuY2VudGVyWTtcbiAgICAgIHZhciBsYWJlbENvbG9yLCB2YWx1ZUNvbG9yO1xuXG4gICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy5uYW1lLmNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGFiZWxDb2xvciA9IHcuZ2xvYmFscy5jb2xvcnNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbENvbG9yID0gZGF0YUxhYmVsc0NvbmZpZy5uYW1lLmNvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy52YWx1ZS5jb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlQ29sb3IgPSB3LmNvbmZpZy5jaGFydC5mb3JlQ29sb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZUNvbG9yID0gZGF0YUxhYmVsc0NvbmZpZy52YWx1ZS5jb2xvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxiRm9ybWF0dGVyID0gZGF0YUxhYmVsc0NvbmZpZy52YWx1ZS5mb3JtYXR0ZXI7XG4gICAgICB2YXIgdmFsID0gJyc7XG4gICAgICB2YXIgbmFtZSA9ICcnO1xuXG4gICAgICBpZiAoc2hvd1RvdGFsKSB7XG4gICAgICAgIGxhYmVsQ29sb3IgPSBkYXRhTGFiZWxzQ29uZmlnLnRvdGFsLmNvbG9yO1xuICAgICAgICBuYW1lID0gZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5sYWJlbDtcbiAgICAgICAgdmFsID0gZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5mb3JtYXR0ZXIodyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAody5nbG9iYWxzLnNlcmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB2YWwgPSBsYkZvcm1hdHRlcih3Lmdsb2JhbHMuc2VyaWVzWzBdLCB3KTtcbiAgICAgICAgICBuYW1lID0gdy5nbG9iYWxzLnNlcmllc05hbWVzWzBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhTGFiZWxzQ29uZmlnLm5hbWUuc2hvdykge1xuICAgICAgICB2YXIgZWxMYWJlbCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHkgKyBwYXJzZUludChkYXRhTGFiZWxzQ29uZmlnLm5hbWUub2Zmc2V0WSksXG4gICAgICAgICAgdGV4dDogbmFtZSxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICBmb3JlQ29sb3I6IGxhYmVsQ29sb3IsXG4gICAgICAgICAgZm9udFNpemU6IGRhdGFMYWJlbHNDb25maWcubmFtZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiBkYXRhTGFiZWxzQ29uZmlnLm5hbWUuZm9udEZhbWlseVxuICAgICAgICB9KTtcbiAgICAgICAgZWxMYWJlbC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZGF0YWxhYmVsLWxhYmVsJyk7XG4gICAgICAgIGcuYWRkKGVsTGFiZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YUxhYmVsc0NvbmZpZy52YWx1ZS5zaG93KSB7XG4gICAgICAgIHZhciB2YWxPZmZzZXQgPSBkYXRhTGFiZWxzQ29uZmlnLm5hbWUuc2hvdyA/IHBhcnNlSW50KGRhdGFMYWJlbHNDb25maWcudmFsdWUub2Zmc2V0WSkgKyAxNiA6IGRhdGFMYWJlbHNDb25maWcudmFsdWUub2Zmc2V0WTtcbiAgICAgICAgdmFyIGVsVmFsdWUgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5ICsgdmFsT2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IHZhbCxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICBmb3JlQ29sb3I6IHZhbHVlQ29sb3IsXG4gICAgICAgICAgZm9udFNpemU6IGRhdGFMYWJlbHNDb25maWcudmFsdWUuZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogZGF0YUxhYmVsc0NvbmZpZy52YWx1ZS5mb250RmFtaWx5XG4gICAgICAgIH0pO1xuICAgICAgICBlbFZhbHVlLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1kYXRhbGFiZWwtdmFsdWUnKTtcbiAgICAgICAgZy5hZGQoZWxWYWx1ZSk7XG4gICAgICB9IC8vIGZvciBhIG11bHRpLXNlcmllcyBjaXJjbGUgY2hhcnQsIHdlIG5lZWQgdG8gc2hvdyB0b3RhbCB2YWx1ZSBpbnN0ZWFkIG9mIGZpcnN0IHNlcmllcyBsYWJlbHNcblxuXG4gICAgICByZXR1cm4gZztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsIC0gVGhlIHZhbHVlIG9mIHRoYXQgc2VyaWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsIC0gT3B0aW9uYWwgZWwgKGluZGljYXRlcyB3aGljaCBzZXJpZXMgd2FzIGhvdmVyZWQvY2xpY2tlZCkuIElmIHRoaXMgcGFyYW0gaXMgbm90IHByZXNlbnQsIG1lYW5zIHdlIG5lZWQgdG8gc2hvdyB0b3RhbFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJpbnRJbm5lckxhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmludElubmVyTGFiZWxzKGxhYmVsc0NvbmZpZywgbmFtZSwgdmFsLCBlbCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbGFiZWxDb2xvcjtcblxuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGlmIChsYWJlbHNDb25maWcubmFtZS5jb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGFiZWxDb2xvciA9IHcuZ2xvYmFscy5jb2xvcnNbcGFyc2VJbnQoZWwucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsQ29sb3IgPSBsYWJlbHNDb25maWcubmFtZS5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSAmJiBsYWJlbHNDb25maWcudG90YWwuc2hvdykge1xuICAgICAgICAgIGxhYmVsQ29sb3IgPSBsYWJlbHNDb25maWcudG90YWwuY29sb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGVsTGFiZWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1kYXRhbGFiZWwtbGFiZWwnKTtcbiAgICAgIHZhciBlbFZhbHVlID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZGF0YWxhYmVsLXZhbHVlJyk7XG4gICAgICB2YXIgbGJGb3JtYXR0ZXIgPSBsYWJlbHNDb25maWcudmFsdWUuZm9ybWF0dGVyO1xuICAgICAgdmFsID0gbGJGb3JtYXR0ZXIodmFsLCB3KTsgLy8gd2UgbmVlZCB0byBzaG93IFRvdGFsIFZhbCAtIHNvIGdldCB0aGUgZm9ybWF0dGVyIG9mIGl0XG5cbiAgICAgIGlmICghZWwgJiYgdHlwZW9mIGxhYmVsc0NvbmZpZy50b3RhbC5mb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsID0gbGFiZWxzQ29uZmlnLnRvdGFsLmZvcm1hdHRlcih3KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsTGFiZWwgIT09IG51bGwpIHtcbiAgICAgICAgZWxMYWJlbC50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGVsVmFsdWUudGV4dENvbnRlbnQgPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbExhYmVsICE9PSBudWxsKSB7XG4gICAgICAgIGVsTGFiZWwuc3R5bGUuZmlsbCA9IGxhYmVsQ29sb3I7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByaW50RGF0YUxhYmVsc0lubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByaW50RGF0YUxhYmVsc0lubmVyKGVsLCBkYXRhTGFiZWxzQ29uZmlnKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB2YWwgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGE6dmFsdWUnKTtcbiAgICAgIHZhciBuYW1lID0gdy5nbG9iYWxzLnNlcmllc05hbWVzW3BhcnNlSW50KGVsLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdyZWwnKSkgLSAxXTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnByaW50SW5uZXJMYWJlbHMoZGF0YUxhYmVsc0NvbmZpZywgbmFtZSwgdmFsLCBlbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhTGFiZWxzR3JvdXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1kYXRhbGFiZWxzLWdyb3VwJyk7XG5cbiAgICAgIGlmIChkYXRhTGFiZWxzR3JvdXAgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YUxhYmVsc0dyb3VwLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnREYXRhTGFiZWxzSW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJ0RGF0YUxhYmVsc0lubmVyKGVsLCBkYXRhTGFiZWxzQ29uZmlnKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBkYXRhTGFiZWxzR3JvdXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1kYXRhbGFiZWxzLWdyb3VwJyk7XG5cbiAgICAgIGlmIChkYXRhTGFiZWxzQ29uZmlnLnRvdGFsLnNob3cgJiYgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBwaWUgPSBuZXcgUGllKHRoaXMuY3R4KTtcbiAgICAgICAgcGllLnByaW50SW5uZXJMYWJlbHMoZGF0YUxhYmVsc0NvbmZpZywgZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5sYWJlbCwgZGF0YUxhYmVsc0NvbmZpZy50b3RhbC5mb3JtYXR0ZXIodykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHMubGVuZ3RoICYmIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHcuZ2xvYmFscy5zZWxlY3RlZERhdGFQb2ludHNbMF07XG5cbiAgICAgICAgICAgIHZhciBfZWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiI2FwZXhjaGFydHMtXCIuY29uY2F0KHcuY29uZmlnLmNoYXJ0LnR5cGUudG9Mb3dlckNhc2UoKSwgXCItc2xpY2UtXCIpLmNvbmNhdChpbmRleCkpO1xuXG4gICAgICAgICAgICB0aGlzLnByaW50RGF0YUxhYmVsc0lubmVyKF9lbCwgZGF0YUxhYmVsc0NvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzLmxlbmd0aCAmJiB3Lmdsb2JhbHMuc2VsZWN0ZWREYXRhUG9pbnRzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGF0YUxhYmVsc0dyb3VwLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZGF0YUxhYmVsc0dyb3VwICE9PSBudWxsICYmIHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZGF0YUxhYmVsc0dyb3VwLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQaWU7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBSYWRhciBDbGFzcyBmb3IgU3BpZGVyL1JhZGFyIENoYXJ0cy5cbiAqIEBtb2R1bGUgUmFkYXJcbiAqKi9cblxudmFyIFJhZGFyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmFkYXIoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGFyKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMuY2hhcnRUeXBlID0gdGhpcy53LmNvbmZpZy5jaGFydC50eXBlO1xuICAgIHRoaXMuaW5pdGlhbEFuaW0gPSB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZDtcbiAgICB0aGlzLmR5bmFtaWNBbmltID0gdGhpcy5pbml0aWFsQW5pbSAmJiB0aGlzLncuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkO1xuICAgIHRoaXMuYW5pbUR1ciA9IDA7XG4gICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgdGhpcy5saW5lQ29sb3JBcnIgPSB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9ycyAhPT0gdW5kZWZpbmVkID8gdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnMgOiB3Lmdsb2JhbHMuY29sb3JzO1xuICAgIHRoaXMuZGVmYXVsdFNpemUgPSB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IDwgdy5nbG9iYWxzLnN2Z1dpZHRoID8gdy5nbG9iYWxzLnN2Z0hlaWdodCAtIDM1IDogdy5nbG9iYWxzLmdyaWRXaWR0aDtcbiAgICB0aGlzLm1heFZhbHVlID0gdGhpcy53Lmdsb2JhbHMubWF4WTtcbiAgICB0aGlzLnBvbHlnb25zID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkYXIucG9seWdvbnM7XG4gICAgdGhpcy5tYXhMYWJlbFdpZHRoID0gMjA7XG4gICAgdmFyIGxvbmdlc3RMYWJlbCA9IHcuZ2xvYmFscy5sYWJlbHMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICB9KVswXTtcbiAgICB2YXIgbGFiZWxXaWR0aCA9IHRoaXMuZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKGxvbmdlc3RMYWJlbCwgdy5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5mb250U2l6ZSk7XG4gICAgdGhpcy5zaXplID0gdGhpcy5kZWZhdWx0U2l6ZSAvIDIuMSAtIHcuY29uZmlnLnN0cm9rZS53aWR0aCAtIHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuYmx1ciAtIGxhYmVsV2lkdGgud2lkdGggLyAxLjc1O1xuXG4gICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGFyLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zaXplID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkYXIuc2l6ZTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFSYWRpdXNPZlBlcmNlbnQgPSBbXTtcbiAgICB0aGlzLmRhdGFSYWRpdXMgPSBbXTtcbiAgICB0aGlzLmFuZ2xlQXJyID0gW107XG4gICAgdGhpcy55YXhpc0xhYmVsc1RleHRzUG9zID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmFkYXIsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgYWxsU2VyaWVzID0gW107XG4gICAgICB0aGlzLmRhdGFQb2ludHNMZW4gPSBzZXJpZXNbdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aDtcbiAgICAgIHRoaXMuZGlzQW5nbGUgPSBNYXRoLlBJICogMiAvIHRoaXMuZGF0YVBvaW50c0xlbjtcbiAgICAgIHZhciBoYWxmVyA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyO1xuICAgICAgdmFyIGhhbGZIID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyO1xuICAgICAgdmFyIHRyYW5zbGF0ZVggPSBoYWxmVztcbiAgICAgIHZhciB0cmFuc2xhdGVZID0gaGFsZkg7XG4gICAgICB2YXIgcmV0ID0gdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1yYWRhci1zZXJpZXMnLFxuICAgICAgICAnZGF0YTppbm5lclRyYW5zbGF0ZVgnOiB0cmFuc2xhdGVYLFxuICAgICAgICAnZGF0YTppbm5lclRyYW5zbGF0ZVknOiB0cmFuc2xhdGVZIC0gMjUsXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRyYW5zbGF0ZVggfHwgMCwgXCIsIFwiKS5jb25jYXQodHJhbnNsYXRlWSB8fCAwLCBcIilcIilcbiAgICAgIH0pO1xuICAgICAgdmFyIGRhdGFQb2ludHNQb3MgPSBbXTtcbiAgICAgIHZhciBlbFBvaW50c01haW4gPSBudWxsO1xuICAgICAgdGhpcy55YXhpc0xhYmVscyA9IHRoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMnXG4gICAgICB9KTtcbiAgICAgIHNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgIC8vIGVsIHRvIHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduXG4gICAgICAgIHZhciBlbFNlcmllcyA9IF90aGlzLmdyYXBoaWNzLmdyb3VwKCkuYXR0cih7XG4gICAgICAgICAgY2xhc3M6IFwiYXBleGNoYXJ0cy1zZXJpZXMgXCIuY29uY2F0KFV0aWxzLmVzY2FwZVN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbaV0pKSxcbiAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICdkYXRhOnJlYWxJbmRleCc6IGlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuZGF0YVJhZGl1c09mUGVyY2VudFtpXSA9IFtdO1xuICAgICAgICBfdGhpcy5kYXRhUmFkaXVzW2ldID0gW107XG4gICAgICAgIF90aGlzLmFuZ2xlQXJyW2ldID0gW107XG4gICAgICAgIHMuZm9yRWFjaChmdW5jdGlvbiAoZHYsIGopIHtcbiAgICAgICAgICBfdGhpcy5kYXRhUmFkaXVzT2ZQZXJjZW50W2ldW2pdID0gZHYgLyBfdGhpcy5tYXhWYWx1ZTtcbiAgICAgICAgICBfdGhpcy5kYXRhUmFkaXVzW2ldW2pdID0gX3RoaXMuZGF0YVJhZGl1c09mUGVyY2VudFtpXVtqXSAqIF90aGlzLnNpemU7XG4gICAgICAgICAgX3RoaXMuYW5nbGVBcnJbaV1bal0gPSBqICogX3RoaXMuZGlzQW5nbGU7XG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhUG9pbnRzUG9zID0gX3RoaXMuZ2V0RGF0YVBvaW50c1BvcyhfdGhpcy5kYXRhUmFkaXVzW2ldLCBfdGhpcy5hbmdsZUFycltpXSk7XG5cbiAgICAgICAgdmFyIHBhdGhzID0gX3RoaXMuY3JlYXRlUGF0aHMoZGF0YVBvaW50c1Bvcywge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9KTsgLy8gcG9pbnRzXG5cblxuICAgICAgICBlbFBvaW50c01haW4gPSBfdGhpcy5ncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzLXdyYXAgaGlkZGVuJ1xuICAgICAgICB9KTtcbiAgICAgICAgdy5nbG9iYWxzLmRlbGF5ZWRFbGVtZW50cy5wdXNoKHtcbiAgICAgICAgICBlbDogZWxQb2ludHNNYWluLm5vZGUsXG4gICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucyA9IHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIHJlYWxJbmRleDogaSxcbiAgICAgICAgICBhbmltYXRpb25EZWxheTogaSxcbiAgICAgICAgICBpbml0aWFsU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQsXG4gICAgICAgICAgZGF0YUNoYW5nZVNwZWVkOiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uc3BlZWQsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFwZXhjaGFydHMtcmFkYXJcIixcbiAgICAgICAgICBpZDogXCJhcGV4Y2hhcnRzLXJhZGFyXCIsXG4gICAgICAgICAgc2hvdWxkQ2xpcFRvR3JpZDogZmFsc2UsXG4gICAgICAgICAgYmluZEV2ZW50c09uUGF0aHM6IGZhbHNlLFxuICAgICAgICAgIHN0cm9rZTogdy5nbG9iYWxzLnN0cm9rZS5jb2xvcnNbaV0sXG4gICAgICAgICAgc3Ryb2tlTGluZUNhcDogdy5jb25maWcuc3Ryb2tlLmxpbmVDYXBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhdGhGcm9tID0gbnVsbDtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhdGhGcm9tID0gX3RoaXMuZ2V0UGF0aEZyb20oaSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhdGhzLmxpbmVQYXRoc1RvLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgdmFyIHJlbmRlcmVkTGluZVBhdGggPSBfdGhpcy5ncmFwaGljcy5yZW5kZXJQYXRocyhfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UmVuZGVyZWRQYXRoT3B0aW9ucywge1xuICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tID09PSBudWxsID8gcGF0aHMubGluZVBhdGhzRnJvbVtwXSA6IHBhdGhGcm9tLFxuICAgICAgICAgICAgcGF0aFRvOiBwYXRocy5saW5lUGF0aHNUb1twXSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBBcnJheS5pc0FycmF5KHcuY29uZmlnLnN0cm9rZS53aWR0aCkgPyB3LmNvbmZpZy5zdHJva2Uud2lkdGhbaV0gOiB3LmNvbmZpZy5zdHJva2Uud2lkdGgsXG4gICAgICAgICAgICBmaWxsOiAnbm9uZSdcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBlbFNlcmllcy5hZGQocmVuZGVyZWRMaW5lUGF0aCk7XG4gICAgICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICBzZXJpZXNOdW1iZXI6IGlcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciByZW5kZXJlZEFyZWFQYXRoID0gX3RoaXMuZ3JhcGhpY3MucmVuZGVyUGF0aHMoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFJlbmRlcmVkUGF0aE9wdGlvbnMsIHtcbiAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbSA9PT0gbnVsbCA/IHBhdGhzLmFyZWFQYXRoc0Zyb21bcF0gOiBwYXRoRnJvbSxcbiAgICAgICAgICAgIHBhdGhUbzogcGF0aHMuYXJlYVBhdGhzVG9bcF0sXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgICAgIGZpbGw6IHBhdGhGaWxsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyhfdGhpcy5jdHgpO1xuICAgICAgICAgICAgdmFyIHNoYWRvdyA9IHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3c7XG4gICAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3cocmVuZGVyZWRBcmVhUGF0aCwgX29iamVjdFNwcmVhZCh7fSwgc2hhZG93LCB7XG4gICAgICAgICAgICAgIG5vVXNlclNwYWNlT25Vc2U6IHRydWVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbFNlcmllcy5hZGQocmVuZGVyZWRBcmVhUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHNqLCBqKSB7XG4gICAgICAgICAgdmFyIG1hcmtlcnMgPSBuZXcgTWFya2VycyhfdGhpcy5jdHgpO1xuICAgICAgICAgIHZhciBvcHRzID0gbWFya2Vycy5nZXRNYXJrZXJDb25maWcoJ2FwZXhjaGFydHMtbWFya2VyJywgaSk7XG5cbiAgICAgICAgICB2YXIgcG9pbnQgPSBfdGhpcy5ncmFwaGljcy5kcmF3TWFya2VyKGRhdGFQb2ludHNQb3Nbal0ueCwgZGF0YVBvaW50c1Bvc1tqXS55LCBvcHRzKTtcblxuICAgICAgICAgIHBvaW50LmF0dHIoJ3JlbCcsIGopO1xuICAgICAgICAgIHBvaW50LmF0dHIoJ2onLCBqKTtcbiAgICAgICAgICBwb2ludC5hdHRyKCdpbmRleCcsIGkpO1xuICAgICAgICAgIHBvaW50Lm5vZGUuc2V0QXR0cmlidXRlKCdkZWZhdWx0LW1hcmtlci1zaXplJywgb3B0cy5wU2l6ZSk7XG5cbiAgICAgICAgICB2YXIgZWxQb2ludHNXcmFwID0gX3RoaXMuZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGVsUG9pbnRzV3JhcCkge1xuICAgICAgICAgICAgZWxQb2ludHNXcmFwLmFkZChwb2ludCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxQb2ludHNNYWluLmFkZChlbFBvaW50c1dyYXApO1xuICAgICAgICAgIGVsU2VyaWVzLmFkZChlbFBvaW50c01haW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsU2VyaWVzLnB1c2goZWxTZXJpZXMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRyYXdQb2x5Z29ucyh7XG4gICAgICAgIHBhcmVudDogcmV0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHcuY29uZmlnLmRhdGFMYWJlbHMuZW5hYmxlZCkge1xuICAgICAgICB2YXIgZGF0YUxhYmVscyA9IHRoaXMuZHJhd0xhYmVscygpO1xuICAgICAgICByZXQuYWRkKGRhdGFMYWJlbHMpO1xuICAgICAgfVxuXG4gICAgICByZXQuYWRkKHRoaXMueWF4aXNMYWJlbHMpO1xuICAgICAgYWxsU2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVsUykge1xuICAgICAgICByZXQuYWRkKGVsUyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdQb2x5Z29uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3UG9seWdvbnMob3B0cykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHBhcmVudCA9IG9wdHMucGFyZW50O1xuICAgICAgdmFyIHlheGlzVGV4dHMgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQucmV2ZXJzZSgpO1xuICAgICAgdmFyIGxheWVycyA9IHlheGlzVGV4dHMubGVuZ3RoO1xuICAgICAgdmFyIHJhZGl1c1NpemVzID0gW107XG4gICAgICB2YXIgbGF5ZXJEaXMgPSB0aGlzLnNpemUgLyAobGF5ZXJzIC0gMSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzOyBpKyspIHtcbiAgICAgICAgcmFkaXVzU2l6ZXNbaV0gPSBsYXllckRpcyAqIGk7XG4gICAgICB9XG5cbiAgICAgIHJhZGl1c1NpemVzLnJldmVyc2UoKTtcbiAgICAgIHZhciBwb2x5Z29uU3RyaW5ncyA9IFtdO1xuICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICByYWRpdXNTaXplcy5mb3JFYWNoKGZ1bmN0aW9uIChyYWRpdXNTaXplLCByKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gX3RoaXMyLmdldFBvbHlnb25Qb3MocmFkaXVzU2l6ZSk7XG5cbiAgICAgICAgdmFyIHN0cmluZyA9ICcnO1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICBpZiAociA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBfdGhpczIuZ3JhcGhpY3MuZHJhd0xpbmUocC54LCBwLnksIDAsIDAsIEFycmF5LmlzQXJyYXkoX3RoaXMyLnBvbHlnb25zLmNvbm5lY3RvckNvbG9ycykgPyBfdGhpczIucG9seWdvbnMuY29ubmVjdG9yQ29sb3JzW2ldIDogX3RoaXMyLnBvbHlnb25zLmNvbm5lY3RvckNvbG9ycyk7XG5cbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIF90aGlzMi55YXhpc0xhYmVsc1RleHRzUG9zLnB1c2goe1xuICAgICAgICAgICAgICB4OiBwLngsXG4gICAgICAgICAgICAgIHk6IHAueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyaW5nICs9IHAueCArICcsJyArIHAueSArICcgJztcbiAgICAgICAgfSk7XG4gICAgICAgIHBvbHlnb25TdHJpbmdzLnB1c2goc3RyaW5nKTtcbiAgICAgIH0pO1xuICAgICAgcG9seWdvblN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3JzID0gX3RoaXMyLnBvbHlnb25zLnN0cm9rZUNvbG9ycztcblxuICAgICAgICB2YXIgcG9seWdvbiA9IF90aGlzMi5ncmFwaGljcy5kcmF3UG9seWdvbihwLCBBcnJheS5pc0FycmF5KHN0cm9rZUNvbG9ycykgPyBzdHJva2VDb2xvcnNbaV0gOiBzdHJva2VDb2xvcnMsIHcuZ2xvYmFscy5yYWRhclBvbHlnb25zLmZpbGwuY29sb3JzW2ldKTtcblxuICAgICAgICBwYXJlbnQuYWRkKHBvbHlnb24pO1xuICAgICAgfSk7XG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHBhcmVudC5hZGQobCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzWzBdLnNob3cpIHtcbiAgICAgICAgdGhpcy55YXhpc0xhYmVsc1RleHRzUG9zLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICB2YXIgeVRleHQgPSBfdGhpczIuZHJhd1lBeGlzVGV4dChwLngsIHAueSwgaSwgeWF4aXNUZXh0c1tpXSk7XG5cbiAgICAgICAgICBfdGhpczIueWF4aXNMYWJlbHMuYWRkKHlUZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdZQXhpc1RleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lBeGlzVGV4dCh4LCB5LCBpLCB0ZXh0KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB5YXhpc0NvbmZpZyA9IHcuY29uZmlnLnlheGlzWzBdO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdO1xuICAgICAgdmFyIHlheGlzTGFiZWwgPSB0aGlzLmdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgeDogeCArIHlheGlzQ29uZmlnLmxhYmVscy5vZmZzZXRYLFxuICAgICAgICB5OiB5ICsgeWF4aXNDb25maWcubGFiZWxzLm9mZnNldFksXG4gICAgICAgIHRleHQ6IGZvcm1hdHRlcih0ZXh0LCBpKSxcbiAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgIGZvbnRTaXplOiB5YXhpc0NvbmZpZy5sYWJlbHMuc3R5bGUuZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHk6IHlheGlzQ29uZmlnLmxhYmVscy5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICBmb3JlQ29sb3I6IHlheGlzQ29uZmlnLmxhYmVscy5zdHlsZS5jb2xvclxuICAgICAgfSk7XG4gICAgICByZXR1cm4geWF4aXNMYWJlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0xhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGFiZWxzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGxpbWl0ID0gMTA7XG4gICAgICB2YXIgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgdmFyIGRhdGFMYWJlbHNDb25maWcgPSB3LmNvbmZpZy5kYXRhTGFiZWxzO1xuICAgICAgdmFyIGVsRGF0YUxhYmVsc1dyYXAgPSB0aGlzLmdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWRhdGFsYWJlbHMnXG4gICAgICB9KTtcbiAgICAgIHZhciBwb2x5Z29uUG9zID0gdGhpcy5nZXRQb2x5Z29uUG9zKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgY3VyclBvc1ggPSAwO1xuICAgICAgdmFyIGN1cnJQb3NZID0gMDtcbiAgICAgIHcuZ2xvYmFscy5sYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAobGFiZWwsIGkpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGRhdGFMYWJlbHNDb25maWcuZm9ybWF0dGVyO1xuICAgICAgICB2YXIgZGF0YUxhYmVscyA9IG5ldyBEYXRhTGFiZWxzKF90aGlzMy5jdHgpO1xuXG4gICAgICAgIGlmIChwb2x5Z29uUG9zW2ldKSB7XG4gICAgICAgICAgY3VyclBvc1ggPSBwb2x5Z29uUG9zW2ldLng7XG4gICAgICAgICAgY3VyclBvc1kgPSBwb2x5Z29uUG9zW2ldLnk7XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMocG9seWdvblBvc1tpXS54KSA+PSBsaW1pdCkge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25Qb3NbaV0ueCA+IDApIHtcbiAgICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgICAgICAgIGN1cnJQb3NYICs9IDEwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2x5Z29uUG9zW2ldLnggPCAwKSB7XG4gICAgICAgICAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcbiAgICAgICAgICAgICAgY3VyclBvc1ggLT0gMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMocG9seWdvblBvc1tpXS55KSA+PSBfdGhpczMuc2l6ZSAtIGxpbWl0KSB7XG4gICAgICAgICAgICBpZiAocG9seWdvblBvc1tpXS55IDwgMCkge1xuICAgICAgICAgICAgICBjdXJyUG9zWSAtPSAxMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9seWdvblBvc1tpXS55ID4gMCkge1xuICAgICAgICAgICAgICBjdXJyUG9zWSArPSAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGV4dCA9IGZvcm1hdHRlcihsYWJlbCwge1xuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IC0xLFxuICAgICAgICAgICAgZGF0YVBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICB3OiB3XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGF0YUxhYmVscy5wbG90RGF0YUxhYmVsc1RleHQoe1xuICAgICAgICAgICAgeDogY3VyclBvc1gsXG4gICAgICAgICAgICB5OiBjdXJyUG9zWSxcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIGo6IGksXG4gICAgICAgICAgICBwYXJlbnQ6IGVsRGF0YUxhYmVsc1dyYXAsXG4gICAgICAgICAgICBkYXRhTGFiZWxzQ29uZmlnOiBkYXRhTGFiZWxzQ29uZmlnLFxuICAgICAgICAgICAgb2Zmc2V0Q29ycmVjdGlvbjogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZWxEYXRhTGFiZWxzV3JhcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlUGF0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUGF0aHMocG9zLCBvcmlnaW4pIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgbGluZVBhdGhzVG8gPSBbXTtcbiAgICAgIHZhciBsaW5lUGF0aHNGcm9tID0gW107XG4gICAgICB2YXIgYXJlYVBhdGhzVG8gPSBbXTtcbiAgICAgIHZhciBhcmVhUGF0aHNGcm9tID0gW107XG5cbiAgICAgIGlmIChwb3MubGVuZ3RoKSB7XG4gICAgICAgIGxpbmVQYXRoc0Zyb20gPSBbdGhpcy5ncmFwaGljcy5tb3ZlKG9yaWdpbi54LCBvcmlnaW4ueSldO1xuICAgICAgICBhcmVhUGF0aHNGcm9tID0gW3RoaXMuZ3JhcGhpY3MubW92ZShvcmlnaW4ueCwgb3JpZ2luLnkpXTtcbiAgICAgICAgdmFyIGxpbmVQYXRoVG8gPSB0aGlzLmdyYXBoaWNzLm1vdmUocG9zWzBdLngsIHBvc1swXS55KTtcbiAgICAgICAgdmFyIGFyZWFQYXRoVG8gPSB0aGlzLmdyYXBoaWNzLm1vdmUocG9zWzBdLngsIHBvc1swXS55KTtcbiAgICAgICAgcG9zLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICBsaW5lUGF0aFRvICs9IF90aGlzNC5ncmFwaGljcy5saW5lKHAueCwgcC55KTtcbiAgICAgICAgICBhcmVhUGF0aFRvICs9IF90aGlzNC5ncmFwaGljcy5saW5lKHAueCwgcC55KTtcblxuICAgICAgICAgIGlmIChpID09PSBwb3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbGluZVBhdGhUbyArPSAnWic7XG4gICAgICAgICAgICBhcmVhUGF0aFRvICs9ICdaJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5lUGF0aHNUby5wdXNoKGxpbmVQYXRoVG8pO1xuICAgICAgICBhcmVhUGF0aHNUby5wdXNoKGFyZWFQYXRoVG8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lUGF0aHNGcm9tOiBsaW5lUGF0aHNGcm9tLFxuICAgICAgICBsaW5lUGF0aHNUbzogbGluZVBhdGhzVG8sXG4gICAgICAgIGFyZWFQYXRoc0Zyb206IGFyZWFQYXRoc0Zyb20sXG4gICAgICAgIGFyZWFQYXRoc1RvOiBhcmVhUGF0aHNUb1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGF0aEZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aEZyb20ocmVhbEluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwYXRoRnJvbSA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIHBwID0gMDsgcHAgPCB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5sZW5ndGg7IHBwKyspIHtcbiAgICAgICAgdmFyIGdwcCA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXTtcblxuICAgICAgICBpZiAoZ3BwLnBhdGhzLmxlbmd0aCA+IDAgJiYgcGFyc2VJbnQoZ3BwLnJlYWxJbmRleCkgPT09IHBhcnNlSW50KHJlYWxJbmRleCkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXS5wYXRoc1swXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBhdGhGcm9tID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzWzBdLmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoRnJvbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGF0YVBvaW50c1Bvc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhUG9pbnRzUG9zKGRhdGFSYWRpdXNBcnIsIGFuZ2xlQXJyKSB7XG4gICAgICB2YXIgZGF0YVBvaW50c0xlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5kYXRhUG9pbnRzTGVuO1xuICAgICAgZGF0YVJhZGl1c0FyciA9IGRhdGFSYWRpdXNBcnIgfHwgW107XG4gICAgICBhbmdsZUFyciA9IGFuZ2xlQXJyIHx8IFtdO1xuICAgICAgdmFyIGRhdGFQb2ludHNQb3NBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFQb2ludHNMZW47IGorKykge1xuICAgICAgICB2YXIgY3VyUG9pbnRQb3MgPSB7fTtcbiAgICAgICAgY3VyUG9pbnRQb3MueCA9IGRhdGFSYWRpdXNBcnJbal0gKiBNYXRoLnNpbihhbmdsZUFycltqXSk7XG4gICAgICAgIGN1clBvaW50UG9zLnkgPSAtZGF0YVJhZGl1c0FycltqXSAqIE1hdGguY29zKGFuZ2xlQXJyW2pdKTtcbiAgICAgICAgZGF0YVBvaW50c1Bvc0FycmF5LnB1c2goY3VyUG9pbnRQb3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVBvaW50c1Bvc0FycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2x5Z29uUG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvbHlnb25Qb3Moc2l6ZSkge1xuICAgICAgdmFyIGRvdHNBcnJheSA9IFtdO1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAqIDIgLyB0aGlzLmRhdGFQb2ludHNMZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhUG9pbnRzTGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGN1clBvcyA9IHt9O1xuICAgICAgICBjdXJQb3MueCA9IHNpemUgKiBNYXRoLnNpbihpICogYW5nbGUpO1xuICAgICAgICBjdXJQb3MueSA9IC1zaXplICogTWF0aC5jb3MoaSAqIGFuZ2xlKTtcbiAgICAgICAgZG90c0FycmF5LnB1c2goY3VyUG9zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvdHNBcnJheTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFkYXI7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBSYWRpYWwgQ2xhc3MgZm9yIGRyYXdpbmcgQ2lyY2xlIC8gU2VtaSBDaXJjbGUgQ2hhcnRzLlxuICogQG1vZHVsZSBSYWRpYWxcbiAqKi9cblxudmFyIFJhZGlhbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BpZSkge1xuICBfaW5oZXJpdHMoUmFkaWFsLCBfUGllKTtcblxuICBmdW5jdGlvbiBSYWRpYWwoY3R4KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGlhbCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihSYWRpYWwpLmNhbGwodGhpcywgY3R4KSk7XG4gICAgX3RoaXMuY3R4ID0gY3R4O1xuICAgIF90aGlzLncgPSBjdHgudztcbiAgICBfdGhpcy5hbmltQmVnaW5BcnIgPSBbMF07XG4gICAgX3RoaXMuYW5pbUR1ciA9IDA7XG4gICAgdmFyIHcgPSBfdGhpcy53O1xuICAgIF90aGlzLnN0YXJ0QW5nbGUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuc3RhcnRBbmdsZTtcbiAgICBfdGhpcy5lbmRBbmdsZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5lbmRBbmdsZTtcbiAgICBfdGhpcy50cmFja1N0YXJ0QW5nbGUgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIudHJhY2suc3RhcnRBbmdsZTtcbiAgICBfdGhpcy50cmFja0VuZEFuZ2xlID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnRyYWNrLmVuZEFuZ2xlO1xuICAgIF90aGlzLnJhZGlhbERhdGFMYWJlbHMgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuZGF0YUxhYmVscztcbiAgICBpZiAoIV90aGlzLnRyYWNrU3RhcnRBbmdsZSkgX3RoaXMudHJhY2tTdGFydEFuZ2xlID0gX3RoaXMuc3RhcnRBbmdsZTtcbiAgICBpZiAoIV90aGlzLnRyYWNrRW5kQW5nbGUpIF90aGlzLnRyYWNrRW5kQW5nbGUgPSBfdGhpcy5lbmRBbmdsZTtcbiAgICBpZiAoX3RoaXMuZW5kQW5nbGUgPT09IDM2MCkgX3RoaXMuZW5kQW5nbGUgPSAzNTkuOTk7XG4gICAgX3RoaXMuZnVsbEFuZ2xlID0gMzYwIC0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmVuZEFuZ2xlIC0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnN0YXJ0QW5nbGU7XG4gICAgX3RoaXMubWFyZ2luID0gcGFyc2VJbnQody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLnRyYWNrLm1hcmdpbik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJhZGlhbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KHNlcmllcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHJldCA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhcidcbiAgICAgIH0pO1xuICAgICAgdmFyIGVsU2VyaWVzID0gZ3JhcGhpY3MuZ3JvdXAoKTtcbiAgICAgIHZhciBjZW50ZXJZID0gdGhpcy5kZWZhdWx0U2l6ZSAvIDI7XG4gICAgICB2YXIgY2VudGVyWCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyO1xuICAgICAgdmFyIHNpemUgPSB0aGlzLmRlZmF1bHRTaXplIC8gMi4wNSAtIHcuY29uZmlnLnN0cm9rZS53aWR0aCAtIHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuYmx1cjtcblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2l6ZSA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5zaXplO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3JBcnIgPSB3Lmdsb2JhbHMuZmlsbC5jb2xvcnM7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIudHJhY2suc2hvdykge1xuICAgICAgICB2YXIgZWxUcmFja3MgPSB0aGlzLmRyYXdUcmFja3Moe1xuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgY2VudGVyWDogY2VudGVyWCxcbiAgICAgICAgICBjZW50ZXJZOiBjZW50ZXJZLFxuICAgICAgICAgIGNvbG9yQXJyOiBjb2xvckFycixcbiAgICAgICAgICBzZXJpZXM6IHNlcmllc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKGVsVHJhY2tzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsRyA9IHRoaXMuZHJhd0FyY3Moe1xuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBjZW50ZXJYOiBjZW50ZXJYLFxuICAgICAgICBjZW50ZXJZOiBjZW50ZXJZLFxuICAgICAgICBjb2xvckFycjogY29sb3JBcnIsXG4gICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICB9KTtcbiAgICAgIGVsU2VyaWVzLmFkZChlbEcuZyk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LnBvc2l0aW9uID09PSAnZnJvbnQnKSB7XG4gICAgICAgIGVsRy5nLmFkZChlbEcuZWxIb2xsb3cpO1xuXG4gICAgICAgIGlmIChlbEcuZGF0YUxhYmVscykge1xuICAgICAgICAgIGVsRy5nLmFkZChlbEcuZGF0YUxhYmVscyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0LmFkZChlbFNlcmllcyk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VHJhY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdUcmFja3Mob3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGcgPSBncmFwaGljcy5ncm91cCgpO1xuICAgICAgdmFyIGZpbHRlcnMgPSBuZXcgRmlsdGVycyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuZ2V0U3Ryb2tlV2lkdGgob3B0cyk7XG4gICAgICBvcHRzLnNpemUgPSBvcHRzLnNpemUgLSBzdHJva2VXaWR0aCAvIDI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsUmFkaWFsQmFyVHJhY2sgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci10cmFjayBhcGV4Y2hhcnRzLXRyYWNrJ1xuICAgICAgICB9KTtcbiAgICAgICAgZy5hZGQoZWxSYWRpYWxCYXJUcmFjayk7XG4gICAgICAgIGVsUmFkaWFsQmFyVHJhY2suYXR0cih7XG4gICAgICAgICAgaWQ6ICdhcGV4Y2hhcnRzLXRyYWNrLScgKyBpLFxuICAgICAgICAgIHJlbDogaSArIDFcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdHMuc2l6ZSA9IG9wdHMuc2l6ZSAtIHN0cm9rZVdpZHRoIC0gdGhpcy5tYXJnaW47XG4gICAgICAgIHZhciB0cmFja0NvbmZpZyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci50cmFjaztcbiAgICAgICAgdmFyIHBhdGhGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgc2VyaWVzTnVtYmVyOiAwLFxuICAgICAgICAgIHNpemU6IG9wdHMuc2l6ZSxcbiAgICAgICAgICBmaWxsQ29sb3JzOiBBcnJheS5pc0FycmF5KHRyYWNrQ29uZmlnLmJhY2tncm91bmQpID8gdHJhY2tDb25maWcuYmFja2dyb3VuZFtpXSA6IHRyYWNrQ29uZmlnLmJhY2tncm91bmQsXG4gICAgICAgICAgc29saWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gdGhpcy50cmFja1N0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBlbmRBbmdsZSA9IHRoaXMudHJhY2tFbmRBbmdsZTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGVuZEFuZ2xlKSArIE1hdGguYWJzKHN0YXJ0QW5nbGUpID49IDM2MCkgZW5kQW5nbGUgPSAzNjAgLSBNYXRoLmFicyh0aGlzLnN0YXJ0QW5nbGUpIC0gMC4xO1xuICAgICAgICB2YXIgZWxQYXRoID0gZ3JhcGhpY3MuZHJhd1BhdGgoe1xuICAgICAgICAgIGQ6ICcnLFxuICAgICAgICAgIHN0cm9rZTogcGF0aEZpbGwsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoICogcGFyc2VJbnQodHJhY2tDb25maWcuc3Ryb2tlV2lkdGgpIC8gMTAwLFxuICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICBzdHJva2VPcGFjaXR5OiB0cmFja0NvbmZpZy5vcGFjaXR5LFxuICAgICAgICAgIGNsYXNzZXM6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci1hcmVhJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodHJhY2tDb25maWcuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgICAgdmFyIHNoYWRvdyA9IHRyYWNrQ29uZmlnLmRyb3BTaGFkb3c7XG4gICAgICAgICAgZmlsdGVycy5kcm9wU2hhZG93KGVsUGF0aCwgc2hhZG93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsUmFkaWFsQmFyVHJhY2suYWRkKGVsUGF0aCk7XG4gICAgICAgIGVsUGF0aC5hdHRyKCdpZCcsICdhcGV4Y2hhcnRzLXJhZGlhbGJhclRyYWNrLScgKyBpKTtcbiAgICAgICAgdmFyIHBpZSA9IG5ldyBQaWUodGhpcy5jdHgpO1xuICAgICAgICBwaWUuYW5pbWF0ZVBhdGhzKGVsUGF0aCwge1xuICAgICAgICAgIGNlbnRlclg6IG9wdHMuY2VudGVyWCxcbiAgICAgICAgICBjZW50ZXJZOiBvcHRzLmNlbnRlclksXG4gICAgICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgICAgc2l6ZTogb3B0cy5zaXplLFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgdG90YWxJdGVtczogMixcbiAgICAgICAgICBhbmltQmVnaW5BcnI6IDAsXG4gICAgICAgICAgZHVyOiAwLFxuICAgICAgICAgIGlzVHJhY2s6IHRydWUsXG4gICAgICAgICAgZWFzaW5nOiB3Lmdsb2JhbHMuZWFzaW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0FyY3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0FyY3Mob3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIHNpemUsIGRvbnV0U2l6ZSwgY2VudGVyWCwgY2VudGVyWSwgY29sb3JBcnIsIGxpbmVDb2xvckFyciwgc2VjdG9yQW5nbGVBcnIsIHNlcmllc1xuXG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgZmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBnID0gZ3JhcGhpY3MuZ3JvdXAoKTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuZ2V0U3Ryb2tlV2lkdGgob3B0cyk7XG4gICAgICBvcHRzLnNpemUgPSBvcHRzLnNpemUgLSBzdHJva2VXaWR0aCAvIDI7XG4gICAgICB2YXIgaG9sbG93RmlsbElEID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5iYWNrZ3JvdW5kO1xuICAgICAgdmFyIGhvbGxvd1NpemUgPSBvcHRzLnNpemUgLSBzdHJva2VXaWR0aCAqIG9wdHMuc2VyaWVzLmxlbmd0aCAtIHRoaXMubWFyZ2luICogb3B0cy5zZXJpZXMubGVuZ3RoIC0gc3Ryb2tlV2lkdGggKiBwYXJzZUludCh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIudHJhY2suc3Ryb2tlV2lkdGgpIC8gMTAwIC8gMjtcbiAgICAgIHZhciBob2xsb3dSYWRpdXMgPSBob2xsb3dTaXplIC0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5tYXJnaW47XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaG9sbG93RmlsbElEID0gdGhpcy5kcmF3SG9sbG93SW1hZ2Uob3B0cywgZywgaG9sbG93U2l6ZSwgaG9sbG93RmlsbElEKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsSG9sbG93ID0gdGhpcy5kcmF3SG9sbG93KHtcbiAgICAgICAgc2l6ZTogaG9sbG93UmFkaXVzLFxuICAgICAgICBjZW50ZXJYOiBvcHRzLmNlbnRlclgsXG4gICAgICAgIGNlbnRlclk6IG9wdHMuY2VudGVyWSxcbiAgICAgICAgZmlsbDogaG9sbG93RmlsbElEXG4gICAgICB9KTtcblxuICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuZHJvcFNoYWRvdy5lbmFibGVkKSB7XG4gICAgICAgIHZhciBzaGFkb3cgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmRyb3BTaGFkb3c7XG4gICAgICAgIGZpbHRlcnMuZHJvcFNoYWRvdyhlbEhvbGxvdywgc2hhZG93KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3duID0gMTtcblxuICAgICAgaWYgKCF0aGlzLnJhZGlhbERhdGFMYWJlbHMudG90YWwuc2hvdyAmJiB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2hvd24gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGllID0gbmV3IFBpZSh0aGlzLmN0eCk7XG4gICAgICB2YXIgZGF0YUxhYmVscyA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLnJhZGlhbERhdGFMYWJlbHMuc2hvdykge1xuICAgICAgICBkYXRhTGFiZWxzID0gcGllLnJlbmRlcklubmVyRGF0YUxhYmVscyh0aGlzLnJhZGlhbERhdGFMYWJlbHMsIHtcbiAgICAgICAgICBob2xsb3dTaXplOiBob2xsb3dTaXplLFxuICAgICAgICAgIGNlbnRlclg6IG9wdHMuY2VudGVyWCxcbiAgICAgICAgICBjZW50ZXJZOiBvcHRzLmNlbnRlclksXG4gICAgICAgICAgb3BhY2l0eTogc2hvd25cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LnBvc2l0aW9uID09PSAnYmFjaycpIHtcbiAgICAgICAgZy5hZGQoZWxIb2xsb3cpO1xuXG4gICAgICAgIGlmIChkYXRhTGFiZWxzKSB7XG4gICAgICAgICAgZy5hZGQoZGF0YUxhYmVscyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJldmVyc2VMb29wID0gZmFsc2U7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaW52ZXJzZU9yZGVyKSB7XG4gICAgICAgIHJldmVyc2VMb29wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHJldmVyc2VMb29wID8gb3B0cy5zZXJpZXMubGVuZ3RoIC0gMSA6IDA7IHJldmVyc2VMb29wID8gaSA+PSAwIDogaSA8IG9wdHMuc2VyaWVzLmxlbmd0aDsgcmV2ZXJzZUxvb3AgPyBpLS0gOiBpKyspIHtcbiAgICAgICAgdmFyIGVsUmFkaWFsQmFyQXJjID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIGFwZXhjaGFydHMtcmFkaWFsLXNlcmllcyBcIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHcuZ2xvYmFscy5zZXJpZXNOYW1lc1tpXSkpXG4gICAgICAgIH0pO1xuICAgICAgICBnLmFkZChlbFJhZGlhbEJhckFyYyk7XG4gICAgICAgIGVsUmFkaWFsQmFyQXJjLmF0dHIoe1xuICAgICAgICAgIGlkOiAnYXBleGNoYXJ0cy1zZXJpZXMtJyArIGksXG4gICAgICAgICAgcmVsOiBpICsgMVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdHguc2VyaWVzLmFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXMoZWxSYWRpYWxCYXJBcmMsIGkpO1xuICAgICAgICBvcHRzLnNpemUgPSBvcHRzLnNpemUgLSBzdHJva2VXaWR0aCAtIHRoaXMubWFyZ2luO1xuICAgICAgICB2YXIgcGF0aEZpbGwgPSBmaWxsLmZpbGxQYXRoKHtcbiAgICAgICAgICBzZXJpZXNOdW1iZXI6IGksXG4gICAgICAgICAgc2l6ZTogb3B0cy5zaXplXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHRoaXMuc3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIHByZXZTdGFydEFuZ2xlID0gdm9pZCAwO1xuICAgICAgICB2YXIgdG90YWxBbmdsZSA9IE1hdGguYWJzKHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5lbmRBbmdsZSAtIHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5zdGFydEFuZ2xlKTsgLy8gaWYgZGF0YSBleGNlZWRzIDEwMCwgbWFrZSBpdCAxMDBcblxuICAgICAgICB2YXIgZGF0YVZhbHVlID0gVXRpbHMubmVnVG9aZXJvKG9wdHMuc2VyaWVzW2ldID4gMTAwID8gMTAwIDogb3B0cy5zZXJpZXNbaV0pIC8gMTAwO1xuICAgICAgICB2YXIgZW5kQW5nbGUgPSBNYXRoLnJvdW5kKHRvdGFsQW5nbGUgKiBkYXRhVmFsdWUpICsgdGhpcy5zdGFydEFuZ2xlO1xuICAgICAgICB2YXIgcHJldkVuZEFuZ2xlID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICBwcmV2U3RhcnRBbmdsZSA9IHRoaXMuc3RhcnRBbmdsZTtcbiAgICAgICAgICBwcmV2RW5kQW5nbGUgPSBNYXRoLnJvdW5kKHRvdGFsQW5nbGUgKiBVdGlscy5uZWdUb1plcm8ody5nbG9iYWxzLnByZXZpb3VzUGF0aHNbaV0pIC8gMTAwKSArIHByZXZTdGFydEFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJGdWxsQW5nbGUgPSBNYXRoLmFicyhlbmRBbmdsZSkgKyBNYXRoLmFicyhzdGFydEFuZ2xlKTtcblxuICAgICAgICBpZiAoY3VyckZ1bGxBbmdsZSA+PSAzNjApIHtcbiAgICAgICAgICBlbmRBbmdsZSA9IGVuZEFuZ2xlIC0gMC4wMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2RnVsbEFuZ2xlID0gTWF0aC5hYnMocHJldkVuZEFuZ2xlKSArIE1hdGguYWJzKHByZXZTdGFydEFuZ2xlKTtcblxuICAgICAgICBpZiAocHJldkZ1bGxBbmdsZSA+PSAzNjApIHtcbiAgICAgICAgICBwcmV2RW5kQW5nbGUgPSBwcmV2RW5kQW5nbGUgLSAwLjAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuZ2xlID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xuICAgICAgICB2YXIgZGFzaEFycmF5ID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2UuZGFzaEFycmF5KSA/IHcuY29uZmlnLnN0cm9rZS5kYXNoQXJyYXlbaV0gOiB3LmNvbmZpZy5zdHJva2UuZGFzaEFycmF5O1xuICAgICAgICB2YXIgZWxQYXRoID0gZ3JhcGhpY3MuZHJhd1BhdGgoe1xuICAgICAgICAgIGQ6ICcnLFxuICAgICAgICAgIHN0cm9rZTogcGF0aEZpbGwsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogdy5jb25maWcuZmlsbC5vcGFjaXR5LFxuICAgICAgICAgIGNsYXNzZXM6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci1hcmVhJyxcbiAgICAgICAgICBzdHJva2VEYXNoQXJyYXk6IGRhc2hBcnJheVxuICAgICAgICB9KTtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZWxQYXRoLm5vZGUsIHtcbiAgICAgICAgICAnZGF0YTphbmdsZSc6IGFuZ2xlLFxuICAgICAgICAgICdkYXRhOnZhbHVlJzogb3B0cy5zZXJpZXNbaV1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LmRyb3BTaGFkb3cuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBfc2hhZG93ID0gdy5jb25maWcuY2hhcnQuZHJvcFNoYWRvdztcbiAgICAgICAgICBmaWx0ZXJzLmRyb3BTaGFkb3coZWxQYXRoLCBfc2hhZG93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkTGlzdGVuZXJzKGVsUGF0aCwgdGhpcy5yYWRpYWxEYXRhTGFiZWxzKTtcblxuICAgICAgICB2YXIgX3BpZSA9IG5ldyBQaWUodGhpcy5jdHgpO1xuXG4gICAgICAgIGVsUmFkaWFsQmFyQXJjLmFkZChlbFBhdGgpO1xuICAgICAgICBlbFBhdGguYXR0cih7XG4gICAgICAgICAgaWQ6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci1zbGljZS0nICsgaSxcbiAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICBqOiBpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZHVyID0gMDtcblxuICAgICAgICBpZiAoX3BpZS5pbml0aWFsQW5pbSAmJiAhdy5nbG9iYWxzLnJlc2l6ZWQgJiYgIXcuZ2xvYmFscy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICAgIGR1ciA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gMzYwICogdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5zcGVlZDtcbiAgICAgICAgICB0aGlzLmFuaW1EdXIgPSBkdXIgLyAob3B0cy5zZXJpZXMubGVuZ3RoICogMS4yKSArIHRoaXMuYW5pbUR1cjtcbiAgICAgICAgICB0aGlzLmFuaW1CZWdpbkFyci5wdXNoKHRoaXMuYW5pbUR1cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5nbG9iYWxzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgICAgZHVyID0gKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAzNjAgKiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uc3BlZWQ7XG4gICAgICAgICAgdGhpcy5hbmltRHVyID0gZHVyIC8gKG9wdHMuc2VyaWVzLmxlbmd0aCAqIDEuMikgKyB0aGlzLmFuaW1EdXI7XG4gICAgICAgICAgdGhpcy5hbmltQmVnaW5BcnIucHVzaCh0aGlzLmFuaW1EdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BpZS5hbmltYXRlUGF0aHMoZWxQYXRoLCB7XG4gICAgICAgICAgY2VudGVyWDogb3B0cy5jZW50ZXJYLFxuICAgICAgICAgIGNlbnRlclk6IG9wdHMuY2VudGVyWSxcbiAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICBwcmV2RW5kQW5nbGU6IHByZXZFbmRBbmdsZSxcbiAgICAgICAgICBwcmV2U3RhcnRBbmdsZTogcHJldlN0YXJ0QW5nbGUsXG4gICAgICAgICAgc2l6ZTogb3B0cy5zaXplLFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgdG90YWxJdGVtczogMixcbiAgICAgICAgICBhbmltQmVnaW5BcnI6IHRoaXMuYW5pbUJlZ2luQXJyLFxuICAgICAgICAgIGR1cjogZHVyLFxuICAgICAgICAgIHNob3VsZFNldFByZXZQYXRoczogdHJ1ZSxcbiAgICAgICAgICBlYXNpbmc6IHcuZ2xvYmFscy5lYXNpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGc6IGcsXG4gICAgICAgIGVsSG9sbG93OiBlbEhvbGxvdyxcbiAgICAgICAgZGF0YUxhYmVsczogZGF0YUxhYmVsc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0hvbGxvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SG9sbG93KG9wdHMpIHtcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgY2lyY2xlID0gZ3JhcGhpY3MuZHJhd0NpcmNsZShvcHRzLnNpemUgKiAyKTtcbiAgICAgIGNpcmNsZS5hdHRyKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXJhZGlhbGJhci1ob2xsb3cnLFxuICAgICAgICBjeDogb3B0cy5jZW50ZXJYLFxuICAgICAgICBjeTogb3B0cy5jZW50ZXJZLFxuICAgICAgICByOiBvcHRzLnNpemUsXG4gICAgICAgIGZpbGw6IG9wdHMuZmlsbFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3SG9sbG93SW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0hvbGxvd0ltYWdlKG9wdHMsIGcsIGhvbGxvd1NpemUsIGhvbGxvd0ZpbGxJRCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHRoaXMuY3R4KTtcbiAgICAgIHZhciByYW5kSUQgPSAoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNCk7XG4gICAgICB2YXIgaG9sbG93RmlsbEltZyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuaW1hZ2U7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRpYWxCYXIuaG9sbG93LmltYWdlQ2xpcHBlZCkge1xuICAgICAgICBmaWxsLmNsaXBwZWRJbWdBcmVhKHtcbiAgICAgICAgICB3aWR0aDogaG9sbG93U2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGhvbGxvd1NpemUsXG4gICAgICAgICAgaW1hZ2U6IGhvbGxvd0ZpbGxJbWcsXG4gICAgICAgICAgcGF0dGVybklEOiBcInBhdHRlcm5cIi5jb25jYXQody5nbG9iYWxzLmN1aWQpLmNvbmNhdChyYW5kSUQpXG4gICAgICAgIH0pO1xuICAgICAgICBob2xsb3dGaWxsSUQgPSBcInVybCgjcGF0dGVyblwiLmNvbmNhdCh3Lmdsb2JhbHMuY3VpZCkuY29uY2F0KHJhbmRJRCwgXCIpXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGltZ1dpZHRoID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZVdpZHRoO1xuICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZUhlaWdodDtcblxuICAgICAgICBpZiAoaW1nV2lkdGggPT09IHVuZGVmaW5lZCAmJiBpbWdIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBpbWFnZSA9IHcuZ2xvYmFscy5kb20uUGFwZXIuaW1hZ2UoaG9sbG93RmlsbEltZykubG9hZGVkKGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZShvcHRzLmNlbnRlclggLSBsb2FkZXIud2lkdGggLyAyICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZU9mZnNldFgsIG9wdHMuY2VudGVyWSAtIGxvYWRlci5oZWlnaHQgLyAyICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZU9mZnNldFkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGcuYWRkKGltYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2ltYWdlID0gdy5nbG9iYWxzLmRvbS5QYXBlci5pbWFnZShob2xsb3dGaWxsSW1nKS5sb2FkZWQoZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgICAgICAgdGhpcy5tb3ZlKG9wdHMuY2VudGVyWCAtIGltZ1dpZHRoIC8gMiArIHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5ob2xsb3cuaW1hZ2VPZmZzZXRYLCBvcHRzLmNlbnRlclkgLSBpbWdIZWlnaHQgLyAyICsgdy5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5pbWFnZU9mZnNldFkpO1xuICAgICAgICAgICAgdGhpcy5zaXplKGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZy5hZGQoX2ltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaG9sbG93RmlsbElEO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdHJva2VXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHJva2VXaWR0aChvcHRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHJldHVybiBvcHRzLnNpemUgKiAoMTAwIC0gcGFyc2VJbnQody5jb25maWcucGxvdE9wdGlvbnMucmFkaWFsQmFyLmhvbGxvdy5zaXplKSkgLyAxMDAgLyAob3B0cy5zZXJpZXMubGVuZ3RoICsgMSkgLSB0aGlzLm1hcmdpbjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFkaWFsO1xufShQaWUpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgTGluZSBDbGFzcyByZXNwb25zaWJsZSBmb3IgZHJhd2luZyBMaW5lIC8gQXJlYSBDaGFydHMuXG4gKiBUaGlzIGNsYXNzIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdmFsdWVzIGZvciBCdWJibGUvU2NhdHRlciBjaGFydHMsIHNvIG5lZWQgdG8gcmVuYW1lIGl0IHRvIEF4aXMgQ2hhcnRzIHRvIGF2b2lkIGNvbmZ1c2lvbnNcbiAqIEBtb2R1bGUgTGluZVxuICoqL1xuXG52YXIgTGluZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpbmUoY3R4LCB4eVJhdGlvcywgaXNQb2ludHNDaGFydCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMueHlSYXRpb3MgPSB4eVJhdGlvcztcbiAgICB0aGlzLnBvaW50c0NoYXJ0ID0gISh0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdidWJibGUnICYmIHRoaXMudy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ3NjYXR0ZXInKSB8fCBpc1BvaW50c0NoYXJ0O1xuICAgIHRoaXMuc2NhdHRlciA9IG5ldyBTY2F0dGVyKHRoaXMuY3R4KTtcbiAgICB0aGlzLm5vTmVnYXRpdmVzID0gdGhpcy53Lmdsb2JhbHMubWluWCA9PT0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0aGlzLnlheGlzSW5kZXggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpbmUsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhzZXJpZXMsIHB0eXBlLCBzZXJpZXNJbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpbGwgPSBuZXcgRmlsbCh0aGlzLmN0eCk7XG4gICAgICB2YXIgdHlwZSA9IHcuZ2xvYmFscy5jb21ib0NoYXJ0cyA/IHB0eXBlIDogdy5jb25maWcuY2hhcnQudHlwZTtcbiAgICAgIHZhciByZXQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUsIFwiLXNlcmllcyBhcGV4Y2hhcnRzLXBsb3Qtc2VyaWVzXCIpXG4gICAgICB9KTtcbiAgICAgIHZhciBjb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4LCB3KTtcbiAgICAgIHNlcmllcyA9IGNvcmVVdGlscy5nZXRMb2dTZXJpZXMoc2VyaWVzKTtcbiAgICAgIHZhciB5UmF0aW8gPSB0aGlzLnh5UmF0aW9zLnlSYXRpbztcbiAgICAgIHlSYXRpbyA9IGNvcmVVdGlscy5nZXRMb2dZUmF0aW9zKHlSYXRpbyk7XG4gICAgICB2YXIgelJhdGlvID0gdGhpcy54eVJhdGlvcy56UmF0aW87XG4gICAgICB2YXIgeFJhdGlvID0gdGhpcy54eVJhdGlvcy54UmF0aW87XG4gICAgICB2YXIgYmFzZUxpbmVZID0gdGhpcy54eVJhdGlvcy5iYXNlTGluZVk7IC8vIHB1c2ggYWxsIHNlcmllcyBpbiBhbiBhcnJheSwgc28gd2UgY2FuIGRyYXcgaW4gcmV2ZXJzZSBvcmRlciAoZm9yIHN0YWNrZWQgY2hhcnRzKVxuXG4gICAgICB2YXIgYWxsU2VyaWVzID0gW107XG4gICAgICB2YXIgcHJldlNlcmllc1kgPSBbXTtcbiAgICAgIHZhciBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gd2lkdGggZGl2aWRlZCBpbnRvIGVxdWFsIHBhcnRzXG4gICAgICAgIGlmICh0eXBlID09PSAnbGluZScgJiYgKHcuY29uZmlnLmZpbGwudHlwZSA9PT0gJ2dyYWRpZW50JyB8fCB3LmNvbmZpZy5maWxsLnR5cGVbaV0gPT09ICdncmFkaWVudCcpKSB7XG4gICAgICAgICAgLy8gYSBzbWFsbCBhZGp1c3RtZW50IHRvIGFsbG93IGdyYWRpZW50IGxpbmUgdG8gZHJhdyBjb3JyZWN0bHkgZm9yIGFsbCBzYW1lIHZhbHVlc1xuXG4gICAgICAgICAgLyogI2ZpeCBodHRwczovL2dpdGh1Yi5jb20vYXBleGNoYXJ0cy9hcGV4Y2hhcnRzLmpzL2lzc3Vlcy8zNTggKi9cbiAgICAgICAgICBpZiAoY29yZVV0aWxzLnNlcmllc0hhdmVTYW1lVmFsdWVzKGkpKSB7XG4gICAgICAgICAgICB2YXIgZ1NlcmllcyA9IHNlcmllc1tpXS5zbGljZSgpO1xuICAgICAgICAgICAgZ1Nlcmllc1tnU2VyaWVzLmxlbmd0aCAtIDFdID0gZ1Nlcmllc1tnU2VyaWVzLmxlbmd0aCAtIDFdICsgMC4wMDAwMDE7XG4gICAgICAgICAgICBzZXJpZXNbaV0gPSBnU2VyaWVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4RGl2aXNpb24gPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIHZhciByZWFsSW5kZXggPSB3Lmdsb2JhbHMuY29tYm9DaGFydHMgPyBzZXJpZXNJbmRleFtpXSA6IGk7XG5cbiAgICAgICAgaWYgKHlSYXRpby5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy55YXhpc0luZGV4ID0gcmVhbEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1JldmVyc2VkID0gdy5jb25maWcueWF4aXNbdGhpcy55YXhpc0luZGV4XSAmJiB3LmNvbmZpZy55YXhpc1t0aGlzLnlheGlzSW5kZXhdLnJldmVyc2VkO1xuICAgICAgICB2YXIgeUFycmogPSBbXTsgLy8gaG9sZCB5IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcblxuICAgICAgICB2YXIgeEFycmogPSBbXTsgLy8gaG9sZCB4IHZhbHVlcyBvZiBjdXJyZW50IGl0ZXJhdGluZyBzZXJpZXNcbiAgICAgICAgLy8gemVyb1kgaXMgdGhlIDAgdmFsdWUgaW4geSBzZXJpZXMgd2hpY2ggY2FuIGJlIHVzZWQgaW4gbmVnYXRpdmUgY2hhcnRzXG5cbiAgICAgICAgdmFyIHplcm9ZID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLSBiYXNlTGluZVlbdGhpcy55YXhpc0luZGV4XSAtICh0aGlzLmlzUmV2ZXJzZWQgPyB3Lmdsb2JhbHMuZ3JpZEhlaWdodCA6IDApICsgKHRoaXMuaXNSZXZlcnNlZCA/IGJhc2VMaW5lWVt0aGlzLnlheGlzSW5kZXhdICogMiA6IDApO1xuICAgICAgICB2YXIgYXJlYUJvdHRvbVkgPSB6ZXJvWTtcblxuICAgICAgICBpZiAoemVyb1kgPiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkge1xuICAgICAgICAgIGFyZWFCb3R0b21ZID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uID0geERpdmlzaW9uIC8gMjtcbiAgICAgICAgdmFyIHggPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArIGNhdGVnb3J5QXhpc0NvcnJlY3Rpb247XG4gICAgICAgIHZhciB5ID0gMTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICB4ID0gKHcuZ2xvYmFscy5zZXJpZXNYW3JlYWxJbmRleF1bMF0gLSB3Lmdsb2JhbHMubWluWCkgLyB4UmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICB4QXJyai5wdXNoKHgpO1xuICAgICAgICB2YXIgbGluZVBhdGggPSB2b2lkIDAsXG4gICAgICAgICAgICBhcmVhUGF0aCA9IHZvaWQgMCxcbiAgICAgICAgICAgIHBhdGhGcm9tTGluZSA9IHZvaWQgMCxcbiAgICAgICAgICAgIHBhdGhGcm9tQXJlYSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGxpbmVQYXRocyA9IFtdO1xuICAgICAgICB2YXIgYXJlYVBhdGhzID0gW107IC8vIGVsIHRvIHdoaWNoIHNlcmllcyB3aWxsIGJlIGRyYXduXG5cbiAgICAgICAgdmFyIGVsU2VyaWVzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiBcImFwZXhjaGFydHMtc2VyaWVzIFwiLmNvbmNhdChVdGlscy5lc2NhcGVTdHJpbmcody5nbG9iYWxzLnNlcmllc05hbWVzW3JlYWxJbmRleF0pKVxuICAgICAgICB9KTsgLy8gcG9pbnRzXG5cbiAgICAgICAgdmFyIGVsUG9pbnRzTWFpbiA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcCdcbiAgICAgICAgfSk7IC8vIGVsZGF0YWxhYmVsc1xuXG4gICAgICAgIHZhciBlbERhdGFMYWJlbHNXcmFwID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1kYXRhbGFiZWxzJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jdHguc2VyaWVzLmFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXMoZWxTZXJpZXMsIHJlYWxJbmRleCk7XG4gICAgICAgIHZhciBsb25nZXN0U2VyaWVzID0gc2VyaWVzW2ldLmxlbmd0aCA9PT0gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgIGVsU2VyaWVzLmF0dHIoe1xuICAgICAgICAgICdkYXRhOmxvbmdlc3RTZXJpZXMnOiBsb25nZXN0U2VyaWVzLFxuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6cmVhbEluZGV4JzogcmVhbEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGVuZFBhdGhGcm9tID0gdHJ1ZTtcbiAgICAgICAgdmFyIHBYID0geDtcbiAgICAgICAgdmFyIHBZID0gdm9pZCAwO1xuICAgICAgICB2YXIgcHJldlggPSBwWDtcbiAgICAgICAgdmFyIHByZXZZID0gemVyb1k7IC8vIHcuZ2xvYmFscy5zdmdIZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxpbmVZUG9zaXRpb24gPSAwOyAvLyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGN1cnJlbnQgc2VyaWVzIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuXG4gICAgICAgIHZhciBmaXJzdFByZXZZID0gdGhpcy5kZXRlcm1pbmVGaXJzdFByZXZZKHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgIHlSYXRpbzogeVJhdGlvW3RoaXMueWF4aXNJbmRleF0sXG4gICAgICAgICAgemVyb1k6IHplcm9ZLFxuICAgICAgICAgIHByZXZZOiBwcmV2WSxcbiAgICAgICAgICBwcmV2U2VyaWVzWTogcHJldlNlcmllc1ksXG4gICAgICAgICAgbGluZVlQb3NpdGlvbjogbGluZVlQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgcHJldlkgPSBmaXJzdFByZXZZLnByZXZZO1xuICAgICAgICB5QXJyai5wdXNoKHByZXZZKTtcbiAgICAgICAgcFkgPSBwcmV2WTtcblxuICAgICAgICBpZiAoc2VyaWVzW2ldWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgdmFsdWUgaXRzZWxmIGlzIG51bGwsIHdlIG5lZWQgdG8gbW92ZSB0aGUgcG9pbnRlciB0byBhIGxvY2F0aW9uIHdoZXJlIGEgbnVsbCB2YWx1ZSBpcyBub3QgZm91bmRcbiAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNlcmllc1tpXS5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgaWYgKHNlcmllc1tpXVtzXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2WCA9IHhEaXZpc2lvbiAqIHM7XG4gICAgICAgICAgICAgIHByZXZZID0gemVyb1kgLSBzZXJpZXNbaV1bc10gLyB5UmF0aW9bdGhpcy55YXhpc0luZGV4XTtcbiAgICAgICAgICAgICAgbGluZVBhdGggPSBncmFwaGljcy5tb3ZlKHByZXZYLCBwcmV2WSk7XG4gICAgICAgICAgICAgIGFyZWFQYXRoID0gZ3JhcGhpY3MubW92ZShwcmV2WCwgYXJlYUJvdHRvbVkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZVBhdGggPSBncmFwaGljcy5tb3ZlKHByZXZYLCBwcmV2WSk7XG4gICAgICAgICAgYXJlYVBhdGggPSBncmFwaGljcy5tb3ZlKHByZXZYLCBhcmVhQm90dG9tWSkgKyBncmFwaGljcy5saW5lKHByZXZYLCBwcmV2WSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoRnJvbUxpbmUgPSBncmFwaGljcy5tb3ZlKC0xLCB6ZXJvWSkgKyBncmFwaGljcy5saW5lKC0xLCB6ZXJvWSk7XG4gICAgICAgIHBhdGhGcm9tQXJlYSA9IGdyYXBoaWNzLm1vdmUoLTEsIHplcm9ZKSArIGdyYXBoaWNzLmxpbmUoLTEsIHplcm9ZKTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBwYXRoRnJvbSA9IHRoaXMuY2hlY2tQcmV2aW91c1BhdGhzKHtcbiAgICAgICAgICAgIHBhdGhGcm9tTGluZTogcGF0aEZyb21MaW5lLFxuICAgICAgICAgICAgcGF0aEZyb21BcmVhOiBwYXRoRnJvbUFyZWEsXG4gICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBhdGhGcm9tTGluZSA9IHBhdGhGcm9tLnBhdGhGcm9tTGluZTtcbiAgICAgICAgICBwYXRoRnJvbUFyZWEgPSBwYXRoRnJvbS5wYXRoRnJvbUFyZWE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IHcuZ2xvYmFscy5kYXRhUG9pbnRzID4gMSA/IHcuZ2xvYmFscy5kYXRhUG9pbnRzIC0gMSA6IHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgICB2YXIgc1ggPSB3Lmdsb2JhbHMuc2VyaWVzWFtyZWFsSW5kZXhdW2ogKyAxXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuc2VyaWVzWFtyZWFsSW5kZXhdW2ogKyAxXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLyogZml4ICMzNzQgKi9cbiAgICAgICAgICAgICAgc1ggPSB3Lmdsb2JhbHMuc2VyaWVzWFtyZWFsSW5kZXhdW2l0ZXJhdGlvbnMgLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeCA9IChzWCAtIHcuZ2xvYmFscy5taW5YKSAvIHhSYXRpbztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHggKyB4RGl2aXNpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1pblkgPSBVdGlscy5pc051bWJlcih3Lmdsb2JhbHMubWluWUFycltyZWFsSW5kZXhdKSA/IHcuZ2xvYmFscy5taW5ZQXJyW3JlYWxJbmRleF0gOiB3Lmdsb2JhbHMubWluWTtcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDAgJiYgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5sZW5ndGggPCB3LmNvbmZpZy5zZXJpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBsaW5lWVBvc2l0aW9uID0gcHJldlNlcmllc1lbaSAtIDFdW2ogKyAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBzZXJpZXMgd2lsbCBub3QgaGF2ZSBwcmV2WSB2YWx1ZXNcbiAgICAgICAgICAgICAgbGluZVlQb3NpdGlvbiA9IHplcm9ZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlcmllc1tpXVtqICsgMV0gPT09ICd1bmRlZmluZWQnIHx8IHNlcmllc1tpXVtqICsgMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgeSA9IGxpbmVZUG9zaXRpb24gLSBtaW5ZIC8geVJhdGlvW3RoaXMueWF4aXNJbmRleF0gKyAodGhpcy5pc1JldmVyc2VkID8gbWluWSAvIHlSYXRpb1t0aGlzLnlheGlzSW5kZXhdIDogMCkgKiAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeSA9IGxpbmVZUG9zaXRpb24gLSBzZXJpZXNbaV1baiArIDFdIC8geVJhdGlvW3RoaXMueWF4aXNJbmRleF0gKyAodGhpcy5pc1JldmVyc2VkID8gc2VyaWVzW2ldW2ogKyAxXSAvIHlSYXRpb1t0aGlzLnlheGlzSW5kZXhdIDogMCkgKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlcmllc1tpXVtqICsgMV0gPT09ICd1bmRlZmluZWQnIHx8IHNlcmllc1tpXVtqICsgMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgeSA9IHplcm9ZIC0gbWluWSAvIHlSYXRpb1t0aGlzLnlheGlzSW5kZXhdICsgKHRoaXMuaXNSZXZlcnNlZCA/IG1pblkgLyB5UmF0aW9bdGhpcy55YXhpc0luZGV4XSA6IDApICogMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHkgPSB6ZXJvWSAtIHNlcmllc1tpXVtqICsgMV0gLyB5UmF0aW9bdGhpcy55YXhpc0luZGV4XSArICh0aGlzLmlzUmV2ZXJzZWQgPyBzZXJpZXNbaV1baiArIDFdIC8geVJhdGlvW3RoaXMueWF4aXNJbmRleF0gOiAwKSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBwdXNoIGN1cnJlbnQgWFxuXG5cbiAgICAgICAgICB4QXJyai5wdXNoKHgpOyAvLyBwdXNoIGN1cnJlbnQgWSB0aGF0IHdpbGwgYmUgdXNlZCBhcyBuZXh0IHNlcmllcydzIGJvdHRvbSBwb3NpdGlvblxuXG4gICAgICAgICAgeUFycmoucHVzaCh5KTtcbiAgICAgICAgICB2YXIgY2FsY3VsYXRlZFBhdGhzID0gdGhpcy5jcmVhdGVQYXRocyh7XG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB4RGl2aXNpb246IHhEaXZpc2lvbixcbiAgICAgICAgICAgIHBYOiBwWCxcbiAgICAgICAgICAgIHBZOiBwWSxcbiAgICAgICAgICAgIGFyZWFCb3R0b21ZOiBhcmVhQm90dG9tWSxcbiAgICAgICAgICAgIGxpbmVQYXRoOiBsaW5lUGF0aCxcbiAgICAgICAgICAgIGFyZWFQYXRoOiBhcmVhUGF0aCxcbiAgICAgICAgICAgIGxpbmVQYXRoczogbGluZVBhdGhzLFxuICAgICAgICAgICAgYXJlYVBhdGhzOiBhcmVhUGF0aHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhcmVhUGF0aHMgPSBjYWxjdWxhdGVkUGF0aHMuYXJlYVBhdGhzO1xuICAgICAgICAgIGxpbmVQYXRocyA9IGNhbGN1bGF0ZWRQYXRocy5saW5lUGF0aHM7XG4gICAgICAgICAgcFggPSBjYWxjdWxhdGVkUGF0aHMucFg7XG4gICAgICAgICAgcFkgPSBjYWxjdWxhdGVkUGF0aHMucFk7XG4gICAgICAgICAgYXJlYVBhdGggPSBjYWxjdWxhdGVkUGF0aHMuYXJlYVBhdGg7XG4gICAgICAgICAgbGluZVBhdGggPSBjYWxjdWxhdGVkUGF0aHMubGluZVBhdGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5hcHBlbmRQYXRoRnJvbSkge1xuICAgICAgICAgICAgcGF0aEZyb21MaW5lID0gcGF0aEZyb21MaW5lICsgZ3JhcGhpY3MubGluZSh4LCB6ZXJvWSk7XG4gICAgICAgICAgICBwYXRoRnJvbUFyZWEgPSBwYXRoRnJvbUFyZWEgKyBncmFwaGljcy5saW5lKHgsIHplcm9ZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcG9pbnRzUG9zID0gdGhpcy5jYWxjdWxhdGVQb2ludHMoe1xuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICBwcmV2WTogcHJldlksXG4gICAgICAgICAgICBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uOiBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uLFxuICAgICAgICAgICAgeFJhdGlvOiB4UmF0aW9cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghdGhpcy5wb2ludHNDaGFydCkge1xuICAgICAgICAgICAgdmFyIG1hcmtlcnMgPSBuZXcgTWFya2Vycyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuZGF0YVBvaW50cyA+IDEpIHtcbiAgICAgICAgICAgICAgZWxQb2ludHNNYWluLm5vZGUuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbFBvaW50c1dyYXAgPSBtYXJrZXJzLnBsb3RDaGFydE1hcmtlcnMocG9pbnRzUG9zLCByZWFsSW5kZXgsIGogKyAxKTtcblxuICAgICAgICAgICAgaWYgKGVsUG9pbnRzV3JhcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbFBvaW50c01haW4uYWRkKGVsUG9pbnRzV3JhcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNjYXR0ZXIgLyBidWJibGUgY2hhcnQgcG9pbnRzIGNyZWF0aW9uXG4gICAgICAgICAgICB0aGlzLnNjYXR0ZXIuZHJhdyhlbFNlcmllcywgaiwge1xuICAgICAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgcG9pbnRzUG9zOiBwb2ludHNQb3MsXG4gICAgICAgICAgICAgIHpSYXRpbzogelJhdGlvLFxuICAgICAgICAgICAgICBlbFBhcmVudDogZWxQb2ludHNNYWluXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGF0YUxhYmVscyA9IG5ldyBEYXRhTGFiZWxzKHRoaXMuY3R4KTtcbiAgICAgICAgICB2YXIgZHJhd25MYWJlbHMgPSBkYXRhTGFiZWxzLmRyYXdEYXRhTGFiZWwocG9pbnRzUG9zLCByZWFsSW5kZXgsIGogKyAxKTtcblxuICAgICAgICAgIGlmIChkcmF3bkxhYmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWxEYXRhTGFiZWxzV3JhcC5hZGQoZHJhd25MYWJlbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwdXNoIGFsbCBjdXJyZW50IHkgdmFsdWVzIGFycmF5IHRvIG1haW4gUHJldlkgQXJyYXlcblxuXG4gICAgICAgIHByZXZTZXJpZXNZLnB1c2goeUFycmopOyAvLyBwdXNoIGFsbCB4IHZhbCBhcnJheXMgaW50byBtYWluIHhBcnJcblxuICAgICAgICB3Lmdsb2JhbHMuc2VyaWVzWHZhbHVlc1tyZWFsSW5kZXhdID0geEFycmo7XG4gICAgICAgIHcuZ2xvYmFscy5zZXJpZXNZdmFsdWVzW3JlYWxJbmRleF0gPSB5QXJyajsgLy8gdGhlc2UgZWxlbWVudHMgd2lsbCBiZSBzaG93biBhZnRlciBhcmVhIHBhdGggYW5pbWF0aW9uIGNvbXBsZXRlc1xuXG4gICAgICAgIGlmICghdGhpcy5wb2ludHNDaGFydCkge1xuICAgICAgICAgIHcuZ2xvYmFscy5kZWxheWVkRWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBlbDogZWxQb2ludHNNYWluLm5vZGUsXG4gICAgICAgICAgICBpbmRleDogcmVhbEluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVmYXVsdFJlbmRlcmVkUGF0aE9wdGlvbnMgPSB7XG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICBhbmltYXRpb25EZWxheTogaSxcbiAgICAgICAgICBpbml0aWFsU3BlZWQ6IHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuc3BlZWQsXG4gICAgICAgICAgZGF0YUNoYW5nZVNwZWVkOiB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uc3BlZWQsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcImFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUpLFxuICAgICAgICAgIGlkOiBcImFwZXhjaGFydHMtXCIuY29uY2F0KHR5cGUpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdhcmVhJykge1xuICAgICAgICAgIHZhciBwYXRoRmlsbCA9IGZpbGwuZmlsbFBhdGgoe1xuICAgICAgICAgICAgc2VyaWVzTnVtYmVyOiByZWFsSW5kZXhcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgYXJlYVBhdGhzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRQYXRoID0gZ3JhcGhpY3MucmVuZGVyUGF0aHMoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFJlbmRlcmVkUGF0aE9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgcGF0aEZyb206IHBhdGhGcm9tQXJlYSxcbiAgICAgICAgICAgICAgcGF0aFRvOiBhcmVhUGF0aHNbcF0sXG4gICAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgICAgICAgc3Ryb2tlTGluZUNhcDogbnVsbCxcbiAgICAgICAgICAgICAgZmlsbDogcGF0aEZpbGxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGVsU2VyaWVzLmFkZChyZW5kZXJlZFBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2Uuc2hvdyAmJiAhdGhpcy5wb2ludHNDaGFydCkge1xuICAgICAgICAgIHZhciBsaW5lRmlsbCA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAvLyBmaWxsYWJsZSBsaW5lcyBvbmx5IGZvciBsaW5lQ2hhcnRcbiAgICAgICAgICAgIGxpbmVGaWxsID0gZmlsbC5maWxsUGF0aCh7XG4gICAgICAgICAgICAgIHNlcmllc051bWJlcjogcmVhbEluZGV4LFxuICAgICAgICAgICAgICBpOiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZUZpbGwgPSB3Lmdsb2JhbHMuc3Ryb2tlLmNvbG9yc1tyZWFsSW5kZXhdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9wID0gMDsgX3AgPCBsaW5lUGF0aHMubGVuZ3RoOyBfcCsrKSB7XG4gICAgICAgICAgICB2YXIgX3JlbmRlcmVkUGF0aCA9IGdyYXBoaWNzLnJlbmRlclBhdGhzKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRSZW5kZXJlZFBhdGhPcHRpb25zLCB7XG4gICAgICAgICAgICAgIHBhdGhGcm9tOiBwYXRoRnJvbUxpbmUsXG4gICAgICAgICAgICAgIHBhdGhUbzogbGluZVBhdGhzW19wXSxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBsaW5lRmlsbCxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IEFycmF5LmlzQXJyYXkody5jb25maWcuc3Ryb2tlLndpZHRoKSA/IHcuY29uZmlnLnN0cm9rZS53aWR0aFtyZWFsSW5kZXhdIDogdy5jb25maWcuc3Ryb2tlLndpZHRoLFxuICAgICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiB3LmNvbmZpZy5zdHJva2UubGluZUNhcCxcbiAgICAgICAgICAgICAgZmlsbDogJ25vbmUnXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGVsU2VyaWVzLmFkZChfcmVuZGVyZWRQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbFNlcmllcy5hZGQoZWxQb2ludHNNYWluKTtcbiAgICAgICAgZWxTZXJpZXMuYWRkKGVsRGF0YUxhYmVsc1dyYXApO1xuICAgICAgICBhbGxTZXJpZXMucHVzaChlbFNlcmllcyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9zID0gYWxsU2VyaWVzLmxlbmd0aDsgX3MgPiAwOyBfcy0tKSB7XG4gICAgICAgIHJldC5hZGQoYWxsU2VyaWVzW19zIC0gMV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVQYXRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQYXRocyhfcmVmKSB7XG4gICAgICB2YXIgc2VyaWVzID0gX3JlZi5zZXJpZXMsXG4gICAgICAgICAgaSA9IF9yZWYuaSxcbiAgICAgICAgICBqID0gX3JlZi5qLFxuICAgICAgICAgIHggPSBfcmVmLngsXG4gICAgICAgICAgeSA9IF9yZWYueSxcbiAgICAgICAgICBwWCA9IF9yZWYucFgsXG4gICAgICAgICAgcFkgPSBfcmVmLnBZLFxuICAgICAgICAgIHhEaXZpc2lvbiA9IF9yZWYueERpdmlzaW9uLFxuICAgICAgICAgIGFyZWFCb3R0b21ZID0gX3JlZi5hcmVhQm90dG9tWSxcbiAgICAgICAgICBsaW5lUGF0aCA9IF9yZWYubGluZVBhdGgsXG4gICAgICAgICAgYXJlYVBhdGggPSBfcmVmLmFyZWFQYXRoLFxuICAgICAgICAgIGxpbmVQYXRocyA9IF9yZWYubGluZVBhdGhzLFxuICAgICAgICAgIGFyZWFQYXRocyA9IF9yZWYuYXJlYVBhdGhzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIGN1cnZlID0gQXJyYXkuaXNBcnJheSh3LmNvbmZpZy5zdHJva2UuY3VydmUpID8gdy5jb25maWcuc3Ryb2tlLmN1cnZlW2ldIDogdy5jb25maWcuc3Ryb2tlLmN1cnZlOyAvLyBsb2dpYyBvZiBzbW9vdGggY3VydmUgZGVyaXZlZCBmcm9tIGNoYXJ0aXN0XG4gICAgICAvLyBDUkVESVRTOiBodHRwczovL2dpb25rdW56LmdpdGh1Yi5pby9jaGFydGlzdC1qcy9cblxuICAgICAgaWYgKGN1cnZlID09PSAnc21vb3RoJykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gKHggLSBwWCkgKiAwLjM1O1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaGFzTnVsbFZhbHVlcykge1xuICAgICAgICAgIGlmIChzZXJpZXNbaV1bal0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzZXJpZXNbaV1baiArIDFdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxpbmVQYXRoID0gZ3JhcGhpY3MubW92ZShwWCwgcFkpICsgZ3JhcGhpY3MuY3VydmUocFggKyBsZW5ndGgsIHBZLCB4IC0gbGVuZ3RoLCB5LCB4ICsgMSwgeSk7XG4gICAgICAgICAgICAgIGFyZWFQYXRoID0gZ3JhcGhpY3MubW92ZShwWCArIDEsIHBZKSArIGdyYXBoaWNzLmN1cnZlKHBYICsgbGVuZ3RoLCBwWSwgeCAtIGxlbmd0aCwgeSwgeCArIDEsIHkpICsgZ3JhcGhpY3MubGluZSh4LCBhcmVhQm90dG9tWSkgKyBncmFwaGljcy5saW5lKHBYLCBhcmVhQm90dG9tWSkgKyAneic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsaW5lUGF0aCA9IGdyYXBoaWNzLm1vdmUocFgsIHBZKTtcbiAgICAgICAgICAgICAgYXJlYVBhdGggPSBncmFwaGljcy5tb3ZlKHBYLCBwWSkgKyAneic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZVBhdGhzLnB1c2gobGluZVBhdGgpO1xuICAgICAgICAgIGFyZWFQYXRocy5wdXNoKGFyZWFQYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lUGF0aCA9IGxpbmVQYXRoICsgZ3JhcGhpY3MuY3VydmUocFggKyBsZW5ndGgsIHBZLCB4IC0gbGVuZ3RoLCB5LCB4LCB5KTtcbiAgICAgICAgICBhcmVhUGF0aCA9IGFyZWFQYXRoICsgZ3JhcGhpY3MuY3VydmUocFggKyBsZW5ndGgsIHBZLCB4IC0gbGVuZ3RoLCB5LCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBYID0geDtcbiAgICAgICAgcFkgPSB5O1xuXG4gICAgICAgIGlmIChqID09PSBzZXJpZXNbaV0ubGVuZ3RoIC0gMikge1xuICAgICAgICAgIC8vIGxhc3QgbG9vcCwgY2xvc2UgcGF0aFxuICAgICAgICAgIGFyZWFQYXRoID0gYXJlYVBhdGggKyBncmFwaGljcy5jdXJ2ZShwWCwgcFksIHgsIHksIHgsIGFyZWFCb3R0b21ZKSArIGdyYXBoaWNzLm1vdmUoeCwgeSkgKyAneic7XG5cbiAgICAgICAgICBpZiAoIXcuZ2xvYmFscy5oYXNOdWxsVmFsdWVzKSB7XG4gICAgICAgICAgICBsaW5lUGF0aHMucHVzaChsaW5lUGF0aCk7XG4gICAgICAgICAgICBhcmVhUGF0aHMucHVzaChhcmVhUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2VyaWVzW2ldW2ogKyAxXSA9PT0gbnVsbCkge1xuICAgICAgICAgIGxpbmVQYXRoID0gbGluZVBhdGggKyBncmFwaGljcy5tb3ZlKHgsIHkpO1xuICAgICAgICAgIGFyZWFQYXRoID0gYXJlYVBhdGggKyBncmFwaGljcy5saW5lKHggLSB4RGl2aXNpb24sIGFyZWFCb3R0b21ZKSArIGdyYXBoaWNzLm1vdmUoeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VyaWVzW2ldW2pdID09PSBudWxsKSB7XG4gICAgICAgICAgbGluZVBhdGggPSBsaW5lUGF0aCArIGdyYXBoaWNzLm1vdmUoeCwgeSk7XG4gICAgICAgICAgYXJlYVBhdGggPSBhcmVhUGF0aCArIGdyYXBoaWNzLm1vdmUoeCwgYXJlYUJvdHRvbVkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnZlID09PSAnc3RlcGxpbmUnKSB7XG4gICAgICAgICAgbGluZVBhdGggPSBsaW5lUGF0aCArIGdyYXBoaWNzLmxpbmUoeCwgbnVsbCwgJ0gnKSArIGdyYXBoaWNzLmxpbmUobnVsbCwgeSwgJ1YnKTtcbiAgICAgICAgICBhcmVhUGF0aCA9IGFyZWFQYXRoICsgZ3JhcGhpY3MubGluZSh4LCBudWxsLCAnSCcpICsgZ3JhcGhpY3MubGluZShudWxsLCB5LCAnVicpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnZlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICAgICAgbGluZVBhdGggPSBsaW5lUGF0aCArIGdyYXBoaWNzLmxpbmUoeCwgeSk7XG4gICAgICAgICAgYXJlYVBhdGggPSBhcmVhUGF0aCArIGdyYXBoaWNzLmxpbmUoeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA9PT0gc2VyaWVzW2ldLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAvLyBsYXN0IGxvb3AsIGNsb3NlIHBhdGhcbiAgICAgICAgICBhcmVhUGF0aCA9IGFyZWFQYXRoICsgZ3JhcGhpY3MubGluZSh4LCBhcmVhQm90dG9tWSkgKyBncmFwaGljcy5tb3ZlKHgsIHkpICsgJ3onO1xuICAgICAgICAgIGxpbmVQYXRocy5wdXNoKGxpbmVQYXRoKTtcbiAgICAgICAgICBhcmVhUGF0aHMucHVzaChhcmVhUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVBhdGhzOiBsaW5lUGF0aHMsXG4gICAgICAgIGFyZWFQYXRoczogYXJlYVBhdGhzLFxuICAgICAgICBwWDogcFgsXG4gICAgICAgIHBZOiBwWSxcbiAgICAgICAgbGluZVBhdGg6IGxpbmVQYXRoLFxuICAgICAgICBhcmVhUGF0aDogYXJlYVBhdGhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZVBvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVQb2ludHMoX3JlZjIpIHtcbiAgICAgIHZhciBzZXJpZXMgPSBfcmVmMi5zZXJpZXMsXG4gICAgICAgICAgcmVhbEluZGV4ID0gX3JlZjIucmVhbEluZGV4LFxuICAgICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgICAgIGkgPSBfcmVmMi5pLFxuICAgICAgICAgIGogPSBfcmVmMi5qLFxuICAgICAgICAgIHByZXZZID0gX3JlZjIucHJldlksXG4gICAgICAgICAgY2F0ZWdvcnlBeGlzQ29ycmVjdGlvbiA9IF9yZWYyLmNhdGVnb3J5QXhpc0NvcnJlY3Rpb24sXG4gICAgICAgICAgeFJhdGlvID0gX3JlZjIueFJhdGlvO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcHRYID0gW107XG4gICAgICB2YXIgcHRZID0gW107XG5cbiAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgIHZhciB4UFQxc3QgPSBjYXRlZ29yeUF4aXNDb3JyZWN0aW9uICsgdy5jb25maWcubWFya2Vycy5vZmZzZXRYOyAvLyB0aGUgZmlyc3QgcG9pbnQgZm9yIGxpbmUgc2VyaWVzXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY2hlY2sgd2hldGhlciBpdCdzIG5vdCBhIHRpbWUgc2VyaWVzLCBiZWNhdXNlIGEgdGltZSBzZXJpZXMgbWF5XG4gICAgICAgIC8vIHN0YXJ0IGZyb20gdGhlIG1pZGRsZSBvZiB0aGUgeCBheGlzXG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgeFBUMXN0ID0gKHcuZ2xvYmFscy5zZXJpZXNYW3JlYWxJbmRleF1bMF0gLSB3Lmdsb2JhbHMubWluWCkgLyB4UmF0aW8gKyB3LmNvbmZpZy5tYXJrZXJzLm9mZnNldFg7XG4gICAgICAgIH0gLy8gcHVzaCAyIHBvaW50cyBmb3IgdGhlIGZpcnN0IGRhdGEgdmFsdWVzXG5cblxuICAgICAgICBwdFgucHVzaCh4UFQxc3QpO1xuICAgICAgICBwdFkucHVzaChVdGlscy5pc051bWJlcihzZXJpZXNbaV1bMF0pID8gcHJldlkgKyB3LmNvbmZpZy5tYXJrZXJzLm9mZnNldFkgOiBudWxsKTtcbiAgICAgICAgcHRYLnB1c2goeCArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WCk7XG4gICAgICAgIHB0WS5wdXNoKFV0aWxzLmlzTnVtYmVyKHNlcmllc1tpXVtqICsgMV0pID8geSArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WSA6IG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHRYLnB1c2goeCArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WCk7XG4gICAgICAgIHB0WS5wdXNoKFV0aWxzLmlzTnVtYmVyKHNlcmllc1tpXVtqICsgMV0pID8geSArIHcuY29uZmlnLm1hcmtlcnMub2Zmc2V0WSA6IG51bGwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRzUG9zID0ge1xuICAgICAgICB4OiBwdFgsXG4gICAgICAgIHk6IHB0WVxuICAgICAgfTtcbiAgICAgIHJldHVybiBwb2ludHNQb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrUHJldmlvdXNQYXRoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1ByZXZpb3VzUGF0aHMoX3JlZjMpIHtcbiAgICAgIHZhciBwYXRoRnJvbUxpbmUgPSBfcmVmMy5wYXRoRnJvbUxpbmUsXG4gICAgICAgICAgcGF0aEZyb21BcmVhID0gX3JlZjMucGF0aEZyb21BcmVhLFxuICAgICAgICAgIHJlYWxJbmRleCA9IF9yZWYzLnJlYWxJbmRleDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBmb3IgKHZhciBwcCA9IDA7IHBwIDwgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMubGVuZ3RoOyBwcCsrKSB7XG4gICAgICAgIHZhciBncHAgPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF07XG5cbiAgICAgICAgaWYgKChncHAudHlwZSA9PT0gJ2xpbmUnIHx8IGdwcC50eXBlID09PSAnYXJlYScpICYmIGdwcC5wYXRocy5sZW5ndGggPiAwICYmIHBhcnNlSW50KGdwcC5yZWFsSW5kZXgpID09PSBwYXJzZUludChyZWFsSW5kZXgpKSB7XG4gICAgICAgICAgaWYgKGdwcC50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kUGF0aEZyb20gPSBmYWxzZTtcbiAgICAgICAgICAgIHBhdGhGcm9tTGluZSA9IHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzW3BwXS5wYXRoc1swXS5kO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZ3BwLnR5cGUgPT09ICdhcmVhJykge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRQYXRoRnJvbSA9IGZhbHNlO1xuICAgICAgICAgICAgcGF0aEZyb21BcmVhID0gdy5nbG9iYWxzLnByZXZpb3VzUGF0aHNbcHBdLnBhdGhzWzBdLmQ7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5zdHJva2Uuc2hvdykge1xuICAgICAgICAgICAgICBwYXRoRnJvbUxpbmUgPSB3Lmdsb2JhbHMucHJldmlvdXNQYXRoc1twcF0ucGF0aHNbMV0uZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aEZyb21MaW5lOiBwYXRoRnJvbUxpbmUsXG4gICAgICAgIHBhdGhGcm9tQXJlYTogcGF0aEZyb21BcmVhXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmVGaXJzdFByZXZZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluZUZpcnN0UHJldlkoX3JlZjQpIHtcbiAgICAgIHZhciBpID0gX3JlZjQuaSxcbiAgICAgICAgICBzZXJpZXMgPSBfcmVmNC5zZXJpZXMsXG4gICAgICAgICAgeVJhdGlvID0gX3JlZjQueVJhdGlvLFxuICAgICAgICAgIHplcm9ZID0gX3JlZjQuemVyb1ksXG4gICAgICAgICAgcHJldlkgPSBfcmVmNC5wcmV2WSxcbiAgICAgICAgICBwcmV2U2VyaWVzWSA9IF9yZWY0LnByZXZTZXJpZXNZLFxuICAgICAgICAgIGxpbmVZUG9zaXRpb24gPSBfcmVmNC5saW5lWVBvc2l0aW9uO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VyaWVzW2ldWzBdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAody5jb25maWcuY2hhcnQuc3RhY2tlZCkge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgLy8gMXN0IHkgdmFsdWUgb2YgcHJldmlvdXMgc2VyaWVzXG4gICAgICAgICAgICBsaW5lWVBvc2l0aW9uID0gcHJldlNlcmllc1lbaSAtIDFdWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgZmlyc3Qgc2VyaWVzIHdpbGwgbm90IGhhdmUgcHJldlkgdmFsdWVzXG4gICAgICAgICAgICBsaW5lWVBvc2l0aW9uID0gemVyb1k7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldlkgPSBsaW5lWVBvc2l0aW9uIC0gc2VyaWVzW2ldWzBdIC8geVJhdGlvICsgKHRoaXMuaXNSZXZlcnNlZCA/IHNlcmllc1tpXVswXSAvIHlSYXRpbyA6IDApICogMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2WSA9IHplcm9ZIC0gc2VyaWVzW2ldWzBdIC8geVJhdGlvICsgKHRoaXMuaXNSZXZlcnNlZCA/IHNlcmllc1tpXVswXSAvIHlSYXRpbyA6IDApICogMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBjdXJyZW50IHNlcmllcyBpcyBudWxsXG4gICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zdGFja2VkICYmIGkgPiAwICYmIHR5cGVvZiBzZXJpZXNbaV1bMF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIHVuZGVmaW5lZCB2YWx1ZSAodW5kZWZpbmVkIHZhbHVlIHdpbGwgb2NjdXIgd2hlbiB3ZSBjbGVhciB0aGUgc2VyaWVzIHdoaWxlIHVzZXIgY2xpY2tzIG9uIGxlZ2VuZCB0byBoaWRlIHNlcmllc2VzKVxuICAgICAgICAgIGZvciAodmFyIHMgPSBpIC0gMTsgcyA+PSAwOyBzLS0pIHtcbiAgICAgICAgICAgIC8vIGZvciBsb29wIHRvIGdldCB0byAxc3QgcHJldmlvdXMgdmFsdWUgdW50aWwgd2UgZ2V0IGl0XG4gICAgICAgICAgICBpZiAoc2VyaWVzW3NdWzBdICE9PSBudWxsICYmIHR5cGVvZiBzZXJpZXNbc11bMF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGxpbmVZUG9zaXRpb24gPSBwcmV2U2VyaWVzWVtzXVswXTtcbiAgICAgICAgICAgICAgcHJldlkgPSBsaW5lWVBvc2l0aW9uO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJldlk6IHByZXZZLFxuICAgICAgICBsaW5lWVBvc2l0aW9uOiBsaW5lWVBvc2l0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgWUF4aXMgQ2xhc3MgZm9yIGRyYXdpbmcgWS1BeGlzLlxuICpcbiAqIEBtb2R1bGUgWUF4aXNcbiAqKi9cblxudmFyIFlBeGlzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWUF4aXMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFlBeGlzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMueGF4aXNGb250U2l6ZSA9IHRoaXMudy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplO1xuICAgIHRoaXMuYXhpc0ZvbnRGYW1pbHkgPSB0aGlzLncuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250RmFtaWx5O1xuICAgIHRoaXMuaXNCYXJIb3Jpem9udGFsID0gISEodGhpcy53LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsKTtcbiAgICB0aGlzLnhheGlzRm9yZUNvbG9ycyA9IHRoaXMudy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmNvbG9ycztcbiAgICB0aGlzLnhBeGlzb2ZmWCA9IDA7XG5cbiAgICBpZiAodGhpcy53LmNvbmZpZy54YXhpcy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMueEF4aXNvZmZYID0gdGhpcy53Lmdsb2JhbHMuZ3JpZEhlaWdodDtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWUF4aXMsIFt7XG4gICAga2V5OiBcImRyYXdZYXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WWF4aXMocmVhbEluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgeWF4aXNGb250U2l6ZSA9IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnN0eWxlLmZvbnRTaXplO1xuICAgICAgdmFyIHlheGlzRm9udEZhbWlseSA9IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnN0eWxlLmZvbnRGYW1pbHk7XG4gICAgICB2YXIgZWxZYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXlheGlzJyxcbiAgICAgICAgcmVsOiByZWFsSW5kZXgsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtyZWFsSW5kZXhdICsgJywgMCknXG4gICAgICB9KTtcblxuICAgICAgaWYgKCF3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnNob3cpIHtcbiAgICAgICAgcmV0dXJuIGVsWWF4aXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbFlheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy10ZXh0cy1nJ1xuICAgICAgfSk7XG4gICAgICBlbFlheGlzLmFkZChlbFlheGlzVGV4dHMpO1xuICAgICAgdmFyIHRpY2tBbW91bnQgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVtyZWFsSW5kZXhdLnJlc3VsdC5sZW5ndGggLSAxOyAvLyBsYWJlbHNEaXZpZGVyIGlzIHNpbXBseSBzdmcgaGVpZ2h0L251bWJlciBvZiB0aWNrc1xuXG4gICAgICB2YXIgbGFiZWxzRGl2aWRlciA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdGlja0Ftb3VudCArIDAuMTsgLy8gaW5pdGlhbCBsYWJlbCBwb3NpdGlvbiA9IDA7XG5cbiAgICAgIHZhciBsID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVk7XG4gICAgICB2YXIgbGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1tyZWFsSW5kZXhdO1xuICAgICAgdmFyIGxhYmVscyA9IHcuZ2xvYmFscy55QXhpc1NjYWxlW3JlYWxJbmRleF0ucmVzdWx0LnNsaWNlKCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnJldmVyc2VkKSB7XG4gICAgICAgIGxhYmVscy5yZXZlcnNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5zaG93KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aWNrQW1vdW50OyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciB2YWwgPSBsYWJlbHNbaV07XG4gICAgICAgICAgdmFsID0gbGJGb3JtYXR0ZXIodmFsLCBpKTtcbiAgICAgICAgICB2YXIgeFBhZCA9IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnBhZGRpbmc7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5vcHBvc2l0ZSAmJiB3LmNvbmZpZy55YXhpcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHhQYWQgPSB4UGFkICogLTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxhYmVsID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgeDogeFBhZCxcbiAgICAgICAgICAgIHk6IGwgKyB0aWNrQW1vdW50IC8gMTAgKyB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmxhYmVscy5vZmZzZXRZICsgMSxcbiAgICAgICAgICAgIHRleHQ6IHZhbCxcbiAgICAgICAgICAgIHRleHRBbmNob3I6IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUgPyAnc3RhcnQnIDogJ2VuZCcsXG4gICAgICAgICAgICBmb250U2l6ZTogeWF4aXNGb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHlheGlzRm9udEZhbWlseSxcbiAgICAgICAgICAgIGZvcmVDb2xvcjogdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMuc3R5bGUuY29sb3IsXG4gICAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtbGFiZWwgJyArIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnN0eWxlLmNzc0NsYXNzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxZYXhpc1RleHRzLmFkZChsYWJlbCk7XG4gICAgICAgICAgdmFyIGxhYmVsUm90YXRpbmdDZW50ZXIgPSBncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIobGFiZWwubm9kZSk7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMucm90YXRlICE9PSAwKSB7XG4gICAgICAgICAgICBsYWJlbC5ub2RlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJyb3RhdGUoXCIuY29uY2F0KHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ubGFiZWxzLnJvdGF0ZSwgXCIgXCIpLmNvbmNhdChsYWJlbFJvdGF0aW5nQ2VudGVyLngsIFwiIFwiKS5jb25jYXQobGFiZWxSb3RhdGluZ0NlbnRlci55LCBcIilcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGwgPSBsICsgbGFiZWxzRGl2aWRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVsWWF4aXNUaXRsZSA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGl0bGUnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgeCA9IDA7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUpIHtcbiAgICAgICAgICB4ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtyZWFsSW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsWUF4aXNUaXRsZVRleHQgPSBncmFwaGljcy5kcmF3VGV4dCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIDIgKyB3Lmdsb2JhbHMudHJhbnNsYXRlWSxcbiAgICAgICAgICB0ZXh0OiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnRleHQsXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ2VuZCcsXG4gICAgICAgICAgZm9yZUNvbG9yOiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnN0eWxlLmNvbG9yLFxuICAgICAgICAgIGZvbnRTaXplOiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGl0bGUtdGV4dCAnICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5zdHlsZS5jc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxZYXhpc1RpdGxlLmFkZChlbFlBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgZWxZYXhpcy5hZGQoZWxZYXhpc1RpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNCb3JkZXIgPSB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmF4aXNCb3JkZXI7XG5cbiAgICAgIGlmIChheGlzQm9yZGVyLnNob3cpIHtcbiAgICAgICAgdmFyIF94ID0gMzEgKyBheGlzQm9yZGVyLm9mZnNldFg7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0ub3Bwb3NpdGUpIHtcbiAgICAgICAgICBfeCA9IC0zMSAtIGF4aXNCb3JkZXIub2Zmc2V0WDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbFZlcnRpY2FsTGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKF94LCB3Lmdsb2JhbHMudHJhbnNsYXRlWSArIGF4aXNCb3JkZXIub2Zmc2V0WSAtIDIsIF94LCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIHcuZ2xvYmFscy50cmFuc2xhdGVZICsgYXhpc0JvcmRlci5vZmZzZXRZICsgMiwgYXhpc0JvcmRlci5jb2xvcik7XG4gICAgICAgIGVsWWF4aXMuYWRkKGVsVmVydGljYWxMaW5lKTtcbiAgICAgICAgdGhpcy5kcmF3QXhpc1RpY2tzKF94LCB0aWNrQW1vdW50LCBheGlzQm9yZGVyLCB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmF4aXNUaWNrcywgcmVhbEluZGV4LCBsYWJlbHNEaXZpZGVyLCBlbFlheGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsWWF4aXM7XG4gICAgfSAvLyBUaGlzIGFjdHVhbGx5IGJlY29tZXMgaG9yaXpvbmFsIGF4aXMgKGZvciBiYXIgY2hhcnRzKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1lheGlzSW52ZXJzZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lheGlzSW52ZXJzZWQocmVhbEluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZWxYYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzIGFwZXhjaGFydHMteWF4aXMtaW52ZXJzZWQnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbFhheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWCwgXCIsIFwiKS5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIGVsWGF4aXMuYWRkKGVsWGF4aXNUZXh0cyk7XG4gICAgICB2YXIgdGlja0Ftb3VudCA9IHcuZ2xvYmFscy55QXhpc1NjYWxlW3JlYWxJbmRleF0ucmVzdWx0Lmxlbmd0aCAtIDE7IC8vIGxhYmVsc0RpdmlkZXIgaXMgc2ltcGx5IHN2ZyB3aWR0aC9udW1iZXIgb2YgdGlja3NcblxuICAgICAgdmFyIGxhYmVsc0RpdmlkZXIgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdGlja0Ftb3VudCArIDAuMTsgLy8gaW5pdGlhbCBsYWJlbCBwb3NpdGlvbjtcblxuICAgICAgdmFyIGwgPSBsYWJlbHNEaXZpZGVyICsgdy5jb25maWcueGF4aXMubGFiZWxzLm9mZnNldFg7XG4gICAgICB2YXIgbGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueExhYmVsRm9ybWF0dGVyO1xuICAgICAgdmFyIGxhYmVscyA9IHcuZ2xvYmFscy55QXhpc1NjYWxlW3JlYWxJbmRleF0ucmVzdWx0LnNsaWNlKCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnJldmVyc2VkKSB7XG4gICAgICAgIGxhYmVscy5yZXZlcnNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMuc2hvdykge1xuICAgICAgICBmb3IgKHZhciBpID0gdGlja0Ftb3VudDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgdmFsID0gbGFiZWxzW2ldO1xuICAgICAgICAgIHZhbCA9IGxiRm9ybWF0dGVyKHZhbCwgaSk7XG4gICAgICAgICAgdmFyIGVsVGljayA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICAgIHg6IHcuZ2xvYmFscy5ncmlkV2lkdGggKyB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCAtIChsIC0gbGFiZWxzRGl2aWRlciArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYKSxcbiAgICAgICAgICAgIHk6IHRoaXMueEF4aXNvZmZYICsgdy5jb25maWcueGF4aXMubGFiZWxzLm9mZnNldFkgKyAzMCxcbiAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICBmb3JlQ29sb3I6IEFycmF5LmlzQXJyYXkodGhpcy54YXhpc0ZvcmVDb2xvcnMpID8gdGhpcy54YXhpc0ZvcmVDb2xvcnNbcmVhbEluZGV4XSA6IHRoaXMueGF4aXNGb3JlQ29sb3JzLFxuICAgICAgICAgICAgZm9udFNpemU6IHRoaXMueGF4aXNGb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHRoaXMueGF4aXNGb250RmFtaWx5LFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLWxhYmVsICcgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuY3NzQ2xhc3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbFhheGlzVGV4dHMuYWRkKGVsVGljayk7XG4gICAgICAgICAgZWxUaWNrLnRzcGFuKHZhbCk7XG4gICAgICAgICAgdmFyIGVsVG9vbHRpcFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ3RpdGxlJyk7XG4gICAgICAgICAgZWxUb29sdGlwVGl0bGUudGV4dENvbnRlbnQgPSB2YWw7XG4gICAgICAgICAgZWxUaWNrLm5vZGUuYXBwZW5kQ2hpbGQoZWxUb29sdGlwVGl0bGUpO1xuICAgICAgICAgIGwgPSBsICsgbGFiZWxzRGl2aWRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMudGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlbFlheGlzVGl0bGUgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRpdGxlIGFwZXhjaGFydHMteWF4aXMtdGl0bGUtaW52ZXJzZWQnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZWxZQXhpc1RpdGxlVGV4dCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICB4OiB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMixcbiAgICAgICAgICB5OiB0aGlzLnhBeGlzb2ZmWCArIHBhcnNlSW50KHRoaXMueGF4aXNGb250U2l6ZSkgKyBwYXJzZUludCh3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250U2l6ZSkgKyAyMCxcbiAgICAgICAgICB0ZXh0OiB3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvbnRTaXplOiB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10aXRsZS10ZXh0ICcgKyB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5jc3NDbGFzc1xuICAgICAgICB9KTtcbiAgICAgICAgZWxZYXhpc1RpdGxlLmFkZChlbFlBeGlzVGl0bGVUZXh0KTtcbiAgICAgICAgZWxYYXhpcy5hZGQoZWxZYXhpc1RpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4aXNCb3JkZXIgPSB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLmF4aXNCb3JkZXI7XG5cbiAgICAgIGlmIChheGlzQm9yZGVyLnNob3cpIHtcbiAgICAgICAgdmFyIGVsVmVydGljYWxMaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUody5nbG9iYWxzLnBhZEhvcml6b250YWwgKyBheGlzQm9yZGVyLm9mZnNldFgsIDEgKyBheGlzQm9yZGVyLm9mZnNldFksIHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsICsgYXhpc0JvcmRlci5vZmZzZXRYLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCArIGF4aXNCb3JkZXIub2Zmc2V0WSwgYXhpc0JvcmRlci5jb2xvcik7XG4gICAgICAgIGVsWGF4aXMuYWRkKGVsVmVydGljYWxMaW5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsWGF4aXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdBeGlzVGlja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0F4aXNUaWNrcyh4LCB0aWNrQW1vdW50LCBheGlzQm9yZGVyLCBheGlzVGlja3MsIHJlYWxJbmRleCwgbGFiZWxzRGl2aWRlciwgZWxZYXhpcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpOyAvLyBpbml0aWFsIGxhYmVsIHBvc2l0aW9uID0gMDtcblxuICAgICAgdmFyIHQgPSB3Lmdsb2JhbHMudHJhbnNsYXRlWTtcblxuICAgICAgaWYgKGF4aXNUaWNrcy5zaG93KSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLm9wcG9zaXRlID09PSB0cnVlKSB4ID0geCArIGF4aXNUaWNrcy53aWR0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gdGlja0Ftb3VudDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgdFkgPSB0ICsgdGlja0Ftb3VudCAvIDEwICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS5sYWJlbHMub2Zmc2V0WSAtIDE7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHRZID0gbGFiZWxzRGl2aWRlciAqIGk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVsVGljayA9IGdyYXBoaWNzLmRyYXdMaW5lKHggKyBheGlzQm9yZGVyLm9mZnNldFggLSBheGlzVGlja3Mud2lkdGggKyBheGlzVGlja3Mub2Zmc2V0WCwgdFkgKyBheGlzVGlja3Mub2Zmc2V0WSwgeCArIGF4aXNCb3JkZXIub2Zmc2V0WCArIGF4aXNUaWNrcy5vZmZzZXRYLCB0WSArIGF4aXNUaWNrcy5vZmZzZXRZLCBheGlzQm9yZGVyLmNvbG9yKTtcbiAgICAgICAgICBlbFlheGlzLmFkZChlbFRpY2spO1xuICAgICAgICAgIHQgPSB0ICsgbGFiZWxzRGl2aWRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5QXhpc1RpdGxlUm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHlBeGlzVGl0bGVSb3RhdGUocmVhbEluZGV4LCB5QXhpc09wcG9zaXRlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgeUF4aXNMYWJlbHNDb29yZCA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIHZhciB5QXhpc1RpdGxlQ29vcmQgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICB2YXIgZWxZQXhpc0xhYmVsc1dyYXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiIC5hcGV4Y2hhcnRzLXlheGlzW3JlbD0nXCIuY29uY2F0KHJlYWxJbmRleCwgXCInXSAuYXBleGNoYXJ0cy15YXhpcy10ZXh0cy1nXCIpKTtcblxuICAgICAgaWYgKGVsWUF4aXNMYWJlbHNXcmFwICE9PSBudWxsKSB7XG4gICAgICAgIHlBeGlzTGFiZWxzQ29vcmQgPSBlbFlBeGlzTGFiZWxzV3JhcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHlBeGlzVGl0bGUgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMteWF4aXNbcmVsPSdcIi5jb25jYXQocmVhbEluZGV4LCBcIiddIC5hcGV4Y2hhcnRzLXlheGlzLXRpdGxlIHRleHRcIikpO1xuXG4gICAgICBpZiAoeUF4aXNUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgICB5QXhpc1RpdGxlQ29vcmQgPSB5QXhpc1RpdGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeUF4aXNUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgeCA9IHRoaXMueFBhZGRpbmdGb3JZQXhpc1RpdGxlKHJlYWxJbmRleCwgeUF4aXNMYWJlbHNDb29yZCwgeUF4aXNUaXRsZUNvb3JkLCB5QXhpc09wcG9zaXRlKTtcbiAgICAgICAgeUF4aXNUaXRsZS5zZXRBdHRyaWJ1dGUoJ3gnLCB4LnhQb3MgLSAoeUF4aXNPcHBvc2l0ZSA/IDEwIDogMCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeUF4aXNUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdGl0bGVSb3RhdGluZ0NlbnRlciA9IGdyYXBoaWNzLnJvdGF0ZUFyb3VuZENlbnRlcih5QXhpc1RpdGxlKTtcblxuICAgICAgICBpZiAoIXlBeGlzT3Bwb3NpdGUpIHtcbiAgICAgICAgICB5QXhpc1RpdGxlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJyb3RhdGUoLVwiLmNvbmNhdCh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnRpdGxlLnJvdGF0ZSwgXCIgXCIpLmNvbmNhdCh0aXRsZVJvdGF0aW5nQ2VudGVyLngsIFwiIFwiKS5jb25jYXQodGl0bGVSb3RhdGluZ0NlbnRlci55LCBcIilcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlBeGlzVGl0bGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBcInJvdGF0ZShcIi5jb25jYXQody5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5yb3RhdGUsIFwiIFwiKS5jb25jYXQodGl0bGVSb3RhdGluZ0NlbnRlci54LCBcIiBcIikuY29uY2F0KHRpdGxlUm90YXRpbmdDZW50ZXIueSwgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4UGFkZGluZ0ZvcllBeGlzVGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geFBhZGRpbmdGb3JZQXhpc1RpdGxlKHJlYWxJbmRleCwgeUF4aXNMYWJlbHNDb29yZCwgeUF4aXNUaXRsZUNvb3JkLCB5QXhpc09wcG9zaXRlKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBvcHBvc2l0ZUF4aXNDb3VudCA9IDA7XG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgcGFkZCA9IDEwO1xuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS50ZXh0ID09PSB1bmRlZmluZWQgfHwgcmVhbEluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHhQb3M6IHgsXG4gICAgICAgICAgcGFkZDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoeUF4aXNPcHBvc2l0ZSkge1xuICAgICAgICB4ID0geUF4aXNMYWJlbHNDb29yZC53aWR0aCArIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0udGl0bGUub2Zmc2V0WCArIHlBeGlzVGl0bGVDb29yZC53aWR0aCAvIDIgKyBwYWRkIC8gMjtcbiAgICAgICAgb3Bwb3NpdGVBeGlzQ291bnQgKz0gMTtcblxuICAgICAgICBpZiAob3Bwb3NpdGVBeGlzQ291bnQgPT09IDApIHtcbiAgICAgICAgICB4ID0geCAtIHBhZGQgLyAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geUF4aXNMYWJlbHNDb29yZC53aWR0aCAqIC0xICsgdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5vZmZzZXRYICsgcGFkZCAvIDIgKyB5QXhpc1RpdGxlQ29vcmQud2lkdGggLyAyO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgIHBhZGQgPSAyNTtcbiAgICAgICAgICB4ID0geUF4aXNMYWJlbHNDb29yZC53aWR0aCAqIC0xIC0gdy5jb25maWcueWF4aXNbcmVhbEluZGV4XS50aXRsZS5vZmZzZXRYIC0gcGFkZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4UG9zOiB4LFxuICAgICAgICBwYWRkOiBwYWRkXG4gICAgICB9O1xuICAgIH0gLy8gc2V0cyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgeS1heGlzIGJ5IGNvdW50aW5nIHRoZSBsYWJlbHMgd2lkdGgsIHRpdGxlIHdpZHRoIGFuZCBhbnkgb2Zmc2V0XG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRZQXhpc1hQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRZQXhpc1hQb3NpdGlvbih5YXhpc0xhYmVsQ29vcmRzLCB5VGl0bGVDb29yZHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHhMZWZ0ID0gMDtcbiAgICAgIHZhciB4UmlnaHQgPSAwO1xuICAgICAgdmFyIGxlZnRPZmZzZXRYID0gMjE7XG4gICAgICB2YXIgcmlnaHRPZmZzZXRYID0gMTtcblxuICAgICAgaWYgKHcuY29uZmlnLnlheGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5tdWx0aXBsZVlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICB2YXIgc2hvdWxkTm90RHJhd0F4aXMgPSB3Lmdsb2JhbHMuaWdub3JlWUF4aXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID4gLTEgfHwgIXlheGUuc2hvdyB8fCB5YXhlLmZsb2F0aW5nIHx8IHlheGlzTGFiZWxDb29yZHNbaW5kZXhdLndpZHRoID09PSAwO1xuICAgICAgICB2YXIgYXhpc1dpZHRoID0geWF4aXNMYWJlbENvb3Jkc1tpbmRleF0ud2lkdGggKyB5VGl0bGVDb29yZHNbaW5kZXhdLndpZHRoO1xuXG4gICAgICAgIGlmICgheWF4ZS5vcHBvc2l0ZSkge1xuICAgICAgICAgIHhMZWZ0ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVggLSBsZWZ0T2Zmc2V0WDtcblxuICAgICAgICAgIGlmICghc2hvdWxkTm90RHJhd0F4aXMpIHtcbiAgICAgICAgICAgIGxlZnRPZmZzZXRYID0gbGVmdE9mZnNldFggKyBheGlzV2lkdGggKyAyMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMudHJhbnNsYXRlWUF4aXNYW2luZGV4XSA9IHhMZWZ0ICsgeWF4ZS5sYWJlbHMub2Zmc2V0WDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoX3RoaXMuaXNCYXJIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB4UmlnaHQgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVggLSAxO1xuICAgICAgICAgICAgdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtpbmRleF0gPSB4UmlnaHQgLSB5YXhlLmxhYmVscy5vZmZzZXRYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4UmlnaHQgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVggKyByaWdodE9mZnNldFg7XG5cbiAgICAgICAgICAgIGlmICghc2hvdWxkTm90RHJhd0F4aXMpIHtcbiAgICAgICAgICAgICAgcmlnaHRPZmZzZXRYID0gcmlnaHRPZmZzZXRYICsgYXhpc1dpZHRoICsgMjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHcuZ2xvYmFscy50cmFuc2xhdGVZQXhpc1hbaW5kZXhdID0geFJpZ2h0IC0geWF4ZS5sYWJlbHMub2Zmc2V0WCArIDIwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFlBeGlzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgRm9ybWF0dGVyIENsYXNzIGZvciBzZXR0aW5nIHZhbHVlIGZvcm1hdHRlcnMgZm9yIGF4ZXMgYXMgd2VsbCBhcyB0b29sdGlwcy5cbiAqXG4gKiBAbW9kdWxlIEZvcm1hdHRlcnNcbiAqKi9cblxudmFyIEZvcm1hdHRlcnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb3JtYXR0ZXJzKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtYXR0ZXJzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMudG9vbHRpcEtleUZvcm1hdCA9ICdkZCBNTU0nO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvcm1hdHRlcnMsIFt7XG4gICAga2V5OiBcInhMYWJlbEZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB4TGFiZWxGb3JtYXQoZm4sIHZhbCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgIC8vIGlmIHVzZXIgaGFzIG5vdCBzcGVjaWZpZWQgYSBjdXN0b20gZm9ybWF0dGVyLCB1c2UgdGhlIGRlZmF1bHQgdG9vbHRpcC54LmZvcm1hdFxuICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC54LmZvcm1hdHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGRhdGV0aW1lT2JqID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcbiAgICAgICAgICByZXR1cm4gZGF0ZXRpbWVPYmouZm9ybWF0RGF0ZShuZXcgRGF0ZSh2YWwpLCB3LmNvbmZpZy50b29sdGlwLnguZm9ybWF0LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4odmFsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TGFiZWxGb3JtYXR0ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExhYmVsRm9ybWF0dGVycygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICB3Lmdsb2JhbHMueExhYmVsRm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcblxuICAgICAgdy5nbG9iYWxzLnhheGlzVG9vbHRpcEZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH07XG5cbiAgICAgIHcuZ2xvYmFscy50dEtleUZvcm1hdHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH07XG5cbiAgICAgIHcuZ2xvYmFscy50dFpGb3JtYXR0ZXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9O1xuXG4gICAgICB3Lmdsb2JhbHMubGVnZW5kRm9ybWF0dGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy50b29sdGlwLnguZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHcuZ2xvYmFscy50dEtleUZvcm1hdHRlciA9IHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcueGF4aXMudG9vbHRpcC5mb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdy5nbG9iYWxzLnhheGlzVG9vbHRpcEZvcm1hdHRlciA9IHcuY29uZmlnLnhheGlzLnRvb2x0aXAuZm9ybWF0dGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh3LmNvbmZpZy50b29sdGlwLnkpKSB7XG4gICAgICAgIHcuZ2xvYmFscy50dFZhbCA9IHcuY29uZmlnLnRvb2x0aXAueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLnkuZm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB3Lmdsb2JhbHMudHRWYWwgPSB3LmNvbmZpZy50b29sdGlwLnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAuei5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMudHRaRm9ybWF0dGVyID0gdy5jb25maWcudG9vbHRpcC56LmZvcm1hdHRlcjtcbiAgICAgIH0gLy8gbGVnZW5kIGZvcm1hdHRlciAtIGlmIHVzZXIgd2FudHMgdG8gYXBwZW5kIGFueSBnbG9iYWwgdmFsdWVzIG9mIHNlcmllcyB0byBsZWdlbmQgdGV4dFxuXG5cbiAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQuZm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdy5nbG9iYWxzLmxlZ2VuZEZvcm1hdHRlciA9IHcuY29uZmlnLmxlZ2VuZC5mb3JtYXR0ZXI7XG4gICAgICB9IC8vIGZvcm1hdHRlciBmdW5jdGlvbiB3aWxsIGFsd2F5cyBvdmVyd3JpdGUgZm9ybWF0IHByb3BlcnR5XG5cblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmxhYmVscy5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMueExhYmVsRm9ybWF0dGVyID0gdy5jb25maWcueGF4aXMubGFiZWxzLmZvcm1hdHRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXIgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICAgIC8vIG51bWVyaWMgeGF4aXMgbWF5IGhhdmUgc21hbGxlciByYW5nZSwgc28gZGVmYXVsdGluZyB0byAxIGRlY2ltYWxcbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50eXBlID09PSAnbnVtZXJpYycgJiYgdy5nbG9iYWxzLmRhdGFQb2ludHMgPCA1MCkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsLnRvRml4ZWQoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfSAvLyBmb3JtYXR0ZXIgZnVuY3Rpb24gd2lsbCBhbHdheXMgb3ZlcndyaXRlIGZvcm1hdCBwcm9wZXJ0eVxuXG5cbiAgICAgIHcuY29uZmlnLnlheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGkpIHtcbiAgICAgICAgaWYgKHlheGUubGFiZWxzLmZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbaV0gPSB5YXhlLmxhYmVscy5mb3JtYXR0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbaV0gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIodmFsKSkge1xuICAgICAgICAgICAgICBpZiAody5nbG9iYWxzLnlWYWx1ZURlY2ltYWwgIT09IDAgfHwgdy5nbG9iYWxzLm1heFkgLSB3Lmdsb2JhbHMubWluWSA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnRvRml4ZWQoeWF4ZS5kZWNpbWFsc0luRmxvYXQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwudG9GaXhlZCgwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHcuZ2xvYmFscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGVhdG1hcExhYmVsRm9ybWF0dGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWF0bWFwTGFiZWxGb3JtYXR0ZXJzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ucmVzdWx0ID0gdy5nbG9iYWxzLnNlcmllc05hbWVzLnNsaWNlKCk7IC8vICBnZXQgdGhlIGxvbmdlc3Qgc3RyaW5nIGZyb20gdGhlIGxhYmVscyBhcnJheSBhbmQgYWxzbyBhcHBseSBsYWJlbCBmb3JtYXR0ZXIgdG8gaXRcblxuICAgICAgICB2YXIgbG9uZ2VzdCA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgdy5nbG9iYWxzLnlBeGlzU2NhbGVbMF0ubmljZU1heCA9IGxvbmdlc3Q7XG4gICAgICAgIHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLm5pY2VNaW4gPSBsb25nZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JtYXR0ZXJzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgWEF4aXMgQ2xhc3MgZm9yIGRyYXdpbmcgWC1BeGlzLlxuICpcbiAqIEBtb2R1bGUgWEF4aXNcbiAqKi9cblxudmFyIFhBeGlzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEF4aXMoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhBeGlzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHRoaXMueGF4aXNMYWJlbHMgPSB3Lmdsb2JhbHMubGFiZWxzLnNsaWNlKCk7XG5cbiAgICBpZiAody5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vICB0aW1lbGluZSBsYWJlbHMgYXJlIHRoZXJlXG4gICAgICB0aGlzLnhheGlzTGFiZWxzID0gdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3bkxhYmVscyA9IFtdO1xuXG4gICAgaWYgKHcuY29uZmlnLnhheGlzLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgdGhpcy5vZmZZID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vZmZZID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgKyAxO1xuICAgIH1cblxuICAgIHRoaXMub2ZmWSA9IHRoaXMub2ZmWSArIHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXIub2Zmc2V0WTtcbiAgICB0aGlzLnhheGlzRm9udFNpemUgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udFNpemU7XG4gICAgdGhpcy54YXhpc0ZvbnRGYW1pbHkgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udEZhbWlseTtcbiAgICB0aGlzLnhheGlzRm9yZUNvbG9ycyA9IHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5jb2xvcnM7XG4gICAgdGhpcy54YXhpc0JvcmRlcldpZHRoID0gdy5jb25maWcueGF4aXMuYXhpc0JvcmRlci53aWR0aDtcblxuICAgIGlmICh0aGlzLnhheGlzQm9yZGVyV2lkdGguaW5kZXhPZignJScpID4gLTEpIHtcbiAgICAgIHRoaXMueGF4aXNCb3JkZXJXaWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggKiBwYXJzZUludCh0aGlzLnhheGlzQm9yZGVyV2lkdGgpIC8gMTAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnhheGlzQm9yZGVyV2lkdGggPSBwYXJzZUludCh0aGlzLnhheGlzQm9yZGVyV2lkdGgpO1xuICAgIH1cblxuICAgIHRoaXMueGF4aXNCb3JkZXJIZWlnaHQgPSB3LmNvbmZpZy54YXhpcy5heGlzQm9yZGVyLmhlaWdodDsgLy8gRm9yIGJhcnMsIHdlIHdpbGwgb25seSBjb25zaWRlciBzaW5nbGUgeSB4YWlzLFxuICAgIC8vIGFzIHdlIGFyZSBub3QgcHJvdmlkaW5nIG11bHRpcGxlIHlheGlzIGZvciBiYXIgY2hhcnRzXG5cbiAgICB0aGlzLnlheGlzID0gdy5jb25maWcueWF4aXNbMF07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWEF4aXMsIFt7XG4gICAga2V5OiBcImRyYXdYYXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3WGF4aXMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgZWxYYXhpcyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQody5jb25maWcueGF4aXMub2Zmc2V0WCwgXCIsIFwiKS5jb25jYXQody5jb25maWcueGF4aXMub2Zmc2V0WSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIHZhciBlbFhheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWCwgXCIsIFwiKS5jb25jYXQody5nbG9iYWxzLnRyYW5zbGF0ZVhBeGlzWSwgXCIpXCIpXG4gICAgICB9KTtcbiAgICAgIGVsWGF4aXMuYWRkKGVsWGF4aXNUZXh0cyk7XG4gICAgICB2YXIgY29sV2lkdGg7IC8vIGluaXRpYWwgeCBQb3NpdGlvbiAoa2VlcCBhZGRpbmcgY29sdW1uIHdpZHRoIGluIHRoZSBsb29wKVxuXG4gICAgICB2YXIgeFBvcyA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsO1xuICAgICAgdmFyIGxhYmVscyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMueGF4aXNMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGFiZWxzLnB1c2godGhpcy54YXhpc0xhYmVsc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICBjb2xXaWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAobGFiZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgICB4UG9zID0geFBvcyArIGNvbFdpZHRoIC8gMiArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sV2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgeFBvcyA9IHhQb3MgKyBjb2xXaWR0aCArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYO1xuICAgICAgfVxuXG4gICAgICB2YXIgeGxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnhMYWJlbEZvcm1hdHRlcjtcbiAgICAgIHZhciBjdXN0b21Gb3JtYXR0ZXIgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyO1xuICAgICAgdmFyIGxhYmVsc0xlbiA9IGxhYmVscy5sZW5ndGg7XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMuc2hvdykge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDw9IGxhYmVsc0xlbiAtIDE7IF9pKyspIHtcbiAgICAgICAgICB2YXIgcmF3TGFiZWwgPSB0eXBlb2YgbGFiZWxzW19pXSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IGxhYmVsc1tfaV07XG4gICAgICAgICAgdmFyIGxhYmVsID0gdm9pZCAwO1xuICAgICAgICAgIHZhciB4Rm9ybWF0ID0gbmV3IEZvcm1hdHRlcnModGhpcy5jdHgpO1xuICAgICAgICAgIGxhYmVsID0geEZvcm1hdC54TGFiZWxGb3JtYXQoeGxiRm9ybWF0dGVyLCByYXdMYWJlbCk7XG5cbiAgICAgICAgICBpZiAoY3VzdG9tRm9ybWF0dGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhYmVsID0gY3VzdG9tRm9ybWF0dGVyKHJhd0xhYmVsLCB0aGlzLnhheGlzTGFiZWxzW19pXSwgX2kpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB4ID0geFBvcyAtIGNvbFdpZHRoIC8gMiArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYO1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB4ID0gdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzW19pXS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxhYmVsID0gdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzW19pXS52YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScgJiYgY3VzdG9tRm9ybWF0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGFiZWwgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGxhYmVsID09PSAndW5kZWZpbmVkJykgbGFiZWwgPSAnJztcbiAgICAgICAgICBsYWJlbCA9IGxhYmVsLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICBpZiAobGFiZWwuaW5kZXhPZignTmFOJykgPT09IDAgfHwgbGFiZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdpbnZhbGlkJykgPT09IDAgfHwgbGFiZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdpbmZpbml0eScpID49IDAgfHwgdGhpcy5kcmF3bkxhYmVscy5pbmRleE9mKGxhYmVsKSA+PSAwICYmICF3LmNvbmZpZy54YXhpcy5sYWJlbHMuc2hvd0R1cGxpY2F0ZXMpIHtcbiAgICAgICAgICAgIGxhYmVsID0gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kcmF3bkxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgICB2YXIgb2Zmc2V0WUNvcnJlY3Rpb24gPSAyODtcblxuICAgICAgICAgIGlmICh3Lmdsb2JhbHMucm90YXRlWExhYmVscykge1xuICAgICAgICAgICAgb2Zmc2V0WUNvcnJlY3Rpb24gPSAyMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZWxUaWNrID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHRoaXMub2ZmWSArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRZICsgb2Zmc2V0WUNvcnJlY3Rpb24sXG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgZm9udFNpemU6IHRoaXMueGF4aXNGb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHRoaXMueGF4aXNGb250RmFtaWx5LFxuICAgICAgICAgICAgZm9yZUNvbG9yOiBBcnJheS5pc0FycmF5KHRoaXMueGF4aXNGb3JlQ29sb3JzKSA/IHRoaXMueGF4aXNGb3JlQ29sb3JzW19pXSA6IHRoaXMueGF4aXNGb3JlQ29sb3JzLFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLWxhYmVsICcgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuY3NzQ2xhc3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbFhheGlzVGV4dHMuYWRkKGVsVGljayk7XG4gICAgICAgICAgZ3JhcGhpY3MuYWRkVHNwYW4oZWxUaWNrLCBsYWJlbCwgdGhpcy54YXhpc0ZvbnRGYW1pbHkpO1xuICAgICAgICAgIHZhciBlbFRvb2x0aXBUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh3Lmdsb2JhbHMuU1ZHTlMsICd0aXRsZScpO1xuICAgICAgICAgIGVsVG9vbHRpcFRpdGxlLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgICAgICAgZWxUaWNrLm5vZGUuYXBwZW5kQ2hpbGQoZWxUb29sdGlwVGl0bGUpO1xuICAgICAgICAgIHhQb3MgPSB4UG9zICsgY29sV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnRpdGxlLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZWxYYXhpc1RpdGxlID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy14YXhpcy10aXRsZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbFhBeGlzVGl0bGVUZXh0ID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgIHg6IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyICsgdy5jb25maWcueGF4aXMudGl0bGUub2Zmc2V0WCxcbiAgICAgICAgICB5OiB0aGlzLm9mZlkgLSBwYXJzZUludCh0aGlzLnhheGlzRm9udFNpemUpICsgdy5nbG9iYWxzLnhBeGlzTGFiZWxzSGVpZ2h0ICsgdy5jb25maWcueGF4aXMudGl0bGUub2Zmc2V0WSxcbiAgICAgICAgICB0ZXh0OiB3LmNvbmZpZy54YXhpcy50aXRsZS50ZXh0LFxuICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgIGZvbnRTaXplOiB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiB3LmNvbmZpZy54YXhpcy50aXRsZS5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGZvcmVDb2xvcjogdy5jb25maWcueGF4aXMudGl0bGUuc3R5bGUuY29sb3IsXG4gICAgICAgICAgY3NzQ2xhc3M6ICdhcGV4Y2hhcnRzLXhheGlzLXRpdGxlLXRleHQgJyArIHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmNzc0NsYXNzXG4gICAgICAgIH0pO1xuICAgICAgICBlbFhheGlzVGl0bGUuYWRkKGVsWEF4aXNUaXRsZVRleHQpO1xuICAgICAgICBlbFhheGlzLmFkZChlbFhheGlzVGl0bGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMuYXhpc0JvcmRlci5zaG93KSB7XG4gICAgICAgIHZhciBsaW5lQ29ycmVjdGlvbiA9IDA7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgICAgbGluZUNvcnJlY3Rpb24gPSBsaW5lQ29ycmVjdGlvbiAtIDE1O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsSG9yekxpbmUgPSBncmFwaGljcy5kcmF3TGluZSh3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArIGxpbmVDb3JyZWN0aW9uICsgdy5jb25maWcueGF4aXMuYXhpc0JvcmRlci5vZmZzZXRYLCB0aGlzLm9mZlksIHRoaXMueGF4aXNCb3JkZXJXaWR0aCwgdGhpcy5vZmZZLCB3LmNvbmZpZy54YXhpcy5heGlzQm9yZGVyLmNvbG9yLCAwLCB0aGlzLnhheGlzQm9yZGVySGVpZ2h0KTtcbiAgICAgICAgZWxYYXhpcy5hZGQoZWxIb3J6TGluZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbFhheGlzO1xuICAgIH0gLy8gdGhpcyBhY3R1YWxseSBiZWNvbWVzIHRoZSB2ZXJ0aWNhbCBheGlzIChmb3IgYmFyIGNoYXJ0cylcblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdYYXhpc0ludmVyc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYYXhpc0ludmVyc2VkKHJlYWxJbmRleCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHRyYW5zbGF0ZVlBeGlzWCA9IHcuY29uZmlnLnlheGlzWzBdLm9wcG9zaXRlID8gdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtyZWFsSW5kZXhdIDogMDtcbiAgICAgIHZhciBlbFlheGlzID0gZ3JhcGhpY3MuZ3JvdXAoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMgYXBleGNoYXJ0cy14YXhpcy1pbnZlcnNlZCcsXG4gICAgICAgIHJlbDogcmVhbEluZGV4XG4gICAgICB9KTtcbiAgICAgIHZhciBlbFlheGlzVGV4dHMgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy10ZXh0cy1nIGFwZXhjaGFydHMteGF4aXMtaW52ZXJzZWQtdGV4dHMtZycsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgdHJhbnNsYXRlWUF4aXNYICsgJywgMCknXG4gICAgICB9KTtcbiAgICAgIGVsWWF4aXMuYWRkKGVsWWF4aXNUZXh0cyk7XG4gICAgICB2YXIgY29sSGVpZ2h0OyAvLyBpbml0aWFsIHggUG9zaXRpb24gKGtlZXAgYWRkaW5nIGNvbHVtbiB3aWR0aCBpbiB0aGUgbG9vcClcblxuICAgICAgdmFyIHlQb3M7XG4gICAgICB2YXIgbGFiZWxzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy54YXhpc0xhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsYWJlbHMucHVzaCh0aGlzLnhheGlzTGFiZWxzW2ldKTtcbiAgICAgIH1cblxuICAgICAgY29sSGVpZ2h0ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyBsYWJlbHMubGVuZ3RoO1xuICAgICAgeVBvcyA9IC0oY29sSGVpZ2h0IC8gMi4yKTtcbiAgICAgIHZhciBsYkZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdO1xuICAgICAgdmFyIHlsYWJlbHMgPSB3LmNvbmZpZy55YXhpc1swXS5sYWJlbHM7XG5cbiAgICAgIGlmICh5bGFiZWxzLnNob3cpIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDw9IGxhYmVscy5sZW5ndGggLSAxOyBfaTIrKykge1xuICAgICAgICAgIHZhciBsYWJlbCA9IHR5cGVvZiBsYWJlbHNbX2kyXSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IGxhYmVsc1tfaTJdO1xuICAgICAgICAgIGxhYmVsID0gbGJGb3JtYXR0ZXIobGFiZWwpO1xuICAgICAgICAgIHZhciBlbExhYmVsID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgICAgeDogeWxhYmVscy5vZmZzZXRYIC0gMTUsXG4gICAgICAgICAgICB5OiB5UG9zICsgY29sSGVpZ2h0ICsgeWxhYmVscy5vZmZzZXRZLFxuICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiB0aGlzLnlheGlzLm9wcG9zaXRlID8gJ3N0YXJ0JyA6ICdlbmQnLFxuICAgICAgICAgICAgZm9yZUNvbG9yOiB5bGFiZWxzLnN0eWxlLmNvbG9yID8geWxhYmVscy5zdHlsZS5jb2xvciA6IHlsYWJlbHMuc3R5bGUuY29sb3JzW19pMl0sXG4gICAgICAgICAgICBmb250U2l6ZTogeWxhYmVscy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHlsYWJlbHMuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnYXBleGNoYXJ0cy15YXhpcy1sYWJlbCAnICsgeWxhYmVscy5zdHlsZS5jc3NDbGFzc1xuICAgICAgICAgIH0pOyAvLyBsZXQgbGFiZWxSb3RhdGluZ0NlbnRlciA9IGdyYXBoaWNzLnJvdGF0ZUFyb3VuZENlbnRlcihlbExhYmVsLm5vZGUpXG4gICAgICAgICAgLy8gaWYgKHlsYWJlbHMucm90YXRlICE9PSAwKSB7XG4gICAgICAgICAgLy8gICBlbExhYmVsLm5vZGUuc2V0QXR0cmlidXRlKFxuICAgICAgICAgIC8vICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICAvLyAgICAgYHJvdGF0ZSgke3lsYWJlbHMucm90YXRlfSAke2xhYmVsUm90YXRpbmdDZW50ZXIueH0gJHtsYWJlbFJvdGF0aW5nQ2VudGVyLnl9KWBcbiAgICAgICAgICAvLyAgIClcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICBlbFlheGlzVGV4dHMuYWRkKGVsTGFiZWwpO1xuICAgICAgICAgIHlQb3MgPSB5UG9zICsgY29sSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy55YXhpc1swXS50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGVsWGF4aXNUaXRsZSA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGl0bGUgYXBleGNoYXJ0cy14YXhpcy10aXRsZS1pbnZlcnNlZCcsXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyB0cmFuc2xhdGVZQXhpc1ggKyAnLCAwKSdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbFhBeGlzVGl0bGVUZXh0ID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyAyLFxuICAgICAgICAgIHRleHQ6IHcuY29uZmlnLnlheGlzWzBdLnRpdGxlLnRleHQsXG4gICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgZm9yZUNvbG9yOiB3LmNvbmZpZy55YXhpc1swXS50aXRsZS5zdHlsZS5jb2xvcixcbiAgICAgICAgICBmb250U2l6ZTogdy5jb25maWcueWF4aXNbMF0udGl0bGUuc3R5bGUuZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogdy5jb25maWcueWF4aXNbMF0udGl0bGUuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICBjc3NDbGFzczogJ2FwZXhjaGFydHMteWF4aXMtdGl0bGUtdGV4dCAnICsgdy5jb25maWcueWF4aXNbMF0udGl0bGUuc3R5bGUuY3NzQ2xhc3NcbiAgICAgICAgfSk7XG4gICAgICAgIGVsWGF4aXNUaXRsZS5hZGQoZWxYQXhpc1RpdGxlVGV4dCk7XG4gICAgICAgIGVsWWF4aXMuYWRkKGVsWGF4aXNUaXRsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5heGlzQm9yZGVyLnNob3cpIHtcbiAgICAgICAgdmFyIGVsSG9yekxpbmUgPSBncmFwaGljcy5kcmF3TGluZSh3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArIHcuY29uZmlnLnhheGlzLmF4aXNCb3JkZXIub2Zmc2V0WCwgdGhpcy5vZmZZLCB0aGlzLnhheGlzQm9yZGVyV2lkdGgsIHRoaXMub2ZmWSwgdGhpcy55YXhpcy5heGlzQm9yZGVyLmNvbG9yLCAwLCB0aGlzLnhheGlzQm9yZGVySGVpZ2h0KTtcbiAgICAgICAgZWxZYXhpcy5hZGQoZWxIb3J6TGluZSk7IC8vIGxldCB4ID0gdy5nbG9iYWxzLnlBeGlzV2lkdGhzWzBdIC8gMlxuICAgICAgICAvLyBpZiAody5jb25maWcueWF4aXNbMF0ub3Bwb3NpdGUpIHtcbiAgICAgICAgLy8gICB4ID0gLXcuZ2xvYmFscy55QXhpc1dpZHRoc1swXSAvIDJcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHZhciB5YXhpcyA9IG5ldyBZQXhpcyh0aGlzLmN0eCk7XG4gICAgICAgIHlheGlzLmRyYXdBeGlzVGlja3MoMCwgbGFiZWxzLmxlbmd0aCwgdy5jb25maWcueWF4aXNbMF0uYXhpc0JvcmRlciwgdy5jb25maWcueWF4aXNbMF0uYXhpc1RpY2tzLCAwLCBjb2xIZWlnaHQsIGVsWWF4aXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxZYXhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1hheGlzVGlja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1hheGlzVGlja3MoeDEsIGFwcGVuZFRvRWxlbWVudCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeDIgPSB4MTtcbiAgICAgIGlmICh4MSA8IDAgfHwgeDEgPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSByZXR1cm47XG4gICAgICB2YXIgeTEgPSB0aGlzLm9mZlkgKyB3LmNvbmZpZy54YXhpcy5heGlzVGlja3Mub2Zmc2V0WTtcbiAgICAgIHZhciB5MiA9IHkxICsgdy5jb25maWcueGF4aXMuYXhpc1RpY2tzLmhlaWdodDtcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5zaG93KSB7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciBsaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUoeDEgKyB3LmNvbmZpZy54YXhpcy5heGlzVGlja3Mub2Zmc2V0WCwgeTEgKyB3LmNvbmZpZy54YXhpcy5vZmZzZXRZLCB4MiArIHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5vZmZzZXRYLCB5MiArIHcuY29uZmlnLnhheGlzLm9mZnNldFksIHcuY29uZmlnLnhheGlzLmF4aXNUaWNrcy5jb2xvcik7IC8vIHdlIGFyZSBub3QgcmV0dXJuaW5nIGFueXRoaW5nLCBidXQgYXBwZW5kaW5nIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHBhc2VkIGluIHBhcmFtXG5cbiAgICAgICAgYXBwZW5kVG9FbGVtZW50LmFkZChsaW5lKTtcbiAgICAgICAgbGluZS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMteGF4aXMtdGljaycpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRYQXhpc1RpY2tzUG9zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFhBeGlzVGlja3NQb3NpdGlvbnMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4QXhpc1RpY2tzUG9zaXRpb25zID0gW107XG4gICAgICB2YXIgeENvdW50ID0gdGhpcy54YXhpc0xhYmVscy5sZW5ndGg7XG4gICAgICB2YXIgeDEgPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeENvdW50OyBpKyspIHtcbiAgICAgICAgICB4MSA9IHRoaXMueGF4aXNMYWJlbHNbaV0ucG9zaXRpb247XG4gICAgICAgICAgeEF4aXNUaWNrc1Bvc2l0aW9ucy5wdXNoKHgxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHhDb3VudEZvckNhdGVnb3J5Q2hhcnRzID0geENvdW50O1xuXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHhDb3VudEZvckNhdGVnb3J5Q2hhcnRzOyBfaTMrKykge1xuICAgICAgICAgIHZhciB4MUNvdW50ID0geENvdW50Rm9yQ2F0ZWdvcnlDaGFydHM7XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMgJiYgdy5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2JhcicpIHtcbiAgICAgICAgICAgIHgxQ291bnQgLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MSA9IHgxICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHgxQ291bnQ7XG4gICAgICAgICAgeEF4aXNUaWNrc1Bvc2l0aW9ucy5wdXNoKHgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geEF4aXNUaWNrc1Bvc2l0aW9ucztcbiAgICB9IC8vIHRvIHJvdGF0ZSB4LWF4aXMgbGFiZWxzIG9yIHRvIHB1dCAuLi4gZm9yIGxvbmdlciB0ZXh0IGluIHhheGlzXG5cbiAgfSwge1xuICAgIGtleTogXCJ4QXhpc0xhYmVsQ29ycmVjdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geEF4aXNMYWJlbENvcnJlY3Rpb25zKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHhBeGlzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteGF4aXMtdGV4dHMtZycpO1xuICAgICAgdmFyIHhBeGlzVGV4dHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy14YXhpcy10ZXh0cy1nIHRleHQnKTtcbiAgICAgIHZhciB5QXhpc1RleHRzSW52ZXJzZWQgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy15YXhpcy1pbnZlcnNlZCB0ZXh0Jyk7XG4gICAgICB2YXIgeEF4aXNUZXh0c0ludmVyc2VkID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMteGF4aXMtaW52ZXJzZWQtdGV4dHMtZyB0ZXh0Jyk7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMucm90YXRlWExhYmVscyB8fCB3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlQWx3YXlzKSB7XG4gICAgICAgIGZvciAodmFyIHhhdCA9IDA7IHhhdCA8IHhBeGlzVGV4dHMubGVuZ3RoOyB4YXQrKykge1xuICAgICAgICAgIHZhciB0ZXh0Um90YXRpbmdDZW50ZXIgPSBncmFwaGljcy5yb3RhdGVBcm91bmRDZW50ZXIoeEF4aXNUZXh0c1t4YXRdKTtcbiAgICAgICAgICB0ZXh0Um90YXRpbmdDZW50ZXIueSA9IHRleHRSb3RhdGluZ0NlbnRlci55IC0gMTsgLy8gKyB0aWNrV2lkdGgvNDtcblxuICAgICAgICAgIHRleHRSb3RhdGluZ0NlbnRlci54ID0gdGV4dFJvdGF0aW5nQ2VudGVyLnggKyAxO1xuICAgICAgICAgIHhBeGlzVGV4dHNbeGF0XS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwicm90YXRlKFwiLmNvbmNhdCh3LmNvbmZpZy54YXhpcy5sYWJlbHMucm90YXRlLCBcIiBcIikuY29uY2F0KHRleHRSb3RhdGluZ0NlbnRlci54LCBcIiBcIikuY29uY2F0KHRleHRSb3RhdGluZ0NlbnRlci55LCBcIilcIikpO1xuICAgICAgICAgIHhBeGlzVGV4dHNbeGF0XS5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgXCJlbmRcIik7XG4gICAgICAgICAgdmFyIG9mZnNldEhlaWdodCA9IDEwO1xuICAgICAgICAgIHhBeGlzLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgXCJ0cmFuc2xhdGUoMCwgXCIuY29uY2F0KC1vZmZzZXRIZWlnaHQsIFwiKVwiKSk7XG4gICAgICAgICAgdmFyIHRTcGFuID0geEF4aXNUZXh0c1t4YXRdLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBpZiAody5jb25maWcueGF4aXMubGFiZWxzLnRyaW0pIHtcbiAgICAgICAgICAgIGdyYXBoaWNzLnBsYWNlVGV4dFdpdGhFbGxpcHNpcyh0U3BhblswXSwgdFNwYW5bMF0udGV4dENvbnRlbnQsIHcuY29uZmlnLnhheGlzLmxhYmVscy5tYXhIZWlnaHQgLSA0MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgd2lkdGggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gdy5nbG9iYWxzLmxhYmVscy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgX3hhdCA9IDA7IF94YXQgPCB4QXhpc1RleHRzLmxlbmd0aDsgX3hhdCsrKSB7XG4gICAgICAgICAgdmFyIF90U3BhbiA9IHhBeGlzVGV4dHNbX3hhdF0uY2hpbGROb2RlcztcblxuICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMudHJpbSAmJiB3LmNvbmZpZy5jaGFydC50eXBlICE9PSAnYmFyJyAmJiB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgZ3JhcGhpY3MucGxhY2VUZXh0V2l0aEVsbGlwc2lzKF90U3BhblswXSwgX3RTcGFuWzBdLnRleHRDb250ZW50LCB3aWR0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh5QXhpc1RleHRzSW52ZXJzZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyB0cnVuY2F0ZSByb3RhdGVkIHkgYXhpcyBpbiBiYXIgY2hhcnQgKHggYXhpcylcbiAgICAgICAgdmFyIGZpcnN0TGFiZWxQb3NYID0geUF4aXNUZXh0c0ludmVyc2VkW3lBeGlzVGV4dHNJbnZlcnNlZC5sZW5ndGggLSAxXS5nZXRCQm94KCk7XG4gICAgICAgIHZhciBsYXN0TGFiZWxQb3NYID0geUF4aXNUZXh0c0ludmVyc2VkWzBdLmdldEJCb3goKTtcblxuICAgICAgICBpZiAoZmlyc3RMYWJlbFBvc1gueCA8IC0yMCkge1xuICAgICAgICAgIHlBeGlzVGV4dHNJbnZlcnNlZFt5QXhpc1RleHRzSW52ZXJzZWQubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh5QXhpc1RleHRzSW52ZXJzZWRbeUF4aXNUZXh0c0ludmVyc2VkLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0TGFiZWxQb3NYLnggKyBsYXN0TGFiZWxQb3NYLndpZHRoID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkge1xuICAgICAgICAgIHlBeGlzVGV4dHNJbnZlcnNlZFswXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHlBeGlzVGV4dHNJbnZlcnNlZFswXSk7XG4gICAgICAgIH0gLy8gdHJ1bmNhdGUgcm90YXRlZCB4IGF4aXMgaW4gYmFyIGNoYXJ0ICh5IGF4aXMpXG5cblxuICAgICAgICBmb3IgKHZhciBfeGF0MiA9IDA7IF94YXQyIDwgeEF4aXNUZXh0c0ludmVyc2VkLmxlbmd0aDsgX3hhdDIrKykge1xuICAgICAgICAgIGdyYXBoaWNzLnBsYWNlVGV4dFdpdGhFbGxpcHNpcyh4QXhpc1RleHRzSW52ZXJzZWRbX3hhdDJdLCB4QXhpc1RleHRzSW52ZXJzZWRbX3hhdDJdLnRleHRDb250ZW50LCB3LmNvbmZpZy55YXhpc1swXS5sYWJlbHMubWF4V2lkdGggLSBwYXJzZUludCh3LmNvbmZpZy55YXhpc1swXS50aXRsZS5zdHlsZS5mb250U2l6ZSkgKiAyIC0gMjApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyByZW5kZXJYQXhpc0JhbmRzKCkge1xuICAgIC8vICAgbGV0IHcgPSB0aGlzLnc7XG4gICAgLy8gICBsZXQgcGxvdEJhbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMody5nbG9iYWxzLlNWR05TLCAncmVjdCcpXG4gICAgLy8gICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZChwbG90QmFuZClcbiAgICAvLyB9XG5cbiAgfV0pO1xuXG4gIHJldHVybiBYQXhpcztcbn0oKTtcblxudmFyIFJhbmdlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmFuZ2UoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMuaXNCYXJIb3Jpem9udGFsID0gISEodGhpcy53LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsKTtcbiAgfSAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMyNjY3OS9jaG9vc2luZy1hbi1hdHRyYWN0aXZlLWxpbmVhci1zY2FsZS1mb3ItYS1ncmFwaHMteS1heGlzc1xuICAvLyBUaGlzIHJvdXRpbmUgY3JlYXRlcyB0aGUgWSBheGlzIHZhbHVlcyBmb3IgYSBncmFwaC5cblxuXG4gIF9jcmVhdGVDbGFzcyhSYW5nZSwgW3tcbiAgICBrZXk6IFwibmljZVNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5pY2VTY2FsZSh5TWluLCB5TWF4KSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICB2YXIgdGlja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDEwO1xuXG4gICAgICBpZiAoeU1pbiA9PT0gTnVtYmVyLk1JTl9WQUxVRSAmJiB5TWF4ID09PSAwIHx8ICFVdGlscy5pc051bWJlcih5TWluKSAmJiAhVXRpbHMuaXNOdW1iZXIoeU1heCkgfHwgeU1pbiA9PT0gTnVtYmVyLk1JTl9WQUxVRSAmJiB5TWF4ID09PSAtTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAvLyB3aGVuIGFsbCB2YWx1ZXMgYXJlIDBcbiAgICAgICAgeU1pbiA9IDA7XG4gICAgICAgIHlNYXggPSB0aWNrcztcbiAgICAgICAgdmFyIGxpbmVhclNjYWxlID0gdGhpcy5saW5lYXJTY2FsZSh5TWluLCB5TWF4LCB0aWNrcyk7XG4gICAgICAgIHJldHVybiBsaW5lYXJTY2FsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHlNaW4gPiB5TWF4KSB7XG4gICAgICAgIC8vIGlmIHNvbWVob3cgZHVlIHRvIHNvbWUgd3JvbmcgY29uZmlnLCB1c2VyIHNlbnQgbWF4IGxlc3MgdGhhbiBtaW4sXG4gICAgICAgIC8vIGFkanVzdCB0aGUgbWluL21heCBhZ2FpblxuICAgICAgICBjb25zb2xlLndhcm4oJ3lheGlzLm1pbiBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIHlheGlzLm1heCcpO1xuICAgICAgICB5TWF4ID0geU1pbiArIDAuMTtcbiAgICAgIH0gZWxzZSBpZiAoeU1pbiA9PT0geU1heCkge1xuICAgICAgICAvLyBJZiB5TWluIGFuZCB5TWF4IGFyZSBpZGVudGljYWwsIHRoZW5cbiAgICAgICAgLy8gYWRqdXN0IHRoZSB5TWluIGFuZCB5TWF4IHZhbHVlcyB0byBhY3R1YWxseVxuICAgICAgICAvLyBtYWtlIGEgZ3JhcGguIEFsc28gYXZvaWRzIGRpdmlzaW9uIGJ5IHplcm8gZXJyb3JzLlxuICAgICAgICB5TWluID0geU1pbiA9PT0gMCA/IDAgOiB5TWluIC0gMC4xOyAvLyBzb21lIHNtYWxsIHZhbHVlXG5cbiAgICAgICAgeU1heCA9IHlNYXggPT09IDAgPyAyIDogeU1heCArIDAuMTsgLy8gc29tZSBzbWFsbCB2YWx1ZVxuICAgICAgfSAvLyBDYWxjdWxhdGUgTWluIGFtZCBNYXggZ3JhcGhpY2FsIGxhYmVscyBhbmQgZ3JhcGhcbiAgICAgIC8vIGluY3JlbWVudHMuICBUaGUgbnVtYmVyIG9mIHRpY2tzIGRlZmF1bHRzIHRvXG4gICAgICAvLyAxMCB3aGljaCBpcyB0aGUgU1VHR0VTVEVEIHZhbHVlLiAgQW55IHRpY2sgdmFsdWVcbiAgICAgIC8vIGVudGVyZWQgaXMgdXNlZCBhcyBhIHN1Z2dlc3RlZCB2YWx1ZSB3aGljaCBpc1xuICAgICAgLy8gYWRqdXN0ZWQgdG8gYmUgYSAncHJldHR5JyB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICAvLyBPdXRwdXQgd2lsbCBiZSBhbiBhcnJheSBvZiB0aGUgWSBheGlzIHZhbHVlcyB0aGF0XG4gICAgICAvLyBlbmNvbXBhc3MgdGhlIFkgdmFsdWVzLlxuXG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTsgLy8gRGV0ZXJtaW5lIFJhbmdlXG5cbiAgICAgIHZhciByYW5nZSA9IHlNYXggLSB5TWluO1xuICAgICAgdmFyIHRpa3MgPSB0aWNrcyArIDE7IC8vIEFkanVzdCB0aWNrcyBpZiBuZWVkZWRcblxuICAgICAgaWYgKHRpa3MgPCAyKSB7XG4gICAgICAgIHRpa3MgPSAyO1xuICAgICAgfSBlbHNlIGlmICh0aWtzID4gMikge1xuICAgICAgICB0aWtzIC09IDI7XG4gICAgICB9IC8vIEdldCByYXcgc3RlcCB2YWx1ZVxuXG5cbiAgICAgIHZhciB0ZW1wU3RlcCA9IHJhbmdlIC8gdGlrczsgLy8gQ2FsY3VsYXRlIHByZXR0eSBzdGVwIHZhbHVlXG5cbiAgICAgIHZhciBtYWcgPSBNYXRoLmZsb29yKFV0aWxzLmxvZzEwKHRlbXBTdGVwKSk7XG4gICAgICB2YXIgbWFnUG93ID0gTWF0aC5wb3coMTAsIG1hZyk7XG4gICAgICB2YXIgbWFnTXNkID0gcGFyc2VJbnQodGVtcFN0ZXAgLyBtYWdQb3cpO1xuICAgICAgdmFyIHN0ZXBTaXplID0gbWFnTXNkICogbWFnUG93OyAvLyBidWlsZCBZIGxhYmVsIGFycmF5LlxuICAgICAgLy8gTG93ZXIgYW5kIHVwcGVyIGJvdW5kcyBjYWxjdWxhdGlvbnNcblxuICAgICAgdmFyIGxiID0gc3RlcFNpemUgKiBNYXRoLmZsb29yKHlNaW4gLyBzdGVwU2l6ZSk7XG4gICAgICB2YXIgdWIgPSBzdGVwU2l6ZSAqIE1hdGguY2VpbCh5TWF4IC8gc3RlcFNpemUpOyAvLyBCdWlsZCBhcnJheVxuXG4gICAgICB2YXIgdmFsID0gbGI7XG5cbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICAgIHZhbCArPSBzdGVwU2l6ZTtcblxuICAgICAgICBpZiAodmFsID4gdWIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBUT0RPOiBuZWVkIHRvIHJlbW92ZSB0aGlzIGNvbmRpdGlvbiBiZWxvdyB3aGljaCBtYWtlcyB0aGlzIGZ1bmN0aW9uIHRpZ2h0bHkgY291cGxlZCB3aXRoIHcuXG5cblxuICAgICAgaWYgKHRoaXMudy5jb25maWcueWF4aXNbaW5kZXhdLm1heCA9PT0gdW5kZWZpbmVkICYmIHRoaXMudy5jb25maWcueWF4aXNbaW5kZXhdLm1pbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudy5jb25maWcueWF4aXNbaW5kZXhdLmZvcmNlTmljZVNjYWxlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgbmljZU1pbjogcmVzdWx0WzBdLFxuICAgICAgICAgIG5pY2VNYXg6IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgdiA9IHlNaW47XG4gICAgICAgIHJlc3VsdC5wdXNoKHYpO1xuICAgICAgICB2YXIgdmFsdWVzRGl2aWRlciA9IE1hdGguYWJzKHlNYXggLSB5TWluKSAvIHRpY2tzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHRpY2tzIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdiA9IHYgKyB2YWx1ZXNEaXZpZGVyO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICBuaWNlTWluOiByZXN1bHRbMF0sXG4gICAgICAgICAgbmljZU1heDogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaW5lYXJTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lYXJTY2FsZSh5TWluLCB5TWF4KSB7XG4gICAgICB2YXIgdGlja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDEwO1xuICAgICAgdmFyIHJhbmdlID0gTWF0aC5hYnMoeU1heCAtIHlNaW4pO1xuICAgICAgdmFyIHN0ZXAgPSByYW5nZSAvIHRpY2tzO1xuXG4gICAgICBpZiAodGlja3MgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgdGlja3MgPSAxMDtcbiAgICAgICAgc3RlcCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciB2ID0geU1pbjtcblxuICAgICAgd2hpbGUgKHRpY2tzID49IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2godik7XG4gICAgICAgIHYgPSB2ICsgc3RlcDtcbiAgICAgICAgdGlja3MgLT0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgIG5pY2VNaW46IHJlc3VsdFswXSxcbiAgICAgICAgbmljZU1heDogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9nYXJpdGhtaWNTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dhcml0aG1pY1NjYWxlKGluZGV4LCB5TWluLCB5TWF4LCB0aWNrcykge1xuICAgICAgaWYgKHlNaW4gPCAwIHx8IHlNaW4gPT09IE51bWJlci5NSU5fVkFMVUUpIHlNaW4gPSAwLjAxO1xuICAgICAgdmFyIGJhc2UgPSAxMDtcbiAgICAgIHZhciBtaW4gPSBNYXRoLmxvZyh5TWluKSAvIE1hdGgubG9nKGJhc2UpO1xuICAgICAgdmFyIG1heCA9IE1hdGgubG9nKHlNYXgpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgICB2YXIgcmFuZ2UgPSBNYXRoLmFicyh5TWF4IC0geU1pbik7XG4gICAgICB2YXIgc3RlcCA9IHJhbmdlIC8gdGlja3M7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgdiA9IHlNaW47XG5cbiAgICAgIHdoaWxlICh0aWNrcyA+PSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHYpO1xuICAgICAgICB2ID0gdiArIHN0ZXA7XG4gICAgICAgIHRpY2tzIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb2dzID0gcmVzdWx0Lm1hcChmdW5jdGlvbiAobmljZU51bWJlciwgaSkge1xuICAgICAgICBpZiAobmljZU51bWJlciA8PSAwKSB7XG4gICAgICAgICAgbmljZU51bWJlciA9IDAuMDE7XG4gICAgICAgIH0gLy8gY2FsY3VsYXRlIGFkanVzdG1lbnQgZmFjdG9yXG5cblxuICAgICAgICB2YXIgc2NhbGUgPSAobWF4IC0gbWluKSAvICh5TWF4IC0geU1pbik7XG4gICAgICAgIHZhciBsb2dWYWwgPSBNYXRoLnBvdyhiYXNlLCBtaW4gKyBzY2FsZSAqIChuaWNlTnVtYmVyIC0gbWluKSk7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGxvZ1ZhbCAvIFV0aWxzLnJvdW5kVG9CYXNlKGxvZ1ZhbCwgYmFzZSkpICogVXRpbHMucm91bmRUb0Jhc2UobG9nVmFsLCBiYXNlKTtcbiAgICAgIH0pOyAvLyBNYXRoLmZsb29yIG1heSBoYXZlIHJvdW5kZWQgdGhlIHZhbHVlIHRvIDAsIHJldmVydCBiYWNrIHRvIDFcblxuICAgICAgaWYgKGxvZ3NbMF0gPT09IDApIGxvZ3NbMF0gPSAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBsb2dzLFxuICAgICAgICBuaWNlTWluOiBsb2dzWzBdLFxuICAgICAgICBuaWNlTWF4OiBsb2dzW2xvZ3MubGVuZ3RoIC0gMV1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFlTY2FsZUZvckluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFlTY2FsZUZvckluZGV4KGluZGV4LCBtaW5ZLCBtYXhZKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIHkgPSB0aGlzLmlzQmFySG9yaXpvbnRhbCA/IGNuZi54YXhpcyA6IGNuZi55YXhpc1tpbmRleF07XG5cbiAgICAgIGlmICh0eXBlb2YgZ2wueUF4aXNTY2FsZVtpbmRleF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGdsLnlBeGlzU2NhbGVbaW5kZXhdID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh5LmxvZ2FyaXRobWljKSB7XG4gICAgICAgIGdsLmFsbFNlcmllc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICBnbC55QXhpc1NjYWxlW2luZGV4XSA9IHRoaXMubG9nYXJpdGhtaWNTY2FsZShpbmRleCwgbWluWSwgbWF4WSwgeS50aWNrQW1vdW50ID8geS50aWNrQW1vdW50IDogTWF0aC5mbG9vcihNYXRoLmxvZzEwKG1heFkpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWF4WSA9PT0gLU51bWJlci5NQVhfVkFMVUUgfHwgIVV0aWxzLmlzTnVtYmVyKG1heFkpKSB7XG4gICAgICAgICAgLy8gbm8gZGF0YSBpbiB0aGUgY2hhcnQuIEVpdGhlciBhbGwgc2VyaWVzIGNvbGxhcHNlZCBvciB1c2VyIHBhc3NlZCBhIGJsYW5rIGFycmF5XG4gICAgICAgICAgZ2wueUF4aXNTY2FsZVtpbmRleF0gPSB0aGlzLmxpbmVhclNjYWxlKDAsIDUsIDUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZXJlIGlzIHNvbWUgZGF0YS4gVHVybiBvZmYgdGhlIGFsbFNlcmllc0NvbGxhcHNlZCBmbGFnXG4gICAgICAgICAgZ2wuYWxsU2VyaWVzQ29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgZ2wueUF4aXNTY2FsZVtpbmRleF0gPSB0aGlzLm5pY2VTY2FsZShtaW5ZLCBtYXhZLCBpbmRleCwgLy8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hcGV4Y2hhcnRzL2FwZXhjaGFydHMuanMvaXNzdWVzLzM5N1xuICAgICAgICAgIHkudGlja0Ftb3VudCA/IHkudGlja0Ftb3VudCA6IG1heFkgPCA1ICYmIG1heFkgPiAxID8gbWF4WSArIDEgOiA1KTsgLy9cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNdWx0aXBsZVlTY2FsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TXVsdGlwbGVZU2NhbGVzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBtaW5ZQXJyID0gZ2wubWluWUFyci5jb25jYXQoW10pO1xuICAgICAgdmFyIG1heFlBcnIgPSBnbC5tYXhZQXJyLmNvbmNhdChbXSk7XG4gICAgICB2YXIgc2NhbGVzSW5kaWNlcyA9IFtdOyAvLyBoZXJlLCB3ZSBsb29wIHRocm91Z2ggdGhlIHlheGlzIGFycmF5IGFuZCBmaW5kIHRoZSBpdGVtIHdoaWNoIGhhcyBcInNlcmllc05hbWVcIiBwcm9wZXJ0eVxuXG4gICAgICBjbmYueWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpO1xuICAgICAgICBjbmYuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHMsIHNpKSB7XG4gICAgICAgICAgLy8gaWYgc2VyaWVzTmFtZSBtYXRjaGVzIGFuZCB0aGF0IHNlcmllcyBpcyBub3QgY29sbGFwc2VkLCB3ZSB1c2UgdGhhdCBzY2FsZVxuICAgICAgICAgIGlmIChzLm5hbWUgPT09IHlheGUuc2VyaWVzTmFtZSAmJiBnbC5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2Yoc2kpID09PSAtMSkge1xuICAgICAgICAgICAgaW5kZXggPSBzaTtcblxuICAgICAgICAgICAgaWYgKGkgIT09IHNpKSB7XG4gICAgICAgICAgICAgIHNjYWxlc0luZGljZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHNpLFxuICAgICAgICAgICAgICAgIHNpbWlsYXJJbmRleDogaSxcbiAgICAgICAgICAgICAgICBhbHJlYWR5RXhpc3RzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2NhbGVzSW5kaWNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogc2lcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1pblkgPSBtaW5ZQXJyW2luZGV4XTtcbiAgICAgICAgdmFyIG1heFkgPSBtYXhZQXJyW2luZGV4XTtcblxuICAgICAgICBfdGhpcy5zZXRZU2NhbGVGb3JJbmRleChpLCBtaW5ZLCBtYXhZKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zYW1lU2NhbGVJbk11bHRpcGxlQXhlcyhtaW5ZQXJyLCBtYXhZQXJyLCBzY2FsZXNJbmRpY2VzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2FtZVNjYWxlSW5NdWx0aXBsZUF4ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FtZVNjYWxlSW5NdWx0aXBsZUF4ZXMobWluWUFyciwgbWF4WUFyciwgc2NhbGVzSW5kaWNlcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7IC8vIHdlIGdvdCB0aGUgc2NhbGVzSW5kaWNlcyBhcnJheSBpbiB0aGUgYWJvdmUgY29kZSwgYnV0IHdlIG5lZWQgdG8gZmlsdGVyIG91dCB0aGUgaXRlbXMgd2hpY2ggZG9lc24ndCBoYXZlIHNhbWUgc2NhbGVzXG5cbiAgICAgIHZhciBzaW1pbGFySW5kaWNlcyA9IFtdO1xuICAgICAgc2NhbGVzSW5kaWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgICBpZiAoc2NhbGUuYWxyZWFkeUV4aXN0cykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc2ltaWxhckluZGljZXNbc2NhbGUuaW5kZXhdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2ltaWxhckluZGljZXNbc2NhbGUuaW5kZXhdID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2ltaWxhckluZGljZXNbc2NhbGUuaW5kZXhdLnB1c2goc2NhbGUuaW5kZXgpO1xuICAgICAgICAgIHNpbWlsYXJJbmRpY2VzW3NjYWxlLmluZGV4XS5wdXNoKHNjYWxlLnNpbWlsYXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGIuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2ltaWxhckluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAoc2ksIGkpIHtcbiAgICAgICAgc2ltaWxhckluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAoc2osIGopIHtcbiAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdChzaSwgc2opLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc2ltaWxhckluZGljZXNbaV0gPSBzaW1pbGFySW5kaWNlc1tpXS5jb25jYXQoc2ltaWxhckluZGljZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gdGhlbiwgd2UgcmVtb3ZlIGR1cGxpY2F0ZXMgZnJvbSB0aGUgc2ltaWxhclNjYWxlIGFycmF5XG5cbiAgICAgIHZhciB1bmlxdWVTaW1pbGFySW5kaWNlcyA9IHNpbWlsYXJJbmRpY2VzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5maWx0ZXIoZnVuY3Rpb24gKGksIHBvcykge1xuICAgICAgICAgIHJldHVybiBpdGVtLmluZGV4T2YoaSkgPT09IHBvcztcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gc29ydCBmdXJ0aGVyIHRvIHJlbW92ZSB3aG9sZSBkdXBsaWNhdGUgYXJyYXlzIGxhdGVyXG5cbiAgICAgIHZhciBzb3J0ZWRJbmRpY2VzID0gdW5pcXVlU2ltaWxhckluZGljZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLnNvcnQoKTtcbiAgICAgIH0pOyAvLyByZW1vdmUgdW5kZWZpbmVkIGl0ZW1zXG5cbiAgICAgIHNpbWlsYXJJbmRpY2VzID0gc2ltaWxhckluZGljZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiAhIXM7XG4gICAgICB9KTtcbiAgICAgIHZhciBpbmRpY2VzID0gc29ydGVkSW5kaWNlcy5zbGljZSgpO1xuICAgICAgdmFyIHN0cmluZ0luZGljZXMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbiAoaW5kKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbmQpO1xuICAgICAgfSk7XG4gICAgICBpbmRpY2VzID0gaW5kaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGluZCwgcCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nSW5kaWNlcy5pbmRleE9mKEpTT04uc3RyaW5naWZ5KGluZCkpID09PSBwO1xuICAgICAgfSk7XG4gICAgICB2YXIgc2FtZVNjYWxlTWluWUFyciA9IFtdO1xuICAgICAgdmFyIHNhbWVTY2FsZU1heFlBcnIgPSBbXTtcbiAgICAgIG1pbllBcnIuZm9yRWFjaChmdW5jdGlvbiAobWluWVZhbHVlLCB5aSkge1xuICAgICAgICBpbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKHNjYWxlLCBpKSB7XG4gICAgICAgICAgLy8gd2UgY29tcGFyZSBvbmx5IHRoZSB5SW5kZXggd2hpY2ggZXhpc3RzIGluIHRoZSBpbmRpY2VzIGFycmF5XG4gICAgICAgICAgaWYgKHNjYWxlLmluZGV4T2YoeWkpID4gLTEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2FtZVNjYWxlTWluWUFycltpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc2FtZVNjYWxlTWluWUFycltpXSA9IFtdO1xuICAgICAgICAgICAgICBzYW1lU2NhbGVNYXhZQXJyW2ldID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNhbWVTY2FsZU1pbllBcnJbaV0ucHVzaCh7XG4gICAgICAgICAgICAgIGtleTogeWksXG4gICAgICAgICAgICAgIHZhbHVlOiBtaW5ZVmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2FtZVNjYWxlTWF4WUFycltpXS5wdXNoKHtcbiAgICAgICAgICAgICAga2V5OiB5aSxcbiAgICAgICAgICAgICAgdmFsdWU6IG1heFlBcnJbeWldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgc2FtZVNjYWxlTWluID0gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoaW5kaWNlcy5sZW5ndGgpKS5tYXAoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLCBOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgIHZhciBzYW1lU2NhbGVNYXggPSBBcnJheS5hcHBseShudWxsLCBBcnJheShpbmRpY2VzLmxlbmd0aCkpLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgIHNhbWVTY2FsZU1pbllBcnIuZm9yRWFjaChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICBzLmZvckVhY2goZnVuY3Rpb24gKHNjLCBqKSB7XG4gICAgICAgICAgc2FtZVNjYWxlTWluW2ldID0gTWF0aC5taW4oc2MudmFsdWUsIHNhbWVTY2FsZU1pbltpXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBzYW1lU2NhbGVNYXhZQXJyLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChzYywgaikge1xuICAgICAgICAgIHNhbWVTY2FsZU1heFtpXSA9IE1hdGgubWF4KHNjLnZhbHVlLCBzYW1lU2NhbGVNYXhbaV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgbWluWUFyci5mb3JFYWNoKGZ1bmN0aW9uIChtaW4sIGkpIHtcbiAgICAgICAgc2FtZVNjYWxlTWF4WUFyci5mb3JFYWNoKGZ1bmN0aW9uIChzLCBzaSkge1xuICAgICAgICAgIHZhciBtaW5ZID0gc2FtZVNjYWxlTWluW3NpXTtcbiAgICAgICAgICB2YXIgbWF4WSA9IHNhbWVTY2FsZU1heFtzaV07XG4gICAgICAgICAgcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmQsIGspIHtcbiAgICAgICAgICAgIGlmIChzW2tdLmtleSA9PT0gaSkge1xuICAgICAgICAgICAgICBpZiAoY25mLnlheGlzW2ldLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjbmYueWF4aXNbaV0ubWluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICBtaW5ZID0gY25mLnlheGlzW2ldLm1pbihnbC5taW5ZKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWluWSA9IGNuZi55YXhpc1tpXS5taW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNuZi55YXhpc1tpXS5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY25mLnlheGlzW2ldLm1heCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgbWF4WSA9IGNuZi55YXhpc1tpXS5tYXgoZ2wubWF4WSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1heFkgPSBjbmYueWF4aXNbaV0ubWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzMi5zZXRZU2NhbGVGb3JJbmRleChpLCBtaW5ZLCBtYXhZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXV0b1NjYWxlWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdXRvU2NhbGVZKGN0eCwgZSkge1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgY3R4ID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgY3R4LncuY29uZmlnLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChzZXJpZSkge1xuICAgICAgICB2YXIgbWluLCBtYXg7XG4gICAgICAgIHZhciBmaXJzdCA9IHNlcmllLmRhdGEuZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4WzBdID49IGUueGF4aXMubWluO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSBmaXJzdFsxXTtcbiAgICAgICAgbWF4ID0gbWluID0gZmlyc3RWYWx1ZTtcbiAgICAgICAgc2VyaWUuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgaWYgKGRhdGFbMF0gPD0gZS54YXhpcy5tYXggJiYgZGF0YVswXSA+PSBlLnhheGlzLm1pbikge1xuICAgICAgICAgICAgaWYgKGRhdGFbMV0gPiBtYXggJiYgZGF0YVsxXSAhPT0gbnVsbCkgbWF4ID0gZGF0YVsxXTtcbiAgICAgICAgICAgIGlmIChkYXRhWzFdIDwgbWluICYmIGRhdGFbMV0gIT09IG51bGwpIG1pbiA9IGRhdGFbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWluICo9IDAuOTU7XG4gICAgICAgIG1heCAqPSAxLjA1O1xuICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhbmdlO1xufSgpO1xuXG4vKipcbiAqIFJhbmdlIGlzIHVzZWQgdG8gZ2VuZXJhdGVzIHZhbHVlcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuICpcbiAqIEBtb2R1bGUgUmFuZ2VcbiAqKi9cblxudmFyIFJhbmdlJDEgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSYW5nZSQkMShjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFuZ2UkJDEpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy5pc0Jhckhvcml6b250YWwgPSAhISh0aGlzLncuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIHRoaXMudy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwpO1xuICAgIHRoaXMuc2NhbGVzID0gbmV3IFJhbmdlKGN0eCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmFuZ2UkJDEsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuc2V0WVJhbmdlKCk7XG4gICAgICB0aGlzLnNldFhSYW5nZSgpO1xuICAgICAgdGhpcy5zZXRaUmFuZ2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWluWU1heFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWluWU1heFkoc3RhcnRpbmdJbmRleCkge1xuICAgICAgdmFyIGxvd2VzdFkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICB2YXIgaGlnaGVzdFkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIG1heFkgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIHZhciBtaW5ZID0gTnVtYmVyLk1JTl9WQUxVRTtcblxuICAgICAgaWYgKGxlbiA9PT0gbnVsbCkge1xuICAgICAgICBsZW4gPSBzdGFydGluZ0luZGV4ICsgMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlcmllcyA9IGdsLnNlcmllcztcbiAgICAgIHZhciBzZXJpZXNNaW4gPSBzZXJpZXM7XG4gICAgICB2YXIgc2VyaWVzTWF4ID0gc2VyaWVzO1xuXG4gICAgICBpZiAodGhpcy53LmNvbmZpZy5jaGFydC50eXBlID09PSAnY2FuZGxlc3RpY2snKSB7XG4gICAgICAgIHNlcmllc01pbiA9IGdsLnNlcmllc0NhbmRsZUw7XG4gICAgICAgIHNlcmllc01heCA9IGdsLnNlcmllc0NhbmRsZUg7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydGluZ0luZGV4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZ2wuZGF0YVBvaW50cyA9IE1hdGgubWF4KGdsLmRhdGFQb2ludHMsIHNlcmllc1tpXS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2wuc2VyaWVzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHNlcmllc1tpXVtqXSAhPT0gbnVsbCAmJiBVdGlscy5pc051bWJlcihzZXJpZXNbaV1bal0pKSB7XG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgc2VyaWVzTWF4W2ldW2pdKTtcbiAgICAgICAgICAgIGxvd2VzdFkgPSBNYXRoLm1pbihsb3dlc3RZLCBzZXJpZXNNaW5baV1bal0pO1xuICAgICAgICAgICAgaGlnaGVzdFkgPSBNYXRoLm1heChoaWdoZXN0WSwgc2VyaWVzTWluW2ldW2pdKTtcblxuICAgICAgICAgICAgaWYgKFV0aWxzLmlzRmxvYXQoc2VyaWVzW2ldW2pdKSkge1xuICAgICAgICAgICAgICBnbC55VmFsdWVEZWNpbWFsID0gTWF0aC5tYXgoZ2wueVZhbHVlRGVjaW1hbCwgc2VyaWVzW2ldW2pdLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWluWSA+IHNlcmllc01pbltpXVtqXSAmJiBzZXJpZXNNaW5baV1bal0gPCAwKSB7XG4gICAgICAgICAgICAgIG1pblkgPSBzZXJpZXNNaW5baV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmhhc051bGxWYWx1ZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICBtYXhZOiBtYXhZLFxuICAgICAgICBsb3dlc3RZOiBsb3dlc3RZLFxuICAgICAgICBoaWdoZXN0WTogaGlnaGVzdFlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFlSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRZUmFuZ2UoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgZ2wubWF4WSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wubWluWSA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgICB2YXIgbG93ZXN0WUluQWxsU2VyaWVzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgaWYgKGdsLmlzTXVsdGlwbGVZQXhpcykge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGdldCBtaW5ZIGFuZCBtYXhZIGZvciBtdWx0aXBsZSB5IGF4aXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbC5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWluWU1heFlBcnIgPSB0aGlzLmdldE1pbllNYXhZKGksIGxvd2VzdFlJbkFsbFNlcmllcywgbnVsbCwgaSArIDEpO1xuICAgICAgICAgIGdsLm1pbllBcnIucHVzaChtaW5ZTWF4WUFyci5taW5ZKTtcbiAgICAgICAgICBnbC5tYXhZQXJyLnB1c2gobWluWU1heFlBcnIubWF4WSk7XG4gICAgICAgICAgbG93ZXN0WUluQWxsU2VyaWVzID0gbWluWU1heFlBcnIubG93ZXN0WTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhbmQgdGhlbiwgZ2V0IHRoZSBtaW5ZIGFuZCBtYXhZIGZyb20gYWxsIHNlcmllc1xuXG5cbiAgICAgIHZhciBtaW5ZTWF4WSA9IHRoaXMuZ2V0TWluWU1heFkoMCwgbG93ZXN0WUluQWxsU2VyaWVzLCBudWxsLCBnbC5zZXJpZXMubGVuZ3RoKTtcbiAgICAgIGdsLm1pblkgPSBtaW5ZTWF4WS5taW5ZO1xuICAgICAgZ2wubWF4WSA9IG1pbllNYXhZLm1heFk7XG4gICAgICBsb3dlc3RZSW5BbGxTZXJpZXMgPSBtaW5ZTWF4WS5sb3dlc3RZO1xuXG4gICAgICBpZiAoY25mLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgLy8gZm9yIHN0YWNrZWQgY2hhcnRzLCB3ZSBjYWxjdWxhdGUgZWFjaCBzZXJpZXMncyBwYXJhbGxlbCB2YWx1ZXMuIGkuZSwgc2VyaWVzWzBdW2pdICsgc2VyaWVzWzFdW2pdIC4uLi4gW3Nlcmllc1tpLmxlbmd0aF1bal1dIGFuZCBnZXQgdGhlIG1heCBvdXQgb2YgaXRcbiAgICAgICAgdmFyIHN0YWNrZWRQb3NzID0gW107XG4gICAgICAgIHZhciBzdGFja2VkTmVncyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2wuc2VyaWVzW2dsLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHBvc3MgPSAwO1xuICAgICAgICAgIHZhciBuZWdzID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBnbC5zZXJpZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpZiAoZ2wuc2VyaWVzW19pXVtqXSAhPT0gbnVsbCAmJiBVdGlscy5pc051bWJlcihnbC5zZXJpZXNbX2ldW2pdKSkge1xuICAgICAgICAgICAgICBpZiAoZ2wuc2VyaWVzW19pXVtqXSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyAwLjAwMDEgZml4ZXMgIzE4NSB3aGVuIHZhbHVlcyBhcmUgdmVyeSBzbWFsbFxuICAgICAgICAgICAgICAgIHBvc3MgPSBwb3NzICsgcGFyc2VGbG9hdChnbC5zZXJpZXNbX2ldW2pdKSArIDAuMDAwMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWdzID0gbmVncyArIHBhcnNlRmxvYXQoZ2wuc2VyaWVzW19pXVtqXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF9pID09PSBnbC5zZXJpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAvLyBwdXNoIGFsbCB0aGUgdG90YWxzIHRvIHRoZSBhcnJheSBmb3IgZnV0dXJlIHVzZVxuICAgICAgICAgICAgICBzdGFja2VkUG9zcy5wdXNoKHBvc3MpO1xuICAgICAgICAgICAgICBzdGFja2VkTmVncy5wdXNoKG5lZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBnZXQgdGhlIG1heC9taW4gb3V0IG9mIHRoZSBhZGRlZCBwYXJhbGxlbCB2YWx1ZXNcblxuXG4gICAgICAgIGZvciAodmFyIHogPSAwOyB6IDwgc3RhY2tlZFBvc3MubGVuZ3RoOyB6KyspIHtcbiAgICAgICAgICBnbC5tYXhZID0gTWF0aC5tYXgoZ2wubWF4WSwgc3RhY2tlZFBvc3Nbel0pO1xuICAgICAgICAgIGdsLm1pblkgPSBNYXRoLm1pbihnbC5taW5ZLCBzdGFja2VkTmVnc1t6XSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgdGhlIG51bWJlcnMgYXJlIHRvbyBiaWcsIHJlZHVjZSB0aGUgcmFuZ2VcbiAgICAgIC8vIGZvciBlZywgaWYgbnVtYmVyIGlzIGJldHdlZW4gMTAwMDAwLTExMDAwMCwgcHV0dGluZyAwIGFzIHRoZSBsb3dlc3QgdmFsdWUgaXMgbm90IHNvIGdvb2QgaWRlYS4gU28gY2hhbmdlIHRoZSBnbC5taW5ZIGZvciBsaW5lL2FyZWEvY2FuZGxlc3RpY2tzXG5cblxuICAgICAgaWYgKGNuZi5jaGFydC50eXBlID09PSAnbGluZScgfHwgY25mLmNoYXJ0LnR5cGUgPT09ICdhcmVhJyB8fCBjbmYuY2hhcnQudHlwZSA9PT0gJ2NhbmRsZXN0aWNrJykge1xuICAgICAgICBpZiAoZ2wubWluWSA9PT0gTnVtYmVyLk1JTl9WQUxVRSAmJiBsb3dlc3RZSW5BbGxTZXJpZXMgIT09IC1OdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgdmFyIGRpZmYgPSBnbC5tYXhZIC0gbG93ZXN0WUluQWxsU2VyaWVzO1xuXG4gICAgICAgICAgaWYgKGxvd2VzdFlJbkFsbFNlcmllcyA+PSAwICYmIGxvd2VzdFlJbkFsbFNlcmllcyA8PSAxMCkge1xuICAgICAgICAgICAgLy8gaWYgbWluWSBpcyBhbHJlYWR5IDAvbG93IHZhbHVlLCB3ZSBkb24ndCB3YW50IHRvIGdvIG5lZ2F0aXZlcyBoZXJlIC0gc28gdGhpcyBjaGVjayBpcyBlc3NlbnRpYWwuXG4gICAgICAgICAgICBkaWZmID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnbC5taW5ZID0gbG93ZXN0WUluQWxsU2VyaWVzIC0gZGlmZiAqIDUgLyAxMDA7XG4gICAgICAgICAgZ2wubWF4WSA9IGdsLm1heFkgKyBkaWZmICogNSAvIDEwMCArIDAuMDU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY25mLnlheGlzLm1hcChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgLy8gb3ZlcnJpZGUgYWxsIG1pbi9tYXggdmFsdWVzIGJ5IHVzZXIgZGVmaW5lZCB2YWx1ZXMgKHkgYXhpcylcbiAgICAgICAgaWYgKHlheGUubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHlheGUubWF4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZ2wubWF4WUFycltpbmRleF0gPSB5YXhlLm1heDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB5YXhlLm1heCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZ2wubWF4WUFycltpbmRleF0gPSB5YXhlLm1heChnbC5tYXhZKTtcbiAgICAgICAgICB9IC8vIGdsLm1heFkgaXMgZm9yIHNpbmdsZSB5LWF4aXMgY2hhcnQsIGl0IHdpbGwgYmUgaWdub3JlZCBpbiBtdWx0aS15YXhpc1xuXG5cbiAgICAgICAgICBnbC5tYXhZID0gZ2wubWF4WUFycltpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeWF4ZS5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgeWF4ZS5taW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBnbC5taW5ZQXJyW2luZGV4XSA9IHlheGUubWluO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHlheGUubWluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBnbC5taW5ZQXJyW2luZGV4XSA9IHlheGUubWluKGdsLm1pblkpO1xuICAgICAgICAgIH0gLy8gZ2wubWluWSBpcyBmb3Igc2luZ2xlIHktYXhpcyBjaGFydCwgaXQgd2lsbCBiZSBpZ25vcmVkIGluIG11bHRpLXlheGlzXG5cblxuICAgICAgICAgIGdsLm1pblkgPSBnbC5taW5ZQXJyW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIGZvciBob3Jpem9udGFsIGJhciBjaGFydHMsIHdlIG5lZWQgdG8gY2hlY2sgeGF4aXMgbWluL21heCBhcyB1c2VyIG1heSBoYXZlIHNwZWNpZmllZCB0aGVyZVxuXG4gICAgICBpZiAodGhpcy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGNuZi54YXhpcy5taW4gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY25mLnhheGlzLm1pbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBnbC5taW5ZID0gY25mLnhheGlzLm1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbmYueGF4aXMubWF4ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNuZi54YXhpcy5tYXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZ2wubWF4WSA9IGNuZi54YXhpcy5tYXg7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIG11bHRpIHktYXhpcyB3ZSBuZWVkIGRpZmZlcmVudCBzY2FsZXMgZm9yIGVhY2hcblxuXG4gICAgICBpZiAoZ2wuaXNNdWx0aXBsZVlBeGlzKSB7XG4gICAgICAgIHRoaXMuc2NhbGVzLnNldE11bHRpcGxlWVNjYWxlcygpO1xuICAgICAgICBnbC5taW5ZID0gbG93ZXN0WUluQWxsU2VyaWVzO1xuICAgICAgICBnbC55QXhpc1NjYWxlLmZvckVhY2goZnVuY3Rpb24gKHNjYWxlLCBpKSB7XG4gICAgICAgICAgZ2wubWluWUFycltpXSA9IHNjYWxlLm5pY2VNaW47XG4gICAgICAgICAgZ2wubWF4WUFycltpXSA9IHNjYWxlLm5pY2VNYXg7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zY2FsZXMuc2V0WVNjYWxlRm9ySW5kZXgoMCwgZ2wubWluWSwgZ2wubWF4WSk7XG4gICAgICAgIGdsLm1pblkgPSBnbC55QXhpc1NjYWxlWzBdLm5pY2VNaW47XG4gICAgICAgIGdsLm1heFkgPSBnbC55QXhpc1NjYWxlWzBdLm5pY2VNYXg7XG4gICAgICAgIGdsLm1pbllBcnJbMF0gPSBnbC55QXhpc1NjYWxlWzBdLm5pY2VNaW47XG4gICAgICAgIGdsLm1heFlBcnJbMF0gPSBnbC55QXhpc1NjYWxlWzBdLm5pY2VNYXg7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFhSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRYUmFuZ2UoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIGlzWE51bWVyaWMgPSBjbmYueGF4aXMudHlwZSA9PT0gJ251bWVyaWMnIHx8IGNuZi54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnIHx8IGNuZi54YXhpcy50eXBlID09PSAnY2F0ZWdvcnknICYmICFnbC5ub0xhYmVsc1Byb3ZpZGVkOyAvLyBtaW5YIG1heFggc3RhcnRzIGhlcmVcblxuICAgICAgaWYgKGdsLmlzWE51bWVyaWMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbC5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZ2wubGFiZWxzW2ldKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdsLmxhYmVsc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoZ2wubGFiZWxzW2ldW2pdICE9PSBudWxsICYmIFV0aWxzLmlzTnVtYmVyKGdsLmxhYmVsc1tpXVtqXSkpIHtcbiAgICAgICAgICAgICAgICBnbC5tYXhYID0gTWF0aC5tYXgoZ2wubWF4WCwgZ2wubGFiZWxzW2ldW2pdKTtcbiAgICAgICAgICAgICAgICBnbC5pbml0aWFsbWF4WCA9IE1hdGgubWF4KGdsLm1heFgsIGdsLmxhYmVsc1tpXVtqXSk7XG4gICAgICAgICAgICAgICAgZ2wubWluWCA9IE1hdGgubWluKGdsLm1pblgsIGdsLmxhYmVsc1tpXVtqXSk7XG4gICAgICAgICAgICAgICAgZ2wuaW5pdGlhbG1pblggPSBNYXRoLm1pbihnbC5taW5YLCBnbC5sYWJlbHNbaV1bal0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChnbC5ub0xhYmVsc1Byb3ZpZGVkKSB7XG4gICAgICAgIGlmIChjbmYueGF4aXMuY2F0ZWdvcmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBnbC5tYXhYID0gZ2wubGFiZWxzW2dsLmxhYmVscy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBnbC5pbml0aWFsbWF4WCA9IGdsLmxhYmVsc1tnbC5sYWJlbHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgZ2wubWluWCA9IDE7XG4gICAgICAgICAgZ2wuaW5pdGlhbG1pblggPSAxO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBudW1lcmljIHhheGlzLCB3ZSBuZWVkIHRvIGFkanVzdCBzb21lIHBhZGRpbmcgbGVmdCBhbmQgcmlnaHQgZm9yIGJhciBjaGFydHNcblxuXG4gICAgICBpZiAoZ2wuY29tYm9DaGFydHNIYXNCYXJzIHx8IGNuZi5jaGFydC50eXBlID09PSAnY2FuZGxlc3RpY2snIHx8IGNuZi5jaGFydC50eXBlID09PSAnYmFyJyAmJiBjbmYueGF4aXMudHlwZSAhPT0gJ2NhdGVnb3J5Jykge1xuICAgICAgICBpZiAoY25mLnhheGlzLnR5cGUgIT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgICB2YXIgbWluWCA9IGdsLm1pblggLSBnbC5zdmdXaWR0aCAvIGdsLmRhdGFQb2ludHMgKiAoTWF0aC5hYnMoZ2wubWF4WCAtIGdsLm1pblgpIC8gZ2wuc3ZnV2lkdGgpIC8gMjtcbiAgICAgICAgICBnbC5taW5YID0gbWluWDtcbiAgICAgICAgICBnbC5pbml0aWFsbWluWCA9IG1pblg7XG4gICAgICAgICAgdmFyIG1heFggPSBnbC5tYXhYICsgZ2wuc3ZnV2lkdGggLyBnbC5kYXRhUG9pbnRzICogKE1hdGguYWJzKGdsLm1heFggLSBnbC5taW5YKSAvIGdsLnN2Z1dpZHRoKSAvIDI7XG4gICAgICAgICAgZ2wubWF4WCA9IG1heFg7XG4gICAgICAgICAgZ2wuaW5pdGlhbG1heFggPSBtYXhYO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChnbC5pc1hOdW1lcmljIHx8IGdsLm5vTGFiZWxzUHJvdmlkZWQpIHtcbiAgICAgICAgdmFyIHRpY2tzO1xuXG4gICAgICAgIGlmIChjbmYueGF4aXMudGlja0Ftb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGlja3MgPSBNYXRoLnJvdW5kKGdsLnN2Z1dpZHRoIC8gMTUwKTsgLy8gbm8gbGFiZWxzIHByb3ZpZGVkIGFuZCB0b3RhbCBudW1iZXIgb2YgZGF0YVBvaW50cyBpcyBsZXNzIHRoYW4gMjBcblxuICAgICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ251bWVyaWMnICYmIGdsLmRhdGFQb2ludHMgPCAyMCkge1xuICAgICAgICAgICAgdGlja3MgPSBnbC5kYXRhUG9pbnRzIC0gMTtcbiAgICAgICAgICB9IC8vIHRoaXMgY2hlY2sgaXMgZm9yIHdoZW4gdGlja3MgZXhjZWVkcyB0b3RhbCBkYXRhcG9pbnRzIGFuZCB0aGF0IHdvdWxkIHJlc3VsdCBpbiBkdXBsaWNhdGUgbGFiZWxzXG5cblxuICAgICAgICAgIGlmICh0aWNrcyA+IGdsLmRhdGFQb2ludHMgJiYgZ2wuZGF0YVBvaW50cyAhPT0gMCkge1xuICAgICAgICAgICAgdGlja3MgPSBnbC5kYXRhUG9pbnRzIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY25mLnhheGlzLnRpY2tBbW91bnQgPT09ICdkYXRhUG9pbnRzJykge1xuICAgICAgICAgIHRpY2tzID0gZ2wuc2VyaWVzW2dsLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja3MgPSBjbmYueGF4aXMudGlja0Ftb3VudDtcbiAgICAgICAgfSAvLyBvdmVycmlkZSBhbGwgbWluL21heCB2YWx1ZXMgYnkgdXNlciBkZWZpbmVkIHZhbHVlcyAoeCBheGlzKVxuXG5cbiAgICAgICAgaWYgKGNuZi54YXhpcy5tYXggIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgY25mLnhheGlzLm1heCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBnbC5tYXhYID0gY25mLnhheGlzLm1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbmYueGF4aXMubWluICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNuZi54YXhpcy5taW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZ2wubWluWCA9IGNuZi54YXhpcy5taW47XG4gICAgICAgIH0gLy8gaWYgcmFuZ2UgaXMgcHJvdmlkZWQsIGFkanVzdCB0aGUgbmV3IG1pblhcblxuXG4gICAgICAgIGlmIChjbmYueGF4aXMucmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGdsLm1pblggPSBnbC5tYXhYIC0gY25mLnhheGlzLnJhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsLm1pblggIT09IE51bWJlci5NQVhfVkFMVUUgJiYgZ2wubWF4WCAhPT0gLU51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICBnbC54QXhpc1NjYWxlID0gdGhpcy5zY2FsZXMubGluZWFyU2NhbGUoZ2wubWluWCwgZ2wubWF4WCwgdGlja3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnhBeGlzU2NhbGUgPSB0aGlzLnNjYWxlcy5saW5lYXJTY2FsZSgxLCB0aWNrcywgdGlja3MpO1xuXG4gICAgICAgICAgaWYgKGdsLm5vTGFiZWxzUHJvdmlkZWQgJiYgZ2wubGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdsLnhBeGlzU2NhbGUgPSB0aGlzLnNjYWxlcy5saW5lYXJTY2FsZSgxLCBnbC5sYWJlbHMubGVuZ3RoLCB0aWNrcyAtIDEpO1xuICAgICAgICAgICAgZ2wuc2VyaWVzWCA9IGdsLmxhYmVscy5zbGljZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB3ZSB3aWxsIHN0aWxsIHN0b3JlIHRoZXNlIGxhYmVscyBhcyB0aGUgY291bnQgZm9yIHRoaXMgd2lsbCBiZSBkaWZmZXJlbnQgKHRvIGRyYXcgZ3JpZCBhbmQgbGFiZWxzIHBsYWNlbWVudClcblxuXG4gICAgICAgIGlmIChpc1hOdW1lcmljKSB7XG4gICAgICAgICAgZ2wubGFiZWxzID0gZ2wueEF4aXNTY2FsZS5yZXN1bHQuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ2wubWluWCA9PT0gZ2wubWF4WCkge1xuICAgICAgICAvLyBzaW5nbGUgZGF0YVBvaW50XG4gICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgIHZhciBuZXdNaW5YID0gbmV3IERhdGUoZ2wubWluWCk7XG4gICAgICAgICAgbmV3TWluWC5zZXREYXRlKG5ld01pblguZ2V0RGF0ZSgpIC0gMik7XG4gICAgICAgICAgZ2wubWluWCA9IG5ldyBEYXRlKG5ld01pblgpLmdldFRpbWUoKTtcbiAgICAgICAgICB2YXIgbmV3TWF4WCA9IG5ldyBEYXRlKGdsLm1heFgpO1xuICAgICAgICAgIG5ld01heFguc2V0RGF0ZShuZXdNYXhYLmdldERhdGUoKSArIDIpO1xuICAgICAgICAgIGdsLm1heFggPSBuZXcgRGF0ZShuZXdNYXhYKS5nZXRUaW1lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdudW1lcmljJyB8fCBjbmYueGF4aXMudHlwZSA9PT0gJ2NhdGVnb3J5JyAmJiAhZ2wubm9MYWJlbHNQcm92aWRlZCkge1xuICAgICAgICAgIGdsLm1pblggPSBnbC5taW5YIC0gMjtcbiAgICAgICAgICBnbC5tYXhYID0gZ2wubWF4WCArIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WlJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFpSYW5nZSgpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzOyAvLyBtaW5aLCBtYXhaIHN0YXJ0cyBoZXJlXG5cbiAgICAgIGlmIChnbC5pc0RhdGFYWVopIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbC5zZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGdsLnNlcmllc1pbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdsLnNlcmllc1pbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKGdsLnNlcmllc1pbaV1bal0gIT09IG51bGwgJiYgVXRpbHMuaXNOdW1iZXIoZ2wuc2VyaWVzWltpXVtqXSkpIHtcbiAgICAgICAgICAgICAgICBnbC5tYXhaID0gTWF0aC5tYXgoZ2wubWF4WiwgZ2wuc2VyaWVzWltpXVtqXSk7XG4gICAgICAgICAgICAgICAgZ2wubWluWiA9IE1hdGgubWluKGdsLm1pblosIGdsLnNlcmllc1pbaV1bal0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhbmdlJCQxO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgU2VyaWVzIENsYXNzIGZvciBpbnRlcmF0aW9uIHdpdGggdGhlIFNlcmllcyBvZiB0aGUgY2hhcnQuXG4gKlxuICogQG1vZHVsZSBTZXJpZXNcbiAqKi9cblxudmFyIFNlcmllcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNlcmllcyhjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VyaWVzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNlcmllcywgW3tcbiAgICBrZXk6IFwiZ2V0QWxsU2VyaWVzRWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbFNlcmllc0VscygpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1zZXJpZXNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlcmllc0J5TmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXJpZXNCeU5hbWUoc2VyaWVzTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXNlcmllcy5cIi5jb25jYXQoVXRpbHMuZXNjYXBlU3RyaW5nKHNlcmllc05hbWUpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZENvbGxhcHNlZENsYXNzVG9TZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ29sbGFwc2VkQ2xhc3NUb1NlcmllcyhlbFNlcmllcywgaW5kZXgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBmb3IgKHZhciBjcyA9IDA7IGNzIDwgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5sZW5ndGg7IGNzKyspIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNbY3NdLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgIGVsU2VyaWVzLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1zZXJpZXMtY29sbGFwc2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlU2VyaWVzT25Ib3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVTZXJpZXNPbkhvdmVyKGUsIHRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGFsbFNlcmllc0VscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1zZXJpZXNcIik7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICAgIHZhciBzZXJpZXNDbnQgPSBwYXJzZUludCh0YXJnZXRFbGVtZW50LmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMTtcbiAgICAgICAgdmFyIHNlcmllc0VsID0gbnVsbDtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhZGlhbEJhcicpIHtcbiAgICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICAgIHNlcmllc0VsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpyZWFsSW5kZXg9J1wiLmNvbmNhdChzZXJpZXNDbnQsIFwiJ11cIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXJpZXNFbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1zZXJpZXNbcmVsPSdcIi5jb25jYXQoc2VyaWVzQ250ICsgMSwgXCInXVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlcmllc0VsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9J1wiLmNvbmNhdChzZXJpZXNDbnQgKyAxLCBcIiddIHBhdGhcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgc2UgPSAwOyBzZSA8IGFsbFNlcmllc0Vscy5sZW5ndGg7IHNlKyspIHtcbiAgICAgICAgICBhbGxTZXJpZXNFbHNbc2VdLmNsYXNzTGlzdC5hZGQoJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXJpZXNFbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghdy5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICAgIHNlcmllc0VsLnBhcmVudE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnbGVnZW5kLW1vdXNlb3Zlci1pbmFjdGl2ZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlcmllc0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2xlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgICAgZm9yICh2YXIgX3NlID0gMDsgX3NlIDwgYWxsU2VyaWVzRWxzLmxlbmd0aDsgX3NlKyspIHtcbiAgICAgICAgICBhbGxTZXJpZXNFbHNbX3NlXS5jbGFzc0xpc3QucmVtb3ZlKCdsZWdlbmQtbW91c2VvdmVyLWluYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGlnaGxpZ2h0UmFuZ2VJblNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWdobGlnaHRSYW5nZUluU2VyaWVzKGUsIHRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGFsbEhlYXRNYXBFbGVtZW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWhlYXRtYXAtcmVjdCcpO1xuXG4gICAgICB2YXIgYWxsQWN0aXZlID0gZnVuY3Rpb24gYWxsQWN0aXZlKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEhlYXRNYXBFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFsbEhlYXRNYXBFbGVtZW50c1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdsZWdlbmQtbW91c2VvdmVyLWluYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBhbGxJbmFjdGl2ZSA9IGZ1bmN0aW9uIGFsbEluYWN0aXZlKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEhlYXRNYXBFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFsbEhlYXRNYXBFbGVtZW50c1tpXS5jbGFzc0xpc3QuYWRkKCdsZWdlbmQtbW91c2VvdmVyLWluYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBzZWxlY3RlZEFjdGl2ZSA9IGZ1bmN0aW9uIHNlbGVjdGVkQWN0aXZlKHJhbmdlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsSGVhdE1hcEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IHBhcnNlSW50KGFsbEhlYXRNYXBFbGVtZW50c1tpXS5nZXRBdHRyaWJ1dGUoJ3ZhbCcpKTtcblxuICAgICAgICAgIGlmICh2YWwgPj0gcmFuZ2UuZnJvbSAmJiB2YWwgPD0gcmFuZ2UudG8pIHtcbiAgICAgICAgICAgIGFsbEhlYXRNYXBFbGVtZW50c1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdsZWdlbmQtbW91c2VvdmVyLWluYWN0aXZlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgICB2YXIgc2VyaWVzQ250ID0gcGFyc2VJbnQodGFyZ2V0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSAtIDE7XG4gICAgICAgIGFsbEFjdGl2ZSgpO1xuICAgICAgICBhbGxJbmFjdGl2ZSgpO1xuICAgICAgICB2YXIgcmFuZ2UgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5oZWF0bWFwLmNvbG9yU2NhbGUucmFuZ2VzW3Nlcmllc0NudF07XG4gICAgICAgIHNlbGVjdGVkQWN0aXZlKHJhbmdlKTtcbiAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICAgIGFsbEFjdGl2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBY3RpdmVTZXJpZXNJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBY3RpdmVTZXJpZXNJbmRleCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gMDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBhY3RpdmUgc2VyaWVzIGZsYWcgaXMgcmVxdWlyZWQgdG8ga25vdyBpZiB1c2VyIGhhcyBub3QgZGVhY3RpdmF0ZWQgdmlhIGxlZ2VuZCBjbGlja1xuICAgICAgICB2YXIgZmlyc3RBY3RpdmVTZXJpZXNJbmRleCA9IHcuZ2xvYmFscy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzZXJpZXMsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKHNlcmllcy5sZW5ndGggPiAwICYmIHcuY29uZmlnLnNlcmllc1tpbmRleF0udHlwZSAhPT0gJ2JhcicgJiYgdy5jb25maWcuc2VyaWVzW2luZGV4XS50eXBlICE9PSAnY29sdW1uJykge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGZpcnN0QWN0aXZlU2VyaWVzSW5kZXgubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICBpZiAoZmlyc3RBY3RpdmVTZXJpZXNJbmRleFthXSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFjdGl2ZUluZGV4ID0gZmlyc3RBY3RpdmVTZXJpZXNJbmRleFthXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWN0aXZlSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFjdGl2ZUNvbmZpZ1Nlcmllc0luZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjdGl2ZUNvbmZpZ1Nlcmllc0luZGV4KCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSAwO1xuXG4gICAgICBpZiAody5jb25maWcuc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gYWN0aXZlIHNlcmllcyBmbGFnIGlzIHJlcXVpcmVkIHRvIGtub3cgaWYgdXNlciBoYXMgbm90IGRlYWN0aXZhdGVkIHZpYSBsZWdlbmQgY2xpY2tcbiAgICAgICAgdmFyIGZpcnN0QWN0aXZlU2VyaWVzSW5kZXggPSB3LmNvbmZpZy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzZXJpZXMsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKHNlcmllcy5kYXRhICYmIHNlcmllcy5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBmaXJzdEFjdGl2ZVNlcmllc0luZGV4Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgaWYgKGZpcnN0QWN0aXZlU2VyaWVzSW5kZXhbYV0gIT09IC0xKSB7XG4gICAgICAgICAgICBhY3RpdmVJbmRleCA9IGZpcnN0QWN0aXZlU2VyaWVzSW5kZXhbYV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjdGl2ZUluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcmV2aW91c1BhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByZXZpb3VzUGF0aHMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIHB1c2hQYXRocyhzZXJpZXNFbHMsIGksIHR5cGUpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gc2VyaWVzRWxzW2ldLmNoaWxkTm9kZXM7XG4gICAgICAgIHZhciBkQXJyID0ge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgcGF0aHM6IFtdLFxuICAgICAgICAgIHJlYWxJbmRleDogc2VyaWVzRWxzW2ldLmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGF0aHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAocGF0aHNbal0uaGFzQXR0cmlidXRlKCdwYXRoVG8nKSkge1xuICAgICAgICAgICAgdmFyIGQgPSBwYXRoc1tqXS5nZXRBdHRyaWJ1dGUoJ3BhdGhUbycpO1xuICAgICAgICAgICAgZEFyci5wYXRocy5wdXNoKHtcbiAgICAgICAgICAgICAgZDogZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMucHVzaChkQXJyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmVQYXRocyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWxpbmUtc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBpZiAobGluZVBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgcCA9IGxpbmVQYXRocy5sZW5ndGggLSAxOyBwID49IDA7IHAtLSkge1xuICAgICAgICAgIHB1c2hQYXRocyhsaW5lUGF0aHMsIHAsICdsaW5lJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGFyZWFwYXRocyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWFyZWEtc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBpZiAoYXJlYXBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZWFwYXRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHB1c2hQYXRocyhhcmVhcGF0aHMsIGksICdhcmVhJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJhclBhdGhzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtYmFyLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXMnKTtcblxuICAgICAgaWYgKGJhclBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgX3AgPSAwOyBfcCA8IGJhclBhdGhzLmxlbmd0aDsgX3ArKykge1xuICAgICAgICAgIHB1c2hQYXRocyhiYXJQYXRocywgX3AsICdiYXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2FuZGxlc3RpY2tQYXRocyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXMnKTtcblxuICAgICAgaWYgKGNhbmRsZXN0aWNrUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBfcDIgPSAwOyBfcDIgPCBjYW5kbGVzdGlja1BhdGhzLmxlbmd0aDsgX3AyKyspIHtcbiAgICAgICAgICBwdXNoUGF0aHMoY2FuZGxlc3RpY2tQYXRocywgX3AyLCAnY2FuZGxlc3RpY2snKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmFkYXJQYXRocyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXJhZGFyLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXMnKTtcblxuICAgICAgaWYgKHJhZGFyUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBfcDMgPSAwOyBfcDMgPCByYWRhclBhdGhzLmxlbmd0aDsgX3AzKyspIHtcbiAgICAgICAgICBwdXNoUGF0aHMocmFkYXJQYXRocywgX3AzLCAncmFkYXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYnViYmxlcGF0aHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1idWJibGUtc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBpZiAoYnViYmxlcGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGJ1YmJsZXBhdGhzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgdmFyIHNlcmllc0VscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1idWJibGUtc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpyZWFsSW5kZXg9J1wiLmNvbmNhdChzLCBcIiddIGNpcmNsZVwiKSk7XG4gICAgICAgICAgdmFyIGRBcnIgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzZXJpZXNFbHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBkQXJyLnB1c2goe1xuICAgICAgICAgICAgICB4OiBzZXJpZXNFbHNbX2ldLmdldEF0dHJpYnV0ZSgnY3gnKSxcbiAgICAgICAgICAgICAgeTogc2VyaWVzRWxzW19pXS5nZXRBdHRyaWJ1dGUoJ2N5JyksXG4gICAgICAgICAgICAgIHI6IHNlcmllc0Vsc1tfaV0uZ2V0QXR0cmlidXRlKCdyJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy5wcmV2aW91c1BhdGhzLnB1c2goZEFycik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNjYXR0ZXJwYXRocyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNjYXR0ZXItc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBpZiAoc2NhdHRlcnBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgX3MgPSAwOyBfcyA8IHNjYXR0ZXJwYXRocy5sZW5ndGg7IF9zKyspIHtcbiAgICAgICAgICB2YXIgX3Nlcmllc0VscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1zY2F0dGVyLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXNbZGF0YVxcXFw6cmVhbEluZGV4PSdcIi5jb25jYXQoX3MsIFwiJ10gY2lyY2xlXCIpKTtcblxuICAgICAgICAgIHZhciBfZEFyciA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX3Nlcmllc0Vscy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBfZEFyci5wdXNoKHtcbiAgICAgICAgICAgICAgeDogX3Nlcmllc0Vsc1tfaTJdLmdldEF0dHJpYnV0ZSgnY3gnKSxcbiAgICAgICAgICAgICAgeTogX3Nlcmllc0Vsc1tfaTJdLmdldEF0dHJpYnV0ZSgnY3knKSxcbiAgICAgICAgICAgICAgcjogX3Nlcmllc0Vsc1tfaTJdLmdldEF0dHJpYnV0ZSgncicpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMucHJldmlvdXNQYXRocy5wdXNoKF9kQXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaGVhdG1hcENvbG9ycyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWhlYXRtYXAgLmFwZXhjaGFydHMtc2VyaWVzJyk7XG5cbiAgICAgIGlmIChoZWF0bWFwQ29sb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCBoZWF0bWFwQ29sb3JzLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgICAgdmFyIF9zZXJpZXNFbHMyID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLWhlYXRtYXAgLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KGgsIFwiJ10gcmVjdFwiKSk7XG5cbiAgICAgICAgICB2YXIgX2RBcnIyID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBfc2VyaWVzRWxzMi5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICBfZEFycjIucHVzaCh7XG4gICAgICAgICAgICAgIGNvbG9yOiBfc2VyaWVzRWxzMltfaTNdLmdldEF0dHJpYnV0ZSgnY29sb3InKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMucHVzaChfZEFycjIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgLy8gZm9yIG5vbi1heGlzIGNoYXJ0cyAoaS5lLiwgY2lyY3VsYXIgY2hhcnRzLCBwYXRoRnJvbSBpcyBub3QgdXNhYmxlLiBXZSBuZWVkIHdob2xlIHNlcmllcylcbiAgICAgICAgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMgPSB3Lmdsb2JhbHMuc2VyaWVzO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVOb0RhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTm9EYXRhKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIG5vRGF0YU9wdHMgPSB3LmNvbmZpZy5ub0RhdGE7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MobWUuY3R4KTtcbiAgICAgIHZhciB4ID0gdy5nbG9iYWxzLnN2Z1dpZHRoIC8gMjtcbiAgICAgIHZhciB5ID0gdy5nbG9iYWxzLnN2Z0hlaWdodCAvIDI7XG4gICAgICB2YXIgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgdy5nbG9iYWxzLm5vRGF0YSA9IHRydWU7XG4gICAgICB3Lmdsb2JhbHMuYW5pbWF0aW9uRW5kZWQgPSB0cnVlO1xuXG4gICAgICBpZiAobm9EYXRhT3B0cy5hbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHggPSAxMDtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICB9IGVsc2UgaWYgKG5vRGF0YU9wdHMuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeCA9IHcuZ2xvYmFscy5zdmdXaWR0aCAtIDEwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChub0RhdGFPcHRzLnZlcnRpY2FsQWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkgPSA1MDtcbiAgICAgIH0gZWxzZSBpZiAobm9EYXRhT3B0cy52ZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICB5ID0gdy5nbG9iYWxzLnN2Z0hlaWdodCAtIDUwO1xuICAgICAgfVxuXG4gICAgICB4ID0geCArIG5vRGF0YU9wdHMub2Zmc2V0WDtcbiAgICAgIHkgPSB5ICsgcGFyc2VJbnQobm9EYXRhT3B0cy5zdHlsZS5mb250U2l6ZSkgKyAyO1xuXG4gICAgICBpZiAobm9EYXRhT3B0cy50ZXh0ICE9PSB1bmRlZmluZWQgJiYgbm9EYXRhT3B0cy50ZXh0ICE9PSAnJykge1xuICAgICAgICB2YXIgdGl0bGVUZXh0ID0gZ3JhcGhpY3MuZHJhd1RleHQoe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICB0ZXh0OiBub0RhdGFPcHRzLnRleHQsXG4gICAgICAgICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvcixcbiAgICAgICAgICBmb250U2l6ZTogbm9EYXRhT3B0cy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiBub0RhdGFPcHRzLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9yZUNvbG9yOiBub0RhdGFPcHRzLnN0eWxlLmNvbG9yLFxuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXRleHQtbm9kYXRhJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGl0bGVUZXh0Lm5vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdhcGV4Y2hhcnRzLXRpdGxlLXRleHQnKTtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5QYXBlci5hZGQodGl0bGVUZXh0KTtcbiAgICAgIH1cbiAgICB9IC8vIFdoZW4gdXNlciBjbGlja3Mgb24gbGVnZW5kcywgdGhlIGNvbGxhcHNlZCBzZXJpZXMgaXMgZmlsbGVkIHdpdGggWzAsMCwwLC4uLiwwXVxuICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGFsdGVyIHRoZSBzZXJpZXMnIGxlbmd0aCBhcyBpdCBpcyB1c2VkIGF0IG1hbnkgcGxhY2VzXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXROdWxsU2VyaWVzVG9aZXJvVmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE51bGxTZXJpZXNUb1plcm9WYWx1ZXMoc2VyaWVzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgZm9yICh2YXIgc2wgPSAwOyBzbCA8IHNlcmllcy5sZW5ndGg7IHNsKyspIHtcbiAgICAgICAgaWYgKHNlcmllc1tzbF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJpZXNbdy5nbG9iYWxzLm1heFZhbHNJbkFycmF5SW5kZXhdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBzZXJpZXNbc2xdLnB1c2goMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXJpZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0FsbFNlcmllc0VxdWFsWFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNBbGxTZXJpZXNFcXVhbFgoKSB7XG4gICAgICB2YXIgZXF1YWxMZW4gPSB0cnVlO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVyZWRTZXJYID0gdGhpcy5maWx0ZXJlZFNlcmllc1goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJlZFNlclgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChmaWx0ZXJlZFNlclhbaV1bMF0gIT09IGZpbHRlcmVkU2VyWFtpICsgMV1bMF0pIHtcbiAgICAgICAgICBlcXVhbExlbiA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHcuZ2xvYmFscy5hbGxTZXJpZXNIYXNFcXVhbFggPSBlcXVhbExlbjtcbiAgICAgIHJldHVybiBlcXVhbExlbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsdGVyZWRTZXJpZXNYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcmVkU2VyaWVzWCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGZpbHRlcmVkU2VyaWVzWCA9IHcuZ2xvYmFscy5zZXJpZXNYLm1hcChmdW5jdGlvbiAoc2VyLCBpbmRleCkge1xuICAgICAgICBpZiAoc2VyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gc2VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWRTZXJpZXNYO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTZXJpZXM7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBEaW1lbnNpb25zIENsYXNzIGZvciBjYWxjdWxhdGluZyByZWN0cyBvZiBhbGwgZWxlbWVudHMgdGhhdCBhcmUgZHJhd24gYW5kIHdpbGwgYmUgZHJhd24uXG4gKlxuICogQG1vZHVsZSBEaW1lbnNpb25zXG4gKiovXG5cbnZhciBEaW1lbnNpb25zID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGltZW5zaW9ucyhjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGltZW5zaW9ucyk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmxnUmVjdCA9IHt9O1xuICAgIHRoaXMueUF4aXNXaWR0aCA9IDA7XG4gICAgdGhpcy54QXhpc0hlaWdodCA9IDA7XG4gICAgdGhpcy5pc1NwYXJrbGluZSA9IHRoaXMudy5jb25maWcuY2hhcnQuc3BhcmtsaW5lLmVuYWJsZWQ7XG4gICAgdGhpcy54UGFkUmlnaHQgPSAwO1xuICAgIHRoaXMueFBhZExlZnQgPSAwO1xuICAgIHRoaXMuaXNCYXJIb3Jpem9udGFsID0gISEodGhpcy53LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB0aGlzLncuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsKTtcbiAgfVxuICAvKipcbiAgICogQG1lbWJlcm9mIERpbWVuc2lvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IHcgLSBjaGFydCBjb250ZXh0XG4gICAqKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhEaW1lbnNpb25zLCBbe1xuICAgIGtleTogXCJwbG90Q29vcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsb3RDb29yZHMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgIHZhciBsZ1JlY3QgPSB0aGlzLmdldExlZ2VuZHNSZWN0KCk7XG5cbiAgICAgIGlmIChnbC5heGlzQ2hhcnRzKSB7XG4gICAgICAgIC8vIGZvciBsaW5lIC8gYXJlYSAvIHNjYXR0ZXIgLyBjb2x1bW5cbiAgICAgICAgdGhpcy5zZXRHcmlkQ29vcmRzRm9yQXhpc0NoYXJ0cyhsZ1JlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZm9yIHBpZSAvIGRvbnV0cyAvIGNpcmNsZVxuICAgICAgICB0aGlzLnNldEdyaWRDb29yZHNGb3JOb25BeGlzQ2hhcnRzKGxnUmVjdCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGl0bGVTdWJ0aXRsZU9mZnNldCgpOyAvLyBhZnRlciBjYWxjdWxhdGluZyBldmVyeXRoaW5nLCBhcHBseSBwYWRkaW5nIHNldCBieSB1c2VyXG5cbiAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5ncmlkSGVpZ2h0IC0gdy5jb25maWcuZ3JpZC5wYWRkaW5nLnRvcCAtIHcuY29uZmlnLmdyaWQucGFkZGluZy5ib3R0b207XG4gICAgICBnbC5ncmlkV2lkdGggPSBnbC5ncmlkV2lkdGggLSB3LmNvbmZpZy5ncmlkLnBhZGRpbmcubGVmdCAtIHcuY29uZmlnLmdyaWQucGFkZGluZy5yaWdodCAtIHRoaXMueFBhZFJpZ2h0IC0gdGhpcy54UGFkTGVmdDtcbiAgICAgIGdsLnRyYW5zbGF0ZVggPSBnbC50cmFuc2xhdGVYICsgdy5jb25maWcuZ3JpZC5wYWRkaW5nLmxlZnQgKyB0aGlzLnhQYWRMZWZ0O1xuICAgICAgZ2wudHJhbnNsYXRlWSA9IGdsLnRyYW5zbGF0ZVkgKyB3LmNvbmZpZy5ncmlkLnBhZGRpbmcudG9wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25kaXRpb25hbENoZWNrc0ZvckF4aXNDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZGl0aW9uYWxDaGVja3NGb3JBeGlzQ29vcmRzKHhheGlzTGFiZWxDb29yZHMsIHh0aXRsZUNvb3Jkcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gKHhheGlzTGFiZWxDb29yZHMuaGVpZ2h0ICsgeHRpdGxlQ29vcmRzLmhlaWdodCkgKiB3Lmdsb2JhbHMuTElORV9IRUlHSFRfUkFUSU8gKyAxNTtcbiAgICAgIHRoaXMueEF4aXNXaWR0aCA9IHhheGlzTGFiZWxDb29yZHMud2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLnhBeGlzSGVpZ2h0IC0geHRpdGxlQ29vcmRzLmhlaWdodCA+IHcuY29uZmlnLnhheGlzLmxhYmVscy5tYXhIZWlnaHQpIHtcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IHcuY29uZmlnLnhheGlzLmxhYmVscy5tYXhIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMubWluSGVpZ2h0ICYmIHRoaXMueEF4aXNIZWlnaHQgPCB3LmNvbmZpZy54YXhpcy5sYWJlbHMubWluSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSB3LmNvbmZpZy54YXhpcy5sYWJlbHMubWluSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMuZmxvYXRpbmcpIHtcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gdGhpcy5nZXRUb3RhbFlBeGlzV2lkdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHcuZ2xvYmFscy55TGFiZWxzQ29vcmRzWzBdLndpZHRoICsgdy5nbG9iYWxzLnlUaXRsZUNvb3Jkc1swXS53aWR0aCArIDE1O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXcuZ2xvYmFscy5pc011bHRpcGxlWUF4aXMpIHtcbiAgICAgICAgaWYgKHRoaXMueUF4aXNXaWR0aCA8IHcuY29uZmlnLnlheGlzWzBdLmxhYmVscy5taW5XaWR0aCkge1xuICAgICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHcuY29uZmlnLnlheGlzWzBdLmxhYmVscy5taW5XaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnlBeGlzV2lkdGggPiB3LmNvbmZpZy55YXhpc1swXS5sYWJlbHMubWF4V2lkdGgpIHtcbiAgICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3LmNvbmZpZy55YXhpc1swXS5sYWJlbHMubWF4V2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0R3JpZENvb3Jkc0ZvckF4aXNDaGFydHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0R3JpZENvb3Jkc0ZvckF4aXNDaGFydHMobGdSZWN0KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgIHZhciB5YXhpc0xhYmVsQ29vcmRzID0gdGhpcy5nZXR5QXhpc0xhYmVsc0Nvb3JkcygpO1xuICAgICAgdmFyIHhheGlzTGFiZWxDb29yZHMgPSB0aGlzLmdldHhBeGlzTGFiZWxzQ29vcmRzKCk7XG4gICAgICB2YXIgeVRpdGxlQ29vcmRzID0gdGhpcy5nZXR5QXhpc1RpdGxlQ29vcmRzKCk7XG4gICAgICB2YXIgeHRpdGxlQ29vcmRzID0gdGhpcy5nZXR4QXhpc1RpdGxlQ29vcmRzKCk7XG4gICAgICB3Lmdsb2JhbHMueUxhYmVsc0Nvb3JkcyA9IFtdO1xuICAgICAgdy5nbG9iYWxzLnlUaXRsZUNvb3JkcyA9IFtdO1xuICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAvLyBzdG9yZSB0aGUgbGFiZWxzIGFuZCB0aXRsZXMgY29vcmRzIGluIGdsb2JhbCB2YXJzXG4gICAgICAgIHcuZ2xvYmFscy55TGFiZWxzQ29vcmRzLnB1c2goe1xuICAgICAgICAgIHdpZHRoOiB5YXhpc0xhYmVsQ29vcmRzW2luZGV4XS53aWR0aCxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICAgIHcuZ2xvYmFscy55VGl0bGVDb29yZHMucHVzaCh7XG4gICAgICAgICAgd2lkdGg6IHlUaXRsZUNvb3Jkc1tpbmRleF0ud2lkdGgsXG4gICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbmRpdGlvbmFsQ2hlY2tzRm9yQXhpc0Nvb3Jkcyh4YXhpc0xhYmVsQ29vcmRzLCB4dGl0bGVDb29yZHMpO1xuICAgICAgZ2wudHJhbnNsYXRlWEF4aXNZID0gdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPyB0aGlzLnhBeGlzSGVpZ2h0IC8gOCA6IC00O1xuICAgICAgZ2wudHJhbnNsYXRlWEF4aXNYID0gdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgJiYgdy5nbG9iYWxzLmlzWE51bWVyaWMgJiYgdy5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZSA8PSAtNDUgPyAtdGhpcy54QXhpc1dpZHRoIC8gNCA6IDA7XG5cbiAgICAgIGlmICh0aGlzLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICBnbC5yb3RhdGVYTGFiZWxzID0gZmFsc2U7XG4gICAgICAgIGdsLnRyYW5zbGF0ZVhBeGlzWSA9IC0xICogKHBhcnNlSW50KHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250U2l6ZSkgLyAxLjUpO1xuICAgICAgfVxuXG4gICAgICBnbC50cmFuc2xhdGVYQXhpc1kgPSBnbC50cmFuc2xhdGVYQXhpc1kgKyB3LmNvbmZpZy54YXhpcy5sYWJlbHMub2Zmc2V0WTtcbiAgICAgIGdsLnRyYW5zbGF0ZVhBeGlzWCA9IGdsLnRyYW5zbGF0ZVhBeGlzWCArIHcuY29uZmlnLnhheGlzLmxhYmVscy5vZmZzZXRYO1xuICAgICAgdmFyIHlBeGlzV2lkdGggPSB0aGlzLnlBeGlzV2lkdGg7XG4gICAgICB2YXIgeEF4aXNIZWlnaHQgPSB0aGlzLnhBeGlzSGVpZ2h0O1xuICAgICAgZ2wueEF4aXNMYWJlbHNIZWlnaHQgPSB0aGlzLnhBeGlzSGVpZ2h0O1xuICAgICAgZ2wueEF4aXNIZWlnaHQgPSB0aGlzLnhBeGlzSGVpZ2h0O1xuICAgICAgdmFyIHRyYW5zbGF0ZVkgPSAxMDtcblxuICAgICAgaWYgKCF3LmNvbmZpZy5ncmlkLnNob3cgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3JhZGFyJykge1xuICAgICAgICB5QXhpc1dpZHRoID0gMDtcbiAgICAgICAgeEF4aXNIZWlnaHQgPSAzNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNTcGFya2xpbmUpIHtcbiAgICAgICAgbGdSZWN0ID0ge1xuICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICB3aWR0aDogMFxuICAgICAgICB9O1xuICAgICAgICB4QXhpc0hlaWdodCA9IDA7XG4gICAgICAgIHlBeGlzV2lkdGggPSAwO1xuICAgICAgICB0cmFuc2xhdGVZID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRpdGlvbmFsUGFkZGluZ1hMYWJlbHMoeGF4aXNMYWJlbENvb3Jkcyk7XG5cbiAgICAgIHN3aXRjaCAody5jb25maWcubGVnZW5kLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IHRyYW5zbGF0ZVk7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IHlBeGlzV2lkdGg7XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLnN2Z0hlaWdodCAtIGxnUmVjdC5oZWlnaHQgLSB4QXhpc0hlaWdodCAtICghdGhpcy5pc1NwYXJrbGluZSA/IHcuZ2xvYmFscy5yb3RhdGVYTGFiZWxzID8gMTAgOiAxNSA6IDApO1xuICAgICAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLnN2Z1dpZHRoIC0geUF4aXNXaWR0aDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGdsLnRyYW5zbGF0ZVkgPSBsZ1JlY3QuaGVpZ2h0ICsgdHJhbnNsYXRlWTtcbiAgICAgICAgICBnbC50cmFuc2xhdGVYID0geUF4aXNXaWR0aDtcbiAgICAgICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0IC0gbGdSZWN0LmhlaWdodCAtIHhBeGlzSGVpZ2h0IC0gKCF0aGlzLmlzU3BhcmtsaW5lID8gdy5nbG9iYWxzLnJvdGF0ZVhMYWJlbHMgPyAxMCA6IDE1IDogMCk7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSB5QXhpc1dpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGdsLnRyYW5zbGF0ZVkgPSB0cmFuc2xhdGVZO1xuICAgICAgICAgIGdsLnRyYW5zbGF0ZVggPSBsZ1JlY3Qud2lkdGggKyB5QXhpc1dpZHRoO1xuICAgICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5zdmdIZWlnaHQgLSB4QXhpc0hlaWdodCAtIDEyO1xuICAgICAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLnN2Z1dpZHRoIC0gbGdSZWN0LndpZHRoIC0geUF4aXNXaWR0aDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IHRyYW5zbGF0ZVk7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IHlBeGlzV2lkdGg7XG4gICAgICAgICAgZ2wuZ3JpZEhlaWdodCA9IGdsLnN2Z0hlaWdodCAtIHhBeGlzSGVpZ2h0IC0gMTI7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSBsZ1JlY3Qud2lkdGggLSB5QXhpc1dpZHRoIC0gNTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGVnZW5kIHBvc2l0aW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRHcmlkWFBvc0ZvckR1YWxZQXhpcyh5VGl0bGVDb29yZHMsIHlheGlzTGFiZWxDb29yZHMpOyAvLyBhZnRlciBkcmF3aW5nIGV2ZXJ5dGhpbmcsIHNldCB0aGUgWSBheGlzIHBvc2l0aW9uc1xuXG4gICAgICB2YXIgb2JqeUF4aXMgPSBuZXcgWUF4aXModGhpcy5jdHgpO1xuICAgICAgb2JqeUF4aXMuc2V0WUF4aXNYUG9zaXRpb24oeWF4aXNMYWJlbENvb3JkcywgeVRpdGxlQ29vcmRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0R3JpZENvb3Jkc0Zvck5vbkF4aXNDaGFydHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0R3JpZENvb3Jkc0Zvck5vbkF4aXNDaGFydHMobGdSZWN0KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgIHZhciB4UGFkID0gMDtcblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5zaG93ICYmICF3LmNvbmZpZy5sZWdlbmQuZmxvYXRpbmcpIHtcbiAgICAgICAgeFBhZCA9IDIwO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2ZmWSA9IDEwO1xuICAgICAgdmFyIG9mZlggPSAwO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ3BpZScgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2RvbnV0Jykge1xuICAgICAgICBvZmZZID0gb2ZmWSArIHcuY29uZmlnLnBsb3RPcHRpb25zLnBpZS5vZmZzZXRZO1xuICAgICAgICBvZmZYID0gb2ZmWCArIHcuY29uZmlnLnBsb3RPcHRpb25zLnBpZS5vZmZzZXRYO1xuICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFkaWFsQmFyJykge1xuICAgICAgICBvZmZZID0gb2ZmWSArIHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5vZmZzZXRZO1xuICAgICAgICBvZmZYID0gb2ZmWCArIHcuY29uZmlnLnBsb3RPcHRpb25zLnJhZGlhbEJhci5vZmZzZXRYO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXcuY29uZmlnLmxlZ2VuZC5zaG93KSB7XG4gICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5zdmdIZWlnaHQgLSAzNTtcbiAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuZ3JpZEhlaWdodDtcbiAgICAgICAgZ2wudHJhbnNsYXRlWSA9IG9mZlkgLSAxMDtcbiAgICAgICAgZ2wudHJhbnNsYXRlWCA9IG9mZlggKyAoZ2wuc3ZnV2lkdGggLSBnbC5ncmlkV2lkdGgpIC8gMjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbikge1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5zdmdIZWlnaHQgLSBsZ1JlY3QuaGVpZ2h0IC0gMzU7XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuZ3JpZEhlaWdodDtcbiAgICAgICAgICBnbC50cmFuc2xhdGVZID0gb2ZmWSAtIDIwO1xuICAgICAgICAgIGdsLnRyYW5zbGF0ZVggPSBvZmZYICsgKGdsLnN2Z1dpZHRoIC0gZ2wuZ3JpZFdpZHRoKSAvIDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICBnbC5ncmlkSGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0IC0gbGdSZWN0LmhlaWdodCAtIDM1O1xuICAgICAgICAgIGdsLmdyaWRXaWR0aCA9IGdsLmdyaWRIZWlnaHQ7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IGxnUmVjdC5oZWlnaHQgKyBvZmZZO1xuICAgICAgICAgIGdsLnRyYW5zbGF0ZVggPSBvZmZYICsgKGdsLnN2Z1dpZHRoIC0gZ2wuZ3JpZFdpZHRoKSAvIDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgZ2wuZ3JpZFdpZHRoID0gZ2wuc3ZnV2lkdGggLSBsZ1JlY3Qud2lkdGggLSB4UGFkO1xuICAgICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5ncmlkV2lkdGg7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IG9mZlk7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IG9mZlggKyBsZ1JlY3Qud2lkdGggKyB4UGFkO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBnbC5ncmlkV2lkdGggPSBnbC5zdmdXaWR0aCAtIGxnUmVjdC53aWR0aCAtIHhQYWQgLSA1O1xuICAgICAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5ncmlkV2lkdGg7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWSA9IG9mZlk7XG4gICAgICAgICAgZ2wudHJhbnNsYXRlWCA9IG9mZlggKyAxMDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGVnZW5kIHBvc2l0aW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0R3JpZFhQb3NGb3JEdWFsWUF4aXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0R3JpZFhQb3NGb3JEdWFsWUF4aXMoeVRpdGxlQ29vcmRzLCB5YXhpc0xhYmVsQ29vcmRzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHcuY29uZmlnLnlheGlzLm1hcChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5pZ25vcmVZQXhpc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xICYmICF3LmNvbmZpZy55YXhpc1tpbmRleF0uZmxvYXRpbmcgJiYgdy5jb25maWcueWF4aXNbaW5kZXhdLnNob3cpIHtcbiAgICAgICAgICBpZiAoeWF4ZS5vcHBvc2l0ZSkge1xuICAgICAgICAgICAgdy5nbG9iYWxzLnRyYW5zbGF0ZVggPSB3Lmdsb2JhbHMudHJhbnNsYXRlWCAtICh5YXhpc0xhYmVsQ29vcmRzW2luZGV4XS53aWR0aCArIHlUaXRsZUNvb3Jkc1tpbmRleF0ud2lkdGgpIC0gcGFyc2VJbnQody5jb25maWcueWF4aXNbaW5kZXhdLmxhYmVscy5zdHlsZS5mb250U2l6ZSkgLyAxLjIgLSAxMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gU29tZXRpbWVzLCB0aGUgbGFzdCBsYWJlbHMgZ2V0cyBjcm9wcGVkIGluIGNhdGVnb3J5L251bWVyaWMgeGF4aXMuXG4gICAgLy8gSGVuY2UsIHdlIGFkZCBzb21lIGFkZGl0aW9uYWwgcGFkZGluZyBiYXNlZCBvbiB0aGUgbGFiZWwgbGVuZ3RoIHRvIGF2b2lkIHRoZSBsYXN0IGxhYmVsIGJlaW5nIGNyb3BwZWQuXG4gICAgLy8gTk9URTogZGF0ZXRpbWUgeC1heGlzIHdvbid0IGhhdmUgYW55IGVmZmVjdCB3aXRoIHRoaXMgYXMgd2UgZG9uJ3Qga25vdyB0aGUgbGFiZWwgbGVuZ3RoIHRoZXJlIGR1ZSB0byBtYW55IGNvbnN0cmFpbnRzLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkaXRpb25hbFBhZGRpbmdYTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZGl0aW9uYWxQYWRkaW5nWExhYmVscyh4YXhpc0xhYmVsQ29vcmRzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdjYXRlZ29yeScgJiYgdGhpcy5pc0Jhckhvcml6b250YWwgfHwgdy5jb25maWcueGF4aXMudHlwZSA9PT0gJ251bWVyaWMnKSB7XG4gICAgICAgIHZhciByaWdodFBhZCA9IGZ1bmN0aW9uIHJpZ2h0UGFkKGxhYmVscykge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnBhZGRpbmcucmlnaHQgPCBsYWJlbHMud2lkdGgpIHtcbiAgICAgICAgICAgIF90aGlzLnhQYWRSaWdodCA9IGxhYmVscy53aWR0aCAvIDIgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGVmdFBhZCA9IGZ1bmN0aW9uIGxlZnRQYWQobGFiZWxzKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQucGFkZGluZy5sZWZ0IDwgbGFiZWxzLndpZHRoKSB7XG4gICAgICAgICAgICBfdGhpcy54UGFkTGVmdCA9IGxhYmVscy53aWR0aCAvIDIgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGluZUFyZWEgPSB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnbGluZScgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2FyZWEnO1xuICAgICAgICB3LmNvbmZpZy55YXhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5YXhlLCBpKSB7XG4gICAgICAgICAgdmFyIHNob3VsZFBhZCA9ICF5YXhlLnNob3cgfHwgeWF4ZS5mbG9hdGluZyB8fCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpICE9PSAtMSB8fCBsaW5lQXJlYSB8fCB5YXhlLm9wcG9zaXRlICYmIF90aGlzLmlzQmFySG9yaXpvbnRhbDtcblxuICAgICAgICAgIGlmIChzaG91bGRQYWQpIHtcbiAgICAgICAgICAgIGlmIChsaW5lQXJlYSAmJiB3Lmdsb2JhbHMuaXNNdWx0aXBsZVlBeGlzICYmIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmluZGV4T2YoaSkgIT09IC0xIHx8IF90aGlzLmlzQmFySG9yaXpvbnRhbCAmJiB5YXhlLm9wcG9zaXRlKSB7XG4gICAgICAgICAgICAgIGxlZnRQYWQoeGF4aXNMYWJlbENvb3Jkcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNCYXJIb3Jpem9udGFsICYmIHlheGUub3Bwb3NpdGUgJiYgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihpKSAhPT0gLTEgfHwgbGluZUFyZWEgJiYgIXcuZ2xvYmFscy5pc011bHRpcGxlWUF4aXMpIHtcbiAgICAgICAgICAgICAgcmlnaHRQYWQoeGF4aXNMYWJlbENvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGl0bGVTdWJ0aXRsZU9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aXRsZVN1YnRpdGxlT2Zmc2V0KCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ2wgPSB3Lmdsb2JhbHM7XG4gICAgICB2YXIgZ3JpZFNocmlua09mZnNldCA9IHRoaXMuaXNTcGFya2xpbmUgPyAwIDogMTA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy50aXRsZS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ3JpZFNocmlua09mZnNldCArPSB3LmNvbmZpZy50aXRsZS5tYXJnaW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmlkU2hyaW5rT2Zmc2V0ICs9IHRoaXMuaXNTcGFya2xpbmUgPyAwIDogNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnN1YnRpdGxlLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBncmlkU2hyaW5rT2Zmc2V0ICs9IHcuY29uZmlnLnN1YnRpdGxlLm1hcmdpbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRTaHJpbmtPZmZzZXQgKz0gdGhpcy5pc1NwYXJrbGluZSA/IDAgOiA1O1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcubGVnZW5kLnNob3cgJiYgdy5jb25maWcubGVnZW5kLnBvc2l0aW9uID09PSAnYm90dG9tJyAmJiAhdy5jb25maWcubGVnZW5kLmZsb2F0aW5nICYmIHcuY29uZmlnLnNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGdyaWRTaHJpbmtPZmZzZXQgKz0gMTA7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aXRsZUNvb3JkcyA9IHRoaXMuZ2V0VGl0bGVTdWJ0aXRsZUNvb3JkcygndGl0bGUnKTtcbiAgICAgIHZhciBzdWJ0aXRsZUNvb3JkcyA9IHRoaXMuZ2V0VGl0bGVTdWJ0aXRsZUNvb3Jkcygnc3VidGl0bGUnKTtcbiAgICAgIGdsLmdyaWRIZWlnaHQgPSBnbC5ncmlkSGVpZ2h0IC0gdGl0bGVDb29yZHMuaGVpZ2h0IC0gc3VidGl0bGVDb29yZHMuaGVpZ2h0IC0gZ3JpZFNocmlua09mZnNldDtcbiAgICAgIGdsLnRyYW5zbGF0ZVkgPSBnbC50cmFuc2xhdGVZICsgdGl0bGVDb29yZHMuaGVpZ2h0ICsgc3VidGl0bGVDb29yZHMuaGVpZ2h0ICsgZ3JpZFNocmlua09mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VG90YWxZQXhpc1dpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdGFsWUF4aXNXaWR0aCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHlBeGlzV2lkdGggPSAwO1xuICAgICAgdmFyIHBhZGRpbmcgPSAxMDtcblxuICAgICAgdmFyIGlzSGlkZGVuWUF4aXMgPSBmdW5jdGlvbiBpc0hpZGRlbllBeGlzKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB3Lmdsb2JhbHMuaWdub3JlWUF4aXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID4gLTE7XG4gICAgICB9O1xuXG4gICAgICB3Lmdsb2JhbHMueUxhYmVsc0Nvb3Jkcy5tYXAoZnVuY3Rpb24gKHlMYWJlbENvb3JkLCBpbmRleCkge1xuICAgICAgICB2YXIgZmxvYXRpbmcgPSB3LmNvbmZpZy55YXhpc1tpbmRleF0uZmxvYXRpbmc7XG5cbiAgICAgICAgaWYgKHlMYWJlbENvb3JkLndpZHRoID4gMCAmJiAhZmxvYXRpbmcpIHtcbiAgICAgICAgICB5QXhpc1dpZHRoID0geUF4aXNXaWR0aCArIHlMYWJlbENvb3JkLndpZHRoICsgcGFkZGluZztcblxuICAgICAgICAgIGlmIChpc0hpZGRlbllBeGlzKGluZGV4KSkge1xuICAgICAgICAgICAgeUF4aXNXaWR0aCA9IHlBeGlzV2lkdGggLSB5TGFiZWxDb29yZC53aWR0aCAtIHBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlBeGlzV2lkdGggPSB5QXhpc1dpZHRoICsgKGZsb2F0aW5nIHx8ICF3LmNvbmZpZy55YXhpc1tpbmRleF0uc2hvdyA/IDAgOiA1KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3Lmdsb2JhbHMueVRpdGxlQ29vcmRzLm1hcChmdW5jdGlvbiAoeVRpdGxlQ29vcmQsIGluZGV4KSB7XG4gICAgICAgIHZhciBmbG9hdGluZyA9IHcuY29uZmlnLnlheGlzW2luZGV4XS5mbG9hdGluZztcbiAgICAgICAgcGFkZGluZyA9IHBhcnNlSW50KHcuY29uZmlnLnlheGlzW2luZGV4XS50aXRsZS5zdHlsZS5mb250U2l6ZSk7XG5cbiAgICAgICAgaWYgKHlUaXRsZUNvb3JkLndpZHRoID4gMCAmJiAhZmxvYXRpbmcpIHtcbiAgICAgICAgICB5QXhpc1dpZHRoID0geUF4aXNXaWR0aCArIHlUaXRsZUNvb3JkLndpZHRoICsgcGFkZGluZztcblxuICAgICAgICAgIGlmIChpc0hpZGRlbllBeGlzKGluZGV4KSkge1xuICAgICAgICAgICAgeUF4aXNXaWR0aCA9IHlBeGlzV2lkdGggLSB5VGl0bGVDb29yZC53aWR0aCAtIHBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlBeGlzV2lkdGggPSB5QXhpc1dpZHRoICsgKGZsb2F0aW5nIHx8ICF3LmNvbmZpZy55YXhpc1tpbmRleF0uc2hvdyA/IDAgOiA1KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4geUF4aXNXaWR0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0eEF4aXNUaW1lU2NhbGVMYWJlbHNDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0eEF4aXNUaW1lU2NhbGVMYWJlbHNDb29yZHMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciByZWN0O1xuICAgICAgdmFyIHRpbWVzY2FsZUxhYmVscyA9IHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5zbGljZSgpO1xuICAgICAgdmFyIGxhYmVscyA9IHRpbWVzY2FsZUxhYmVscy5tYXAoZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBsYWJlbC52YWx1ZTtcbiAgICAgIH0pOyAvLyAgZ2V0IHRoZSBsb25nZXN0IHN0cmluZyBmcm9tIHRoZSBsYWJlbHMgYXJyYXkgYW5kIGFsc28gYXBwbHkgbGFiZWwgZm9ybWF0dGVyIHRvIGl0XG5cbiAgICAgIHZhciB2YWwgPSBsYWJlbHMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIC8vIGlmIHVuZGVmaW5lZCwgbWF5YmUgdXNlciBkaWRuJ3QgcGFzcyB0aGUgZGF0ZXRpbWUoeCkgdmFsdWVzXG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdZb3UgaGF2ZSBwb3NzaWJseSBzdXBwbGllZCBpbnZhbGlkIERhdGUgZm9ybWF0LiBQbGVhc2Ugc3VwcGx5IGEgdmFsaWQgSmF2YVNjcmlwdCBEYXRlJyk7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYjtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgcmVjdCA9IGdyYXBoaWNzLmdldFRleHRSZWN0cyh2YWwsIHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250U2l6ZSk7XG4gICAgICB2YXIgdG90YWxXaWR0aFJvdGF0ZWQgPSByZWN0LndpZHRoICogMS4wNSAqIGxhYmVscy5sZW5ndGg7XG5cbiAgICAgIGlmICh0b3RhbFdpZHRoUm90YXRlZCA+IHcuZ2xvYmFscy5ncmlkV2lkdGggJiYgdy5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZSAhPT0gMCkge1xuICAgICAgICB3Lmdsb2JhbHMub3ZlcmxhcHBpbmdYTGFiZWxzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBYIEF4aXMgRGltZW5zaW9uc1xuICAgICAqIEBtZW1iZXJvZiBEaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7e3dpZHRoLCBoZWlnaHR9fVxuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldHhBeGlzTGFiZWxzQ29vcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldHhBeGlzTGFiZWxzQ29vcmRzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgeGF4aXNMYWJlbHMgPSB3Lmdsb2JhbHMubGFiZWxzLnNsaWNlKCk7XG4gICAgICB2YXIgcmVjdDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldHhBeGlzVGltZVNjYWxlTGFiZWxzQ29vcmRzKCk7XG4gICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgd2lkdGg6IGNvb3Jkcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNvb3Jkcy5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsZ1dpZHRoRm9yU2lkZUxlZ2VuZHMgPSB3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdsZWZ0JyAmJiB3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdyaWdodCcgJiYgIXcuY29uZmlnLmxlZ2VuZC5mbG9hdGluZyA/IHRoaXMubGdSZWN0LndpZHRoIDogMDsgLy8gIGdldCB0aGUgbG9uZ2VzdCBzdHJpbmcgZnJvbSB0aGUgbGFiZWxzIGFycmF5IGFuZCBhbHNvIGFwcGx5IGxhYmVsIGZvcm1hdHRlciB0byBpdFxuXG4gICAgICAgIHZhciB2YWwgPSB4YXhpc0xhYmVscy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiO1xuICAgICAgICB9LCAwKTsgLy8gdGhlIGxhYmVscyBnZXRzIGNoYW5nZWQgZm9yIGJhciBjaGFydHNcblxuICAgICAgICBpZiAodGhpcy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICB2YWwgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5yZXN1bHQucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhsYkZvcm1hdHRlciA9IHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXI7XG4gICAgICAgIHZhciB4Rm9ybWF0ID0gbmV3IEZvcm1hdHRlcnModGhpcy5jdHgpO1xuICAgICAgICB2YWwgPSB4Rm9ybWF0LnhMYWJlbEZvcm1hdCh4bGJGb3JtYXR0ZXIsIHZhbCk7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB4TGFiZWxyZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHZhbCwgdy5jb25maWcueGF4aXMubGFiZWxzLnN0eWxlLmZvbnRTaXplKTtcbiAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICB3aWR0aDogeExhYmVscmVjdC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHhMYWJlbHJlY3QuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlY3Qud2lkdGggKiB4YXhpc0xhYmVscy5sZW5ndGggPiB3Lmdsb2JhbHMuc3ZnV2lkdGggLSBsZ1dpZHRoRm9yU2lkZUxlZ2VuZHMgLSB0aGlzLnlBeGlzV2lkdGggJiYgdy5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZSAhPT0gMCkge1xuICAgICAgICAgIGlmICghdGhpcy5pc0Jhckhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5yb3RhdGVYTGFiZWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIHhMYWJlbHJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHModmFsLCB3LmNvbmZpZy54YXhpcy5sYWJlbHMuc3R5bGUuZm9udFNpemUsIHcuY29uZmlnLnhheGlzLmxhYmVscy5zdHlsZS5mb250RmFtaWx5LCBcInJvdGF0ZShcIi5jb25jYXQody5jb25maWcueGF4aXMubGFiZWxzLnJvdGF0ZSwgXCIgMCAwKVwiKSwgZmFsc2UpO1xuICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSB4TGFiZWxyZWN0LmhlaWdodCAvIDEuNjY7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcuZ2xvYmFscy5yb3RhdGVYTGFiZWxzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF3LmNvbmZpZy54YXhpcy5sYWJlbHMuc2hvdykge1xuICAgICAgICByZWN0ID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IFkgQXhpcyBEaW1lbnNpb25zXG4gICAgICogQG1lbWJlcm9mIERpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHt7d2lkdGgsIGhlaWdodH19XG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0eUF4aXNMYWJlbHNDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0eUF4aXNMYWJlbHNDb29yZHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICB2YXIgbGFiZWxQYWQgPSAxMDtcbiAgICAgIHcuY29uZmlnLnlheGlzLm1hcChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHlheGUuc2hvdyAmJiB5YXhlLmxhYmVscy5zaG93ICYmIHcuZ2xvYmFscy55QXhpc1NjYWxlW2luZGV4XS5yZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbaW5kZXhdOyAvLyB0aGUgc2Vjb25kIHBhcmFtZXRlciAtMSBpcyB0aGUgaW5kZXggb2YgdGljayB3aGljaCB1c2VyIGNhbiB1c2UgaW4gdGhlIGZvcm1hdHRlclxuXG4gICAgICAgICAgdmFyIHZhbCA9IGxiRm9ybWF0dGVyKHcuZ2xvYmFscy55QXhpc1NjYWxlW2luZGV4XS5uaWNlTWF4LCAtMSk7IC8vIGlmIHVzZXIgaGFzIHNwZWNpZmllZCBhIGN1c3RvbSBmb3JtYXR0ZXIsIGFuZCB0aGUgcmVzdWx0IGlzIG51bGwgb3IgZW1wdHksIHdlIG5lZWQgdG8gZGlzY2FyZCB0aGUgZm9ybWF0dGVyIGFuZCB0YWtlIHRoZSB2YWx1ZSBhcyBpdCBpcy5cblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyB8fCB2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YWwgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVtpbmRleF0ubmljZU1heDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3RoaXMyLmlzQmFySG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgbGFiZWxQYWQgPSAwO1xuICAgICAgICAgICAgdmFyIGJhcllheGlzTGFiZWxzID0gdy5nbG9iYWxzLmxhYmVscy5zbGljZSgpOyAvLyAgZ2V0IHRoZSBsb25nZXN0IHN0cmluZyBmcm9tIHRoZSBsYWJlbHMgYXJyYXkgYW5kIGFsc28gYXBwbHkgbGFiZWwgZm9ybWF0dGVyIHRvIGl0XG5cbiAgICAgICAgICAgIHZhbCA9IGJhcllheGlzTGFiZWxzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB2YWwgPSBsYkZvcm1hdHRlcih2YWwsIC0xKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoX3RoaXMyLmN0eCk7XG4gICAgICAgICAgdmFyIHJlY3QgPSBncmFwaGljcy5nZXRUZXh0UmVjdHModmFsLCB5YXhlLmxhYmVscy5zdHlsZS5mb250U2l6ZSk7XG4gICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggKyBsYWJlbFBhZCxcbiAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBYIEF4aXMgVGl0bGUgRGltZW5zaW9uc1xuICAgICAqIEBtZW1iZXJvZiBEaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7e3dpZHRoLCBoZWlnaHR9fVxuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldHhBeGlzVGl0bGVDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0eEF4aXNUaXRsZUNvb3JkcygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgIHZhciBoZWlnaHQgPSAwO1xuXG4gICAgICBpZiAody5jb25maWcueGF4aXMudGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHcuY29uZmlnLnhheGlzLnRpdGxlLnRleHQsIHcuY29uZmlnLnhheGlzLnRpdGxlLnN0eWxlLmZvbnRTaXplKTtcbiAgICAgICAgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IFkgQXhpcyBEaW1lbnNpb25zXG4gICAgICogQG1lbWJlcm9mIERpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHt7d2lkdGgsIGhlaWdodH19XG4gICAgICoqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0eUF4aXNUaXRsZUNvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXR5QXhpc1RpdGxlQ29vcmRzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgdy5jb25maWcueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICBpZiAoeWF4ZS5zaG93ICYmIHlheGUudGl0bGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKF90aGlzMy5jdHgpO1xuICAgICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHlheGUudGl0bGUudGV4dCwgeWF4ZS50aXRsZS5zdHlsZS5mb250U2l6ZSwgeWF4ZS50aXRsZS5zdHlsZS5mb250RmFtaWx5LCAncm90YXRlKC05MCAwIDApJywgZmFsc2UpO1xuICAgICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IENoYXJ0IFRpdGxlL1N1YnRpdGxlIERpbWVuc2lvbnNcbiAgICAgKiBAbWVtYmVyb2YgRGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge3t3aWR0aCwgaGVpZ2h0fX1cbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaXRsZVN1YnRpdGxlQ29vcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRpdGxlU3VidGl0bGVDb29yZHModHlwZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICB2YXIgZmxvYXRpbmcgPSB0eXBlID09PSAndGl0bGUnID8gdy5jb25maWcudGl0bGUuZmxvYXRpbmcgOiB3LmNvbmZpZy5zdWJ0aXRsZS5mbG9hdGluZztcbiAgICAgIHZhciBlbCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoXCIuYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItdGV4dFwiKSk7XG5cbiAgICAgIGlmIChlbCAhPT0gbnVsbCAmJiAhZmxvYXRpbmcpIHtcbiAgICAgICAgdmFyIGNvb3JkID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHdpZHRoID0gY29vcmQud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IHcuZ2xvYmFscy5heGlzQ2hhcnRzID8gY29vcmQuaGVpZ2h0ICsgNSA6IGNvb3JkLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGVnZW5kc1JlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGVnZW5kc1JlY3QoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBlbExlZ2VuZFdyYXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1sZWdlbmQnKTtcbiAgICAgIHZhciBsZ1JlY3QgPSBPYmplY3QuYXNzaWduKHt9LCBVdGlscy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxMZWdlbmRXcmFwKSk7XG5cbiAgICAgIGlmIChlbExlZ2VuZFdyYXAgIT09IG51bGwgJiYgIXcuY29uZmlnLmxlZ2VuZC5mbG9hdGluZyAmJiB3LmNvbmZpZy5sZWdlbmQuc2hvdykge1xuICAgICAgICB0aGlzLmxnUmVjdCA9IHtcbiAgICAgICAgICB4OiBsZ1JlY3QueCxcbiAgICAgICAgICB5OiBsZ1JlY3QueSxcbiAgICAgICAgICBoZWlnaHQ6IGxnUmVjdC5oZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IGxnUmVjdC5oZWlnaHQgPT09IDAgPyAwIDogbGdSZWN0LndpZHRoXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxnUmVjdCA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIHdpZHRoOiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxnUmVjdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGltZW5zaW9ucztcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFRpbWVTY2FsZSBDbGFzcyBmb3IgZ2VuZXJhdGluZyB0aW1lIHRpY2tzIGZvciB4LWF4aXMuXG4gKlxuICogQG1vZHVsZSBUaW1lU2NhbGVcbiAqKi9cblxudmFyIFRpbWVTY2FsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRpbWVTY2FsZShjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZVNjYWxlKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMudGltZVNjYWxlQXJyYXkgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaW1lU2NhbGUsIFt7XG4gICAga2V5OiBcImNhbGN1bGF0ZVRpbWVTY2FsZVRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVRpbWVTY2FsZVRpY2tzKG1pblgsIG1heFgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53OyAvLyBudWxsIGNoZWNrIHdoZW4gbm8gc2VyaWVzIHRvIHNob3dcblxuICAgICAgaWYgKHcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQpIHtcbiAgICAgICAgdy5nbG9iYWxzLmxhYmVscyA9IFtdO1xuICAgICAgICB3Lmdsb2JhbHMudGltZWxpbmVMYWJlbHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgdmFyIGRheXNEaWZmID0gKG1heFggLSBtaW5YKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lSW50ZXJ2YWwoZGF5c0RpZmYpO1xuICAgICAgdy5nbG9iYWxzLmRpc2FibGVab29tSW4gPSBmYWxzZTtcbiAgICAgIHcuZ2xvYmFscy5kaXNhYmxlWm9vbU91dCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZGF5c0RpZmYgPCAwLjAwNSkge1xuICAgICAgICB3Lmdsb2JhbHMuZGlzYWJsZVpvb21JbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRheXNEaWZmID4gNTAwMDApIHtcbiAgICAgICAgdy5nbG9iYWxzLmRpc2FibGVab29tT3V0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWVJbnRlcnZhbHMgPSBkdC5nZXRUaW1lVW5pdHNmcm9tVGltZXN0YW1wKG1pblgsIG1heFgpO1xuICAgICAgdmFyIGRheXNXaWR0aE9uWEF4aXMgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gZGF5c0RpZmY7XG4gICAgICB2YXIgaG91cnNXaWR0aE9uWEF4aXMgPSBkYXlzV2lkdGhPblhBeGlzIC8gMjQ7XG4gICAgICB2YXIgbWludXRlc1dpZHRoT25YQXhpcyA9IGhvdXJzV2lkdGhPblhBeGlzIC8gNjA7XG4gICAgICB2YXIgbnVtYmVyT2ZIb3VycyA9IE1hdGguZmxvb3IoZGF5c0RpZmYgKiAyNCk7XG4gICAgICB2YXIgbnVtYmVyT2ZNaW51dGVzID0gTWF0aC5mbG9vcihkYXlzRGlmZiAqIDI0ICogNjApO1xuICAgICAgdmFyIG51bWJlck9mRGF5cyA9IE1hdGguZmxvb3IoZGF5c0RpZmYpO1xuICAgICAgdmFyIG51bWJlck9mTW9udGhzID0gTWF0aC5mbG9vcihkYXlzRGlmZiAvIDMwKTtcbiAgICAgIHZhciBudW1iZXJPZlllYXJzID0gTWF0aC5mbG9vcihkYXlzRGlmZiAvIDM2NSk7XG4gICAgICB2YXIgZmlyc3RWYWwgPSB7XG4gICAgICAgIG1pbk1pbnV0ZTogdGltZUludGVydmFscy5taW5NaW51dGUsXG4gICAgICAgIG1pbkhvdXI6IHRpbWVJbnRlcnZhbHMubWluSG91cixcbiAgICAgICAgbWluRGF0ZTogdGltZUludGVydmFscy5taW5EYXRlLFxuICAgICAgICBtaW5Nb250aDogdGltZUludGVydmFscy5taW5Nb250aCxcbiAgICAgICAgbWluWWVhcjogdGltZUludGVydmFscy5taW5ZZWFyXG4gICAgICB9O1xuICAgICAgdmFyIGN1cnJlbnRNaW51dGUgPSBmaXJzdFZhbC5taW5NaW51dGU7XG4gICAgICB2YXIgY3VycmVudEhvdXIgPSBmaXJzdFZhbC5taW5Ib3VyO1xuICAgICAgdmFyIGN1cnJlbnRNb250aERhdGUgPSBmaXJzdFZhbC5taW5EYXRlO1xuICAgICAgdmFyIGN1cnJlbnREYXRlID0gZmlyc3RWYWwubWluRGF0ZTtcbiAgICAgIHZhciBjdXJyZW50TW9udGggPSBmaXJzdFZhbC5taW5Nb250aDtcbiAgICAgIHZhciBjdXJyZW50WWVhciA9IGZpcnN0VmFsLm1pblllYXI7XG4gICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICBmaXJzdFZhbDogZmlyc3RWYWwsXG4gICAgICAgIGN1cnJlbnRNaW51dGU6IGN1cnJlbnRNaW51dGUsXG4gICAgICAgIGN1cnJlbnRIb3VyOiBjdXJyZW50SG91cixcbiAgICAgICAgY3VycmVudE1vbnRoRGF0ZTogY3VycmVudE1vbnRoRGF0ZSxcbiAgICAgICAgY3VycmVudERhdGU6IGN1cnJlbnREYXRlLFxuICAgICAgICBjdXJyZW50TW9udGg6IGN1cnJlbnRNb250aCxcbiAgICAgICAgY3VycmVudFllYXI6IGN1cnJlbnRZZWFyLFxuICAgICAgICBkYXlzV2lkdGhPblhBeGlzOiBkYXlzV2lkdGhPblhBeGlzLFxuICAgICAgICBob3Vyc1dpZHRoT25YQXhpczogaG91cnNXaWR0aE9uWEF4aXMsXG4gICAgICAgIG1pbnV0ZXNXaWR0aE9uWEF4aXM6IG1pbnV0ZXNXaWR0aE9uWEF4aXMsXG4gICAgICAgIG51bWJlck9mTWludXRlczogbnVtYmVyT2ZNaW51dGVzLFxuICAgICAgICBudW1iZXJPZkhvdXJzOiBudW1iZXJPZkhvdXJzLFxuICAgICAgICBudW1iZXJPZkRheXM6IG51bWJlck9mRGF5cyxcbiAgICAgICAgbnVtYmVyT2ZNb250aHM6IG51bWJlck9mTW9udGhzLFxuICAgICAgICBudW1iZXJPZlllYXJzOiBudW1iZXJPZlllYXJzXG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHRoaXMudGlja0ludGVydmFsKSB7XG4gICAgICAgIGNhc2UgJ3llYXJzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlWWVhclNjYWxlKHBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbW9udGhzJzpcbiAgICAgICAgY2FzZSAnaGFsZl95ZWFyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlTW9udGhTY2FsZShwYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21vbnRoc19kYXlzJzpcbiAgICAgICAgY2FzZSAnbW9udGhzX2ZvcnRuaWdodCc6XG4gICAgICAgIGNhc2UgJ2RheXMnOlxuICAgICAgICBjYXNlICd3ZWVrX2RheXMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVEYXlTY2FsZShwYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2hvdXJzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlSG91clNjYWxlKHBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbWludXRlcyc6XG4gICAgICAgICAgdGhpcy5nZW5lcmF0ZU1pbnV0ZVNjYWxlKHBhcmFtcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIGZpcnN0LCB3ZSB3aWxsIGFkanVzdCB0aGUgbW9udGggdmFsdWVzIGluZGV4XG4gICAgICAvLyBhcyBpbiB0aGUgdXBwZXIgZnVuY3Rpb24sIGl0IGlzIHN0YXJ0aW5nIGZyb20gMFxuICAgICAgLy8gd2Ugd2lsbCBzdGFydCB0aGVtIGZyb20gMVxuXG5cbiAgICAgIHZhciBhZGp1c3RlZE1vbnRoSW5UaW1lU2NhbGVBcnJheSA9IHRoaXMudGltZVNjYWxlQXJyYXkubWFwKGZ1bmN0aW9uICh0cykge1xuICAgICAgICB2YXIgZGVmYXVsdFJldHVybiA9IHtcbiAgICAgICAgICBwb3NpdGlvbjogdHMucG9zaXRpb24sXG4gICAgICAgICAgdW5pdDogdHMudW5pdCxcbiAgICAgICAgICB5ZWFyOiB0cy55ZWFyLFxuICAgICAgICAgIGRheTogdHMuZGF5ID8gdHMuZGF5IDogMSxcbiAgICAgICAgICBob3VyOiB0cy5ob3VyID8gdHMuaG91ciA6IDAsXG4gICAgICAgICAgbW9udGg6IHRzLm1vbnRoICsgMVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0cy51bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRSZXR1cm4sIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cy52YWx1ZSArIDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cy51bml0ID09PSAnZGF5JyB8fCB0cy51bml0ID09PSAnaG91cicpIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFJldHVybiwge1xuICAgICAgICAgICAgdmFsdWU6IHRzLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHMudW5pdCA9PT0gJ21pbnV0ZScpIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFJldHVybiwge1xuICAgICAgICAgICAgdmFsdWU6IHRzLnZhbHVlLFxuICAgICAgICAgICAgbWludXRlOiB0cy52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRzO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmlsdGVyZWRUaW1lU2NhbGUgPSBhZGp1c3RlZE1vbnRoSW5UaW1lU2NhbGVBcnJheS5maWx0ZXIoZnVuY3Rpb24gKHRzKSB7XG4gICAgICAgIHZhciBtb2R1bG8gPSAxO1xuICAgICAgICB2YXIgdGlja3MgPSBNYXRoLmNlaWwody5nbG9iYWxzLmdyaWRXaWR0aCAvIDEyMCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRzLnZhbHVlO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50aWNrQW1vdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aWNrcyA9IHcuY29uZmlnLnhheGlzLnRpY2tBbW91bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRqdXN0ZWRNb250aEluVGltZVNjYWxlQXJyYXkubGVuZ3RoID4gdGlja3MpIHtcbiAgICAgICAgICBtb2R1bG8gPSBNYXRoLmZsb29yKGFkanVzdGVkTW9udGhJblRpbWVTY2FsZUFycmF5Lmxlbmd0aCAvIHRpY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG91bGROb3RTa2lwVW5pdCA9IGZhbHNlOyAvLyB0aGVyZSBpcyBhIGJpZyBjaGFuZ2UgaW4gdW5pdCBpLmUgZGF5cyB0byBtb250aHNcblxuICAgICAgICB2YXIgc2hvdWxkTm90UHJpbnQgPSBmYWxzZTsgLy8gc2hvdWxkIHNraXAgdGhlc2UgdmFsdWVzXG5cbiAgICAgICAgc3dpdGNoIChfdGhpcy50aWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICBjYXNlICdoYWxmX3llYXInOlxuICAgICAgICAgICAgbW9kdWxvID0gNztcblxuICAgICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICBzaG91bGROb3RTa2lwVW5pdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbW9udGhzJzpcbiAgICAgICAgICAgIG1vZHVsbyA9IDE7XG5cbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgc2hvdWxkTm90U2tpcFVuaXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ21vbnRoc19mb3J0bmlnaHQnOlxuICAgICAgICAgICAgbW9kdWxvID0gMTU7XG5cbiAgICAgICAgICAgIGlmICh0cy51bml0ID09PSAneWVhcicgfHwgdHMudW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICBzaG91bGROb3RTa2lwVW5pdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMzApIHtcbiAgICAgICAgICAgICAgc2hvdWxkTm90UHJpbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ21vbnRoc19kYXlzJzpcbiAgICAgICAgICAgIG1vZHVsbyA9IDEwO1xuXG4gICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICBzaG91bGROb3RTa2lwVW5pdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMzApIHtcbiAgICAgICAgICAgICAgc2hvdWxkTm90UHJpbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3dlZWtfZGF5cyc6XG4gICAgICAgICAgICBtb2R1bG8gPSA4O1xuXG4gICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICBzaG91bGROb3RTa2lwVW5pdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZGF5cyc6XG4gICAgICAgICAgICBtb2R1bG8gPSAxO1xuXG4gICAgICAgICAgICBpZiAodHMudW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICBzaG91bGROb3RTa2lwVW5pdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgIHNob3VsZE5vdFNraXBVbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdtaW51dGVzJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZSAlIDUgIT09IDApIHtcbiAgICAgICAgICAgICAgc2hvdWxkTm90UHJpbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcy50aWNrSW50ZXJ2YWwgPT09ICdtaW51dGVzJyB8fCBfdGhpcy50aWNrSW50ZXJ2YWwgPT09ICdob3VycycpIHtcbiAgICAgICAgICBpZiAoIXNob3VsZE5vdFByaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCh2YWx1ZSAlIG1vZHVsbyA9PT0gMCB8fCBzaG91bGROb3RTa2lwVW5pdCkgJiYgIXNob3VsZE5vdFByaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkVGltZVNjYWxlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWNhbGNEaW1lbnNpb25zQmFzZWRPbkZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNhbGNEaW1lbnNpb25zQmFzZWRPbkZvcm1hdChmaWx0ZXJlZFRpbWVTY2FsZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcmVmb3JtYXR0ZWRUaW1lc2NhbGVBcnJheSA9IHRoaXMuZm9ybWF0RGF0ZXMoZmlsdGVyZWRUaW1lU2NhbGUpO1xuICAgICAgdmFyIHJlbW92ZWRPdmVybGFwcGluZ1RTID0gdGhpcy5yZW1vdmVPdmVybGFwcGluZ1RTKHJlZm9ybWF0dGVkVGltZXNjYWxlQXJyYXkpO1xuICAgICAgdy5nbG9iYWxzLnRpbWVsaW5lTGFiZWxzID0gcmVtb3ZlZE92ZXJsYXBwaW5nVFMuc2xpY2UoKTsgLy8gYXQgdGhpcyBzdGFnZSwgd2UgbmVlZCB0byByZS1jYWxjdWxhdGUgY29vcmRzIG9mIHRoZSBncmlkIGFzIHRpbWVsaW5lIGxhYmVscyBtYXkgaGF2ZSBhbHRlcmVkIHRoZSB4YXhpcyBsYWJlbHMgY29vcmRzXG4gICAgICAvLyBUaGUgcmVhc29uIHdlIGNhbid0IGRvIHRoaXMgcHJpb3IgdG8gdGhpcyBzdGFnZSBpcyBiZWNhdXNlIHRpbWVsaW5lIGxhYmVscyBkZXBlbmRzIG9uIGdyaWRXaWR0aCwgYW5kIGFzIHRoZSB0aWNrcyBhcmUgY2FsY3VsYXRlZCBiYXNlZCBvbiBhdmFpbGFibGUgZ3JpZFdpZHRoLCB0aGVyZSBjYW4gYmUgdW5rbm93biBudW1iZXIgb2YgdGlja3MgZ2VuZXJhdGVkIGZvciBkaWZmZXJlbnQgbWluWCBhbmQgbWF4WFxuICAgICAgLy8gRGVwZW5kZW5jeSBvbiBEaW1lbnNpb25zKCksIG5lZWQgdG8gcmVmYWN0b3IgY29ycmVjdGx5XG4gICAgICAvLyBUT0RPIC0gZmluZCBhbiBhbHRlcm5hdGUgd2F5IHRvIGF2b2lkIGNhbGxpbmcgdGhpcyBIZWF2eSBtZXRob2QgdHdpY2VcblxuICAgICAgdmFyIGRpbWVuc2lvbnMgPSBuZXcgRGltZW5zaW9ucyh0aGlzLmN0eCk7XG4gICAgICBkaW1lbnNpb25zLnBsb3RDb29yZHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZXJtaW5lSW50ZXJ2YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lSW50ZXJ2YWwoZGF5c0RpZmYpIHtcbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIGRheXNEaWZmID4gMTgyNTpcbiAgICAgICAgICAvLyBkaWZmZXJlbmNlIGlzIG1vcmUgdGhhbiA1IHllYXJzXG4gICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAneWVhcnMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiA4MDAgJiYgZGF5c0RpZmYgPD0gMTgyNTpcbiAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdoYWxmX3llYXInO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiAxODAgJiYgZGF5c0RpZmYgPD0gODAwOlxuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ21vbnRocyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBkYXlzRGlmZiA+IDkwICYmIGRheXNEaWZmIDw9IDE4MDpcbiAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICdtb250aHNfZm9ydG5pZ2h0JztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGRheXNEaWZmID4gNjAgJiYgZGF5c0RpZmYgPD0gOTA6XG4gICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnbW9udGhzX2RheXMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiAzMCAmJiBkYXlzRGlmZiA8PSA2MDpcbiAgICAgICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9ICd3ZWVrX2RheXMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiAyICYmIGRheXNEaWZmIDw9IDMwOlxuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ2RheXMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgZGF5c0RpZmYgPiAwLjEgJiYgZGF5c0RpZmYgPD0gMjpcbiAgICAgICAgICAvLyBsZXNzIHRoYW4gIDIgZGF5c1xuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ2hvdXJzJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGRheXNEaWZmIDwgMC4xOlxuICAgICAgICAgIHRoaXMudGlja0ludGVydmFsID0gJ21pbnV0ZXMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSAnZGF5cyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlWWVhclNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlWWVhclNjYWxlKHBhcmFtcykge1xuICAgICAgdmFyIGZpcnN0VmFsID0gcGFyYW1zLmZpcnN0VmFsLFxuICAgICAgICAgIGN1cnJlbnRNb250aCA9IHBhcmFtcy5jdXJyZW50TW9udGgsXG4gICAgICAgICAgY3VycmVudFllYXIgPSBwYXJhbXMuY3VycmVudFllYXIsXG4gICAgICAgICAgZGF5c1dpZHRoT25YQXhpcyA9IHBhcmFtcy5kYXlzV2lkdGhPblhBeGlzLFxuICAgICAgICAgIG51bWJlck9mWWVhcnMgPSBwYXJhbXMubnVtYmVyT2ZZZWFycztcbiAgICAgIHZhciBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pblllYXI7XG4gICAgICB2YXIgZmlyc3RUaWNrUG9zaXRpb24gPSAwO1xuICAgICAgdmFyIGR0ID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcbiAgICAgIHZhciB1bml0ID0gJ3llYXInO1xuXG4gICAgICBpZiAoZmlyc3RWYWwubWluRGF0ZSA+IDEgJiYgZmlyc3RWYWwubWluTW9udGggPiAwKSB7XG4gICAgICAgIHZhciByZW1haW5pbmdEYXlzID0gZHQuZGV0ZXJtaW5lUmVtYWluaW5nRGF5c09mWWVhcihmaXJzdFZhbC5taW5ZZWFyLCBmaXJzdFZhbC5taW5Nb250aCwgZmlyc3RWYWwubWluRGF0ZSk7IC8vIHJlbWFpbmluZ0RheXNvZkZpcnN0TW9udGggaXMgdXNlZCB0byByZWFjaHQgdGhlIDJuZCB0aWNrIHBvc2l0aW9uXG5cbiAgICAgICAgdmFyIHJlbWFpbmluZ0RheXNPZkZpcnN0WWVhciA9IGR0LmRldGVybWluZURheXNPZlllYXIoZmlyc3RWYWwubWluWWVhcikgLSByZW1haW5pbmdEYXlzICsgMTsgLy8gY2FsY3VsYXRlIHRoZSBmaXJzdCB0aWNrIHBvc2l0aW9uXG5cbiAgICAgICAgZmlyc3RUaWNrUG9zaXRpb24gPSByZW1haW5pbmdEYXlzT2ZGaXJzdFllYXIgKiBkYXlzV2lkdGhPblhBeGlzO1xuICAgICAgICBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pblllYXIgKyAxOyAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG4gICAgICAgIHRoaXMudGltZVNjYWxlQXJyYXkucHVzaCh7XG4gICAgICAgICAgcG9zaXRpb246IGZpcnN0VGlja1Bvc2l0aW9uLFxuICAgICAgICAgIHZhbHVlOiBmaXJzdFRpY2tWYWx1ZSxcbiAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgIHllYXI6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICAgIG1vbnRoOiBVdGlscy5tb250aE1vZChjdXJyZW50TW9udGggKyAxKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RWYWwubWluRGF0ZSA9PT0gMSAmJiBmaXJzdFZhbC5taW5Nb250aCA9PT0gMCkge1xuICAgICAgICAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBmaXJzdFRpY2tQb3NpdGlvbixcbiAgICAgICAgICB2YWx1ZTogZmlyc3RUaWNrVmFsdWUsXG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICB5ZWFyOiBjdXJyZW50WWVhcixcbiAgICAgICAgICBtb250aDogVXRpbHMubW9udGhNb2QoY3VycmVudE1vbnRoICsgMSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ZWFyID0gZmlyc3RUaWNrVmFsdWU7XG4gICAgICB2YXIgcG9zID0gZmlyc3RUaWNrUG9zaXRpb247IC8vIGtlZXAgZHJhd2luZyByZXN0IG9mIHRoZSB0aWNrc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mWWVhcnM7IGkrKykge1xuICAgICAgICB5ZWFyKys7XG4gICAgICAgIHBvcyA9IGR0LmRldGVybWluZURheXNPZlllYXIoeWVhciAtIDEpICogZGF5c1dpZHRoT25YQXhpcyArIHBvcztcbiAgICAgICAgdGhpcy50aW1lU2NhbGVBcnJheS5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgIHZhbHVlOiB5ZWFyLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICBtb250aDogMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVNb250aFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlTW9udGhTY2FsZShwYXJhbXMpIHtcbiAgICAgIHZhciBmaXJzdFZhbCA9IHBhcmFtcy5maXJzdFZhbCxcbiAgICAgICAgICBjdXJyZW50TW9udGhEYXRlID0gcGFyYW1zLmN1cnJlbnRNb250aERhdGUsXG4gICAgICAgICAgY3VycmVudE1vbnRoID0gcGFyYW1zLmN1cnJlbnRNb250aCxcbiAgICAgICAgICBjdXJyZW50WWVhciA9IHBhcmFtcy5jdXJyZW50WWVhcixcbiAgICAgICAgICBkYXlzV2lkdGhPblhBeGlzID0gcGFyYW1zLmRheXNXaWR0aE9uWEF4aXMsXG4gICAgICAgICAgbnVtYmVyT2ZNb250aHMgPSBwYXJhbXMubnVtYmVyT2ZNb250aHM7XG4gICAgICB2YXIgZmlyc3RUaWNrVmFsdWUgPSBjdXJyZW50TW9udGg7XG4gICAgICB2YXIgZmlyc3RUaWNrUG9zaXRpb24gPSAwO1xuICAgICAgdmFyIGR0ID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcbiAgICAgIHZhciB1bml0ID0gJ21vbnRoJztcbiAgICAgIHZhciB5ckNvdW50ZXIgPSAwO1xuXG4gICAgICBpZiAoZmlyc3RWYWwubWluRGF0ZSA+IDEpIHtcbiAgICAgICAgLy8gcmVtYWluaW5nRGF5c29mRmlyc3RNb250aCBpcyB1c2VkIHRvIHJlYWNodCB0aGUgMm5kIHRpY2sgcG9zaXRpb25cbiAgICAgICAgdmFyIHJlbWFpbmluZ0RheXNPZkZpcnN0TW9udGggPSBkdC5kZXRlcm1pbmVEYXlzT2ZNb250aHMoY3VycmVudE1vbnRoICsgMSwgZmlyc3RWYWwubWluWWVhcikgLSBjdXJyZW50TW9udGhEYXRlICsgMTsgLy8gY2FsY3VsYXRlIHRoZSBmaXJzdCB0aWNrIHBvc2l0aW9uXG5cbiAgICAgICAgZmlyc3RUaWNrUG9zaXRpb24gPSByZW1haW5pbmdEYXlzT2ZGaXJzdE1vbnRoICogZGF5c1dpZHRoT25YQXhpcztcbiAgICAgICAgZmlyc3RUaWNrVmFsdWUgPSBVdGlscy5tb250aE1vZChjdXJyZW50TW9udGggKyAxKTtcbiAgICAgICAgdmFyIHllYXIgPSBjdXJyZW50WWVhciArIHlyQ291bnRlcjtcblxuICAgICAgICB2YXIgX21vbnRoID0gVXRpbHMubW9udGhNb2QoZmlyc3RUaWNrVmFsdWUpO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IGZpcnN0VGlja1ZhbHVlOyAvLyBpdCdzIEphbiwgc28gdXBkYXRlIHRoZSB5ZWFyXG5cbiAgICAgICAgaWYgKGZpcnN0VGlja1ZhbHVlID09PSAwKSB7XG4gICAgICAgICAgdW5pdCA9ICd5ZWFyJztcbiAgICAgICAgICB2YWx1ZSA9IHllYXI7XG4gICAgICAgICAgX21vbnRoID0gMTtcbiAgICAgICAgICB5ckNvdW50ZXIgKz0gMTtcbiAgICAgICAgICB5ZWFyID0geWVhciArIHlyQ291bnRlcjtcbiAgICAgICAgfSAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG5cbiAgICAgICAgdGhpcy50aW1lU2NhbGVBcnJheS5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICBtb250aDogX21vbnRoXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHVzaCB0aGUgZmlyc3QgdGljayBpbiB0aGUgYXJyYXlcbiAgICAgICAgdGhpcy50aW1lU2NhbGVBcnJheS5wdXNoKHtcbiAgICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgICAgdmFsdWU6IGZpcnN0VGlja1ZhbHVlLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgeWVhcjogY3VycmVudFllYXIsXG4gICAgICAgICAgbW9udGg6IFV0aWxzLm1vbnRoTW9kKGN1cnJlbnRNb250aClcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb250aCA9IGZpcnN0VGlja1ZhbHVlICsgMTtcbiAgICAgIHZhciBwb3MgPSBmaXJzdFRpY2tQb3NpdGlvbjsgLy8ga2VlcCBkcmF3aW5nIHJlc3Qgb2YgdGhlIHRpY2tzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMTsgaSA8IG51bWJlck9mTW9udGhzOyBpKyssIGorKykge1xuICAgICAgICBtb250aCA9IFV0aWxzLm1vbnRoTW9kKG1vbnRoKTtcblxuICAgICAgICBpZiAobW9udGggPT09IDApIHtcbiAgICAgICAgICB1bml0ID0gJ3llYXInO1xuICAgICAgICAgIHlyQ291bnRlciArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaXQgPSAnbW9udGgnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF95ZWFyID0gY3VycmVudFllYXIgKyBNYXRoLmZsb29yKG1vbnRoIC8gMTIpICsgeXJDb3VudGVyO1xuXG4gICAgICAgIHBvcyA9IGR0LmRldGVybWluZURheXNPZk1vbnRocyhtb250aCwgX3llYXIpICogZGF5c1dpZHRoT25YQXhpcyArIHBvcztcbiAgICAgICAgdmFyIG1vbnRoVmFsID0gbW9udGggPT09IDAgPyBfeWVhciA6IG1vbnRoO1xuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgdmFsdWU6IG1vbnRoVmFsLFxuICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgeWVhcjogX3llYXIsXG4gICAgICAgICAgbW9udGg6IG1vbnRoID09PSAwID8gMSA6IG1vbnRoXG4gICAgICAgIH0pO1xuICAgICAgICBtb250aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZURheVNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlRGF5U2NhbGUocGFyYW1zKSB7XG4gICAgICB2YXIgZmlyc3RWYWwgPSBwYXJhbXMuZmlyc3RWYWwsXG4gICAgICAgICAgY3VycmVudE1vbnRoID0gcGFyYW1zLmN1cnJlbnRNb250aCxcbiAgICAgICAgICBjdXJyZW50WWVhciA9IHBhcmFtcy5jdXJyZW50WWVhcixcbiAgICAgICAgICBob3Vyc1dpZHRoT25YQXhpcyA9IHBhcmFtcy5ob3Vyc1dpZHRoT25YQXhpcyxcbiAgICAgICAgICBudW1iZXJPZkRheXMgPSBwYXJhbXMubnVtYmVyT2ZEYXlzO1xuICAgICAgdmFyIGR0ID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcbiAgICAgIHZhciB1bml0ID0gJ2RheSc7XG4gICAgICB2YXIgcmVtYWluaW5nSG91cnMgPSAyNCAtIGZpcnN0VmFsLm1pbkhvdXI7XG4gICAgICB2YXIgeXJDb3VudGVyID0gMDsgLy8gY2FsY3VsYXRlIHRoZSBmaXJzdCB0aWNrIHBvc2l0aW9uXG5cbiAgICAgIHZhciBmaXJzdFRpY2tQb3NpdGlvbiA9IHJlbWFpbmluZ0hvdXJzICogaG91cnNXaWR0aE9uWEF4aXM7XG4gICAgICB2YXIgZmlyc3RUaWNrVmFsdWUgPSBmaXJzdFZhbC5taW5EYXRlICsgMTtcbiAgICAgIHZhciB2YWwgPSBmaXJzdFRpY2tWYWx1ZTtcblxuICAgICAgdmFyIGNoYW5nZU1vbnRoID0gZnVuY3Rpb24gY2hhbmdlTW9udGgoZGF0ZVZhbCwgbW9udGgsIHllYXIpIHtcbiAgICAgICAgdmFyIG1vbnRoZGF5cyA9IGR0LmRldGVybWluZURheXNPZk1vbnRocyhtb250aCArIDEsIHllYXIpO1xuXG4gICAgICAgIGlmIChkYXRlVmFsID4gbW9udGhkYXlzKSB7XG4gICAgICAgICAgbW9udGggPSBtb250aCArIDE7XG4gICAgICAgICAgZGF0ZSA9IDE7XG4gICAgICAgICAgdW5pdCA9ICdtb250aCc7XG4gICAgICAgICAgdmFsID0gbW9udGg7XG4gICAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRhdGUgPSBmaXJzdFRpY2tWYWx1ZTtcbiAgICAgIHZhciBtb250aCA9IGNoYW5nZU1vbnRoKGRhdGUsIGN1cnJlbnRNb250aCwgY3VycmVudFllYXIpOyAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG4gICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgIHllYXI6IGN1cnJlbnRZZWFyLFxuICAgICAgICBtb250aDogVXRpbHMubW9udGhNb2QobW9udGgpLFxuICAgICAgICBkYXk6IGRhdGVcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvcyA9IGZpcnN0VGlja1Bvc2l0aW9uOyAvLyBrZWVwIGRyYXdpbmcgcmVzdCBvZiB0aGUgdGlja3NcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJPZkRheXM7IGkrKykge1xuICAgICAgICBkYXRlICs9IDE7XG4gICAgICAgIHVuaXQgPSAnZGF5JztcbiAgICAgICAgbW9udGggPSBjaGFuZ2VNb250aChkYXRlLCBtb250aCwgY3VycmVudFllYXIgKyBNYXRoLmZsb29yKG1vbnRoIC8gMTIpICsgeXJDb3VudGVyKTtcbiAgICAgICAgdmFyIHllYXIgPSBjdXJyZW50WWVhciArIE1hdGguZmxvb3IobW9udGggLyAxMikgKyB5ckNvdW50ZXI7XG4gICAgICAgIHBvcyA9IDI0ICogaG91cnNXaWR0aE9uWEF4aXMgKyBwb3M7XG5cbiAgICAgICAgdmFyIF92YWwgPSBkYXRlID09PSAxID8gVXRpbHMubW9udGhNb2QobW9udGgpIDogZGF0ZTtcblxuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgdmFsdWU6IF92YWwsXG4gICAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICAgIG1vbnRoOiBVdGlscy5tb250aE1vZChtb250aCksXG4gICAgICAgICAgZGF5OiBfdmFsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZUhvdXJTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUhvdXJTY2FsZShwYXJhbXMpIHtcbiAgICAgIHZhciBmaXJzdFZhbCA9IHBhcmFtcy5maXJzdFZhbCxcbiAgICAgICAgICBjdXJyZW50RGF0ZSA9IHBhcmFtcy5jdXJyZW50RGF0ZSxcbiAgICAgICAgICBjdXJyZW50TW9udGggPSBwYXJhbXMuY3VycmVudE1vbnRoLFxuICAgICAgICAgIGN1cnJlbnRZZWFyID0gcGFyYW1zLmN1cnJlbnRZZWFyLFxuICAgICAgICAgIG1pbnV0ZXNXaWR0aE9uWEF4aXMgPSBwYXJhbXMubWludXRlc1dpZHRoT25YQXhpcyxcbiAgICAgICAgICBudW1iZXJPZkhvdXJzID0gcGFyYW1zLm51bWJlck9mSG91cnM7XG4gICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUodGhpcy5jdHgpO1xuICAgICAgdmFyIHlyQ291bnRlciA9IDA7XG4gICAgICB2YXIgdW5pdCA9ICdob3VyJztcblxuICAgICAgdmFyIGNoYW5nZURhdGUgPSBmdW5jdGlvbiBjaGFuZ2VEYXRlKGRhdGVWYWwsIG1vbnRoKSB7XG4gICAgICAgIHZhciBtb250aGRheXMgPSBkdC5kZXRlcm1pbmVEYXlzT2ZNb250aHMobW9udGggKyAxLCBjdXJyZW50WWVhcik7XG5cbiAgICAgICAgaWYgKGRhdGVWYWwgPiBtb250aGRheXMpIHtcbiAgICAgICAgICBkYXRlID0gMTtcbiAgICAgICAgICBtb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9udGg6IG1vbnRoLFxuICAgICAgICAgIGRhdGU6IGRhdGVcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGFuZ2VNb250aCA9IGZ1bmN0aW9uIGNoYW5nZU1vbnRoKGRhdGVWYWwsIG1vbnRoKSB7XG4gICAgICAgIHZhciBtb250aGRheXMgPSBkdC5kZXRlcm1pbmVEYXlzT2ZNb250aHMobW9udGggKyAxLCBjdXJyZW50WWVhcik7XG5cbiAgICAgICAgaWYgKGRhdGVWYWwgPiBtb250aGRheXMpIHtcbiAgICAgICAgICBtb250aCA9IG1vbnRoICsgMTtcbiAgICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVtYWluaW5nTWlucyA9IDYwIC0gZmlyc3RWYWwubWluTWludXRlO1xuICAgICAgdmFyIGZpcnN0VGlja1Bvc2l0aW9uID0gcmVtYWluaW5nTWlucyAqIG1pbnV0ZXNXaWR0aE9uWEF4aXM7XG4gICAgICB2YXIgZmlyc3RUaWNrVmFsdWUgPSBmaXJzdFZhbC5taW5Ib3VyICsgMTtcbiAgICAgIHZhciBob3VyID0gZmlyc3RUaWNrVmFsdWUgKyAxO1xuXG4gICAgICBpZiAocmVtYWluaW5nTWlucyA9PT0gNjApIHtcbiAgICAgICAgZmlyc3RUaWNrUG9zaXRpb24gPSAwO1xuICAgICAgICBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pbkhvdXI7XG4gICAgICAgIGhvdXIgPSBmaXJzdFRpY2tWYWx1ZSArIDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRlID0gY3VycmVudERhdGU7XG4gICAgICB2YXIgbW9udGggPSBjaGFuZ2VNb250aChkYXRlLCBjdXJyZW50TW9udGgpOyAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG4gICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgIHZhbHVlOiBmaXJzdFRpY2tWYWx1ZSxcbiAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgZGF5OiBkYXRlLFxuICAgICAgICBob3VyOiBob3VyLFxuICAgICAgICB5ZWFyOiBjdXJyZW50WWVhcixcbiAgICAgICAgbW9udGg6IFV0aWxzLm1vbnRoTW9kKG1vbnRoKVxuICAgICAgfSk7XG4gICAgICB2YXIgcG9zID0gZmlyc3RUaWNrUG9zaXRpb247IC8vIGtlZXAgZHJhd2luZyByZXN0IG9mIHRoZSB0aWNrc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mSG91cnM7IGkrKykge1xuICAgICAgICB1bml0ID0gJ2hvdXInO1xuXG4gICAgICAgIGlmIChob3VyID49IDI0KSB7XG4gICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgZGF0ZSArPSAxO1xuICAgICAgICAgIHVuaXQgPSAnZGF5JztcbiAgICAgICAgICB2YXIgY2hlY2tOZXh0TW9udGggPSBjaGFuZ2VEYXRlKGRhdGUsIG1vbnRoKTtcbiAgICAgICAgICBtb250aCA9IGNoZWNrTmV4dE1vbnRoLm1vbnRoO1xuICAgICAgICAgIG1vbnRoID0gY2hhbmdlTW9udGgoZGF0ZSwgbW9udGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHllYXIgPSBjdXJyZW50WWVhciArIE1hdGguZmxvb3IobW9udGggLyAxMikgKyB5ckNvdW50ZXI7XG4gICAgICAgIHBvcyA9IGhvdXIgPT09IDAgJiYgaSA9PT0gMCA/IHJlbWFpbmluZ01pbnMgKiBtaW51dGVzV2lkdGhPblhBeGlzIDogNjAgKiBtaW51dGVzV2lkdGhPblhBeGlzICsgcG9zO1xuICAgICAgICB2YXIgdmFsID0gaG91ciA9PT0gMCA/IGRhdGUgOiBob3VyO1xuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgICAgZGF5OiBkYXRlLFxuICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgbW9udGg6IFV0aWxzLm1vbnRoTW9kKG1vbnRoKVxuICAgICAgICB9KTtcbiAgICAgICAgaG91cisrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZU1pbnV0ZVNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlTWludXRlU2NhbGUocGFyYW1zKSB7XG4gICAgICB2YXIgZmlyc3RWYWwgPSBwYXJhbXMuZmlyc3RWYWwsXG4gICAgICAgICAgY3VycmVudE1pbnV0ZSA9IHBhcmFtcy5jdXJyZW50TWludXRlLFxuICAgICAgICAgIGN1cnJlbnRIb3VyID0gcGFyYW1zLmN1cnJlbnRIb3VyLFxuICAgICAgICAgIGN1cnJlbnREYXRlID0gcGFyYW1zLmN1cnJlbnREYXRlLFxuICAgICAgICAgIGN1cnJlbnRNb250aCA9IHBhcmFtcy5jdXJyZW50TW9udGgsXG4gICAgICAgICAgY3VycmVudFllYXIgPSBwYXJhbXMuY3VycmVudFllYXIsXG4gICAgICAgICAgbWludXRlc1dpZHRoT25YQXhpcyA9IHBhcmFtcy5taW51dGVzV2lkdGhPblhBeGlzLFxuICAgICAgICAgIG51bWJlck9mTWludXRlcyA9IHBhcmFtcy5udW1iZXJPZk1pbnV0ZXM7XG4gICAgICB2YXIgeXJDb3VudGVyID0gMDtcbiAgICAgIHZhciB1bml0ID0gJ21pbnV0ZSc7XG4gICAgICB2YXIgcmVtYWluaW5nTWlucyA9IGN1cnJlbnRNaW51dGUgLSBmaXJzdFZhbC5taW5NaW51dGU7XG4gICAgICB2YXIgZmlyc3RUaWNrUG9zaXRpb24gPSBtaW51dGVzV2lkdGhPblhBeGlzIC0gcmVtYWluaW5nTWlucztcbiAgICAgIHZhciBmaXJzdFRpY2tWYWx1ZSA9IGZpcnN0VmFsLm1pbk1pbnV0ZSArIDE7XG4gICAgICB2YXIgbWludXRlID0gZmlyc3RUaWNrVmFsdWUgKyAxO1xuICAgICAgdmFyIGRhdGUgPSBjdXJyZW50RGF0ZTtcbiAgICAgIHZhciBtb250aCA9IGN1cnJlbnRNb250aDtcbiAgICAgIHZhciB5ZWFyID0gY3VycmVudFllYXI7XG4gICAgICB2YXIgaG91ciA9IGN1cnJlbnRIb3VyOyAvLyBwdXNoIHRoZSBmaXJzdCB0aWNrIGluIHRoZSBhcnJheVxuXG4gICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICBwb3NpdGlvbjogZmlyc3RUaWNrUG9zaXRpb24sXG4gICAgICAgIHZhbHVlOiBmaXJzdFRpY2tWYWx1ZSxcbiAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgZGF5OiBkYXRlLFxuICAgICAgICBob3VyOiBob3VyLFxuICAgICAgICBtaW51dGU6IG1pbnV0ZSxcbiAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgbW9udGg6IFV0aWxzLm1vbnRoTW9kKG1vbnRoKVxuICAgICAgfSk7XG4gICAgICB2YXIgcG9zID0gZmlyc3RUaWNrUG9zaXRpb247IC8vIGtlZXAgZHJhd2luZyByZXN0IG9mIHRoZSB0aWNrc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlck9mTWludXRlczsgaSsrKSB7XG4gICAgICAgIGlmIChtaW51dGUgPj0gNjApIHtcbiAgICAgICAgICBtaW51dGUgPSAwO1xuICAgICAgICAgIGhvdXIgKz0gMTtcblxuICAgICAgICAgIGlmIChob3VyID09PSAyNCkge1xuICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF95ZWFyMiA9IGN1cnJlbnRZZWFyICsgTWF0aC5mbG9vcihtb250aCAvIDEyKSArIHlyQ291bnRlcjtcblxuICAgICAgICBwb3MgPSBtaW51dGVzV2lkdGhPblhBeGlzICsgcG9zO1xuICAgICAgICB2YXIgdmFsID0gbWludXRlO1xuICAgICAgICB0aGlzLnRpbWVTY2FsZUFycmF5LnB1c2goe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICB1bml0OiB1bml0LFxuICAgICAgICAgIGhvdXI6IGhvdXIsXG4gICAgICAgICAgbWludXRlOiBtaW51dGUsXG4gICAgICAgICAgZGF5OiBkYXRlLFxuICAgICAgICAgIHllYXI6IF95ZWFyMixcbiAgICAgICAgICBtb250aDogVXRpbHMubW9udGhNb2QobW9udGgpXG4gICAgICAgIH0pO1xuICAgICAgICBtaW51dGUrKztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlUmF3RGF0ZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSYXdEYXRlU3RyaW5nKHRzLCB2YWx1ZSkge1xuICAgICAgdmFyIHJhdyA9IHRzLnllYXI7XG4gICAgICByYXcgKz0gJy0nICsgKCcwJyArIHRzLm1vbnRoLnRvU3RyaW5nKCkpLnNsaWNlKC0yKTsgLy8gdW5pdCBpcyBkYXlcblxuICAgICAgaWYgKHRzLnVuaXQgPT09ICdkYXknKSB7XG4gICAgICAgIHJhdyArPSB0cy51bml0ID09PSAnZGF5JyA/ICctJyArICgnMCcgKyB2YWx1ZSkuc2xpY2UoLTIpIDogJy0wMSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXcgKz0gJy0nICsgKCcwJyArICh0cy5kYXkgPyB0cy5kYXkgOiAnMScpKS5zbGljZSgtMik7XG4gICAgICB9IC8vIHVuaXQgaXMgaG91clxuXG5cbiAgICAgIGlmICh0cy51bml0ID09PSAnaG91cicpIHtcbiAgICAgICAgcmF3ICs9IHRzLnVuaXQgPT09ICdob3VyJyA/ICdUJyArICgnMCcgKyB2YWx1ZSkuc2xpY2UoLTIpIDogJ1QwMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXcgKz0gJ1QnICsgKCcwJyArICh0cy5ob3VyID8gdHMuaG91ciA6ICcwJykpLnNsaWNlKC0yKTtcbiAgICAgIH0gLy8gdW5pdCBpcyBtaW51dGVcblxuXG4gICAgICByYXcgKz0gdHMudW5pdCA9PT0gJ21pbnV0ZScgPyAnOicgKyAoJzAnICsgdmFsdWUpLnNsaWNlKC0yKSArICc6MDAuMDAwWicgOiAnOjAwOjAwLjAwMFonO1xuICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0RGF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0RGF0ZXMoZmlsdGVyZWRUaW1lU2NhbGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciByZWZvcm1hdHRlZFRpbWVzY2FsZUFycmF5ID0gZmlsdGVyZWRUaW1lU2NhbGUubWFwKGZ1bmN0aW9uICh0cykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0cy52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZVRpbWUoX3RoaXMyLmN0eCk7XG5cbiAgICAgICAgdmFyIHJhdyA9IF90aGlzMi5jcmVhdGVSYXdEYXRlU3RyaW5nKHRzLCB2YWx1ZSk7IC8vIHBhcnNlIHRoZSB3aG9sZSBJU08gZGF0ZXN0cmluZ1xuXG5cbiAgICAgICAgdmFyIGRhdGVTdHJpbmcgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKHJhdykpO1xuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgY3VzdG9tRm9ybWF0ID0gJ2RkIE1NTSc7XG4gICAgICAgICAgdmFyIGR0Rm9ybWF0dGVyID0gdy5jb25maWcueGF4aXMubGFiZWxzLmRhdGV0aW1lRm9ybWF0dGVyO1xuICAgICAgICAgIGlmICh0cy51bml0ID09PSAneWVhcicpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLnllYXI7XG4gICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdtb250aCcpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLm1vbnRoO1xuICAgICAgICAgIGlmICh0cy51bml0ID09PSAnZGF5JykgY3VzdG9tRm9ybWF0ID0gZHRGb3JtYXR0ZXIuZGF5O1xuICAgICAgICAgIGlmICh0cy51bml0ID09PSAnaG91cicpIGN1c3RvbUZvcm1hdCA9IGR0Rm9ybWF0dGVyLmhvdXI7XG4gICAgICAgICAgaWYgKHRzLnVuaXQgPT09ICdtaW51dGUnKSBjdXN0b21Gb3JtYXQgPSBkdEZvcm1hdHRlci5taW51dGU7XG4gICAgICAgICAgdmFsdWUgPSBkdC5mb3JtYXREYXRlKGRhdGVTdHJpbmcsIGN1c3RvbUZvcm1hdCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gZHQuZm9ybWF0RGF0ZShkYXRlU3RyaW5nLCB3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0ZVN0cmluZzogcmF3LFxuICAgICAgICAgIHBvc2l0aW9uOiB0cy5wb3NpdGlvbixcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgdW5pdDogdHMudW5pdCxcbiAgICAgICAgICB5ZWFyOiB0cy55ZWFyLFxuICAgICAgICAgIG1vbnRoOiB0cy5tb250aFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVmb3JtYXR0ZWRUaW1lc2NhbGVBcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlT3ZlcmxhcHBpbmdUU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVPdmVybGFwcGluZ1RTKGFycikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgbGFzdERyYXduSW5kZXggPSAwO1xuICAgICAgdmFyIGZpbHRlcmVkQXJyYXkgPSBhcnIubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPiAwICYmIF90aGlzMy53LmNvbmZpZy54YXhpcy5sYWJlbHMuaGlkZU92ZXJsYXBwaW5nTGFiZWxzKSB7XG4gICAgICAgICAgdmFyIHByZXZMYWJlbFdpZHRoID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKGFycltsYXN0RHJhd25JbmRleF0udmFsdWUpLndpZHRoO1xuICAgICAgICAgIHZhciBwcmV2UG9zID0gYXJyW2xhc3REcmF3bkluZGV4XS5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgcG9zID0gaXRlbS5wb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChwb3MgPiBwcmV2UG9zICsgcHJldkxhYmVsV2lkdGggKyAxMCkge1xuICAgICAgICAgICAgbGFzdERyYXduSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZmlsdGVyZWRBcnJheSA9IGZpbHRlcmVkQXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmICE9PSBudWxsO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWRBcnJheTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGltZVNjYWxlO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgQ29yZSBDbGFzcyByZXNwb25zaWJsZSBmb3IgbWFqb3IgY2FsY3VsYXRpb25zIGFuZCBjcmVhdGluZyBlbGVtZW50cy5cbiAqXG4gKiBAbW9kdWxlIENvcmVcbiAqKi9cblxudmFyIENvcmUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb3JlKGVsLCBjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29yZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5jb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMuY3R4KTtcbiAgICB0aGlzLnR3b0RTZXJpZXMgPSBbXTtcbiAgICB0aGlzLnRocmVlRFNlcmllcyA9IFtdO1xuICAgIHRoaXMudHdvRFNlcmllc1ggPSBbXTtcbiAgfSAvLyBnZXQgZGF0YSBhbmQgc3RvcmUgaW50byBhcHByb3ByaWF0ZSB2YXJzXG5cblxuICBfY3JlYXRlQ2xhc3MoQ29yZSwgW3tcbiAgICBrZXk6IFwic2V0dXBFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEVsZW1lbnRzKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZzsgLy8gY29uc3QgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpXG5cbiAgICAgIHZhciBjdCA9IGNuZi5jaGFydC50eXBlO1xuICAgICAgdmFyIGF4aXNDaGFydHNBcnJUeXBlcyA9IFsnbGluZScsICdhcmVhJywgJ2JhcicsICdjYW5kbGVzdGljaycsICdyYWRhcicsICdzY2F0dGVyJywgJ2J1YmJsZScsICdoZWF0bWFwJ107XG4gICAgICB2YXIgeHlDaGFydHNBcnJUeXBlcyA9IFsnbGluZScsICdhcmVhJywgJ2JhcicsICdjYW5kbGVzdGljaycsICdzY2F0dGVyJywgJ2J1YmJsZSddO1xuICAgICAgZ2wuYXhpc0NoYXJ0cyA9IGF4aXNDaGFydHNBcnJUeXBlcy5pbmRleE9mKGN0KSA+IC0xO1xuICAgICAgZ2wueHlDaGFydHMgPSB4eUNoYXJ0c0FyclR5cGVzLmluZGV4T2YoY3QpID4gLTE7XG4gICAgICBnbC5jaGFydENsYXNzID0gJy5hcGV4Y2hhcnRzJyArIGdsLmN1aWQ7XG4gICAgICBnbC5kb20uYmFzZUVsID0gdGhpcy5lbDtcbiAgICAgIGdsLmRvbS5lbFdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIEdyYXBoaWNzLnNldEF0dHJzKGdsLmRvbS5lbFdyYXAsIHtcbiAgICAgICAgaWQ6IGdsLmNoYXJ0Q2xhc3Muc3Vic3RyaW5nKDEpLFxuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtY2FudmFzICcgKyBnbC5jaGFydENsYXNzLnN1YnN0cmluZygxKVxuICAgICAgfSk7XG4gICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGdsLmRvbS5lbFdyYXApO1xuICAgICAgZ2wuZG9tLlBhcGVyID0gbmV3IHdpbmRvdy5TVkcuRG9jKGdsLmRvbS5lbFdyYXApO1xuICAgICAgZ2wuZG9tLlBhcGVyLmF0dHIoe1xuICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtc3ZnJyxcbiAgICAgICAgJ3htbG5zOmRhdGEnOiAnQXBleENoYXJ0c05TJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIi5jb25jYXQoY25mLmNoYXJ0Lm9mZnNldFgsIFwiLCBcIikuY29uY2F0KGNuZi5jaGFydC5vZmZzZXRZLCBcIilcIilcbiAgICAgIH0pO1xuICAgICAgZ2wuZG9tLlBhcGVyLm5vZGUuc3R5bGUuYmFja2dyb3VuZCA9IGNuZi5jaGFydC5iYWNrZ3JvdW5kO1xuICAgICAgdGhpcy5zZXRTVkdEaW1lbnNpb25zKCk7XG4gICAgICBnbC5kb20uZWxHcmFwaGljYWwgPSBnbC5kb20uUGFwZXIuZ3JvdXAoKS5hdHRyKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWlubmVyIGFwZXhjaGFydHMtZ3JhcGhpY2FsJ1xuICAgICAgfSk7XG4gICAgICBnbC5kb20uZWxEZWZzID0gZ2wuZG9tLlBhcGVyLmRlZnMoKTtcbiAgICAgIGdsLmRvbS5lbExlZ2VuZFdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGdsLmRvbS5lbExlZ2VuZFdyYXAuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1sZWdlbmQnKTtcbiAgICAgIGdsLmRvbS5lbFdyYXAuYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsTGVnZW5kV3JhcCk7IC8vIGdsLmRvbS5QYXBlci5hZGQoZ2wuZG9tLmVsTGVnZW5kV3JhcClcblxuICAgICAgZ2wuZG9tLlBhcGVyLmFkZChnbC5kb20uZWxHcmFwaGljYWwpO1xuICAgICAgZ2wuZG9tLmVsR3JhcGhpY2FsLmFkZChnbC5kb20uZWxEZWZzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGxvdENoYXJ0VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbG90Q2hhcnRUeXBlKHNlciwgeHlSYXRpb3MpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGNuZiA9IHcuY29uZmlnO1xuICAgICAgdmFyIGdsID0gdy5nbG9iYWxzO1xuICAgICAgdmFyIGxpbmVTZXJpZXMgPSB7XG4gICAgICAgIHNlcmllczogW10sXG4gICAgICAgIGk6IFtdXG4gICAgICB9O1xuICAgICAgdmFyIGFyZWFTZXJpZXMgPSB7XG4gICAgICAgIHNlcmllczogW10sXG4gICAgICAgIGk6IFtdXG4gICAgICB9O1xuICAgICAgdmFyIHNjYXR0ZXJTZXJpZXMgPSB7XG4gICAgICAgIHNlcmllczogW10sXG4gICAgICAgIGk6IFtdXG4gICAgICB9O1xuICAgICAgdmFyIGNvbHVtblNlcmllcyA9IHtcbiAgICAgICAgc2VyaWVzOiBbXSxcbiAgICAgICAgaTogW11cbiAgICAgIH07XG4gICAgICB2YXIgY2FuZGxlc3RpY2tTZXJpZXMgPSB7XG4gICAgICAgIHNlcmllczogW10sXG4gICAgICAgIGk6IFtdXG4gICAgICB9O1xuICAgICAgZ2wuc2VyaWVzLm1hcChmdW5jdGlvbiAoc2VyaWVzLCBzdCkge1xuICAgICAgICAvLyBpZiB1c2VyIGhhcyBzcGVjaWZpZWQgYSBwYXJ0aWN1bGFyIHR5cGUgZm9yIHBhcnRpY3VsYXIgc2VyaWVzXG4gICAgICAgIGlmICh0eXBlb2Ygc2VyW3N0XS50eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChzZXJbc3RdLnR5cGUgPT09ICdjb2x1bW4nIHx8IHNlcltzdF0udHlwZSA9PT0gJ2JhcicpIHtcbiAgICAgICAgICAgIHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsID0gZmFsc2U7IC8vIGJhciBub3Qgc3VwcG9ydGVkIGluIG1peGVkIGNoYXJ0c1xuXG4gICAgICAgICAgICBjb2x1bW5TZXJpZXMuc2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgICAgIGNvbHVtblNlcmllcy5pLnB1c2goc3QpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VyW3N0XS50eXBlID09PSAnYXJlYScpIHtcbiAgICAgICAgICAgIGFyZWFTZXJpZXMuc2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgICAgICAgIGFyZWFTZXJpZXMuaS5wdXNoKHN0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlcltzdF0udHlwZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICBsaW5lU2VyaWVzLnNlcmllcy5wdXNoKHNlcmllcyk7XG4gICAgICAgICAgICBsaW5lU2VyaWVzLmkucHVzaChzdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZXJbc3RdLnR5cGUgPT09ICdzY2F0dGVyJykge1xuICAgICAgICAgICAgc2NhdHRlclNlcmllcy5zZXJpZXMucHVzaChzZXJpZXMpO1xuICAgICAgICAgICAgc2NhdHRlclNlcmllcy5pLnB1c2goc3QpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VyW3N0XS50eXBlID09PSAnYnViYmxlJykgOyBlbHNlIGlmIChzZXJbc3RdLnR5cGUgPT09ICdjYW5kbGVzdGljaycpIHtcbiAgICAgICAgICAgIGNhbmRsZXN0aWNrU2VyaWVzLnNlcmllcy5wdXNoKHNlcmllcyk7XG4gICAgICAgICAgICBjYW5kbGVzdGlja1Nlcmllcy5pLnB1c2goc3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VyIGhhcyBzcGVjaWZpZWQgdHlwZSwgYnV0IGl0IGlzIG5vdCB2YWxpZCAob3RoZXIgdGhhbiBsaW5lL2FyZWEvY29sdW1uKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdZb3UgaGF2ZSBzcGVjaWZpZWQgYW4gdW5yZWNvZ25pemVkIGNoYXJ0IHR5cGUuIEF2YWlsYWJsZSB0eXBlcyBmb3IgdGhpcyBwcm9wZXJ5IGFyZSBsaW5lL2FyZWEvY29sdW1uL2Jhci9zY2F0dGVyL2J1YmJsZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdsLmNvbWJvQ2hhcnRzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lU2VyaWVzLnNlcmllcy5wdXNoKHNlcmllcyk7XG4gICAgICAgICAgbGluZVNlcmllcy5pLnB1c2goc3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBsaW5lID0gbmV3IExpbmUodGhpcy5jdHgsIHh5UmF0aW9zKTtcbiAgICAgIHZhciBjYW5kbGVzdGljayA9IG5ldyBDYW5kbGVTdGljayh0aGlzLmN0eCwgeHlSYXRpb3MpO1xuICAgICAgdmFyIHBpZSA9IG5ldyBQaWUodGhpcy5jdHgpO1xuICAgICAgdmFyIHJhZGlhbEJhciA9IG5ldyBSYWRpYWwodGhpcy5jdHgpO1xuICAgICAgdmFyIHJhZGFyID0gbmV3IFJhZGFyKHRoaXMuY3R4KTtcbiAgICAgIHZhciBlbEdyYXBoID0gW107XG5cbiAgICAgIGlmIChnbC5jb21ib0NoYXJ0cykge1xuICAgICAgICBpZiAoYXJlYVNlcmllcy5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVsR3JhcGgucHVzaChsaW5lLmRyYXcoYXJlYVNlcmllcy5zZXJpZXMsICdhcmVhJywgYXJlYVNlcmllcy5pKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sdW1uU2VyaWVzLnNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnN0YWNrZWQpIHtcbiAgICAgICAgICAgIHZhciBiYXJTdGFja2VkID0gbmV3IEJhclN0YWNrZWQodGhpcy5jdHgsIHh5UmF0aW9zKTtcbiAgICAgICAgICAgIGVsR3JhcGgucHVzaChiYXJTdGFja2VkLmRyYXcoY29sdW1uU2VyaWVzLnNlcmllcywgY29sdW1uU2VyaWVzLmkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJhciA9IG5ldyBCYXIodGhpcy5jdHgsIHh5UmF0aW9zKTtcbiAgICAgICAgICAgIGVsR3JhcGgucHVzaChiYXIuZHJhdyhjb2x1bW5TZXJpZXMuc2VyaWVzLCBjb2x1bW5TZXJpZXMuaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5lU2VyaWVzLnNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZWxHcmFwaC5wdXNoKGxpbmUuZHJhdyhsaW5lU2VyaWVzLnNlcmllcywgJ2xpbmUnLCBsaW5lU2VyaWVzLmkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYW5kbGVzdGlja1Nlcmllcy5zZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVsR3JhcGgucHVzaChjYW5kbGVzdGljay5kcmF3KGNhbmRsZXN0aWNrU2VyaWVzLnNlcmllcywgY2FuZGxlc3RpY2tTZXJpZXMuaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYXR0ZXJTZXJpZXMuc2VyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgc2NhdHRlckxpbmUgPSBuZXcgTGluZSh0aGlzLmN0eCwgeHlSYXRpb3MsIHRydWUpO1xuICAgICAgICAgIGVsR3JhcGgucHVzaChzY2F0dGVyTGluZS5kcmF3KHNjYXR0ZXJTZXJpZXMuc2VyaWVzLCAnc2NhdHRlcicsIHNjYXR0ZXJTZXJpZXMuaSkpO1xuICAgICAgICB9IC8vIFRPRE86IGFsbG93IGJ1YmJsZSBzZXJpZXMgaW4gYSBjb21ibyBjaGFydFxuICAgICAgICAvLyBpZiAoYnViYmxlU2VyaWVzLnNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vICAgY29uc3QgYnViYmxlTGluZSA9IG5ldyBMaW5lKHRoaXMuY3R4LCB4eVJhdGlvcywgdHJ1ZSlcbiAgICAgICAgLy8gICBlbEdyYXBoLnB1c2goXG4gICAgICAgIC8vICAgICBidWJibGVMaW5lLmRyYXcoYnViYmxlU2VyaWVzLnNlcmllcywgJ2J1YmJsZScsIGJ1YmJsZVNlcmllcy5pKVxuICAgICAgICAvLyAgIClcbiAgICAgICAgLy8gfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGNuZi5jaGFydC50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgICAgICBlbEdyYXBoID0gbGluZS5kcmF3KGdsLnNlcmllcywgJ2xpbmUnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYXJlYSc6XG4gICAgICAgICAgICBlbEdyYXBoID0gbGluZS5kcmF3KGdsLnNlcmllcywgJ2FyZWEnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYmFyJzpcbiAgICAgICAgICAgIGlmIChjbmYuY2hhcnQuc3RhY2tlZCkge1xuICAgICAgICAgICAgICB2YXIgX2JhclN0YWNrZWQgPSBuZXcgQmFyU3RhY2tlZCh0aGlzLmN0eCwgeHlSYXRpb3MpO1xuXG4gICAgICAgICAgICAgIGVsR3JhcGggPSBfYmFyU3RhY2tlZC5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2JhciA9IG5ldyBCYXIodGhpcy5jdHgsIHh5UmF0aW9zKTtcblxuICAgICAgICAgICAgICBlbEdyYXBoID0gX2Jhci5kcmF3KGdsLnNlcmllcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2FuZGxlc3RpY2snOlxuICAgICAgICAgICAgdmFyIGNhbmRsZVN0aWNrID0gbmV3IENhbmRsZVN0aWNrKHRoaXMuY3R4LCB4eVJhdGlvcyk7XG4gICAgICAgICAgICBlbEdyYXBoID0gY2FuZGxlU3RpY2suZHJhdyhnbC5zZXJpZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdoZWF0bWFwJzpcbiAgICAgICAgICAgIHZhciBoZWF0bWFwID0gbmV3IEhlYXRNYXAodGhpcy5jdHgsIHh5UmF0aW9zKTtcbiAgICAgICAgICAgIGVsR3JhcGggPSBoZWF0bWFwLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncGllJzpcbiAgICAgICAgICBjYXNlICdkb251dCc6XG4gICAgICAgICAgICBlbEdyYXBoID0gcGllLmRyYXcoZ2wuc2VyaWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmFkaWFsQmFyJzpcbiAgICAgICAgICAgIGVsR3JhcGggPSByYWRpYWxCYXIuZHJhdyhnbC5zZXJpZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyYWRhcic6XG4gICAgICAgICAgICBlbEdyYXBoID0gcmFkYXIuZHJhdyhnbC5zZXJpZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZWxHcmFwaCA9IGxpbmUuZHJhdyhnbC5zZXJpZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbEdyYXBoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRTVkdEaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNWR0RpbWVuc2lvbnMoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgZ2wuc3ZnV2lkdGggPSBjbmYuY2hhcnQud2lkdGg7XG4gICAgICBnbC5zdmdIZWlnaHQgPSBjbmYuY2hhcnQuaGVpZ2h0O1xuICAgICAgdmFyIGVsRGltID0gVXRpbHMuZ2V0RGltZW5zaW9ucyh0aGlzLmVsKTtcbiAgICAgIHZhciB3aWR0aFVuaXQgPSBjbmYuY2hhcnQud2lkdGgudG9TdHJpbmcoKS5zcGxpdCgvWzAtOV0rL2cpLnBvcCgpO1xuXG4gICAgICBpZiAod2lkdGhVbml0ID09PSAnJScpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKGVsRGltWzBdKSkge1xuICAgICAgICAgIGlmIChlbERpbVswXS53aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgZWxEaW0gPSBVdGlscy5nZXREaW1lbnNpb25zKHRoaXMuZWwucGFyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wuc3ZnV2lkdGggPSBlbERpbVswXSAqIHBhcnNlSW50KGNuZi5jaGFydC53aWR0aCkgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAod2lkdGhVbml0ID09PSAncHgnIHx8IHdpZHRoVW5pdCA9PT0gJycpIHtcbiAgICAgICAgZ2wuc3ZnV2lkdGggPSBwYXJzZUludChjbmYuY2hhcnQud2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2wuc3ZnSGVpZ2h0ICE9PSAnYXV0bycgJiYgZ2wuc3ZnSGVpZ2h0ICE9PSAnJykge1xuICAgICAgICB2YXIgaGVpZ2h0VW5pdCA9IGNuZi5jaGFydC5oZWlnaHQudG9TdHJpbmcoKS5zcGxpdCgvWzAtOV0rL2cpLnBvcCgpO1xuXG4gICAgICAgIGlmIChoZWlnaHRVbml0ID09PSAnJScpIHtcbiAgICAgICAgICB2YXIgZWxQYXJlbnREaW0gPSBVdGlscy5nZXREaW1lbnNpb25zKHRoaXMuZWwucGFyZW50Tm9kZSk7XG4gICAgICAgICAgZ2wuc3ZnSGVpZ2h0ID0gZWxQYXJlbnREaW1bMV0gKiBwYXJzZUludChjbmYuY2hhcnQuaGVpZ2h0KSAvIDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC5zdmdIZWlnaHQgPSBwYXJzZUludChjbmYuY2hhcnQuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGdsLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICBnbC5zdmdIZWlnaHQgPSBnbC5zdmdXaWR0aCAvIDEuNjE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2wuc3ZnSGVpZ2h0ID0gZ2wuc3ZnV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZ2wuZG9tLlBhcGVyLm5vZGUsIHtcbiAgICAgICAgd2lkdGg6IGdsLnN2Z1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IGdsLnN2Z0hlaWdodFxuICAgICAgfSk7IC8vIGdsLmRvbS5QYXBlci5ub2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5zdHlsZS5taW5XaWR0aCA9IGdsLnN2Z1dpZHRoICsgXCJweFwiO1xuXG4gICAgICB2YXIgb2Zmc2V0WSA9IGNuZi5jaGFydC5zcGFya2xpbmUuZW5hYmxlZCA/IDAgOiBnbC5heGlzQ2hhcnRzID8gMTQgOiA1O1xuICAgICAgZ2wuZG9tLlBhcGVyLm5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLnN0eWxlLm1pbkhlaWdodCA9IGdsLnN2Z0hlaWdodCArIG9mZnNldFkgKyAncHgnO1xuICAgICAgZ2wuZG9tLmVsV3JhcC5zdHlsZS53aWR0aCA9IGdsLnN2Z1dpZHRoICsgJ3B4JztcbiAgICAgIGdsLmRvbS5lbFdyYXAuc3R5bGUuaGVpZ2h0ID0gZ2wuc3ZnSGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRHcmFwaFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0R3JhcGhQb3NpdGlvbigpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIHRZID0gZ2wudHJhbnNsYXRlWTtcbiAgICAgIHZhciB0WCA9IGdsLnRyYW5zbGF0ZVg7XG4gICAgICB2YXIgc2NhbGluZ0F0dHJzID0ge1xuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHRYICsgJywgJyArIHRZICsgJyknXG4gICAgICB9O1xuICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZ2wuZG9tLmVsR3JhcGhpY2FsLm5vZGUsIHNjYWxpbmdBdHRycyk7XG4gICAgfVxuICAgIC8qXG4gICAgICoqIEFsbCB0aGUgY2FsY3VsYXRpb25zIGZvciBzZXR0aW5nIHJhbmdlIGluIGNoYXJ0cyB3aWxsIGJlIGRvbmUgaGVyZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29yZUNhbGN1bGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3JlQ2FsY3VsYXRpb25zKCkge1xuICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlJDEodGhpcy5jdHgpO1xuICAgICAgcmFuZ2UuaW5pdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldEdsb2JhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRHbG9iYWxzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICBnbC5zZXJpZXMgPSBbXTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZU8gPSBbXTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZUggPSBbXTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZUwgPSBbXTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZUMgPSBbXTtcbiAgICAgIGdsLnNlcmllc1BlcmNlbnQgPSBbXTtcbiAgICAgIGdsLnNlcmllc1ggPSBbXTtcbiAgICAgIGdsLnNlcmllc1ogPSBbXTtcbiAgICAgIGdsLnNlcmllc05hbWVzID0gW107XG4gICAgICBnbC5zZXJpZXNUb3RhbHMgPSBbXTtcbiAgICAgIGdsLnN0YWNrZWRTZXJpZXNUb3RhbHMgPSBbXTtcbiAgICAgIGdsLmxhYmVscyA9IFtdO1xuICAgICAgZ2wudGltZWxpbmVMYWJlbHMgPSBbXTtcbiAgICAgIGdsLm5vTGFiZWxzUHJvdmlkZWQgPSBmYWxzZTtcbiAgICAgIGdsLnRpbWVzY2FsZVRpY2tzID0gW107XG4gICAgICBnbC5yZXNpemVUaW1lciA9IG51bGw7XG4gICAgICBnbC5zZWxlY3Rpb25SZXNpemVUaW1lciA9IG51bGw7XG5cbiAgICAgIGdsLnNlcmllc1h2YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy53LmNvbmZpZy5zZXJpZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICAgIH0oKTtcblxuICAgICAgZ2wuc2VyaWVzWXZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLncuY29uZmlnLnNlcmllcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgICAgfSgpO1xuXG4gICAgICBnbC5kZWxheWVkRWxlbWVudHMgPSBbXTtcbiAgICAgIGdsLnBvaW50c0FycmF5ID0gW107XG4gICAgICBnbC5kYXRhTGFiZWxzUmVjdHMgPSBbXTtcbiAgICAgIGdsLmlzWE51bWVyaWMgPSBmYWxzZTtcbiAgICAgIGdsLmlzRGF0YVhZWiA9IGZhbHNlO1xuICAgICAgZ2wubWF4WSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wubWluWSA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgICBnbC5taW5ZQXJyID0gW107XG4gICAgICBnbC5tYXhZQXJyID0gW107XG4gICAgICBnbC5tYXhYID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICBnbC5taW5YID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGdsLmluaXRpYWxtYXhYID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICBnbC5pbml0aWFsbWluWCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBnbC5tYXhEYXRlID0gMDtcbiAgICAgIGdsLm1pbkRhdGUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgZ2wubWluWiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBnbC5tYXhaID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICBnbC55QXhpc1NjYWxlID0gW107XG4gICAgICBnbC54QXhpc1NjYWxlID0gbnVsbDtcbiAgICAgIGdsLnhBeGlzVGlja3NQb3NpdGlvbnMgPSBbXTtcbiAgICAgIGdsLnlMYWJlbHNDb29yZHMgPSBbXTtcbiAgICAgIGdsLnlUaXRsZUNvb3JkcyA9IFtdO1xuICAgICAgZ2wueFJhbmdlID0gMDtcbiAgICAgIGdsLnlSYW5nZSA9IFtdO1xuICAgICAgZ2wuelJhbmdlID0gMDtcbiAgICAgIGdsLmRhdGFQb2ludHMgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc011bHRpcGxlWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc011bHRpcGxlWSgpIHtcbiAgICAgIC8vIHVzZXIgaGFzIHN1cHBsaWVkIGFuIGFycmF5IGluIHlheGlzIHByb3BlcnR5LiBTbywgdHVybiBvbiBtdWx0aXBsZVlBeGlzIGZsYWdcbiAgICAgIGlmICh0aGlzLncuY29uZmlnLnlheGlzLmNvbnN0cnVjdG9yID09PSBBcnJheSAmJiB0aGlzLncuY29uZmlnLnlheGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gZmlyc3QsIHR1cm4gb2ZmIHN0YWNraW5nIGlmIG11bHRpcGxlIHkgYXhpc1xuICAgICAgICB0aGlzLncuY29uZmlnLmNoYXJ0LnN0YWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53Lmdsb2JhbHMuaXNNdWx0aXBsZVlBeGlzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4Y2x1ZGVDb2xsYXBzZWRTZXJpZXNJbllBeGlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4Y2x1ZGVDb2xsYXBzZWRTZXJpZXNJbllBeGlzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLmlnbm9yZVlBeGlzSW5kZXhlcyA9IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubWFwKGZ1bmN0aW9uIChjb2xsYXBzZWQsIGkpIHtcbiAgICAgICAgaWYgKF90aGlzMi53Lmdsb2JhbHMuaXNNdWx0aXBsZVlBeGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxhcHNlZC5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTXVsdGlGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNNdWx0aUZvcm1hdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRm9ybWF0WFkoKSB8fCB0aGlzLmlzRm9ybWF0MkRBcnJheSgpO1xuICAgIH0gLy8gZ2l2ZW4gZm9ybWF0IGlzIFt7eCwgeX0sIHt4LCB5fV1cblxuICB9LCB7XG4gICAga2V5OiBcImlzRm9ybWF0WFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGb3JtYXRYWSgpIHtcbiAgICAgIHZhciBzZXJpZXMgPSB0aGlzLncuY29uZmlnLnNlcmllcy5zbGljZSgpO1xuICAgICAgdmFyIHNyID0gbmV3IFNlcmllcyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmFjdGl2ZVNlcmllc0luZGV4ID0gc3IuZ2V0QWN0aXZlQ29uZmlnU2VyaWVzSW5kZXgoKTtcblxuICAgICAgaWYgKHR5cGVvZiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGEubGVuZ3RoID4gMCAmJiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YVswXSAhPT0gbnVsbCAmJiB0eXBlb2Ygc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGFbMF0ueCAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGFbMF0gIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBnaXZlbiBmb3JtYXQgaXMgW1t4LCB5XSwgW3gsIHldXVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGb3JtYXQyREFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRm9ybWF0MkRBcnJheSgpIHtcbiAgICAgIHZhciBzZXJpZXMgPSB0aGlzLncuY29uZmlnLnNlcmllcy5zbGljZSgpO1xuICAgICAgdmFyIHNyID0gbmV3IFNlcmllcyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmFjdGl2ZVNlcmllc0luZGV4ID0gc3IuZ2V0QWN0aXZlQ29uZmlnU2VyaWVzSW5kZXgoKTtcblxuICAgICAgaWYgKHR5cGVvZiBzZXJpZXNbdGhpcy5hY3RpdmVTZXJpZXNJbmRleF0uZGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGEubGVuZ3RoID4gMCAmJiB0eXBlb2Ygc2VyaWVzW3RoaXMuYWN0aXZlU2VyaWVzSW5kZXhdLmRhdGFbMF0gIT09ICd1bmRlZmluZWQnICYmIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhWzBdICE9PSBudWxsICYmIHNlcmllc1t0aGlzLmFjdGl2ZVNlcmllc0luZGV4XS5kYXRhWzBdLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRm9ybWF0MkRBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVGb3JtYXQyREFycmF5KHNlciwgaSkge1xuICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAodHlwZW9mIHNlcltpXS5kYXRhW2pdWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlcltpXS5kYXRhW2pdWzFdKSAmJiBzZXJbaV0uZGF0YVtqXVsxXS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMudHdvRFNlcmllcy5wdXNoKFV0aWxzLnBhcnNlTnVtYmVyKHNlcltpXS5kYXRhW2pdWzFdWzNdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHdvRFNlcmllcy5wdXNoKFV0aWxzLnBhcnNlTnVtYmVyKHNlcltpXS5kYXRhW2pdWzFdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNuZi54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgLy8gaWYgdGltZXN0YW1wcyBhcmUgcHJvdmlkZWQgYW5kIHhheGlzIHR5cGUgaXMgZGF0ZXR0aW1lLFxuICAgICAgICAgIHZhciB0cyA9IG5ldyBEYXRlKHNlcltpXS5kYXRhW2pdWzBdKTtcbiAgICAgICAgICB0cyA9IG5ldyBEYXRlKHRzKS5nZXRUaW1lKCk7XG4gICAgICAgICAgdGhpcy50d29EU2VyaWVzWC5wdXNoKHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2goc2VyW2ldLmRhdGFbal1bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBzZXJbaV0uZGF0YS5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXJbaV0uZGF0YVtfal1bMl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy50aHJlZURTZXJpZXMucHVzaChzZXJbaV0uZGF0YVtfal1bMl0pO1xuICAgICAgICAgIGdsLmlzRGF0YVhZWiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRm9ybWF0WFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRm9ybWF0WFkoc2VyLCBpKSB7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIGR0ID0gbmV3IERhdGVUaW1lKHRoaXMuY3R4KTtcbiAgICAgIHZhciBhY3RpdmVJID0gaTtcblxuICAgICAgaWYgKGdsLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihpKSA+IC0xKSB7XG4gICAgICAgIC8vIGZpeCAjMzY4XG4gICAgICAgIGFjdGl2ZUkgPSB0aGlzLmFjdGl2ZVNlcmllc0luZGV4O1xuICAgICAgfSAvLyBnZXQgc2VyaWVzXG5cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAodHlwZW9mIHNlcltpXS5kYXRhW2pdLnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VyW2ldLmRhdGFbal0ueSkgJiYgc2VyW2ldLmRhdGFbal0ueS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMudHdvRFNlcmllcy5wdXNoKFV0aWxzLnBhcnNlTnVtYmVyKHNlcltpXS5kYXRhW2pdLnlbM10pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzLnB1c2goVXRpbHMucGFyc2VOdW1iZXIoc2VyW2ldLmRhdGFbal0ueSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBnZXQgc2VyaWVzWFxuXG5cbiAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IHNlclthY3RpdmVJXS5kYXRhLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgdmFyIGlzWFN0cmluZyA9IHR5cGVvZiBzZXJbYWN0aXZlSV0uZGF0YVtfajJdLnggPT09ICdzdHJpbmcnO1xuICAgICAgICB2YXIgaXNYRGF0ZSA9ICEhZHQuaXNWYWxpZERhdGUoc2VyW2FjdGl2ZUldLmRhdGFbX2oyXS54LnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIGlmIChpc1hTdHJpbmcgfHwgaXNYRGF0ZSkge1xuICAgICAgICAgIC8vIHVzZXIgc3VwcGxpZWQgJzAxLzAxLzIwMTcnIG9yIGEgZGF0ZSBzdHJpbmcgKGEgSlMgZGF0ZSBvYmplY3QgaXMgbm90IHN1cHBvcnRlZClcbiAgICAgICAgICBpZiAoaXNYU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzWC5wdXNoKGR0LnBhcnNlRGF0ZShzZXJbYWN0aXZlSV0uZGF0YVtfajJdLngpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGEgY2F0ZWdvcnkgYW5kIG5vdCBhIG51bWVyaWMgeCB2YWx1ZVxuICAgICAgICAgICAgICB0aGlzLmZhbGxiYWNrVG9DYXRlZ29yeSA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMudHdvRFNlcmllc1gucHVzaChzZXJbYWN0aXZlSV0uZGF0YVtfajJdLngpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzWC5wdXNoKGR0LnBhcnNlRGF0ZShzZXJbYWN0aXZlSV0uZGF0YVtfajJdLngudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzWC5wdXNoKHBhcnNlRmxvYXQoc2VyW2FjdGl2ZUldLmRhdGFbX2oyXS54KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGEgbnVtZXJpYyB2YWx1ZSBpbiB4IHByb3BlcnR5XG4gICAgICAgICAgdGhpcy50d29EU2VyaWVzWC5wdXNoKHNlclthY3RpdmVJXS5kYXRhW19qMl0ueCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlcltpXS5kYXRhWzBdICYmIHR5cGVvZiBzZXJbaV0uZGF0YVswXS56ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHNlcltpXS5kYXRhLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgdGhpcy50aHJlZURTZXJpZXMucHVzaChzZXJbaV0uZGF0YVt0XS56KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmlzRGF0YVhZWiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNhbmRsZVN0aWNrRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDYW5kbGVTdGlja0RhdGEoc2VyLCBpKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBvaGxjID0ge307XG5cbiAgICAgIGlmICh0aGlzLmlzRm9ybWF0MkRBcnJheSgpKSB7XG4gICAgICAgIG9obGMgPSB0aGlzLmhhbmRsZUNhbmRsZVN0aWNrRGF0YUZvcm1hdCgnYXJyYXknLCBzZXIsIGkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRm9ybWF0WFkoKSkge1xuICAgICAgICBvaGxjID0gdGhpcy5oYW5kbGVDYW5kbGVTdGlja0RhdGFGb3JtYXQoJ3h5Jywgc2VyLCBpKTtcbiAgICAgIH1cblxuICAgICAgZ2wuc2VyaWVzQ2FuZGxlTy5wdXNoKG9obGMubyk7XG4gICAgICBnbC5zZXJpZXNDYW5kbGVILnB1c2gob2hsYy5oKTtcbiAgICAgIGdsLnNlcmllc0NhbmRsZUwucHVzaChvaGxjLmwpO1xuICAgICAgZ2wuc2VyaWVzQ2FuZGxlQy5wdXNoKG9obGMuYyk7XG4gICAgICByZXR1cm4gb2hsYztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2FuZGxlU3RpY2tEYXRhRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNhbmRsZVN0aWNrRGF0YUZvcm1hdChmb3JtYXQsIHNlciwgaSkge1xuICAgICAgdmFyIHNlck8gPSBbXTtcbiAgICAgIHZhciBzZXJIID0gW107XG4gICAgICB2YXIgc2VyTCA9IFtdO1xuICAgICAgdmFyIHNlckMgPSBbXTtcbiAgICAgIHZhciBlcnIgPSAnUGxlYXNlIHByb3ZpZGUgW09wZW4sIEhpZ2gsIExvdyBhbmQgQ2xvc2VdIHZhbHVlcyBpbiB2YWxpZCBmb3JtYXQuIFJlYWQgbW9yZSBodHRwczovL2FwZXhjaGFydHMuY29tL2RvY3Mvc2VyaWVzLyNjYW5kbGVzdGljayc7XG5cbiAgICAgIGlmIChmb3JtYXQgPT09ICdhcnJheScpIHtcbiAgICAgICAgaWYgKHNlcltpXS5kYXRhWzBdWzFdLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlck8ucHVzaChzZXJbaV0uZGF0YVtqXVsxXVswXSk7XG4gICAgICAgICAgc2VySC5wdXNoKHNlcltpXS5kYXRhW2pdWzFdWzFdKTtcbiAgICAgICAgICBzZXJMLnB1c2goc2VyW2ldLmRhdGFbal1bMV1bMl0pO1xuICAgICAgICAgIHNlckMucHVzaChzZXJbaV0uZGF0YVtqXVsxXVszXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAneHknKSB7XG4gICAgICAgIGlmIChzZXJbaV0uZGF0YVswXS55Lmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2ozID0gMDsgX2ozIDwgc2VyW2ldLmRhdGEubGVuZ3RoOyBfajMrKykge1xuICAgICAgICAgIHNlck8ucHVzaChzZXJbaV0uZGF0YVtfajNdLnlbMF0pO1xuICAgICAgICAgIHNlckgucHVzaChzZXJbaV0uZGF0YVtfajNdLnlbMV0pO1xuICAgICAgICAgIHNlckwucHVzaChzZXJbaV0uZGF0YVtfajNdLnlbMl0pO1xuICAgICAgICAgIHNlckMucHVzaChzZXJbaV0uZGF0YVtfajNdLnlbM10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG86IHNlck8sXG4gICAgICAgIGg6IHNlckgsXG4gICAgICAgIGw6IHNlckwsXG4gICAgICAgIGM6IHNlckNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlRGF0YUF4aXNDaGFydHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VEYXRhQXhpc0NoYXJ0cyhzZXIpIHtcbiAgICAgIHZhciBjdHggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuY3R4O1xuICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBkdCA9IG5ldyBEYXRlVGltZShjdHgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlci5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnR3b0RTZXJpZXMgPSBbXTtcbiAgICAgICAgdGhpcy50d29EU2VyaWVzWCA9IFtdO1xuICAgICAgICB0aGlzLnRocmVlRFNlcmllcyA9IFtdO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VyW2ldLmRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkl0IGlzIGEgcG9zc2liaWxpdHkgdGhhdCB5b3UgbWF5IGhhdmUgbm90IGluY2x1ZGVkICdkYXRhJyBwcm9wZXJ0eSBpbiBzZXJpZXMuXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzTXVsdGlGb3JtYXQoKSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzRm9ybWF0MkRBcnJheSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZvcm1hdDJEQXJyYXkoc2VyLCBpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNGb3JtYXRYWSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZvcm1hdFhZKHNlciwgaSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNuZi5jaGFydC50eXBlID09PSAnY2FuZGxlc3RpY2snIHx8IHNlcltpXS50eXBlID09PSAnY2FuZGxlc3RpY2snKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNhbmRsZVN0aWNrRGF0YShzZXIsIGkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdsLnNlcmllcy5wdXNoKHRoaXMudHdvRFNlcmllcyk7XG4gICAgICAgICAgZ2wubGFiZWxzLnB1c2godGhpcy50d29EU2VyaWVzWCk7XG4gICAgICAgICAgZ2wuc2VyaWVzWC5wdXNoKHRoaXMudHdvRFNlcmllc1gpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmZhbGxiYWNrVG9DYXRlZ29yeSkge1xuICAgICAgICAgICAgZ2wuaXNYTnVtZXJpYyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjbmYueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICAgICAgLy8gdXNlciBkaWRuJ3Qgc3VwcGxpZWQgW3t4LHl9XSBvciBbW3gseV1dLCBidXQgc2luZ2xlIGFycmF5IGluIGRhdGEuXG4gICAgICAgICAgICAvLyBBbHNvIGxhYmVscy9jYXRlZ29yaWVzIHdlcmUgc3VwcGxpZWQgZGlmZmVyZW50bHlcbiAgICAgICAgICAgIGdsLmlzWE51bWVyaWMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGRhdGVzID0gY25mLmxhYmVscy5sZW5ndGggPiAwID8gY25mLmxhYmVscy5zbGljZSgpIDogY25mLnhheGlzLmNhdGVnb3JpZXMuc2xpY2UoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGVzW2pdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBpc0RhdGUgPSBkdC5pc1ZhbGlkRGF0ZShkYXRlc1tqXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnR3b0RTZXJpZXNYLnB1c2goZHQucGFyc2VEYXRlKGRhdGVzW2pdKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGhhdmUgcHJvdmlkZWQgaW52YWxpZCBEYXRlIGZvcm1hdC4gUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBKYXZhU2NyaXB0IERhdGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuc2VyaWVzWC5wdXNoKHRoaXMudHdvRFNlcmllc1gpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdudW1lcmljJykge1xuICAgICAgICAgICAgZ2wuaXNYTnVtZXJpYyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgeCA9IGNuZi5sYWJlbHMubGVuZ3RoID4gMCA/IGNuZi5sYWJlbHMuc2xpY2UoKSA6IGNuZi54YXhpcy5jYXRlZ29yaWVzLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGlmICh4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy50d29EU2VyaWVzWCA9IHg7XG4gICAgICAgICAgICAgIGdsLnNlcmllc1gucHVzaCh0aGlzLnR3b0RTZXJpZXNYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnbC5sYWJlbHMucHVzaCh0aGlzLnR3b0RTZXJpZXNYKTtcbiAgICAgICAgICB2YXIgc2luZ2xlQXJyYXkgPSBzZXJbaV0uZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5wYXJzZU51bWJlcihkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBnbC5zZXJpZXMucHVzaChzaW5nbGVBcnJheSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5zZXJpZXNaLnB1c2godGhpcy50aHJlZURTZXJpZXMpO1xuXG4gICAgICAgIGlmIChzZXJbaV0ubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZ2wuc2VyaWVzTmFtZXMucHVzaChzZXJbaV0ubmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2wuc2VyaWVzTmFtZXMucHVzaCgnc2VyaWVzLScgKyBwYXJzZUludChpICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlRGF0YU5vbkF4aXNDaGFydHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VEYXRhTm9uQXhpc0NoYXJ0cyhzZXIpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIGNuZiA9IHRoaXMudy5jb25maWc7XG4gICAgICBnbC5zZXJpZXMgPSBzZXIuc2xpY2UoKTtcbiAgICAgIGdsLnNlcmllc05hbWVzID0gY25mLmxhYmVscy5zbGljZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsLnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZ2wuc2VyaWVzTmFtZXNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGdsLnNlcmllc05hbWVzLnB1c2goJ3Nlcmllcy0nICsgKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRXh0ZXJuYWxMYWJlbHNEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUV4dGVybmFsTGFiZWxzRGF0YShzZXIpIHtcbiAgICAgIHZhciBjbmYgPSB0aGlzLncuY29uZmlnO1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7IC8vIHVzZXIgcHJvdmlkZWQgbGFiZWxzIGluIGNhdGVnb3J5IGF4aXNcblxuICAgICAgaWYgKGNuZi54YXhpcy5jYXRlZ29yaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZ2wubGFiZWxzID0gY25mLnhheGlzLmNhdGVnb3JpZXM7XG4gICAgICB9IGVsc2UgaWYgKGNuZi5sYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBnbC5sYWJlbHMgPSBjbmYubGFiZWxzLnNsaWNlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZmFsbGJhY2tUb0NhdGVnb3J5KSB7XG4gICAgICAgIGdsLmxhYmVscyA9IGdsLmxhYmVsc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZXIgZGlkbid0IHByb3ZpZGVkIGxhYmVscywgZmFsbGJhY2sgdG8gMS0yLTMtNC01XG4gICAgICAgIHZhciBsYWJlbEFyciA9IFtdO1xuXG4gICAgICAgIGlmIChnbC5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbC5zZXJpZXNbZ2wubWF4VmFsc0luQXJyYXlJbmRleF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVsQXJyLnB1c2goaSArIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzZXIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBnbC5zZXJpZXNYLnB1c2gobGFiZWxBcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdsLmlzWE51bWVyaWMgPSB0cnVlO1xuICAgICAgICB9IC8vIG5vIHNlcmllcyB0byBwdWxsIGxhYmVscyBmcm9tLCBwdXQgYSAwLTEwIHNlcmllc1xuXG5cbiAgICAgICAgaWYgKGxhYmVsQXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxhYmVsQXJyID0gWzAsIDEwXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHNlci5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBnbC5zZXJpZXNYLnB1c2gobGFiZWxBcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmxhYmVscyA9IGxhYmVsQXJyO1xuICAgICAgICBnbC5ub0xhYmVsc1Byb3ZpZGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoY25mLnhheGlzLnR5cGUgPT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgICBnbC5pc1hOdW1lcmljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFNlZ3JlZ2F0ZSB1c2VyIHByb3ZpZGVkIGRhdGEgaW50byBhcHByb3ByaWF0ZSB2YXJzXG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VEYXRhKHNlcikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgY25mID0gdy5jb25maWc7XG4gICAgICB2YXIgZ2wgPSB3Lmdsb2JhbHM7XG4gICAgICB0aGlzLmV4Y2x1ZGVDb2xsYXBzZWRTZXJpZXNJbllBeGlzKCk7XG4gICAgICB0aGlzLmZhbGxiYWNrVG9DYXRlZ29yeSA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXNldEdsb2JhbHMoKTtcbiAgICAgIHRoaXMuaXNNdWx0aXBsZVkoKTtcblxuICAgICAgaWYgKGdsLmF4aXNDaGFydHMpIHtcbiAgICAgICAgdGhpcy5wYXJzZURhdGFBeGlzQ2hhcnRzKHNlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRGF0YU5vbkF4aXNDaGFydHMoc2VyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb3JlVXRpbHMuZ2V0TGFyZ2VzdFNlcmllcygpOyAvLyBzZXQgTnVsbCB2YWx1ZXMgdG8gMCBpbiBhbGwgc2VyaWVzIHdoZW4gdXNlciBoaWRlcy9zaG93cyBzb21lIHNlcmllc1xuXG4gICAgICBpZiAoY25mLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmIGNuZi5jaGFydC5zdGFja2VkKSB7XG4gICAgICAgIHZhciBzZXJpZXMgPSBuZXcgU2VyaWVzKHRoaXMuY3R4KTtcbiAgICAgICAgZ2wuc2VyaWVzID0gc2VyaWVzLnNldE51bGxTZXJpZXNUb1plcm9WYWx1ZXMoZ2wuc2VyaWVzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb3JlVXRpbHMuZ2V0U2VyaWVzVG90YWxzKCk7XG5cbiAgICAgIGlmIChnbC5heGlzQ2hhcnRzKSB7XG4gICAgICAgIHRoaXMuY29yZVV0aWxzLmdldFN0YWNrZWRTZXJpZXNUb3RhbHMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb3JlVXRpbHMuZ2V0UGVyY2VudFNlcmllcygpOyAvLyB1c2VyIGRpZG4ndCBwcm92aWRlIGEgW1t4LHldLFt4LHldXSBzZXJpZXMsIGJ1dCBhIG5hbWVkIHNlcmllc1xuXG4gICAgICBpZiAoIWdsLmlzWE51bWVyaWMgfHwgY25mLnhheGlzLnR5cGUgPT09ICdudW1lcmljJyAmJiBjbmYubGFiZWxzLmxlbmd0aCA9PT0gMCAmJiBjbmYueGF4aXMuY2F0ZWdvcmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFeHRlcm5hbExhYmVsc0RhdGEoc2VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieHlTZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB4eVNldHRpbmdzKCkge1xuICAgICAgdmFyIHh5UmF0aW9zID0gbnVsbDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMucG9zaXRpb24gPT09ICdiYWNrJykge1xuICAgICAgICAgIHZhciBjcm9zc2hhaXJzID0gbmV3IENyb3NzaGFpcnModGhpcy5jdHgpO1xuICAgICAgICAgIGNyb3NzaGFpcnMuZHJhd1hDcm9zc2hhaXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcueWF4aXNbMF0uY3Jvc3NoYWlycy5wb3NpdGlvbiA9PT0gJ2JhY2snKSB7XG4gICAgICAgICAgdmFyIF9jcm9zc2hhaXJzID0gbmV3IENyb3NzaGFpcnModGhpcy5jdHgpO1xuXG4gICAgICAgICAgX2Nyb3NzaGFpcnMuZHJhd1lDcm9zc2hhaXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB4eVJhdGlvcyA9IHRoaXMuY29yZVV0aWxzLmdldENhbGN1bGF0ZWRSYXRpb3MoKTtcblxuICAgICAgICBpZiAody5jb25maWcueGF4aXMudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiB3LmNvbmZpZy54YXhpcy5sYWJlbHMuZm9ybWF0dGVyID09PSB1bmRlZmluZWQgJiYgaXNGaW5pdGUody5nbG9iYWxzLm1pblgpICYmIGlzRmluaXRlKHcuZ2xvYmFscy5tYXhYKSkge1xuICAgICAgICAgIHZhciB0cyA9IG5ldyBUaW1lU2NhbGUodGhpcy5jdHgpO1xuICAgICAgICAgIHZhciBmb3JtYXR0ZWRUaW1lU2NhbGUgPSB0cy5jYWxjdWxhdGVUaW1lU2NhbGVUaWNrcyh3Lmdsb2JhbHMubWluWCwgdy5nbG9iYWxzLm1heFgpO1xuICAgICAgICAgIHRzLnJlY2FsY0RpbWVuc2lvbnNCYXNlZE9uRm9ybWF0KGZvcm1hdHRlZFRpbWVTY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHh5UmF0aW9zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXhpcyh0eXBlLCB4eVJhdGlvcykge1xuICAgICAgdmFyIGdsID0gdGhpcy53Lmdsb2JhbHM7XG4gICAgICB2YXIgY25mID0gdGhpcy53LmNvbmZpZztcbiAgICAgIHZhciB4QXhpcyA9IG5ldyBYQXhpcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgeUF4aXMgPSBuZXcgWUF4aXModGhpcy5jdHgpO1xuXG4gICAgICBpZiAoZ2wuYXhpc0NoYXJ0cyAmJiB0eXBlICE9PSAncmFkYXInKSB7XG4gICAgICAgIHZhciBlbFhheGlzLCBlbFlheGlzO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnYmFyJyAmJiBjbmYucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwpIHtcbiAgICAgICAgICBlbFlheGlzID0geUF4aXMuZHJhd1lheGlzSW52ZXJzZWQoMCk7XG4gICAgICAgICAgZWxYYXhpcyA9IHhBeGlzLmRyYXdYYXhpc0ludmVyc2VkKDApO1xuICAgICAgICAgIGdsLmRvbS5lbEdyYXBoaWNhbC5hZGQoZWxYYXhpcyk7XG4gICAgICAgICAgZ2wuZG9tLmVsR3JhcGhpY2FsLmFkZChlbFlheGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbFhheGlzID0geEF4aXMuZHJhd1hheGlzKCk7XG4gICAgICAgICAgZ2wuZG9tLmVsR3JhcGhpY2FsLmFkZChlbFhheGlzKTtcbiAgICAgICAgICBjbmYueWF4aXMubWFwKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGdsLmlnbm9yZVlBeGlzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZWxZYXhpcyA9IHlBeGlzLmRyYXdZYXhpcyhpbmRleCk7XG4gICAgICAgICAgICAgIGdsLmRvbS5QYXBlci5hZGQoZWxZYXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY25mLnlheGlzLm1hcChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGdsLmlnbm9yZVlBeGlzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgICB5QXhpcy55QXhpc1RpdGxlUm90YXRlKGluZGV4LCB5YXhlLm9wcG9zaXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwQnJ1c2hIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwQnJ1c2hIYW5kbGVyKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53OyAvLyBvbmx5IGZvciBicnVzaCBjaGFydHNcblxuICAgICAgaWYgKCF3LmNvbmZpZy5jaGFydC5icnVzaC5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gaWYgdXNlciBoYXMgbm90IGRlZmluZWQgYSBjdXN0b20gZnVuY3Rpb24gZm9yIHNlbGVjdGlvbiAtIHdlIGhhbmRsZSB0aGUgYnJ1c2ggY2hhcnRcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSBsZWF2ZSBpdCB0byB0aGUgdXNlciB0byBkZWZpbmUgdGhlIGZ1bmN0aW9uYWxpdHkgZm9yIHNlbGVjdGlvblxuXG5cbiAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgdGFyZ2V0cyA9IHcuY29uZmlnLmNoYXJ0LmJydXNoLnRhcmdldHMgfHwgW3cuY29uZmlnLmNoYXJ0LmJydXNoLnRhcmdldF07IC8vIHJldHJvIGNvbXBhdGliaWxpdHkgd2l0aCBzaW5nbGUgdGFyZ2V0IG9wdGlvblxuXG4gICAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgdmFyIHRhcmdldENoYXJ0ID0gQXBleENoYXJ0cy5nZXRDaGFydEJ5SUQodGFyZ2V0KTtcbiAgICAgICAgICB0YXJnZXRDaGFydC53Lmdsb2JhbHMuYnJ1c2hTb3VyY2UgPSBfdGhpczMuY3R4O1xuXG4gICAgICAgICAgdmFyIHVwZGF0ZVNvdXJjZUNoYXJ0ID0gZnVuY3Rpb24gdXBkYXRlU291cmNlQ2hhcnQoKSB7XG4gICAgICAgICAgICBfdGhpczMuY3R4Ll91cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbjogdGFyZ2V0Q2hhcnQudy5nbG9iYWxzLm1pblgsXG4gICAgICAgICAgICAgICAgICAgIG1heDogdGFyZ2V0Q2hhcnQudy5nbG9iYWxzLm1heFhcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0Q2hhcnQudy5jb25maWcuY2hhcnQuZXZlbnRzLnpvb21lZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGFyZ2V0Q2hhcnQudy5jb25maWcuY2hhcnQuZXZlbnRzLnpvb21lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdXBkYXRlU291cmNlQ2hhcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRDaGFydC53LmNvbmZpZy5jaGFydC5ldmVudHMuc2Nyb2xsZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRhcmdldENoYXJ0LncuY29uZmlnLmNoYXJ0LmV2ZW50cy5zY3JvbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdXBkYXRlU291cmNlQ2hhcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLnNlbGVjdGlvbiA9IGZ1bmN0aW9uIChjaGFydCwgZSkge1xuICAgICAgICAgICAgdmFyIHlheGlzID0gVXRpbHMuY2xvbmUody5jb25maWcueWF4aXMpO1xuXG4gICAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuYnJ1c2guYXV0b1NjYWxlWWF4aXMpIHtcbiAgICAgICAgICAgICAgdmFyIHNjYWxlID0gbmV3IFJhbmdlKHRhcmdldENoYXJ0KTtcbiAgICAgICAgICAgICAgeWF4aXMgPSBzY2FsZS5hdXRvU2NhbGVZKHRhcmdldENoYXJ0LCBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0Q2hhcnQuX3VwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgICAgIG1pbjogZS54YXhpcy5taW4sXG4gICAgICAgICAgICAgICAgbWF4OiBlLnhheGlzLm1heFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB5YXhpczogeWF4aXNcbiAgICAgICAgICAgIH0sIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb3JlO1xufSgpO1xuXG4vKipcbiAqIEB0aGlzIHtQcm9taXNlfVxuICovXG5mdW5jdGlvbiBmaW5hbGx5Q29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn1cblxuLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gcHJvbWlzZS1wb2x5ZmlsbCB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbi8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxudmFyIHNldFRpbWVvdXRGdW5jID0gc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIFByb21pc2UkMShmbikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSQxKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKTtcbiAgLyoqIEB0eXBlIHshbnVtYmVyfSAqL1xuICB0aGlzLl9zdGF0ZSA9IDA7XG4gIC8qKiBAdHlwZSB7IWJvb2xlYW59ICovXG4gIHRoaXMuX2hhbmRsZWQgPSBmYWxzZTtcbiAgLyoqIEB0eXBlIHtQcm9taXNlfHVuZGVmaW5lZH0gKi9cbiAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gIC8qKiBAdHlwZSB7IUFycmF5PCFGdW5jdGlvbj59ICovXG4gIHRoaXMuX2RlZmVycmVkcyA9IFtdO1xuXG4gIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZShzZWxmLCBkZWZlcnJlZCkge1xuICB3aGlsZSAoc2VsZi5fc3RhdGUgPT09IDMpIHtcbiAgICBzZWxmID0gc2VsZi5fdmFsdWU7XG4gIH1cbiAgaWYgKHNlbGYuX3N0YXRlID09PSAwKSB7XG4gICAgc2VsZi5fZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICBzZWxmLl9oYW5kbGVkID0gdHJ1ZTtcbiAgUHJvbWlzZSQxLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICB2YXIgY2IgPSBzZWxmLl9zdGF0ZSA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgcmV0ID0gY2Ioc2VsZi5fdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICB0cnkge1xuICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICBpZiAoXG4gICAgICBuZXdWYWx1ZSAmJlxuICAgICAgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuICAgICAgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSQxKSB7XG4gICAgICAgIHNlbGYuX3N0YXRlID0gMztcbiAgICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRvUmVzb2x2ZShiaW5kKHRoZW4sIG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5fc3RhdGUgPSAxO1xuICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgZmluYWxlKHNlbGYpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHNlbGYsIGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICBzZWxmLl9zdGF0ZSA9IDI7XG4gIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gIGZpbmFsZShzZWxmKTtcbn1cblxuZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3N0YXRlID09PSAyICYmIHNlbGYuX2RlZmVycmVkcy5sZW5ndGggPT09IDApIHtcbiAgICBQcm9taXNlJDEuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFzZWxmLl9oYW5kbGVkKSB7XG4gICAgICAgIFByb21pc2UkMS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oc2VsZi5fdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuX2RlZmVycmVkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICB9XG4gIHNlbGYuX2RlZmVycmVkcyA9IG51bGw7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2UpIHtcbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICovXG5mdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHNlbGYpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBmbihcbiAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlamVjdChzZWxmLCByZWFzb24pO1xuICAgICAgfVxuICAgICk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3Qoc2VsZiwgZXgpO1xuICB9XG59XG5cblByb21pc2UkMS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuXG5Qcm9taXNlJDEucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHZhciBwcm9tID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaGFuZGxlKHRoaXMsIG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9tKSk7XG4gIHJldHVybiBwcm9tO1xufTtcblxuUHJvbWlzZSQxLnByb3RvdHlwZVsnZmluYWxseSddID0gZmluYWxseUNvbnN0cnVjdG9yO1xuXG5Qcm9taXNlJDEuYWxsID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICghYXJyIHx8IHR5cGVvZiBhcnIubGVuZ3RoID09PSAndW5kZWZpbmVkJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2UuYWxsIGFjY2VwdHMgYW4gYXJyYXknKTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJlamVjdChleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgfVxuICB9KTtcbn07XG5cblByb21pc2UkMS5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFByb21pc2UkMSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlJDEucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlJDEucmFjZSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0udGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBVc2UgcG9seWZpbGwgZm9yIHNldEltbWVkaWF0ZSBmb3IgcGVyZm9ybWFuY2UgZ2FpbnNcblByb21pc2UkMS5faW1tZWRpYXRlRm4gPVxuICAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGZ1bmN0aW9uKGZuKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH0pIHx8XG4gIGZ1bmN0aW9uKGZuKSB7XG4gICAgc2V0VGltZW91dEZ1bmMoZm4sIDApO1xuICB9O1xuXG5Qcm9taXNlJDEuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3VuaGFuZGxlZFJlamVjdGlvbkZuKGVycikge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUpIHtcbiAgICBjb25zb2xlLndhcm4oJ1Bvc3NpYmxlIFVuaGFuZGxlZCBQcm9taXNlIFJlamVjdGlvbjonLCBlcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgfVxufTtcblxudmFyIEV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHBvcnRzKGN0eCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHBvcnRzKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEV4cG9ydHMsIFt7XG4gICAga2V5OiBcImdldFN2Z1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdmdTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuZG9tLlBhcGVyLnN2ZygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudzsgLy8gaGlkZSBzb21lIGVsZW1lbnRzIHRvIGF2b2lkIHByaW50aW5nIHRoZW0gb24gZXhwb3J0ZWQgc3ZnXG5cbiAgICAgIHZhciB4Y3Jvc3NoYWlycyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXhjcm9zc2hhaXJzJyk7XG4gICAgICB2YXIgeWNyb3NzaGFpcnMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy15Y3Jvc3NoYWlycycpO1xuXG4gICAgICBpZiAoeGNyb3NzaGFpcnMpIHtcbiAgICAgICAgeGNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd4JywgLTUwMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5Y3Jvc3NoYWlycykge1xuICAgICAgICB5Y3Jvc3NoYWlycy5zZXRBdHRyaWJ1dGUoJ3kxJywgLTEwMCk7XG4gICAgICAgIHljcm9zc2hhaXJzLnNldEF0dHJpYnV0ZSgneTInLCAtMTAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3ZnVXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN2Z1VybCgpIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgdmFyIHN2Z0RhdGEgPSB0aGlzLmdldFN2Z1N0cmluZygpO1xuICAgICAgdmFyIHN2Z0Jsb2IgPSBuZXcgQmxvYihbc3ZnRGF0YV0sIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCdcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoc3ZnQmxvYik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGFVUklcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YVVSSSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciB3ID0gX3RoaXMudztcblxuICAgICAgICBfdGhpcy5jbGVhbnVwKCk7XG5cbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3Lmdsb2JhbHMuc3ZnV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB3Lmdsb2JhbHMuc3ZnSGVpZ2h0O1xuICAgICAgICB2YXIgY2FudmFzQmcgPSB3LmNvbmZpZy5jaGFydC5iYWNrZ3JvdW5kID09PSAndHJhbnNwYXJlbnQnID8gJyNmZmYnIDogdy5jb25maWcuY2hhcnQuYmFja2dyb3VuZDtcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY2FudmFzQmc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB2YXIgRE9NVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdztcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblxuICAgICAgICB2YXIgc3ZnRGF0YSA9IF90aGlzLmdldFN2Z1N0cmluZygpO1xuXG4gICAgICAgIHZhciBzdmdVcmwgPSAnZGF0YTppbWFnZS9zdmcreG1sLCcgKyBlbmNvZGVVUklDb21wb25lbnQoc3ZnRGF0YSk7XG5cbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgICAgRE9NVVJMLnJldm9rZU9iamVjdFVSTChzdmdVcmwpO1xuICAgICAgICAgIHZhciBpbWdVUkkgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgICByZXNvbHZlKGltZ1VSSSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaW1nLnNyYyA9IHN2Z1VybDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHBvcnRUb1NWR1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRUb1NWRygpIHtcbiAgICAgIHRoaXMudHJpZ2dlckRvd25sb2FkKHRoaXMuc3ZnVXJsKCksICcuc3ZnJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4cG9ydFRvUG5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFRvUG5nKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGF0YVVSSSgpLnRoZW4oZnVuY3Rpb24gKGltZ1VSSSkge1xuICAgICAgICBfdGhpczIudHJpZ2dlckRvd25sb2FkKGltZ1VSSSwgJy5wbmcnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmlnZ2VyRG93bmxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJpZ2dlckRvd25sb2FkKGhyZWYsIGV4dCkge1xuICAgICAgdmFyIGRvd25sb2FkTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGRvd25sb2FkTGluay5ocmVmID0gaHJlZjtcbiAgICAgIGRvd25sb2FkTGluay5kb3dubG9hZCA9IHRoaXMudy5nbG9iYWxzLmNoYXJ0SUQgKyBleHQ7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvd25sb2FkTGluayk7XG4gICAgICBkb3dubG9hZExpbmsuY2xpY2soKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZG93bmxvYWRMaW5rKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXhwb3J0cztcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIEdyaWQgQ2xhc3MgZm9yIGRyYXdpbmcgQ2FydGVzaWFuIEdyaWQuXG4gKlxuICogQG1vZHVsZSBHcmlkXG4gKiovXG5cbnZhciBHcmlkID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR3JpZChjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JpZCk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB2YXIgdyA9IHRoaXMudztcbiAgICB0aGlzLmFuaW0gPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmN0eCk7XG4gICAgdGhpcy54YXhpc0xhYmVscyA9IHcuZ2xvYmFscy5sYWJlbHMuc2xpY2UoKTtcbiAgICB0aGlzLmFuaW1YID0gdy5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5hbmltYXRlICYmIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZDtcbiAgICB0aGlzLmFuaW1ZID0gdy5jb25maWcuZ3JpZC55YXhpcy5saW5lcy5hbmltYXRlICYmIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZW5hYmxlZDtcblxuICAgIGlmICh3Lmdsb2JhbHMudGltZWxpbmVMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gIHRpbWVsaW5lIGxhYmVscyBhcmUgdGhlcmVcbiAgICAgIHRoaXMueGF4aXNMYWJlbHMgPSB3Lmdsb2JhbHMudGltZWxpbmVMYWJlbHMuc2xpY2UoKTtcbiAgICB9XG4gIH0gLy8gLndoZW4gdXNpbmcgc3BhcmtsaW5lcyBvciB3aGVuIHNob3dpbmcgbm8gZ3JpZCwgd2UgbmVlZCB0byBoYXZlIGEgZ3JpZCBhcmVhIHdoaWNoIGlzIHJldXNlZCBhdCBtYW55IHBsYWNlcyBmb3Igb3RoZXIgY2FsY3VsYXRpb25zIGFzIHdlbGxcblxuXG4gIF9jcmVhdGVDbGFzcyhHcmlkLCBbe1xuICAgIGtleTogXCJkcmF3R3JpZEFyZWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0dyaWRBcmVhKCkge1xuICAgICAgdmFyIGVsR3JpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcblxuICAgICAgaWYgKGVsR3JpZCA9PT0gbnVsbCkge1xuICAgICAgICBlbEdyaWQgPSBncmFwaGljcy5ncm91cCh7XG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWdyaWQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxWZXJ0aWNhbExpbmUgPSBncmFwaGljcy5kcmF3TGluZSh3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCwgMSwgdy5nbG9iYWxzLnBhZEhvcml6b250YWwsIHcuZ2xvYmFscy5ncmlkSGVpZ2h0LCAndHJhbnNwYXJlbnQnKTtcbiAgICAgIHZhciBlbEhvcnpMaW5lID0gZ3JhcGhpY3MuZHJhd0xpbmUody5nbG9iYWxzLnBhZEhvcml6b250YWwsIHcuZ2xvYmFscy5ncmlkSGVpZ2h0LCB3Lmdsb2JhbHMuZ3JpZFdpZHRoLCB3Lmdsb2JhbHMuZ3JpZEhlaWdodCwgJ3RyYW5zcGFyZW50Jyk7XG4gICAgICBlbEdyaWQuYWRkKGVsSG9yekxpbmUpO1xuICAgICAgZWxHcmlkLmFkZChlbFZlcnRpY2FsTGluZSk7XG4gICAgICByZXR1cm4gZWxHcmlkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3R3JpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3R3JpZCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHhBeGlzID0gbmV3IFhBeGlzKHRoaXMuY3R4KTtcbiAgICAgIHZhciBnbCA9IHRoaXMudy5nbG9iYWxzO1xuICAgICAgdmFyIGVsZ3JpZCA9IG51bGw7XG5cbiAgICAgIGlmIChnbC5heGlzQ2hhcnRzKSB7XG4gICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnNob3cpIHtcbiAgICAgICAgICAvLyBncmlkIGlzIGRyYXduIGFmdGVyIHhheGlzIGFuZCB5YXhpcyBhcmUgZHJhd25cbiAgICAgICAgICBlbGdyaWQgPSB0aGlzLnJlbmRlckdyaWQoKTtcbiAgICAgICAgICBnbC5kb20uZWxHcmFwaGljYWwuYWRkKGVsZ3JpZC5lbCk7XG4gICAgICAgICAgdGhpcy5kcmF3R3JpZEFyZWEoZWxncmlkLmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZWxncmlkQXJlYSA9IHRoaXMuZHJhd0dyaWRBcmVhKCk7XG4gICAgICAgICAgZ2wuZG9tLmVsR3JhcGhpY2FsLmFkZChlbGdyaWRBcmVhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGdyaWQgIT09IG51bGwpIHtcbiAgICAgICAgICB4QXhpcy54QXhpc0xhYmVsQ29ycmVjdGlvbnMoZWxncmlkLnhBeGlzVGlja1dpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gVGhpcyBtYXNrIHdpbGwgY2xpcCBvZmYgb3ZlcmZsb3dpbmcgZ3JhcGhpY3MgZnJvbSB0aGUgZHJhd2FibGUgYXJlYVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlR3JpZE1hc2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlR3JpZE1hc2soKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgc3Ryb2tlU2l6ZSA9IEFycmF5LmlzQXJyYXkody5jb25maWcuc3Ryb2tlLndpZHRoKSA/IDAgOiB3LmNvbmZpZy5zdHJva2Uud2lkdGg7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHcuY29uZmlnLnN0cm9rZS53aWR0aCkpIHtcbiAgICAgICAgdmFyIHN0cm9rZU1heFNpemUgPSAwO1xuICAgICAgICB3LmNvbmZpZy5zdHJva2Uud2lkdGguZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHN0cm9rZU1heFNpemUgPSBNYXRoLm1heChzdHJva2VNYXhTaXplLCBtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cm9rZVNpemUgPSBzdHJva2VNYXhTaXplO1xuICAgICAgfVxuXG4gICAgICBnbC5kb20uZWxHcmlkUmVjdE1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZ2wuU1ZHTlMsICdjbGlwUGF0aCcpO1xuICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXNrLnNldEF0dHJpYnV0ZSgnaWQnLCBcImdyaWRSZWN0TWFza1wiLmNvbmNhdChnbC5jdWlkKSk7XG4gICAgICBnbC5kb20uZWxHcmlkUmVjdE1hcmtlck1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZ2wuU1ZHTlMsICdjbGlwUGF0aCcpO1xuICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXJrZXJNYXNrLnNldEF0dHJpYnV0ZSgnaWQnLCBcImdyaWRSZWN0TWFya2VyTWFza1wiLmNvbmNhdChnbC5jdWlkKSk7XG4gICAgICBnbC5kb20uZWxHcmlkUmVjdCA9IGdyYXBoaWNzLmRyYXdSZWN0KC1zdHJva2VTaXplIC8gMiwgLXN0cm9rZVNpemUgLyAyLCBnbC5ncmlkV2lkdGggKyBzdHJva2VTaXplLCBnbC5ncmlkSGVpZ2h0ICsgc3Ryb2tlU2l6ZSwgMCwgJyNmZmYnKTtcbiAgICAgIHZhciBjb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMpO1xuICAgICAgY29yZVV0aWxzLmdldExhcmdlc3RNYXJrZXJTaXplKCk7XG4gICAgICB2YXIgbWFya2VyU2l6ZSA9IHcuZ2xvYmFscy5tYXJrZXJzLmxhcmdlc3RTaXplICsgdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplT2Zmc2V0ICsgMTtcbiAgICAgIGdsLmRvbS5lbEdyaWRSZWN0TWFya2VyID0gZ3JhcGhpY3MuZHJhd1JlY3QoLW1hcmtlclNpemUsIC1tYXJrZXJTaXplLCBnbC5ncmlkV2lkdGggKyBtYXJrZXJTaXplICogMiwgZ2wuZ3JpZEhlaWdodCArIG1hcmtlclNpemUgKiAyLCAwLCAnI2ZmZicpO1xuICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXNrLmFwcGVuZENoaWxkKGdsLmRvbS5lbEdyaWRSZWN0Lm5vZGUpO1xuICAgICAgZ2wuZG9tLmVsR3JpZFJlY3RNYXJrZXJNYXNrLmFwcGVuZENoaWxkKGdsLmRvbS5lbEdyaWRSZWN0TWFya2VyLm5vZGUpO1xuICAgICAgdmFyIGRlZnMgPSBnbC5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJ2RlZnMnKTtcbiAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsR3JpZFJlY3RNYXNrKTtcbiAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZ2wuZG9tLmVsR3JpZFJlY3RNYXJrZXJNYXNrKTtcbiAgICB9IC8vIGFjdHVhbCBncmlkIHJlbmRlcmluZ1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyR3JpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJHcmlkKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgdmFyIHN0cm9rZURhc2hBcnJheSA9IHcuY29uZmlnLmdyaWQuc3Ryb2tlRGFzaEFycmF5O1xuICAgICAgdmFyIGVsZyA9IGdyYXBoaWNzLmdyb3VwKHtcbiAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLWdyaWQnXG4gICAgICB9KTtcbiAgICAgIHZhciB0aWNrQW1vdW50ID0gODtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygdy5nbG9iYWxzLnlBeGlzU2NhbGVbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGlja0Ftb3VudCA9IHcuZ2xvYmFscy55QXhpc1NjYWxlW2ldLnJlc3VsdC5sZW5ndGggLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpY2tBbW91bnQgPiAyKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHhDb3VudDtcbiAgICAgIHZhciBpbnZlcnNlZEdyaWQgPSAhISh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCAmJiB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyk7XG5cbiAgICAgIGlmICghaW52ZXJzZWRHcmlkKSB7XG4gICAgICAgIHhDb3VudCA9IHRoaXMueGF4aXNMYWJlbHMubGVuZ3RoOyAvLyBkcmF3IHZlcnRpY2FsIGxpbmVzXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQueGF4aXMubGluZXMuc2hvdyB8fCB3LmNvbmZpZy54YXhpcy5heGlzVGlja3Muc2hvdykge1xuICAgICAgICAgIHZhciB4MSA9IHcuZ2xvYmFscy5wYWRIb3Jpem9udGFsO1xuICAgICAgICAgIHZhciB5MSA9IDA7XG4gICAgICAgICAgdmFyIHgyO1xuICAgICAgICAgIHZhciB5MiA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy50aW1lbGluZUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgeENvdW50OyBfaSsrKSB7XG4gICAgICAgICAgICAgIHgxID0gdGhpcy54YXhpc0xhYmVsc1tfaV0ucG9zaXRpb247XG4gICAgICAgICAgICAgIHgyID0gdGhpcy54YXhpc0xhYmVsc1tfaV0ucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQueGF4aXMubGluZXMuc2hvdyAmJiB4MSA+IDAgJiYgeDEgPCB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBncmFwaGljcy5kcmF3TGluZSh4MSwgeTEsIHgyLCB5Miwgdy5jb25maWcuZ3JpZC5ib3JkZXJDb2xvciwgc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgICAgICAgICAgICBsaW5lLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1ncmlkbGluZScpO1xuICAgICAgICAgICAgICAgIGVsZy5hZGQobGluZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltWCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlTGluZShsaW5lLCB7XG4gICAgICAgICAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgICAgICAgICB4MjogMFxuICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICAgICAgICAgIHgyOiB4MlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHhBeGlzID0gbmV3IFhBeGlzKHRoaXMuY3R4KTtcbiAgICAgICAgICAgICAgeEF4aXMuZHJhd1hheGlzVGlja3MoeDEsIGVsZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB4Q291bnRGb3JDYXRlZ29yeUNoYXJ0cyA9IHhDb3VudDtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgeENvdW50Rm9yQ2F0ZWdvcnlDaGFydHM7IF9pMisrKSB7XG4gICAgICAgICAgICAgIHZhciB4MUNvdW50ID0geENvdW50Rm9yQ2F0ZWdvcnlDaGFydHM7XG5cbiAgICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljICYmIHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdiYXInKSB7XG4gICAgICAgICAgICAgICAgeDFDb3VudCAtPSAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgeDEgPSB4MSArIHcuZ2xvYmFscy5ncmlkV2lkdGggLyB4MUNvdW50O1xuICAgICAgICAgICAgICB4MiA9IHgxOyAvLyBza2lwIHRoZSBsYXN0IGxpbmVcblxuICAgICAgICAgICAgICBpZiAoX2kyID09PSB4MUNvdW50IC0gMSkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQueGF4aXMubGluZXMuc2hvdykge1xuICAgICAgICAgICAgICAgIHZhciBfbGluZSA9IGdyYXBoaWNzLmRyYXdMaW5lKHgxLCB5MSwgeDIsIHkyLCB3LmNvbmZpZy5ncmlkLmJvcmRlckNvbG9yLCBzdHJva2VEYXNoQXJyYXkpO1xuXG4gICAgICAgICAgICAgICAgX2xpbmUubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWdyaWRsaW5lJyk7XG5cbiAgICAgICAgICAgICAgICBlbGcuYWRkKF9saW5lKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1YKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVMaW5lKF9saW5lLCB7XG4gICAgICAgICAgICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgICAgICAgICAgICB4MjogMFxuICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICAgICAgICAgIHgyOiB4MlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF94QXhpcyA9IG5ldyBYQXhpcyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICAgICAgX3hBeGlzLmRyYXdYYXhpc1RpY2tzKHgxLCBlbGcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBkcmF3IGhvcml6b250YWwgbGluZXNcblxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5ncmlkLnlheGlzLmxpbmVzLnNob3cpIHtcbiAgICAgICAgICB2YXIgX3ggPSAwO1xuICAgICAgICAgIHZhciBfeSA9IDA7XG4gICAgICAgICAgdmFyIF95MiA9IDA7XG4gICAgICAgICAgdmFyIF94MiA9IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCB0aWNrQW1vdW50ICsgMTsgX2kzKyspIHtcbiAgICAgICAgICAgIHZhciBfbGluZTIgPSBncmFwaGljcy5kcmF3TGluZShfeCwgX3ksIF94MiwgX3kyLCB3LmNvbmZpZy5ncmlkLmJvcmRlckNvbG9yLCBzdHJva2VEYXNoQXJyYXkpO1xuXG4gICAgICAgICAgICBlbGcuYWRkKF9saW5lMik7XG5cbiAgICAgICAgICAgIF9saW5lMi5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZ3JpZGxpbmUnKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbVkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hbmltYXRlTGluZShfbGluZTIsIHtcbiAgICAgICAgICAgICAgICB5MTogX3kgKyAyMCxcbiAgICAgICAgICAgICAgICB5MjogX3kyICsgMjBcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHkxOiBfeSxcbiAgICAgICAgICAgICAgICB5MjogX3kyXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfeSA9IF95ICsgdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB0aWNrQW1vdW50O1xuICAgICAgICAgICAgX3kyID0gX3k7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4Q291bnQgPSB0aWNrQW1vdW50OyAvLyBkcmF3IHZlcnRpY2FsIGxpbmVzXG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmdyaWQueGF4aXMubGluZXMuc2hvdyB8fCB3LmNvbmZpZy54YXhpcy5heGlzVGlja3Muc2hvdykge1xuICAgICAgICAgIHZhciBfeDMgPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbDtcbiAgICAgICAgICB2YXIgX3kzID0gMDtcblxuICAgICAgICAgIHZhciBfeDQ7XG5cbiAgICAgICAgICB2YXIgX3k0ID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCB4Q291bnQgKyAxOyBfaTQrKykge1xuICAgICAgICAgICAgX3gzID0gX3gzICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHhDb3VudCArIDAuMztcbiAgICAgICAgICAgIF94NCA9IF94MzsgLy8gc2tpcCB0aGUgbGFzdCB2ZXJ0aWNhbCBsaW5lXG5cbiAgICAgICAgICAgIGlmIChfaTQgPT09IHhDb3VudCAtIDEpIGJyZWFrO1xuXG4gICAgICAgICAgICBpZiAody5jb25maWcuZ3JpZC54YXhpcy5saW5lcy5zaG93KSB7XG4gICAgICAgICAgICAgIHZhciBfbGluZTMgPSBncmFwaGljcy5kcmF3TGluZShfeDMsIF95MywgX3g0LCBfeTQsIHcuY29uZmlnLmdyaWQuYm9yZGVyQ29sb3IsIHN0cm9rZURhc2hBcnJheSk7XG5cbiAgICAgICAgICAgICAgX2xpbmUzLm5vZGUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1ncmlkbGluZScpO1xuXG4gICAgICAgICAgICAgIGVsZy5hZGQoX2xpbmUzKTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5hbmltWCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUxpbmUoX2xpbmUzLCB7XG4gICAgICAgICAgICAgICAgICB4MTogMCxcbiAgICAgICAgICAgICAgICAgIHgyOiAwXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgeDE6IF94MyxcbiAgICAgICAgICAgICAgICAgIHgyOiBfeDRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBza2lwIHRoZSBmaXJzdCB2ZXJ0aWNhbCBsaW5lXG5cblxuICAgICAgICAgICAgdmFyIF94QXhpczIgPSBuZXcgWEF4aXModGhpcy5jdHgpO1xuXG4gICAgICAgICAgICBfeEF4aXMyLmRyYXdYYXhpc1RpY2tzKF94MywgZWxnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZHJhdyBob3Jpem9udGFsIGxpbmVzXG5cblxuICAgICAgICBpZiAody5jb25maWcuZ3JpZC55YXhpcy5saW5lcy5zaG93KSB7XG4gICAgICAgICAgdmFyIF94NSA9IDA7XG4gICAgICAgICAgdmFyIF95NSA9IDA7XG4gICAgICAgICAgdmFyIF95NiA9IDA7XG4gICAgICAgICAgdmFyIF94NiA9IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCB3Lmdsb2JhbHMuZGF0YVBvaW50cyArIDE7IF9pNSsrKSB7XG4gICAgICAgICAgICB2YXIgX2xpbmU0ID0gZ3JhcGhpY3MuZHJhd0xpbmUoX3g1LCBfeTUsIF94NiwgX3k2LCB3LmNvbmZpZy5ncmlkLmJvcmRlckNvbG9yLCBzdHJva2VEYXNoQXJyYXkpO1xuXG4gICAgICAgICAgICBlbGcuYWRkKF9saW5lNCk7XG5cbiAgICAgICAgICAgIF9saW5lNC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZ3JpZGxpbmUnKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbVkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hbmltYXRlTGluZShfbGluZTQsIHtcbiAgICAgICAgICAgICAgICB5MTogX3k1ICsgMjAsXG4gICAgICAgICAgICAgICAgeTI6IF95NiArIDIwXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB5MTogX3k1LFxuICAgICAgICAgICAgICAgIHkyOiBfeTZcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF95NSA9IF95NSArIHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gdy5nbG9iYWxzLmRhdGFQb2ludHM7XG4gICAgICAgICAgICBfeTYgPSBfeTU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJhd0dyaWRCYW5kcyhlbGcsIHhDb3VudCwgdGlja0Ftb3VudCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbDogZWxnLFxuICAgICAgICB4QXhpc1RpY2tXaWR0aDogdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHhDb3VudFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0dyaWRCYW5kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3R3JpZEJhbmRzKGVsZywgeENvdW50LCB0aWNrQW1vdW50KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7IC8vIHJvd3MgYmFja2dyb3VuZCBiYW5kc1xuXG4gICAgICBpZiAody5jb25maWcuZ3JpZC5yb3cuY29sb3JzICE9PSB1bmRlZmluZWQgJiYgdy5jb25maWcuZ3JpZC5yb3cuY29sb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHgxID0gMDtcbiAgICAgICAgdmFyIHkxID0gMDtcbiAgICAgICAgdmFyIHkyID0gdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB0aWNrQW1vdW50O1xuICAgICAgICB2YXIgeDIgPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBjID0gMDsgaSA8IHRpY2tBbW91bnQ7IGkrKywgYysrKSB7XG4gICAgICAgICAgaWYgKGMgPj0gdy5jb25maWcuZ3JpZC5yb3cuY29sb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgYyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNvbG9yID0gdy5jb25maWcuZ3JpZC5yb3cuY29sb3JzW2NdO1xuICAgICAgICAgIHZhciByZWN0ID0gZ3JhcGhpY3MuZHJhd1JlY3QoeDEsIHkxLCB4MiwgeTIsIDAsIGNvbG9yLCB3LmNvbmZpZy5ncmlkLnJvdy5vcGFjaXR5KTtcbiAgICAgICAgICBlbGcuYWRkKHJlY3QpO1xuICAgICAgICAgIHJlY3Qubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWdyaWRSb3cnKTtcbiAgICAgICAgICB5MSA9IHkxICsgdy5nbG9iYWxzLmdyaWRIZWlnaHQgLyB0aWNrQW1vdW50O1xuICAgICAgICB9XG4gICAgICB9IC8vIGNvbHVtbnMgYmFja2dyb3VuZCBiYW5kc1xuXG5cbiAgICAgIGlmICh3LmNvbmZpZy5ncmlkLmNvbHVtbi5jb2xvcnMgIT09IHVuZGVmaW5lZCAmJiB3LmNvbmZpZy5ncmlkLmNvbHVtbi5jb2xvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX3g3ID0gdy5nbG9iYWxzLnBhZEhvcml6b250YWw7XG4gICAgICAgIHZhciBfeTcgPSAwO1xuXG4gICAgICAgIHZhciBfeDggPSB3Lmdsb2JhbHMucGFkSG9yaXpvbnRhbCArIHcuZ2xvYmFscy5ncmlkV2lkdGggLyB4Q291bnQ7XG5cbiAgICAgICAgdmFyIF95OCA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0O1xuXG4gICAgICAgIGZvciAodmFyIF9pNiA9IDAsIF9jID0gMDsgX2k2IDwgeENvdW50OyBfaTYrKywgX2MrKykge1xuICAgICAgICAgIGlmIChfYyA+PSB3LmNvbmZpZy5ncmlkLmNvbHVtbi5jb2xvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBfYyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9jb2xvciA9IHcuY29uZmlnLmdyaWQuY29sdW1uLmNvbG9yc1tfY107XG5cbiAgICAgICAgICB2YXIgX3JlY3QgPSBncmFwaGljcy5kcmF3UmVjdChfeDcsIF95NywgX3g4LCBfeTgsIDAsIF9jb2xvciwgdy5jb25maWcuZ3JpZC5jb2x1bW4ub3BhY2l0eSk7XG5cbiAgICAgICAgICBfcmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtZ3JpZENvbHVtbicpO1xuXG4gICAgICAgICAgZWxnLmFkZChfcmVjdCk7XG4gICAgICAgICAgX3g3ID0gX3g3ICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHhDb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlTGluZShsaW5lLCBmcm9tLCB0bykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgaW5pdGlhbEFuaW0gPSB3LmNvbmZpZy5jaGFydC5hbmltYXRpb25zO1xuXG4gICAgICBpZiAoaW5pdGlhbEFuaW0gJiYgIXcuZ2xvYmFscy5yZXNpemVkICYmICF3Lmdsb2JhbHMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgdmFyIHNwZWVkID0gaW5pdGlhbEFuaW0uc3BlZWQ7XG4gICAgICAgIHRoaXMuYW5pbS5hbmltYXRlTGluZShsaW5lLCBmcm9tLCB0bywgc3BlZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHcmlkO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgTGVnZW5kIENsYXNzIHRvIGRyYXcgbGVnZW5kLlxuICpcbiAqIEBtb2R1bGUgTGVnZW5kXG4gKiovXG5cbnZhciBMZWdlbmQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMZWdlbmQoY3R4LCBvcHRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExlZ2VuZCk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB0aGlzLm9uTGVnZW5kQ2xpY2sgPSB0aGlzLm9uTGVnZW5kQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTGVnZW5kSG92ZXJlZCA9IHRoaXMub25MZWdlbmRIb3ZlcmVkLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGVnZW5kLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBnbCA9IHcuZ2xvYmFscztcbiAgICAgIHZhciBjbmYgPSB3LmNvbmZpZztcbiAgICAgIHZhciBzaG93TGVnZW5kQWx3YXlzID0gY25mLmxlZ2VuZC5zaG93Rm9yU2luZ2xlU2VyaWVzICYmIGdsLnNlcmllcy5sZW5ndGggPT09IDEgfHwgZ2wuc2VyaWVzLmxlbmd0aCA+IDE7XG5cbiAgICAgIGlmICgoc2hvd0xlZ2VuZEFsd2F5cyB8fCAhZ2wuYXhpc0NoYXJ0cykgJiYgY25mLmxlZ2VuZC5zaG93KSB7XG4gICAgICAgIHdoaWxlIChnbC5kb20uZWxMZWdlbmRXcmFwLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBnbC5kb20uZWxMZWdlbmRXcmFwLnJlbW92ZUNoaWxkKGdsLmRvbS5lbExlZ2VuZFdyYXAuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYXdMZWdlbmRzKCk7XG5cbiAgICAgICAgaWYgKCFVdGlscy5pc0lFMTEoKSkge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVG9Gb3JlaWduT2JqZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSUUxMSBkb2Vzbid0IHN1cHBvcnRzIGZvcmVpZ25PYmplY3QsIGhlbmNlIGFwcGVuZCBpdCB0byA8aGVhZD5cbiAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHRoaXMuZ2V0TGVnZW5kU3R5bGVzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNuZi5sZWdlbmQucG9zaXRpb24gPT09ICdib3R0b20nIHx8IGNuZi5sZWdlbmQucG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgdGhpcy5sZWdlbmRBbGlnbkhvcml6b250YWwoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbmYubGVnZW5kLnBvc2l0aW9uID09PSAncmlnaHQnIHx8IGNuZi5sZWdlbmQucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRoaXMubGVnZW5kQWxpZ25WZXJ0aWNhbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZFRvRm9yZWlnbk9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRUb0ZvcmVpZ25PYmplY3QoKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIHZhciBlbEZvcmVpZ24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZ2wuU1ZHTlMsICdmb3JlaWduT2JqZWN0Jyk7XG4gICAgICBlbEZvcmVpZ24uc2V0QXR0cmlidXRlKCd4JywgMCk7XG4gICAgICBlbEZvcmVpZ24uc2V0QXR0cmlidXRlKCd5JywgMCk7XG4gICAgICBlbEZvcmVpZ24uc2V0QXR0cmlidXRlKCd3aWR0aCcsIGdsLnN2Z1dpZHRoKTtcbiAgICAgIGVsRm9yZWlnbi5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGdsLnN2Z0hlaWdodCk7XG4gICAgICBnbC5kb20uZWxMZWdlbmRXcmFwLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcpO1xuICAgICAgZWxGb3JlaWduLmFwcGVuZENoaWxkKGdsLmRvbS5lbExlZ2VuZFdyYXApO1xuICAgICAgZWxGb3JlaWduLmFwcGVuZENoaWxkKHRoaXMuZ2V0TGVnZW5kU3R5bGVzKCkpO1xuICAgICAgZ2wuZG9tLlBhcGVyLm5vZGUuaW5zZXJ0QmVmb3JlKGVsRm9yZWlnbiwgZ2wuZG9tLmVsR3JhcGhpY2FsLm5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3TGVnZW5kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3TGVnZW5kcygpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGZvbnRGYW1pbHkgPSB3LmNvbmZpZy5sZWdlbmQuZm9udEZhbWlseTtcbiAgICAgIHZhciBsZWdlbmROYW1lcyA9IHcuZ2xvYmFscy5zZXJpZXNOYW1lcztcbiAgICAgIHZhciBmaWxsY29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzLnNsaWNlKCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAuY29sb3JTY2FsZS5yYW5nZXM7XG4gICAgICAgIGxlZ2VuZE5hbWVzID0gcmFuZ2VzLm1hcChmdW5jdGlvbiAoY29sb3JTY2FsZSkge1xuICAgICAgICAgIHJldHVybiBjb2xvclNjYWxlLm5hbWUgPyBjb2xvclNjYWxlLm5hbWUgOiBjb2xvclNjYWxlLmZyb20gKyAnIC0gJyArIGNvbG9yU2NhbGUudG87XG4gICAgICAgIH0pO1xuICAgICAgICBmaWxsY29sb3IgPSByYW5nZXMubWFwKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICAgIHJldHVybiBjb2xvci5jb2xvcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWdlbmRGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMubGVnZW5kRm9ybWF0dGVyO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsZWdlbmROYW1lcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIHRleHQgPSBsZWdlbmRGb3JtYXR0ZXIobGVnZW5kTmFtZXNbaV0sIHtcbiAgICAgICAgICBzZXJpZXNJbmRleDogaSxcbiAgICAgICAgICB3OiB3XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY29sbGFwc2VkU2VyaWVzID0gZmFsc2U7XG4gICAgICAgIHZhciBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXMgPSBmYWxzZTtcblxuICAgICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc1tjXS5pbmRleCA9PT0gaSkge1xuICAgICAgICAgICAgICBjb2xsYXBzZWRTZXJpZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2MgPSAwOyBfYyA8IHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzLmxlbmd0aDsgX2MrKykge1xuICAgICAgICAgICAgaWYgKHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzW19jXSA9PT0gaSkge1xuICAgICAgICAgICAgICBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbE1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgZWxNYXJrZXIuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1sZWdlbmQtbWFya2VyJyk7XG4gICAgICAgIHZhciBtT2Zmc2V0WCA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLm9mZnNldFg7XG4gICAgICAgIHZhciBtT2Zmc2V0WSA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLm9mZnNldFk7XG4gICAgICAgIHZhciBtSGVpZ2h0ID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMuaGVpZ2h0O1xuICAgICAgICB2YXIgbVdpZHRoID0gdy5jb25maWcubGVnZW5kLm1hcmtlcnMud2lkdGg7XG4gICAgICAgIHZhciBtQm9yZGVyV2lkdGggPSB3LmNvbmZpZy5sZWdlbmQubWFya2Vycy5zdHJva2VXaWR0aDtcbiAgICAgICAgdmFyIG1Cb3JkZXJDb2xvciA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLnN0cm9rZUNvbG9yO1xuICAgICAgICB2YXIgbUJvcmRlclJhZGl1cyA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLnJhZGl1cztcbiAgICAgICAgdmFyIG1TdHlsZSA9IGVsTWFya2VyLnN0eWxlO1xuICAgICAgICBtU3R5bGUuYmFja2dyb3VuZCA9IGZpbGxjb2xvcltpXTtcbiAgICAgICAgbVN0eWxlLmNvbG9yID0gZmlsbGNvbG9yW2ldO1xuICAgICAgICBtU3R5bGUuaGVpZ2h0ID0gQXJyYXkuaXNBcnJheShtSGVpZ2h0KSA/IHBhcnNlRmxvYXQobUhlaWdodFtpXSkgKyAncHgnIDogcGFyc2VGbG9hdChtSGVpZ2h0KSArICdweCc7XG4gICAgICAgIG1TdHlsZS53aWR0aCA9IEFycmF5LmlzQXJyYXkobVdpZHRoKSA/IHBhcnNlRmxvYXQobVdpZHRoW2ldKSArICdweCcgOiBwYXJzZUZsb2F0KG1XaWR0aCkgKyAncHgnO1xuICAgICAgICBtU3R5bGUubGVmdCA9IEFycmF5LmlzQXJyYXkobU9mZnNldFgpID8gbU9mZnNldFhbaV0gOiBtT2Zmc2V0WDtcbiAgICAgICAgbVN0eWxlLnRvcCA9IEFycmF5LmlzQXJyYXkobU9mZnNldFkpID8gbU9mZnNldFlbaV0gOiBtT2Zmc2V0WTtcbiAgICAgICAgbVN0eWxlLmJvcmRlcldpZHRoID0gQXJyYXkuaXNBcnJheShtQm9yZGVyV2lkdGgpID8gbUJvcmRlcldpZHRoW2ldIDogbUJvcmRlcldpZHRoO1xuICAgICAgICBtU3R5bGUuYm9yZGVyQ29sb3IgPSBBcnJheS5pc0FycmF5KG1Cb3JkZXJDb2xvcikgPyBtQm9yZGVyQ29sb3JbaV0gOiBtQm9yZGVyQ29sb3I7XG4gICAgICAgIG1TdHlsZS5ib3JkZXJSYWRpdXMgPSBBcnJheS5pc0FycmF5KG1Cb3JkZXJSYWRpdXMpID8gcGFyc2VGbG9hdChtQm9yZGVyUmFkaXVzW2ldKSArICdweCcgOiBwYXJzZUZsb2F0KG1Cb3JkZXJSYWRpdXMpICsgJ3B4JztcblxuICAgICAgICBpZiAody5jb25maWcubGVnZW5kLm1hcmtlcnMuY3VzdG9tSFRNTCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLmN1c3RvbUhUTUwpKSB7XG4gICAgICAgICAgICBlbE1hcmtlci5pbm5lckhUTUwgPSB3LmNvbmZpZy5sZWdlbmQubWFya2Vycy5jdXN0b21IVE1MW2ldKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsTWFya2VyLmlubmVySFRNTCA9IHcuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLmN1c3RvbUhUTUwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhlbE1hcmtlciwge1xuICAgICAgICAgIHJlbDogaSArIDEsXG4gICAgICAgICAgJ2RhdGE6Y29sbGFwc2VkJzogY29sbGFwc2VkU2VyaWVzIHx8IGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY29sbGFwc2VkU2VyaWVzIHx8IGFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcykge1xuICAgICAgICAgIGVsTWFya2VyLmNsYXNzTGlzdC5hZGQoJ2luYWN0aXZlLWxlZ2VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsTGVnZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciBlbExlZ2VuZFRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGVsTGVnZW5kVGV4dC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLWxlZ2VuZC10ZXh0Jyk7XG4gICAgICAgIGVsTGVnZW5kVGV4dC5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgICB2YXIgdGV4dENvbG9yID0gdy5jb25maWcubGVnZW5kLmxhYmVscy51c2VTZXJpZXNDb2xvcnMgPyB3Lmdsb2JhbHMuY29sb3JzW2ldIDogdy5jb25maWcubGVnZW5kLmxhYmVscy5jb2xvcnM7XG5cbiAgICAgICAgaWYgKCF0ZXh0Q29sb3IpIHtcbiAgICAgICAgICB0ZXh0Q29sb3IgPSB3LmNvbmZpZy5jaGFydC5mb3JlQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBlbExlZ2VuZFRleHQuc3R5bGUuY29sb3IgPSB0ZXh0Q29sb3I7XG4gICAgICAgIGVsTGVnZW5kVGV4dC5zdHlsZS5mb250U2l6ZSA9IHBhcnNlRmxvYXQody5jb25maWcubGVnZW5kLmZvbnRTaXplKSArICdweCc7XG4gICAgICAgIGVsTGVnZW5kVGV4dC5zdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseSB8fCB3LmNvbmZpZy5jaGFydC5mb250RmFtaWx5O1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyhlbExlZ2VuZFRleHQsIHtcbiAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICdkYXRhOmNvbGxhcHNlZCc6IGNvbGxhcHNlZFNlcmllcyB8fCBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGVsTGVnZW5kLmFwcGVuZENoaWxkKGVsTWFya2VyKTtcbiAgICAgICAgZWxMZWdlbmQuYXBwZW5kQ2hpbGQoZWxMZWdlbmRUZXh0KTtcbiAgICAgICAgdmFyIGNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcy5jdHgpO1xuXG4gICAgICAgIGlmICghdy5jb25maWcubGVnZW5kLnNob3dGb3JaZXJvU2VyaWVzKSB7XG4gICAgICAgICAgdmFyIHRvdGFsID0gY29yZVV0aWxzLmdldFNlcmllc1RvdGFsQnlJbmRleChpKTtcblxuICAgICAgICAgIGlmICh0b3RhbCA9PT0gMCAmJiBjb3JlVXRpbHMuc2VyaWVzSGF2ZVNhbWVWYWx1ZXMoaSkgJiYgIWNvcmVVdGlscy5pc1Nlcmllc051bGwoaSkgJiYgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihpKSA9PT0gLTEgJiYgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVsTGVnZW5kLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtaGlkZGVuLXplcm8tc2VyaWVzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3LmNvbmZpZy5sZWdlbmQuc2hvd0Zvck51bGxTZXJpZXMpIHtcbiAgICAgICAgICBpZiAoY29yZVV0aWxzLmlzU2VyaWVzTnVsbChpKSAmJiB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSAmJiB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgZWxMZWdlbmQuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1oaWRkZW4tbnVsbC1zZXJpZXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsTGVnZW5kV3JhcC5hcHBlbmRDaGlsZChlbExlZ2VuZCk7XG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLmNsYXNzTGlzdC5hZGQody5jb25maWcubGVnZW5kLmhvcml6b250YWxBbGlnbik7IC8vIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLmNsYXNzTGlzdC5hZGQody5jb25maWcubGVnZW5kLnZlcnRpY2FsQWxpZ24pXG5cbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbExlZ2VuZFdyYXAuY2xhc3NMaXN0LmFkZCgncG9zaXRpb24tJyArIHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbik7XG4gICAgICAgIGVsTGVnZW5kLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtbGVnZW5kLXNlcmllcycpO1xuICAgICAgICBlbExlZ2VuZC5zdHlsZS5tYXJnaW4gPSBcIlwiLmNvbmNhdCh3LmNvbmZpZy5sZWdlbmQuaXRlbU1hcmdpbi5ob3Jpem9udGFsLCBcInB4IFwiKS5jb25jYXQody5jb25maWcubGVnZW5kLml0ZW1NYXJnaW4udmVydGljYWwsIFwicHhcIik7XG4gICAgICAgIHcuZ2xvYmFscy5kb20uZWxMZWdlbmRXcmFwLnN0eWxlLndpZHRoID0gdy5jb25maWcubGVnZW5kLndpZHRoID8gdy5jb25maWcubGVnZW5kLndpZHRoICsgJ3B4JyA6ICcnO1xuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsTGVnZW5kV3JhcC5zdHlsZS5oZWlnaHQgPSB3LmNvbmZpZy5sZWdlbmQuaGVpZ2h0ID8gdy5jb25maWcubGVnZW5kLmhlaWdodCArICdweCcgOiAnJztcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoZWxMZWdlbmQsIHtcbiAgICAgICAgICByZWw6IGkgKyAxLFxuICAgICAgICAgICdkYXRhOmNvbGxhcHNlZCc6IGNvbGxhcHNlZFNlcmllcyB8fCBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNvbGxhcHNlZFNlcmllcyB8fCBhbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXMpIHtcbiAgICAgICAgICBlbExlZ2VuZC5jbGFzc0xpc3QuYWRkKCdpbmFjdGl2ZS1sZWdlbmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdy5jb25maWcubGVnZW5kLm9uSXRlbUNsaWNrLnRvZ2dsZURhdGFTZXJpZXMpIHtcbiAgICAgICAgICBlbExlZ2VuZC5jbGFzc0xpc3QuYWRkKCduby1jbGljaycpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBub3cgLSBqdXN0IHByZXZlbnQgY2xpY2sgb24gaGVhdG1hcCBsZWdlbmQgLSBhbmQgYWxsb3cgaG92ZXIgb25seVxuXG5cbiAgICAgIHZhciBjbGlja0FsbG93ZWQgPSB3LmNvbmZpZy5jaGFydC50eXBlICE9PSAnaGVhdG1hcCc7XG5cbiAgICAgIGlmIChjbGlja0FsbG93ZWQgJiYgdy5jb25maWcubGVnZW5kLm9uSXRlbUNsaWNrLnRvZ2dsZURhdGFTZXJpZXMpIHtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbFdyYXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzZWxmLm9uTGVnZW5kQ2xpY2ssIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcubGVnZW5kLm9uSXRlbUhvdmVyLmhpZ2hsaWdodERhdGFTZXJpZXMpIHtcbiAgICAgICAgdy5nbG9iYWxzLmRvbS5lbFdyYXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2VsZi5vbkxlZ2VuZEhvdmVyZWQsIHRydWUpO1xuICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsV3JhcC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHNlbGYub25MZWdlbmRIb3ZlcmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGVnZW5kQkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZWdlbmRCQm94KCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgY3VyckxlZ2VuZHNXcmFwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtbGVnZW5kJyk7XG4gICAgICB2YXIgY3VyckxlZ2VuZHNXcmFwUmVjdCA9IGN1cnJMZWdlbmRzV3JhcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjdXJyTGVnZW5kc1dyYXBXaWR0aCA9IGN1cnJMZWdlbmRzV3JhcFJlY3Qud2lkdGg7XG4gICAgICB2YXIgY3VyckxlZ2VuZHNXcmFwSGVpZ2h0ID0gY3VyckxlZ2VuZHNXcmFwUmVjdC5oZWlnaHQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbHdoOiBjdXJyTGVnZW5kc1dyYXBIZWlnaHQsXG4gICAgICAgIGNsd3c6IGN1cnJMZWdlbmRzV3JhcFdpZHRoXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRMZWdlbmRXcmFwWFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGVnZW5kV3JhcFhZKG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGVsTGVnZW5kV3JhcCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWxlZ2VuZCcpO1xuICAgICAgdmFyIGxlZ2VuZFJlY3QgPSBlbExlZ2VuZFdyYXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgeSA9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHkgPSB5ICsgKHcuZ2xvYmFscy5zdmdIZWlnaHQgLSBsZWdlbmRSZWN0LmhlaWdodCAvIDIpO1xuICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgIHZhciBkaW0gPSBuZXcgRGltZW5zaW9ucyh0aGlzLmN0eCk7XG4gICAgICAgIHZhciB0aXRsZUggPSBkaW0uZ2V0VGl0bGVTdWJ0aXRsZUNvb3JkcygndGl0bGUnKS5oZWlnaHQ7XG4gICAgICAgIHZhciBzdWJ0aXRsZUggPSBkaW0uZ2V0VGl0bGVTdWJ0aXRsZUNvb3Jkcygnc3VidGl0bGUnKS5oZWlnaHQ7XG4gICAgICAgIHkgPSB5ICsgKHRpdGxlSCA+IDAgPyB0aXRsZUggLSAxMCA6IDApICsgKHN1YnRpdGxlSCA+IDAgPyBzdWJ0aXRsZUggLSAxMCA6IDApO1xuICAgICAgfVxuXG4gICAgICBlbExlZ2VuZFdyYXAuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgeCA9IHggKyBvZmZzZXRYICsgdy5jb25maWcubGVnZW5kLm9mZnNldFg7XG4gICAgICB5ID0geSArIG9mZnNldFkgKyB3LmNvbmZpZy5sZWdlbmQub2Zmc2V0WTtcbiAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICBlbExlZ2VuZFdyYXAuc3R5bGUudG9wID0geSArICdweCc7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS50b3AgPSAnYXV0byc7XG4gICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5ib3R0b20gPSAxMCArIHcuY29uZmlnLmxlZ2VuZC5vZmZzZXRZICsgJ3B4JztcbiAgICAgIH0gZWxzZSBpZiAody5jb25maWcubGVnZW5kLnBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIGVsTGVnZW5kV3JhcC5zdHlsZS5sZWZ0ID0gJ2F1dG8nO1xuICAgICAgICBlbExlZ2VuZFdyYXAuc3R5bGUucmlnaHQgPSAyNSArIHcuY29uZmlnLmxlZ2VuZC5vZmZzZXRYICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgaWYgKGVsTGVnZW5kV3JhcC5zdHlsZS53aWR0aCkge1xuICAgICAgICBlbExlZ2VuZFdyYXAuc3R5bGUud2lkdGggPSBwYXJzZUludCh3LmNvbmZpZy5sZWdlbmQud2lkdGgpICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgaWYgKGVsTGVnZW5kV3JhcC5zdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLmhlaWdodCA9IHBhcnNlSW50KHcuY29uZmlnLmxlZ2VuZC5oZWlnaHQpICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVnZW5kQWxpZ25Ib3Jpem9udGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlZ2VuZEFsaWduSG9yaXpvbnRhbCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGVsTGVnZW5kV3JhcCA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLWxlZ2VuZCcpO1xuICAgICAgZWxMZWdlbmRXcmFwLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICAgIHZhciBsUmVjdCA9IHRoaXMuZ2V0TGVnZW5kQkJveCgpO1xuICAgICAgdmFyIGRpbWVuc2lvbnMgPSBuZXcgRGltZW5zaW9ucyh0aGlzLmN0eCk7XG4gICAgICB2YXIgdGl0bGVSZWN0ID0gZGltZW5zaW9ucy5nZXRUaXRsZVN1YnRpdGxlQ29vcmRzKCd0aXRsZScpO1xuICAgICAgdmFyIHN1YnRpdGxlUmVjdCA9IGRpbWVuc2lvbnMuZ2V0VGl0bGVTdWJ0aXRsZUNvb3Jkcygnc3VidGl0bGUnKTtcbiAgICAgIHZhciBvZmZzZXRYID0gMjA7XG4gICAgICB2YXIgb2Zmc2V0WSA9IDA7IC8vIHRoZSB3aG9sZSBsZWdlbmQgYm94IGlzIHNldCB0byBib3R0b21cblxuICAgICAgaWYgKHcuY29uZmlnLmxlZ2VuZC5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgb2Zmc2V0WSA9IC1sUmVjdC5jbHdoIC8gMS44O1xuICAgICAgfSBlbHNlIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgIG9mZnNldFkgPSB0aXRsZVJlY3QuaGVpZ2h0ICsgc3VidGl0bGVSZWN0LmhlaWdodCArIHcuY29uZmlnLnRpdGxlLm1hcmdpbiArIHcuY29uZmlnLnN1YnRpdGxlLm1hcmdpbiAtIDE1O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldExlZ2VuZFdyYXBYWShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVnZW5kQWxpZ25WZXJ0aWNhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWdlbmRBbGlnblZlcnRpY2FsKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbFJlY3QgPSB0aGlzLmdldExlZ2VuZEJCb3goKTtcbiAgICAgIHZhciBvZmZzZXRZID0gMjA7XG4gICAgICB2YXIgb2Zmc2V0WCA9IDA7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICBvZmZzZXRYID0gMjA7XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5sZWdlbmQucG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgb2Zmc2V0WCA9IHcuZ2xvYmFscy5zdmdXaWR0aCAtIGxSZWN0LmNsd3cgLSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRMZWdlbmRXcmFwWFkob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uTGVnZW5kSG92ZXJlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxlZ2VuZEhvdmVyZWQoZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgaG92ZXJPdmVyTGVnZW5kID0gZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWxlZ2VuZC10ZXh0JykgfHwgZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWxlZ2VuZC1tYXJrZXInKTtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgIT09ICdoZWF0bWFwJykge1xuICAgICAgICBpZiAoIWUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnaW5hY3RpdmUtbGVnZW5kJykgJiYgaG92ZXJPdmVyTGVnZW5kKSB7XG4gICAgICAgICAgdmFyIHNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgICAgIHNlcmllcy50b2dnbGVTZXJpZXNPbkhvdmVyKGUsIGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZm9yIGhlYXRtYXAgaGFuZGxpbmdcbiAgICAgICAgaWYgKGhvdmVyT3ZlckxlZ2VuZCkge1xuICAgICAgICAgIHZhciBzZXJpZXNDbnQgPSBwYXJzZUludChlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSAtIDE7XG4gICAgICAgICAgdGhpcy5jdHguZmlyZUV2ZW50KCdsZWdlbmRIb3ZlcicsIFt0aGlzLmN0eCwgc2VyaWVzQ250LCB0aGlzLnddKTtcblxuICAgICAgICAgIHZhciBfc2VyaWVzID0gbmV3IFNlcmllcyh0aGlzLmN0eCk7XG5cbiAgICAgICAgICBfc2VyaWVzLmhpZ2hsaWdodFJhbmdlSW5TZXJpZXMoZSwgZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uTGVnZW5kQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25MZWdlbmRDbGljayhlKSB7XG4gICAgICBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWxlZ2VuZC10ZXh0JykgfHwgZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWxlZ2VuZC1tYXJrZXInKSkge1xuICAgICAgICB2YXIgc2VyaWVzQ250ID0gcGFyc2VJbnQoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdyZWwnKSkgLSAxO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGE6Y29sbGFwc2VkJykgPT09ICd0cnVlJztcbiAgICAgICAgdmFyIGxlZ2VuZENsaWNrID0gdGhpcy53LmNvbmZpZy5jaGFydC5ldmVudHMubGVnZW5kQ2xpY2s7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZWdlbmRDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGxlZ2VuZENsaWNrKHRoaXMuY3R4LCBzZXJpZXNDbnQsIHRoaXMudyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eC5maXJlRXZlbnQoJ2xlZ2VuZENsaWNrJywgW3RoaXMuY3R4LCBzZXJpZXNDbnQsIHRoaXMud10pO1xuICAgICAgICB2YXIgbWFya2VyQ2xpY2sgPSB0aGlzLncuY29uZmlnLmxlZ2VuZC5tYXJrZXJzLm9uQ2xpY2s7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXJrZXJDbGljayA9PT0gJ2Z1bmN0aW9uJyAmJiBlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtbGVnZW5kLW1hcmtlcicpKSB7XG4gICAgICAgICAgbWFya2VyQ2xpY2sodGhpcy5jdHgsIHNlcmllc0NudCwgdGhpcy53KTtcbiAgICAgICAgICB0aGlzLmN0eC5maXJlRXZlbnQoJ2xlZ2VuZE1hcmtlckNsaWNrJywgW3RoaXMuY3R4LCBzZXJpZXNDbnQsIHRoaXMud10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2dnbGVEYXRhU2VyaWVzKHNlcmllc0NudCwgaXNIaWRkZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMZWdlbmRTdHlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGVnZW5kU3R5bGVzKCkge1xuICAgICAgdmFyIHN0eWxlc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGVzaGVldC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgIHZhciB0ZXh0ID0gXCJcXG4gICAgXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kIHtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICAgIHBhZGRpbmc6IDAgMTBweDtcXG4gICAgICB9XFxuXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLnBvc2l0aW9uLWJvdHRvbSwgLmFwZXhjaGFydHMtbGVnZW5kLnBvc2l0aW9uLXRvcCB7XFxuICAgICAgICBmbGV4LXdyYXA6IHdyYXBcXG4gICAgICB9XFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLnBvc2l0aW9uLXJpZ2h0LCAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tbGVmdCB7XFxuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAgYm90dG9tOiAwO1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tYm90dG9tLmxlZnQsIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi10b3AubGVmdCwgLmFwZXhjaGFydHMtbGVnZW5kLnBvc2l0aW9uLXJpZ2h0LCAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tbGVmdCB7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5wb3NpdGlvbi1ib3R0b20uY2VudGVyLCAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tdG9wLmNlbnRlciB7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgIFxcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tYm90dG9tLnJpZ2h0LCAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tdG9wLnJpZ2h0IHtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXMge1xcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IG5vcm1hbDtcXG4gICAgICB9XFxuXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLnBvc2l0aW9uLWJvdHRvbSAuYXBleGNoYXJ0cy1sZWdlbmQtc2VyaWVzLCAuYXBleGNoYXJ0cy1sZWdlbmQucG9zaXRpb24tdG9wIC5hcGV4Y2hhcnRzLWxlZ2VuZC1zZXJpZXN7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICB9XFxuXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kLXRleHQge1xcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQtdGV4dCAqLCAuYXBleGNoYXJ0cy1sZWdlbmQtbWFya2VyICoge1xcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgICAgfVxcblxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC1tYXJrZXIge1xcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAzcHg7XFxuICAgICAgfVxcbiAgICAgIFxcbiAgICAgIC5hcGV4Y2hhcnRzLWxlZ2VuZC5yaWdodCAuYXBleGNoYXJ0cy1sZWdlbmQtc2VyaWVzLCAuYXBleGNoYXJ0cy1sZWdlbmQubGVmdCAuYXBleGNoYXJ0cy1sZWdlbmQtc2VyaWVze1xcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIH1cXG5cXG4gICAgICAuYXBleGNoYXJ0cy1sZWdlbmQtc2VyaWVzLm5vLWNsaWNrIHtcXG4gICAgICAgIGN1cnNvcjogYXV0bztcXG4gICAgICB9XFxuXFxuICAgICAgLmFwZXhjaGFydHMtbGVnZW5kIC5hcGV4Y2hhcnRzLWhpZGRlbi16ZXJvLXNlcmllcywgLmFwZXhjaGFydHMtbGVnZW5kIC5hcGV4Y2hhcnRzLWhpZGRlbi1udWxsLXNlcmllcyB7XFxuICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgfVxcblxcbiAgICAgIC5pbmFjdGl2ZS1sZWdlbmQge1xcbiAgICAgICAgb3BhY2l0eTogMC40NTtcXG4gICAgICB9XCI7XG4gICAgICB2YXIgcnVsZXMgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgIHN0eWxlc2hlZXQuYXBwZW5kQ2hpbGQocnVsZXMpO1xuICAgICAgcmV0dXJuIHN0eWxlc2hlZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0VG9nZ2xlRGF0YVNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFRvZ2dsZURhdGFTZXJpZXMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBzZXJpZXNFbHMgPSBudWxsO1xuICAgICAgdmFyIHJlYWxJbmRleGVzID0gW107XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICBzZXJpZXNFbHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleF1cIik7XG4gICAgICAgIHNlcmllc0Vscy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmVhbEluZGV4ZXMucHVzaChwYXJzZUludCh2LmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmllc0VscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYXBleGNoYXJ0cy1zZXJpZXNbcmVsXVwiKTtcbiAgICAgICAgc2VyaWVzRWxzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZWFsSW5kZXhlcy5wdXNoKHBhcnNlSW50KHYuZ2V0QXR0cmlidXRlKCdyZWwnKSkgLSAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlYWxJbmRleGVzLnNvcnQoKTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgcmlzaW5nU2VyaWVzID0gdy5nbG9iYWxzLnJpc2luZ1Nlcmllcy5zbGljZSgpO1xuICAgICAgICB2YXIgc2VyaWVzID0gdy5jb25maWcuc2VyaWVzLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcmVhbEluZGV4ZXMuaW5kZXhPZih3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzW2NdLmluZGV4KTtcblxuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgICAgICBzZXJpZXNbaW5kZXhdLmRhdGEgPSB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLnNsaWNlKClbY10uZGF0YS5zbGljZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VyaWVzW2luZGV4XSA9IHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMuc2xpY2UoKVtjXS5kYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByaXNpbmdTZXJpZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcyA9IFtdO1xuICAgICAgICB3Lmdsb2JhbHMuYW5jaWxsYXJ5Q29sbGFwc2VkU2VyaWVzID0gW107XG4gICAgICAgIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzID0gW107XG4gICAgICAgIHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXNJbmRpY2VzID0gW107XG4gICAgICAgIHcuZ2xvYmFscy5yaXNpbmdTZXJpZXMgPSByaXNpbmdTZXJpZXM7XG4gICAgICAgIHcuY29uZmlnLnNlcmllcyA9IHNlcmllcztcblxuICAgICAgICB0aGlzLmN0eC5fdXBkYXRlU2VyaWVzKHcuY29uZmlnLnNlcmllcywgdy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVEYXRhU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZURhdGFTZXJpZXMoc2VyaWVzQ250LCBpc0hpZGRlbikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cyB8fCB3LmNvbmZpZy5jaGFydC50eXBlID09PSAncmFkaWFsQmFyJykge1xuICAgICAgICB3Lmdsb2JhbHMucmVzaXplZCA9IHRydWU7IC8vIHdlIGRvbid0IHdhbnQgaW5pdGlhbCBhbmltYXRpb25zIGFnYWluXG5cbiAgICAgICAgdmFyIHNlcmllc0VsID0gbnVsbDtcbiAgICAgICAgdmFyIHJlYWxJbmRleCA9IG51bGw7IC8vIHllcywgbWFrZSBpdCBudWxsLiAxIHNlcmllcyB3aWxsIHJpc2UgYXQgYSB0aW1lXG5cbiAgICAgICAgdy5nbG9iYWxzLnJpc2luZ1NlcmllcyA9IFtdO1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuYXhpc0NoYXJ0cykge1xuICAgICAgICAgIHNlcmllc0VsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpyZWFsSW5kZXg9J1wiLmNvbmNhdChzZXJpZXNDbnQsIFwiJ11cIikpO1xuICAgICAgICAgIHJlYWxJbmRleCA9IHBhcnNlSW50KHNlcmllc0VsLmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VyaWVzRWwgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW3JlbD0nXCIuY29uY2F0KHNlcmllc0NudCArIDEsIFwiJ11cIikpO1xuICAgICAgICAgIHJlYWxJbmRleCA9IHBhcnNlSW50KHNlcmllc0VsLmdldEF0dHJpYnV0ZSgncmVsJykpIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIHRoaXMucmlzZUNvbGxhcHNlZFNlcmllcyh3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcywgcmVhbEluZGV4KTtcbiAgICAgICAgICB0aGlzLnJpc2VDb2xsYXBzZWRTZXJpZXMody5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllcywgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXMsIHJlYWxJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkTm90SGlkZVlBeGlzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdICYmIHcuY29uZmlnLnlheGlzW3JlYWxJbmRleF0uc2hvdyAmJiB3LmNvbmZpZy55YXhpc1tyZWFsSW5kZXhdLnNob3dBbHdheXMpIHtcbiAgICAgICAgICAgICAgc2hvdWxkTm90SGlkZVlBeGlzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAody5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXMuaW5kZXhPZihyZWFsSW5kZXgpIDwgMCkge1xuICAgICAgICAgICAgICAgIHcuZ2xvYmFscy5hbmNpbGxhcnlDb2xsYXBzZWRTZXJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBpbmRleDogcmVhbEluZGV4LFxuICAgICAgICAgICAgICAgICAgZGF0YTogdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF0uZGF0YS5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgdHlwZTogc2VyaWVzRWwucGFyZW50Tm9kZS5jbGFzc05hbWUuYmFzZVZhbC5zcGxpdCgnLScpWzFdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdy5nbG9iYWxzLmFuY2lsbGFyeUNvbGxhcHNlZFNlcmllc0luZGljZXMucHVzaChyZWFsSW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2hvdWxkTm90SGlkZVlBeGlzKSB7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHJlYWxJbmRleCxcbiAgICAgICAgICAgICAgICBkYXRhOiB3LmNvbmZpZy5zZXJpZXNbcmVhbEluZGV4XS5kYXRhLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgdHlwZTogc2VyaWVzRWwucGFyZW50Tm9kZS5jbGFzc05hbWUuYmFzZVZhbC5zcGxpdCgnLScpWzFdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5wdXNoKHJlYWxJbmRleCk7XG4gICAgICAgICAgICAgIHZhciByZW1vdmVJbmRleE9mUmlzaW5nID0gdy5nbG9iYWxzLnJpc2luZ1Nlcmllcy5pbmRleE9mKHJlYWxJbmRleCk7XG4gICAgICAgICAgICAgIHcuZ2xvYmFscy5yaXNpbmdTZXJpZXMuc3BsaWNlKHJlbW92ZUluZGV4T2ZSaXNpbmcsIDEpO1xuICAgICAgICAgICAgfSAvLyBUT0RPOiBBVk9JRCBtdXRhdGluZyB0aGUgdXNlcidzIGNvbmZpZyBvYmplY3QgYmVsb3dcblxuXG4gICAgICAgICAgICB3LmNvbmZpZy5zZXJpZXNbcmVhbEluZGV4XS5kYXRhID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMucHVzaCh7XG4gICAgICAgICAgICAgIGluZGV4OiByZWFsSW5kZXgsXG4gICAgICAgICAgICAgIGRhdGE6IHcuY29uZmlnLnNlcmllc1tyZWFsSW5kZXhdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzLnB1c2gocmVhbEluZGV4KTtcbiAgICAgICAgICAgIHcuY29uZmlnLnNlcmllc1tyZWFsSW5kZXhdID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2VyaWVzQ2hpbGRyZW4gPSBzZXJpZXNFbC5jaGlsZE5vZGVzO1xuXG4gICAgICAgICAgZm9yICh2YXIgc2MgPSAwOyBzYyA8IHNlcmllc0NoaWxkcmVuLmxlbmd0aDsgc2MrKykge1xuICAgICAgICAgICAgaWYgKHNlcmllc0NoaWxkcmVuW3NjXS5jbGFzc0xpc3QuY29udGFpbnMoJ2FwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMtd3JhcCcpKSB7XG4gICAgICAgICAgICAgIGlmIChzZXJpZXNDaGlsZHJlbltzY10uY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWhpZGUnKSkge1xuICAgICAgICAgICAgICAgIHNlcmllc0NoaWxkcmVuW3NjXS5jbGFzc0xpc3QucmVtb3ZlKCdhcGV4Y2hhcnRzLWhpZGUnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXJpZXNDaGlsZHJlbltzY10uY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1oaWRlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMuYWxsU2VyaWVzQ29sbGFwc2VkID0gdy5nbG9iYWxzLmNvbGxhcHNlZFNlcmllcy5sZW5ndGggPT09IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuXG4gICAgICAgICAgdGhpcy5jdHguX3VwZGF0ZVNlcmllcyh3LmNvbmZpZy5zZXJpZXMsIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZm9yIG5vbi1heGlzIGNoYXJ0cyBpLmUgcGllIC8gZG9udXRzXG4gICAgICAgIHZhciBfc2VyaWVzRWwgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnNlbGVjdChcIiAuYXBleGNoYXJ0cy1zZXJpZXNbcmVsPSdcIi5jb25jYXQoc2VyaWVzQ250ICsgMSwgXCInXSBwYXRoXCIpKTtcblxuICAgICAgICBfc2VyaWVzRWwuZmlyZSgnY2xpY2snKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmlzZUNvbGxhcHNlZFNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByaXNlQ29sbGFwc2VkU2VyaWVzKHNlcmllcywgc2VyaWVzSW5kaWNlcywgcmVhbEluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHNlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc2VyaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgaWYgKHNlcmllc1tjXS5pbmRleCA9PT0gcmVhbEluZGV4KSB7XG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgICAgICAgdy5jb25maWcuc2VyaWVzW3JlYWxJbmRleF0uZGF0YSA9IHNlcmllc1tjXS5kYXRhLnNsaWNlKCk7XG4gICAgICAgICAgICAgIHNlcmllcy5zcGxpY2UoYywgMSk7XG4gICAgICAgICAgICAgIHNlcmllc0luZGljZXMuc3BsaWNlKGMsIDEpO1xuICAgICAgICAgICAgICB3Lmdsb2JhbHMucmlzaW5nU2VyaWVzLnB1c2gocmVhbEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHcuY29uZmlnLnNlcmllc1tyZWFsSW5kZXhdID0gc2VyaWVzW2NdLmRhdGE7XG4gICAgICAgICAgICAgIHNlcmllcy5zcGxpY2UoYywgMSk7XG4gICAgICAgICAgICAgIHNlcmllc0luZGljZXMuc3BsaWNlKGMsIDEpO1xuICAgICAgICAgICAgICB3Lmdsb2JhbHMucmlzaW5nU2VyaWVzLnB1c2gocmVhbEluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdHguX3VwZGF0ZVNlcmllcyh3LmNvbmZpZy5zZXJpZXMsIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGVnZW5kO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgUmVzcG9uc2l2ZSBDbGFzcyB0byBvdmVycmlkZSBvcHRpb25zIGZvciBkaWZmZXJlbnQgc2NyZWVuIHNpemVzLlxuICpcbiAqIEBtb2R1bGUgUmVzcG9uc2l2ZVxuICoqL1xuXG52YXIgUmVzcG9uc2l2ZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc3BvbnNpdmUoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNpdmUpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gIH0gLy8gdGhlIG9wdHMgcGFyYW1ldGVyIGlmIG5vdCBudWxsIGhhcyB0byBiZSBzZXQgb3ZlcnJpZGluZyBldmVyeXRoaW5nXG4gIC8vIGFzIHRoZSBvcHRzIGlzIHNldCBieSB1c2VyIGV4dGVybmFsbHlcblxuXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlLCBbe1xuICAgIGtleTogXCJjaGVja1Jlc3BvbnNpdmVDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tSZXNwb25zaXZlQ29uZmlnKG9wdHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGNuZiA9IHcuY29uZmlnOyAvLyBjaGVjayBpZiByZXNwb25zaXZlIGNvbmZpZyBleGlzdHNcblxuICAgICAgaWYgKGNuZi5yZXNwb25zaXZlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHJlcyA9IGNuZi5yZXNwb25zaXZlLnNsaWNlKCk7XG4gICAgICByZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5icmVha3BvaW50ID4gYi5icmVha3BvaW50ID8gMSA6IGIuYnJlYWtwb2ludCA+IGEuYnJlYWtwb2ludCA/IC0xIDogMDtcbiAgICAgIH0pLnJldmVyc2UoKTtcbiAgICAgIHZhciBjb25maWcgPSBuZXcgQ29uZmlnKHt9KTtcblxuICAgICAgdmFyIGl0ZXJhdGVSZXNwb25zaXZlT3B0aW9ucyA9IGZ1bmN0aW9uIGl0ZXJhdGVSZXNwb25zaXZlT3B0aW9ucygpIHtcbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgbGFyZ2VzdEJyZWFrcG9pbnQgPSByZXNbMF0uYnJlYWtwb2ludDtcbiAgICAgICAgdmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPiAwID8gd2luZG93LmlubmVyV2lkdGggOiBzY3JlZW4ud2lkdGg7XG5cbiAgICAgICAgaWYgKHdpZHRoID4gbGFyZ2VzdEJyZWFrcG9pbnQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IENvcmVVdGlscy5leHRlbmRBcnJheVByb3BzKGNvbmZpZywgdy5nbG9iYWxzLmluaXRpYWxDb25maWcpO1xuICAgICAgICAgIG5ld09wdGlvbnMgPSBVdGlscy5leHRlbmQob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgICAgICAgbmV3T3B0aW9ucyA9IFV0aWxzLmV4dGVuZCh3LmNvbmZpZywgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgICBfdGhpcy5vdmVycmlkZVJlc3BvbnNpdmVPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAod2lkdGggPCByZXNbaV0uYnJlYWtwb2ludCkge1xuICAgICAgICAgICAgICBuZXdPcHRpb25zID0gVXRpbHMuZXh0ZW5kKGNvbmZpZywgbmV3T3B0aW9ucyk7XG4gICAgICAgICAgICAgIG5ld09wdGlvbnMgPSBDb3JlVXRpbHMuZXh0ZW5kQXJyYXlQcm9wcyhuZXdPcHRpb25zLCByZXNbaV0ub3B0aW9ucyk7XG4gICAgICAgICAgICAgIG5ld09wdGlvbnMgPSBVdGlscy5leHRlbmQody5jb25maWcsIG5ld09wdGlvbnMpO1xuXG4gICAgICAgICAgICAgIF90aGlzLm92ZXJyaWRlUmVzcG9uc2l2ZU9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0cykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IENvcmVVdGlscy5leHRlbmRBcnJheVByb3BzKGNvbmZpZywgb3B0cyk7XG4gICAgICAgIG9wdGlvbnMgPSBVdGlscy5leHRlbmQody5jb25maWcsIG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zID0gVXRpbHMuZXh0ZW5kKG9wdGlvbnMsIG9wdHMpO1xuICAgICAgICBpdGVyYXRlUmVzcG9uc2l2ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlUmVzcG9uc2l2ZU9wdGlvbnMoe30pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdmVycmlkZVJlc3BvbnNpdmVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG92ZXJyaWRlUmVzcG9uc2l2ZU9wdGlvbnMobmV3T3B0aW9ucykge1xuICAgICAgdmFyIG5ld0NvbmZpZyA9IG5ldyBDb25maWcobmV3T3B0aW9ucykuaW5pdCgpO1xuICAgICAgdGhpcy53LmNvbmZpZyA9IG5ld0NvbmZpZztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVzcG9uc2l2ZTtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFRoZW1lIENsYXNzIGZvciBzZXR0aW5nIHRoZSBjb2xvcnMgYW5kIHBhbGV0dGVzLlxuICpcbiAqIEBtb2R1bGUgVGhlbWVcbiAqKi9cblxudmFyIFRoZW1lID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGhlbWUoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRoZW1lKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMudyA9IGN0eC53O1xuICAgIHRoaXMuY29sb3JzID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGhlbWUsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuc2V0RGVmYXVsdENvbG9ycygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXREZWZhdWx0Q29sb3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB1dGlscyA9IG5ldyBVdGlscygpO1xuXG4gICAgICBpZiAody5jb25maWcuY29sb3JzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdy5nbG9iYWxzLmNvbG9ycyA9IHRoaXMucHJlZGVmaW5lZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLmNvbG9ycyA9IHcuY29uZmlnLmNvbG9ycztcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLnRoZW1lLm1vbm9jaHJvbWUuZW5hYmxlZCkge1xuICAgICAgICB2YXIgbW9ub0FyciA9IFtdO1xuICAgICAgICB2YXIgZ2xzQ250ID0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5kaXN0cmlidXRlZCAmJiB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJykge1xuICAgICAgICAgIGdsc0NudCA9IHcuZ2xvYmFscy5zZXJpZXNbMF0ubGVuZ3RoICogdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFpbkNvbG9yID0gdy5jb25maWcudGhlbWUubW9ub2Nocm9tZS5jb2xvcjtcbiAgICAgICAgdmFyIHBhcnQgPSAxIC8gKGdsc0NudCAvIHcuY29uZmlnLnRoZW1lLm1vbm9jaHJvbWUuc2hhZGVJbnRlbnNpdHkpO1xuICAgICAgICB2YXIgc2hhZGUgPSB3LmNvbmZpZy50aGVtZS5tb25vY2hyb21lLnNoYWRlVG87XG4gICAgICAgIHZhciBwZXJjZW50ID0gMDtcblxuICAgICAgICBmb3IgKHZhciBnc2wgPSAwOyBnc2wgPCBnbHNDbnQ7IGdzbCsrKSB7XG4gICAgICAgICAgdmFyIG5ld0NvbG9yID0gdm9pZCAwO1xuXG4gICAgICAgICAgaWYgKHNoYWRlID09PSAnZGFyaycpIHtcbiAgICAgICAgICAgIG5ld0NvbG9yID0gdXRpbHMuc2hhZGVDb2xvcihwZXJjZW50ICogLTEsIG1haW5Db2xvcik7XG4gICAgICAgICAgICBwZXJjZW50ID0gcGVyY2VudCArIHBhcnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0NvbG9yID0gdXRpbHMuc2hhZGVDb2xvcihwZXJjZW50LCBtYWluQ29sb3IpO1xuICAgICAgICAgICAgcGVyY2VudCA9IHBlcmNlbnQgKyBwYXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vbm9BcnIucHVzaChuZXdDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICB3Lmdsb2JhbHMuY29sb3JzID0gbW9ub0Fyci5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVmYXVsdENvbG9ycyA9IHcuZ2xvYmFscy5jb2xvcnMuc2xpY2UoKTsgLy8gaWYgdXNlciBzcGVjZmllZCBsZXNzIGNvbG9ycyB0aGFuIG5vLiBvZiBzZXJpZXMsIHB1c2ggdGhlIHNhbWUgY29sb3JzIGFnYWluXG5cbiAgICAgIHRoaXMucHVzaEV4dHJhQ29sb3JzKHcuZ2xvYmFscy5jb2xvcnMpOyAvLyBUaGUgQm9yZGVyIGNvbG9yc1xuXG4gICAgICBpZiAody5jb25maWcuc3Ryb2tlLmNvbG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHcuZ2xvYmFscy5zdHJva2UuY29sb3JzID0gZGVmYXVsdENvbG9ycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcuZ2xvYmFscy5zdHJva2UuY29sb3JzID0gdy5jb25maWcuc3Ryb2tlLmNvbG9ycztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoRXh0cmFDb2xvcnMody5nbG9iYWxzLnN0cm9rZS5jb2xvcnMpOyAvLyBUaGUgRklMTCBjb2xvcnNcblxuICAgICAgaWYgKHcuY29uZmlnLmZpbGwuY29sb3JzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdy5nbG9iYWxzLmZpbGwuY29sb3JzID0gZGVmYXVsdENvbG9ycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcuZ2xvYmFscy5maWxsLmNvbG9ycyA9IHcuY29uZmlnLmZpbGwuY29sb3JzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnB1c2hFeHRyYUNvbG9ycyh3Lmdsb2JhbHMuZmlsbC5jb2xvcnMpO1xuXG4gICAgICBpZiAody5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnMgPSBkZWZhdWx0Q29sb3JzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLmRhdGFMYWJlbHMuc3R5bGUuY29sb3JzID0gdy5jb25maWcuZGF0YUxhYmVscy5zdHlsZS5jb2xvcnM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaEV4dHJhQ29sb3JzKHcuZ2xvYmFscy5kYXRhTGFiZWxzLnN0eWxlLmNvbG9ycywgNTApO1xuXG4gICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMucmFkYXIucG9seWdvbnMuZmlsbC5jb2xvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMucmFkYXJQb2x5Z29ucy5maWxsLmNvbG9ycyA9IFsnI2ZmZiddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLnJhZGFyUG9seWdvbnMuZmlsbC5jb2xvcnMgPSB3LmNvbmZpZy5wbG90T3B0aW9ucy5yYWRhci5wb2x5Z29ucy5maWxsLmNvbG9ycztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoRXh0cmFDb2xvcnMody5nbG9iYWxzLnJhZGFyUG9seWdvbnMuZmlsbC5jb2xvcnMsIDIwKTsgLy8gVGhlIHBvaW50IGNvbG9yc1xuXG4gICAgICBpZiAody5jb25maWcubWFya2Vycy5jb2xvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3Lmdsb2JhbHMubWFya2Vycy5jb2xvcnMgPSBkZWZhdWx0Q29sb3JzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdy5nbG9iYWxzLm1hcmtlcnMuY29sb3JzID0gdy5jb25maWcubWFya2Vycy5jb2xvcnM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaEV4dHJhQ29sb3JzKHcuZ2xvYmFscy5tYXJrZXJzLmNvbG9ycyk7XG4gICAgfSAvLyBXaGVuIHRoZSBudW1iZXIgb2YgY29sb3JzIHByb3ZpZGVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIHNlcmllcywgdGhpcyBtZXRob2RcbiAgICAvLyB3aWxsIHB1c2ggc2FtZSBjb2xvcnMgdG8gdGhlIGxpc3RcbiAgICAvLyBwYXJhbXM6XG4gICAgLy8gZGlzdHJpYnV0ZWQgaXMgb25seSB2YWxpZCBmb3IgZGlzdHJpYnV0ZWQgY29sdW1uL2JhciBjaGFydHNcblxuICB9LCB7XG4gICAga2V5OiBcInB1c2hFeHRyYUNvbG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoRXh0cmFDb2xvcnMoY29sb3JTZXJpZXMsIGxlbmd0aCkge1xuICAgICAgdmFyIGRpc3RyaWJ1dGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbGVuID0gbGVuZ3RoIHx8IHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoZGlzdHJpYnV0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgZGlzdHJpYnV0ZWQgPSB3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGlzdHJpYnV0ZWQgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2hlYXRtYXAnICYmIHcuY29uZmlnLnBsb3RPcHRpb25zLmhlYXRtYXAuY29sb3JTY2FsZS5pbnZlcnNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlzdHJpYnV0ZWQpIHtcbiAgICAgICAgbGVuID0gdy5nbG9iYWxzLnNlcmllc1swXS5sZW5ndGggKiB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbG9yU2VyaWVzLmxlbmd0aCA8IGxlbikge1xuICAgICAgICB2YXIgZGlmZiA9IGxlbiAtIGNvbG9yU2VyaWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmY7IGkrKykge1xuICAgICAgICAgIGNvbG9yU2VyaWVzLnB1c2goY29sb3JTZXJpZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZWRlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlZGVmaW5lZCgpIHtcbiAgICAgIHZhciBwYWxldHRlID0gdGhpcy53LmNvbmZpZy50aGVtZS5wYWxldHRlOyAvLyBENkUzRjgsIEZDRUZFRiwgRENFMEQ5LCBBNTk3OEIsIEVERERENCwgRDZFM0Y4LCBGRUY1RUZcblxuICAgICAgc3dpdGNoIChwYWxldHRlKSB7XG4gICAgICAgIGNhc2UgJ3BhbGV0dGUxJzpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzAwOEZGQicsICcjMDBFMzk2JywgJyNGRUIwMTknLCAnI0ZGNDU2MCcsICcjNzc1REQwJ107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGFsZXR0ZTInOlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjM2Y1MWI1JywgJyMwM2E5ZjQnLCAnIzRjYWY1MCcsICcjZjljZTFkJywgJyNGRjk4MDAnXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYWxldHRlMyc6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyMzM2IyZGYnLCAnIzU0NkU3QScsICcjZDQ1MjZlJywgJyMxM2Q4YWEnLCAnI0E1OTc4QiddO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BhbGV0dGU0JzpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnIzU0NkU3QScsICcjNGVjZGM0JywgJyNjN2Y0NjQnLCAnIzgxRDRGQScsICcjZmQ2YTZhJ107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGFsZXR0ZTUnOlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjMmI5MDhmJywgJyNmOWEzYTQnLCAnIzkwZWU3ZScsICcjZmE0NDQzJywgJyM2OWQyZTcnXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYWxldHRlNic6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyM0NDlERDEnLCAnI0Y4NjYyNCcsICcjRUEzNTQ2JywgJyM2NjJFOUInLCAnI0M1RDg2RCddO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BhbGV0dGU3JzpcbiAgICAgICAgICB0aGlzLmNvbG9ycyA9IFsnI0Q3MjYzRCcsICcjMUI5OThCJywgJyMyRTI5NEUnLCAnI0Y0NjAzNicsICcjRTJDMDQ0J107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGFsZXR0ZTgnOlxuICAgICAgICAgIHRoaXMuY29sb3JzID0gWycjNjYyRTlCJywgJyNGODY2MjQnLCAnI0Y5QzgwRScsICcjRUEzNTQ2JywgJyM0M0JDQ0QnXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYWxldHRlOSc6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyM1QzQ3NDInLCAnI0E1OTc4QicsICcjOEQ1QjRDJywgJyM1QTJBMjcnLCAnI0M0QkJBRiddO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BhbGV0dGUxMCc6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyNBMzAwRDYnLCAnIzdEMDJFQicsICcjNTY1M0ZFJywgJyMyOTgzRkYnLCAnIzAwQjFGMiddO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5jb2xvcnMgPSBbJyMwMDhGRkInLCAnIzAwRTM5NicsICcjRkVCMDE5JywgJyNGRjQ1NjAnLCAnIzc3NUREMCddO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb2xvcnM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRoZW1lO1xufSgpO1xuXG52YXIgVXRpbHMkMSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFV0aWxzKHRvb2x0aXBDb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFV0aWxzKTtcblxuICAgIHRoaXMudyA9IHRvb2x0aXBDb250ZXh0Lnc7XG4gICAgdGhpcy50dEN0eCA9IHRvb2x0aXBDb250ZXh0O1xuICAgIHRoaXMuY3R4ID0gdG9vbHRpcENvbnRleHQuY3R4O1xuICB9XG4gIC8qKlxuICAgKiogV2hlbiBob3ZlcmluZyBvdmVyIHNlcmllcywgeW91IG5lZWQgdG8gY2FwdHVyZSB3aGljaCBzZXJpZXMgaXMgYmVpbmcgaG92ZXJlZCBvbi5cbiAgICoqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYm90aCBjYXB0dXJlZHNlcmllcyBpbmRleCBhcyB3ZWxsIGFzIGlubmVyIGluZGV4IG9mIHRoYXQgc2VyaWVzXG4gICAqIEBtZW1iZXJvZiBVdGlsc1xuICAgKiBAcGFyYW0ge29iamVjdH1cbiAgICogLSBob3ZlckFyZWEgPSB0aGUgcmVjdCBvbiB3aGljaCB1c2VyIGhvdmVyc1xuICAgKiAtIGVsR3JpZCA9IGRpbWVuc2lvbnMgb2YgdGhlIGhvdmVyIHJlY3QgKGl0IGNhbiBiZSBkaWZmZXJlbnQgdGhhbiBob3ZlcmFyZWEpXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFV0aWxzLCBbe1xuICAgIGtleTogXCJnZXROZWFyZXN0VmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5lYXJlc3RWYWx1ZXMoX3JlZikge1xuICAgICAgdmFyIGhvdmVyQXJlYSA9IF9yZWYuaG92ZXJBcmVhLFxuICAgICAgICAgIGVsR3JpZCA9IF9yZWYuZWxHcmlkLFxuICAgICAgICAgIGNsaWVudFggPSBfcmVmLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WSxcbiAgICAgICAgICBoYXNCYXJzID0gX3JlZi5oYXNCYXJzO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgaG92ZXJXaWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGg7XG4gICAgICB2YXIgeERpdmlzb3IgPSBob3ZlcldpZHRoIC8gKHcuZ2xvYmFscy5kYXRhUG9pbnRzIC0gMSk7XG4gICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmIChoYXNCYXJzICYmIHcuZ2xvYmFscy5jb21ib0NoYXJ0cyB8fCBoYXNCYXJzKSB7XG4gICAgICAgIHhEaXZpc29yID0gaG92ZXJXaWR0aCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaG92ZXJYID0gY2xpZW50WCAtIHNlcmllc0JvdW5kLmxlZnQ7XG4gICAgICB2YXIgaG92ZXJZID0gY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcDtcbiAgICAgIHZhciBpblJlY3QgPSBob3ZlclggPCAwIHx8IGhvdmVyWSA8IDAgfHwgaG92ZXJYID4gdy5nbG9iYWxzLmdyaWRXaWR0aCB8fCBob3ZlclkgPiB3Lmdsb2JhbHMuZ3JpZEhlaWdodDtcblxuICAgICAgaWYgKGluUmVjdCkge1xuICAgICAgICBob3ZlckFyZWEuY2xhc3NMaXN0LnJlbW92ZSgnaG92ZXJpbmctem9vbScpO1xuICAgICAgICBob3ZlckFyZWEuY2xhc3NMaXN0LnJlbW92ZSgnaG92ZXJpbmctcGFuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAody5nbG9iYWxzLnpvb21FbmFibGVkKSB7XG4gICAgICAgICAgaG92ZXJBcmVhLmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyaW5nLXBhbicpO1xuICAgICAgICAgIGhvdmVyQXJlYS5jbGFzc0xpc3QuYWRkKCdob3ZlcmluZy16b29tJyk7XG4gICAgICAgIH0gZWxzZSBpZiAody5nbG9iYWxzLnBhbkVuYWJsZWQpIHtcbiAgICAgICAgICBob3ZlckFyZWEuY2xhc3NMaXN0LnJlbW92ZSgnaG92ZXJpbmctem9vbScpO1xuICAgICAgICAgIGhvdmVyQXJlYS5jbGFzc0xpc3QuYWRkKCdob3ZlcmluZy1wYW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaiA9IE1hdGgucm91bmQoaG92ZXJYIC8geERpdmlzb3IpO1xuXG4gICAgICBpZiAoaGFzQmFycykge1xuICAgICAgICBqID0gTWF0aC5jZWlsKGhvdmVyWCAvIHhEaXZpc29yKTtcbiAgICAgICAgaiA9IGogLSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdHVyZWRTZXJpZXMgPSBudWxsO1xuICAgICAgdmFyIGNsb3Nlc3QgPSBudWxsO1xuICAgICAgdmFyIHNlcmllc1hWYWxBcnIgPSBbXTtcbiAgICAgIHZhciBzZXJpZXNZVmFsQXJyID0gW107XG5cbiAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdy5nbG9iYWxzLnNlcmllc1h2YWx1ZXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgc2VyaWVzWFZhbEFyci5wdXNoKFt3Lmdsb2JhbHMuc2VyaWVzWHZhbHVlc1tzXVswXSAtIDAuMDAwMDAxXS5jb25jYXQody5nbG9iYWxzLnNlcmllc1h2YWx1ZXNbc10pKTtcbiAgICAgIH1cblxuICAgICAgc2VyaWVzWFZhbEFyciA9IHNlcmllc1hWYWxBcnIubWFwKGZ1bmN0aW9uIChzZXJpZXNYVmFsKSB7XG4gICAgICAgIHJldHVybiBzZXJpZXNYVmFsLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgc2VyaWVzWVZhbEFyciA9IHcuZ2xvYmFscy5zZXJpZXNZdmFsdWVzLm1hcChmdW5jdGlvbiAoc2VyaWVzWVZhbCkge1xuICAgICAgICByZXR1cm4gc2VyaWVzWVZhbC5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gaWYgWCBheGlzIHR5cGUgaXMgbm90IGNhdGVnb3J5IGFuZCB0b29sdGlwIGlzIG5vdCBzaGFyZWQsIHRoZW4gd2UgbmVlZCB0byBmaW5kIHRoZSBjdXJzb3IgcG9zaXRpb24gYW5kIGdldCB0aGUgbmVhcmVzdCB2YWx1ZVxuXG4gICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgY2xvc2VzdCA9IHRoaXMuY2xvc2VzdEluTXVsdGlBcnJheShob3ZlclgsIGhvdmVyWSwgc2VyaWVzWFZhbEFyciwgc2VyaWVzWVZhbEFycik7XG4gICAgICAgIGNhcHR1cmVkU2VyaWVzID0gY2xvc2VzdC5pbmRleDtcbiAgICAgICAgaiA9IGNsb3Nlc3QuajtcblxuICAgICAgICBpZiAoY2FwdHVyZWRTZXJpZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBpbml0aWFsIHB1c2gsIGl0IHNob3VsZCBiZSBhIGxpdHRsZSBzbWFsbGVyIHRoYW4gdGhlIDFzdCB2YWxcbiAgICAgICAgICBzZXJpZXNYVmFsQXJyID0gdy5nbG9iYWxzLnNlcmllc1h2YWx1ZXNbY2FwdHVyZWRTZXJpZXNdO1xuICAgICAgICAgIGNsb3Nlc3QgPSB0aGlzLmNsb3Nlc3RJbkFycmF5KGhvdmVyWCwgc2VyaWVzWFZhbEFycik7XG4gICAgICAgICAgaiA9IGNsb3Nlc3QuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFqIHx8IGogPCAxKSBqID0gMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhcHR1cmVkU2VyaWVzOiBjYXB0dXJlZFNlcmllcyxcbiAgICAgICAgajogaixcbiAgICAgICAgaG92ZXJYOiBob3ZlclgsXG4gICAgICAgIGhvdmVyWTogaG92ZXJZXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZXN0SW5NdWx0aUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3Nlc3RJbk11bHRpQXJyYXkoaG92ZXJYLCBob3ZlclksIFhhcnJheXMsIFlhcnJheXMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gMDtcbiAgICAgIHZhciBjdXJySW5kZXggPSBudWxsO1xuICAgICAgdmFyIGogPSAtMTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0Rmlyc3RBY3RpdmVYQXJyYXkoWGFycmF5cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJySW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VyclkgPSBZYXJyYXlzW2FjdGl2ZUluZGV4XVswXTtcbiAgICAgIHZhciBjdXJyWCA9IFhhcnJheXNbYWN0aXZlSW5kZXhdWzBdO1xuICAgICAgdmFyIGRpZmZYID0gTWF0aC5hYnMoaG92ZXJYIC0gY3VyclgpO1xuICAgICAgdmFyIGRpZmZZID0gTWF0aC5hYnMoaG92ZXJZIC0gY3VyclkpO1xuICAgICAgdmFyIGRpZmYgPSBkaWZmWSArIGRpZmZYO1xuICAgICAgWWFycmF5cy5tYXAoZnVuY3Rpb24gKGFyclksIGFyckluZGV4KSB7XG4gICAgICAgIGFyclkubWFwKGZ1bmN0aW9uICh5LCBpbm5lcktleSkge1xuICAgICAgICAgIHZhciBuZXdkaWZmWSA9IE1hdGguYWJzKGhvdmVyWSAtIFlhcnJheXNbYXJySW5kZXhdW2lubmVyS2V5XSk7XG4gICAgICAgICAgdmFyIG5ld2RpZmZYID0gTWF0aC5hYnMoaG92ZXJYIC0gWGFycmF5c1thcnJJbmRleF1baW5uZXJLZXldKTtcbiAgICAgICAgICB2YXIgbmV3ZGlmZiA9IG5ld2RpZmZYICsgbmV3ZGlmZlk7XG5cbiAgICAgICAgICBpZiAobmV3ZGlmZiA8IGRpZmYpIHtcbiAgICAgICAgICAgIGRpZmYgPSBuZXdkaWZmO1xuICAgICAgICAgICAgZGlmZlggPSBuZXdkaWZmWDtcbiAgICAgICAgICAgIGRpZmZZID0gbmV3ZGlmZlk7XG4gICAgICAgICAgICBjdXJySW5kZXggPSBhcnJJbmRleDtcbiAgICAgICAgICAgIGogPSBpbm5lcktleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogY3VyckluZGV4LFxuICAgICAgICBqOiBqXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGaXJzdEFjdGl2ZVhBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaXJzdEFjdGl2ZVhBcnJheShYYXJyYXlzKSB7XG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSAwO1xuICAgICAgdmFyIGNvcmVVdGlscyA9IG5ldyBDb3JlVXRpbHModGhpcy5jdHgpO1xuICAgICAgdmFyIGZpcnN0QWN0aXZlU2VyaWVzSW5kZXggPSBYYXJyYXlzLm1hcChmdW5jdGlvbiAoeGFyciwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHhhcnIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGZpcnN0QWN0aXZlU2VyaWVzSW5kZXgubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgdmFyIHRvdGFsID0gY29yZVV0aWxzLmdldFNlcmllc1RvdGFsQnlJbmRleChhKTtcblxuICAgICAgICBpZiAoZmlyc3RBY3RpdmVTZXJpZXNJbmRleFthXSAhPT0gLTEgJiYgdG90YWwgIT09IDAgJiYgIWNvcmVVdGlscy5zZXJpZXNIYXZlU2FtZVZhbHVlcyhhKSkge1xuICAgICAgICAgIGFjdGl2ZUluZGV4ID0gZmlyc3RBY3RpdmVTZXJpZXNJbmRleFthXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWN0aXZlSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3Nlc3RJbkFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3Nlc3RJbkFycmF5KHZhbCwgYXJyKSB7XG4gICAgICB2YXIgY3VyciA9IGFyclswXTtcbiAgICAgIHZhciBjdXJySW5kZXggPSBudWxsO1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyh2YWwgLSBjdXJyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld2RpZmYgPSBNYXRoLmFicyh2YWwgLSBhcnJbaV0pO1xuXG4gICAgICAgIGlmIChuZXdkaWZmIDwgZGlmZikge1xuICAgICAgICAgIGRpZmYgPSBuZXdkaWZmO1xuICAgICAgICAgIGN1cnIgPSBhcnJbaV07XG4gICAgICAgICAgY3VyckluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogY3VyckluZGV4XG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBzZXJpZXMsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgZGlmZmVyZW50IHggdmFsdWVzIGZvciBlYWNoIHNlcmllcy5cbiAgICAgKiBCdXQgaXQgbWF5IGJlIHBvc3NpYmxlIGluIHRob3NlIG11bHRpcGxlIHNlcmllcywgdGhhdCB0aGVyZSBpcyBzYW1lIHggdmFsdWUgZm9yIDIgb3IgbW9yZVxuICAgICAqIHNlcmllcy5cbiAgICAgKiBAbWVtYmVyb2YgVXRpbHNcbiAgICAgKiBAcGFyYW0ge2ludH1cbiAgICAgKiAtIGogPSBpcyB0aGUgaW5uZXIgaW5kZXggb2Ygc2VyaWVzIC0+IChzZXJpZXNbaV1bal0pXG4gICAgICogQHJldHVybiB7Ym9vbH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzWG92ZXJsYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNYb3ZlcmxhcChqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4U2FtZUZvckFsbFNlcmllc0pBcnIgPSBbXTtcbiAgICAgIHZhciBzZXJpZXNYID0gdy5nbG9iYWxzLnNlcmllc1guZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc1swXSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlcmllc1gubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllc1gubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzZXJpZXNYW2ldW2pdICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc2VyaWVzWFtpICsgMV1bal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzWFtpXVtqXSAhPT0gc2VyaWVzWFtpICsgMV1bal0pIHtcbiAgICAgICAgICAgICAgeFNhbWVGb3JBbGxTZXJpZXNKQXJyLnB1c2goJ3VuRXF1YWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHhTYW1lRm9yQWxsU2VyaWVzSkFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNpbml0aWFsU2VyaWVzU2FtZUxlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc2luaXRpYWxTZXJpZXNTYW1lTGVuKCkge1xuICAgICAgdmFyIHNhbWVMZW4gPSB0cnVlO1xuICAgICAgdmFyIGluaXRpYWxTZXJpZXMgPSB0aGlzLncuZ2xvYmFscy5pbml0aWFsU2VyaWVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxTZXJpZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChpbml0aWFsU2VyaWVzW2ldLmRhdGEubGVuZ3RoICE9PSBpbml0aWFsU2VyaWVzW2kgKyAxXS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHNhbWVMZW4gPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2FtZUxlbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFyc0hlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXJzSGVpZ2h0KGFsbGJhcnMpIHtcbiAgICAgIHZhciBiYXJzID0gX3RvQ29uc3VtYWJsZUFycmF5KGFsbGJhcnMpO1xuXG4gICAgICB2YXIgdG90YWxIZWlnaHQgPSBiYXJzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBiYXIpIHtcbiAgICAgICAgcmV0dXJuIGFjYyArIGJhci5nZXRCQm94KCkuaGVpZ2h0O1xuICAgICAgfSwgMCk7XG4gICAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZUFsbFRvb2x0aXBTZXJpZXNHcm91cHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlQWxsVG9vbHRpcFNlcmllc0dyb3VwcyhzdGF0ZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuXG4gICAgICBpZiAodHRDdHguYWxsVG9vbHRpcFNlcmllc0dyb3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdHRDdHguYWxsVG9vbHRpcFNlcmllc0dyb3VwcyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtc2VyaWVzLWdyb3VwJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGxUb29sdGlwU2VyaWVzR3JvdXBzID0gdHRDdHguYWxsVG9vbHRpcFNlcmllc0dyb3VwcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxUb29sdGlwU2VyaWVzR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2VuYWJsZScpIHtcbiAgICAgICAgICBhbGxUb29sdGlwU2VyaWVzR3JvdXBzW2ldLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgIGFsbFRvb2x0aXBTZXJpZXNHcm91cHNbaV0uc3R5bGUuZGlzcGxheSA9IHcuY29uZmlnLnRvb2x0aXAuaXRlbXMuZGlzcGxheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGxUb29sdGlwU2VyaWVzR3JvdXBzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgIGFsbFRvb2x0aXBTZXJpZXNHcm91cHNbaV0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBVdGlscztcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFRvb2x0aXAuTGFiZWxzIENsYXNzIHRvIGRyYXcgdGV4dHMgb24gdGhlIHRvb2x0aXAuXG4gKlxuICogQG1vZHVsZSBUb29sdGlwLkxhYmVsc1xuICoqL1xuXG52YXIgTGFiZWxzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFiZWxzKHRvb2x0aXBDb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVscyk7XG5cbiAgICB0aGlzLncgPSB0b29sdGlwQ29udGV4dC53O1xuICAgIHRoaXMuY3R4ID0gdG9vbHRpcENvbnRleHQuY3R4O1xuICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgICB0aGlzLnRvb2x0aXBVdGlsID0gbmV3IFV0aWxzJDEodG9vbHRpcENvbnRleHQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExhYmVscywgW3tcbiAgICBrZXk6IFwiZHJhd1Nlcmllc1RleHRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTZXJpZXNUZXh0cyhfcmVmKSB7XG4gICAgICB2YXIgX3JlZiRzaGFyZWQgPSBfcmVmLnNoYXJlZCxcbiAgICAgICAgICBzaGFyZWQgPSBfcmVmJHNoYXJlZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkc2hhcmVkLFxuICAgICAgICAgIHR0SXRlbXMgPSBfcmVmLnR0SXRlbXMsXG4gICAgICAgICAgX3JlZiRpID0gX3JlZi5pLFxuICAgICAgICAgIGkgPSBfcmVmJGkgPT09IHZvaWQgMCA/IDAgOiBfcmVmJGksXG4gICAgICAgICAgX3JlZiRqID0gX3JlZi5qLFxuICAgICAgICAgIGogPSBfcmVmJGogPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJGo7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAuY3VzdG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDdXN0b21Ub29sdGlwKHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGo6IGpcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZUluYWN0aXZlU2VyaWVzKHNoYXJlZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlc1RvUHJpbnQoe1xuICAgICAgICBpOiBpLFxuICAgICAgICBqOiBqXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJpbnRMYWJlbHMoe1xuICAgICAgICBpOiBpLFxuICAgICAgICBqOiBqLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgdHRJdGVtczogdHRJdGVtcyxcbiAgICAgICAgc2hhcmVkOiBzaGFyZWRcbiAgICAgIH0pOyAvLyBSZS1jYWxjdWxhdGUgdG9vbHRpcCBkaW1lbnNpb25zIG5vdyB0aGF0IHdlIGhhdmUgZHJhd24gdGhlIHRleHRcblxuICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMudHRDdHguZ2V0RWxUb29sdGlwKCk7XG4gICAgICB0aGlzLnR0Q3R4LnRvb2x0aXBSZWN0LnR0V2lkdGggPSB0b29sdGlwRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICB0aGlzLnR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0ID0gdG9vbHRpcEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJpbnRMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnRMYWJlbHMoX3JlZjIpIHtcbiAgICAgIHZhciBpID0gX3JlZjIuaSxcbiAgICAgICAgICBqID0gX3JlZjIuaixcbiAgICAgICAgICB2YWx1ZXMgPSBfcmVmMi52YWx1ZXMsXG4gICAgICAgICAgdHRJdGVtcyA9IF9yZWYyLnR0SXRlbXMsXG4gICAgICAgICAgc2hhcmVkID0gX3JlZjIuc2hhcmVkO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdmFsO1xuICAgICAgdmFyIHhWYWwgPSB2YWx1ZXMueFZhbCxcbiAgICAgICAgICB6VmFsID0gdmFsdWVzLnpWYWwsXG4gICAgICAgICAgeEF4aXNUVFZhbCA9IHZhbHVlcy54QXhpc1RUVmFsO1xuICAgICAgdmFyIHNlcmllc05hbWUgPSAnJztcbiAgICAgIHZhciBwQ29sb3IgPSB3Lmdsb2JhbHMuY29sb3JzW2ldO1xuXG4gICAgICBpZiAoaiAhPT0gbnVsbCAmJiB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuZGlzdHJpYnV0ZWQpIHtcbiAgICAgICAgcENvbG9yID0gdy5nbG9iYWxzLmNvbG9yc1tqXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgdCA9IDAsIGludmVyc2V0ID0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGggLSAxOyB0IDwgdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7IHQrKywgaW52ZXJzZXQtLSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuZ2V0Rm9ybWF0dGVycyhpKTtcbiAgICAgICAgc2VyaWVzTmFtZSA9IHRoaXMuZ2V0U2VyaWVzTmFtZSh7XG4gICAgICAgICAgZm46IGYueUxiVGl0bGVGb3JtYXR0ZXIsXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgajogalxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2hhcmVkKSB7XG4gICAgICAgICAgdmFyIHRJbmRleCA9IHcuY29uZmlnLnRvb2x0aXAuaW52ZXJzZU9yZGVyID8gaW52ZXJzZXQgOiB0O1xuICAgICAgICAgIGYgPSB0aGlzLmdldEZvcm1hdHRlcnModEluZGV4KTtcbiAgICAgICAgICBzZXJpZXNOYW1lID0gdGhpcy5nZXRTZXJpZXNOYW1lKHtcbiAgICAgICAgICAgIGZuOiBmLnlMYlRpdGxlRm9ybWF0dGVyLFxuICAgICAgICAgICAgaW5kZXg6IHRJbmRleCxcbiAgICAgICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICAgICAgajogalxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBDb2xvciA9IHcuZ2xvYmFscy5jb2xvcnNbdEluZGV4XTsgLy8gZm9yIHBsb3QgY2hhcnRzLCBub3QgZm9yIHBpZS9kb251dHNcblxuICAgICAgICAgIHZhbCA9IGYueUxiRm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNbdEluZGV4XVtqXSwge1xuICAgICAgICAgICAgc2VyaWVzOiB3Lmdsb2JhbHMuc2VyaWVzLFxuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTsgLy8gZGlzY2FyZCAwIHZhbHVlcyBpbiBCQVJTXG5cbiAgICAgICAgICBpZiAodGhpcy50dEN0eC5oYXNCYXJzKCkgJiYgdy5jb25maWcuY2hhcnQuc3RhY2tlZCAmJiB3Lmdsb2JhbHMuc2VyaWVzW3RJbmRleF1bal0gPT09IDAgfHwgdHlwZW9mIHcuZ2xvYmFscy5zZXJpZXNbdEluZGV4XVtqXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gZi55TGJGb3JtYXR0ZXIody5nbG9iYWxzLnNlcmllc1tpXVtqXSwge1xuICAgICAgICAgICAgc2VyaWVzOiB3Lmdsb2JhbHMuc2VyaWVzLFxuICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgICAgIHc6IHdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBmb3IgcGllIC8gZG9udXRzXG5cblxuICAgICAgICBpZiAoaiA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhbCA9IGYueUxiRm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNbaV0sIHcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ET01IYW5kbGluZyh7XG4gICAgICAgICAgdDogdCxcbiAgICAgICAgICB0dEl0ZW1zOiB0dEl0ZW1zLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICB4VmFsOiB4VmFsLFxuICAgICAgICAgICAgeEF4aXNUVFZhbDogeEF4aXNUVFZhbCxcbiAgICAgICAgICAgIHpWYWw6IHpWYWxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXG4gICAgICAgICAgc2hhcmVkOiBzaGFyZWQsXG4gICAgICAgICAgcENvbG9yOiBwQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdHRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0dGVycyhpKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB5TGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1tpXTtcbiAgICAgIHZhciB5TGJUaXRsZUZvcm1hdHRlcjtcblxuICAgICAgaWYgKHcuZ2xvYmFscy50dFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHcuZ2xvYmFscy50dFZhbCkpIHtcbiAgICAgICAgICB5TGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMudHRWYWxbaV0gJiYgdy5nbG9iYWxzLnR0VmFsW2ldLmZvcm1hdHRlcjtcbiAgICAgICAgICB5TGJUaXRsZUZvcm1hdHRlciA9IHcuZ2xvYmFscy50dFZhbFtpXSAmJiB3Lmdsb2JhbHMudHRWYWxbaV0udGl0bGUgJiYgdy5nbG9iYWxzLnR0VmFsW2ldLnRpdGxlLmZvcm1hdHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5TGJGb3JtYXR0ZXIgPSB3Lmdsb2JhbHMudHRWYWwuZm9ybWF0dGVyO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMudHRWYWwudGl0bGUuZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB5TGJUaXRsZUZvcm1hdHRlciA9IHcuZ2xvYmFscy50dFZhbC50aXRsZS5mb3JtYXR0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5TGJUaXRsZUZvcm1hdHRlciA9IHcuY29uZmlnLnRvb2x0aXAueS50aXRsZS5mb3JtYXR0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgeUxiRm9ybWF0dGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMueUxhYmVsRm9ybWF0dGVyc1swXSkge1xuICAgICAgICAgIHlMYkZvcm1hdHRlciA9IHcuZ2xvYmFscy55TGFiZWxGb3JtYXR0ZXJzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlMYkZvcm1hdHRlciA9IGZ1bmN0aW9uIHlMYkZvcm1hdHRlcihsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB5TGJUaXRsZUZvcm1hdHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB5TGJUaXRsZUZvcm1hdHRlciA9IGZ1bmN0aW9uIHlMYlRpdGxlRm9ybWF0dGVyKGxhYmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB5TGJGb3JtYXR0ZXI6IHlMYkZvcm1hdHRlcixcbiAgICAgICAgeUxiVGl0bGVGb3JtYXR0ZXI6IHlMYlRpdGxlRm9ybWF0dGVyXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc05hbWUoX3JlZjMpIHtcbiAgICAgIHZhciBmbiA9IF9yZWYzLmZuLFxuICAgICAgICAgIGluZGV4ID0gX3JlZjMuaW5kZXgsXG4gICAgICAgICAgc2VyaWVzSW5kZXggPSBfcmVmMy5zZXJpZXNJbmRleCxcbiAgICAgICAgICBqID0gX3JlZjMuajtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgcmV0dXJuIGZuKFN0cmluZyh3Lmdsb2JhbHMuc2VyaWVzTmFtZXNbaW5kZXhdKSwge1xuICAgICAgICBzZXJpZXM6IHcuZ2xvYmFscy5zZXJpZXMsXG4gICAgICAgIHNlcmllc0luZGV4OiBzZXJpZXNJbmRleCxcbiAgICAgICAgZGF0YVBvaW50SW5kZXg6IGosXG4gICAgICAgIHc6IHdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJET01IYW5kbGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBET01IYW5kbGluZyhfcmVmNCkge1xuICAgICAgdmFyIHQgPSBfcmVmNC50LFxuICAgICAgICAgIHR0SXRlbXMgPSBfcmVmNC50dEl0ZW1zLFxuICAgICAgICAgIHZhbHVlcyA9IF9yZWY0LnZhbHVlcyxcbiAgICAgICAgICBzZXJpZXNOYW1lID0gX3JlZjQuc2VyaWVzTmFtZSxcbiAgICAgICAgICBzaGFyZWQgPSBfcmVmNC5zaGFyZWQsXG4gICAgICAgICAgcENvbG9yID0gX3JlZjQucENvbG9yO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgdmFyIHZhbCA9IHZhbHVlcy52YWwsXG4gICAgICAgICAgeFZhbCA9IHZhbHVlcy54VmFsLFxuICAgICAgICAgIHhBeGlzVFRWYWwgPSB2YWx1ZXMueEF4aXNUVFZhbCxcbiAgICAgICAgICB6VmFsID0gdmFsdWVzLnpWYWw7XG4gICAgICB2YXIgdHRJdGVtc0NoaWxkcmVuID0gbnVsbDtcbiAgICAgIHR0SXRlbXNDaGlsZHJlbiA9IHR0SXRlbXNbdF0uY2hpbGRyZW47XG5cbiAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmZpbGxTZXJpZXNDb2xvcikge1xuICAgICAgICAvLyAgZWxUb29sdGlwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBDb2xvclxuICAgICAgICB0dEl0ZW1zW3RdLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBDb2xvcjtcbiAgICAgICAgdHRJdGVtc0NoaWxkcmVuWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0dEN0eC5zaG93VG9vbHRpcFRpdGxlKSB7XG4gICAgICAgIGlmICh0dEN0eC50b29sdGlwVGl0bGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBnZXQgaXQgb25jZSBpZiBudWxsLCBhbmQgc3RvcmUgaXQgaW4gY2xhc3MgcHJvcGVydHlcbiAgICAgICAgICB0dEN0eC50b29sdGlwVGl0bGUgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy10b29sdGlwLXRpdGxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0dEN0eC50b29sdGlwVGl0bGUuaW5uZXJIVE1MID0geFZhbDtcbiAgICAgIH0gLy8gaWYgeGF4aXMgdG9vbHRpcCBpcyBjb25zdHJ1Y3RlZCwgd2UgbmVlZCB0byByZXBsYWNlIHRoZSBpbm5lckhUTUxcblxuXG4gICAgICBpZiAodHRDdHguYmx4YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgdHRDdHgueGF4aXNUb29sdGlwVGV4dC5pbm5lckhUTUwgPSB4QXhpc1RUVmFsICE9PSAnJyA/IHhBeGlzVFRWYWwgOiB4VmFsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHRZTGFiZWwgPSB0dEl0ZW1zW3RdLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC1sYWJlbCcpO1xuXG4gICAgICBpZiAodHRZTGFiZWwpIHtcbiAgICAgICAgdHRZTGFiZWwuaW5uZXJIVE1MID0gc2VyaWVzTmFtZSA/IHNlcmllc05hbWUgKyAnOiAnIDogJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciB0dFlWYWwgPSB0dEl0ZW1zW3RdLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC12YWx1ZScpO1xuXG4gICAgICBpZiAodHRZVmFsKSB7XG4gICAgICAgIHR0WVZhbC5pbm5lckhUTUwgPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0dEl0ZW1zQ2hpbGRyZW5bMF0gJiYgdHRJdGVtc0NoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy10b29sdGlwLW1hcmtlcicpKSB7XG4gICAgICAgIHR0SXRlbXNDaGlsZHJlblswXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICghdy5jb25maWcudG9vbHRpcC5tYXJrZXIuc2hvdykge1xuICAgICAgICB0dEl0ZW1zQ2hpbGRyZW5bMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgaWYgKHpWYWwgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHR0WkxhYmVsID0gdHRJdGVtc1t0XS5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy10b29sdGlwLXRleHQtei1sYWJlbCcpO1xuICAgICAgICB0dFpMYWJlbC5pbm5lckhUTUwgPSB3LmNvbmZpZy50b29sdGlwLnoudGl0bGU7XG4gICAgICAgIHZhciB0dFpWYWwgPSB0dEl0ZW1zW3RdLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LXZhbHVlJyk7XG4gICAgICAgIHR0WlZhbC5pbm5lckhUTUwgPSB6VmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hhcmVkICYmIHR0SXRlbXNDaGlsZHJlblswXSkge1xuICAgICAgICAvLyBoaWRlIHdoZW4gbm8gVmFsIG9yIHNlcmllcyBjb2xsYXBzZWRcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnIHx8IHZhbCA9PT0gbnVsbCB8fCB3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzSW5kaWNlcy5pbmRleE9mKHQpID4gLTEpIHtcbiAgICAgICAgICB0dEl0ZW1zQ2hpbGRyZW5bMF0ucGFyZW50Tm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR0SXRlbXNDaGlsZHJlblswXS5wYXJlbnROb2RlLnN0eWxlLmRpc3BsYXkgPSB3LmNvbmZpZy50b29sdGlwLml0ZW1zLmRpc3BsYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlQWN0aXZlSW5hY3RpdmVTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlQWN0aXZlSW5hY3RpdmVTZXJpZXMoc2hhcmVkKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHNoYXJlZCkge1xuICAgICAgICAvLyBtYWtlIGFsbCB0b29sdGlwcyBhY3RpdmVcbiAgICAgICAgdGhpcy50b29sdGlwVXRpbC50b2dnbGVBbGxUb29sdGlwU2VyaWVzR3JvdXBzKCdlbmFibGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpc2FibGUgYWxsIHRvb2x0aXAgdGV4dCBncm91cHNcbiAgICAgICAgdGhpcy50b29sdGlwVXRpbC50b2dnbGVBbGxUb29sdGlwU2VyaWVzR3JvdXBzKCdkaXNhYmxlJyk7IC8vIGVuYWJsZSB0aGUgZmlyc3QgdG9vbHRpcCB0ZXh0IGdyb3VwXG5cbiAgICAgICAgdmFyIGZpcnN0VG9vbHRpcFNlcmllc0dyb3VwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAnKTtcblxuICAgICAgICBpZiAoZmlyc3RUb29sdGlwU2VyaWVzR3JvdXApIHtcbiAgICAgICAgICBmaXJzdFRvb2x0aXBTZXJpZXNHcm91cC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICBmaXJzdFRvb2x0aXBTZXJpZXNHcm91cC5zdHlsZS5kaXNwbGF5ID0gdy5jb25maWcudG9vbHRpcC5pdGVtcy5kaXNwbGF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlc1RvUHJpbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVzVG9QcmludChfcmVmNSkge1xuICAgICAgdmFyIGkgPSBfcmVmNS5pLFxuICAgICAgICAgIGogPSBfcmVmNS5qO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZmlsdGVyZWRTZXJpZXNYID0gdGhpcy5jdHguc2VyaWVzLmZpbHRlcmVkU2VyaWVzWCgpO1xuICAgICAgdmFyIHhWYWwgPSAnJztcbiAgICAgIHZhciB4QXhpc1RUVmFsID0gJyc7XG4gICAgICB2YXIgelZhbCA9IG51bGw7XG4gICAgICB2YXIgdmFsID0gbnVsbDtcbiAgICAgIHZhciBjdXN0b21Gb3JtYXR0ZXJPcHRzID0ge1xuICAgICAgICBzZXJpZXM6IHcuZ2xvYmFscy5zZXJpZXMsXG4gICAgICAgIHNlcmllc0luZGV4OiBpLFxuICAgICAgICBkYXRhUG9pbnRJbmRleDogaixcbiAgICAgICAgdzogd1xuICAgICAgfTtcbiAgICAgIHZhciB6Rm9ybWF0dGVyID0gdy5nbG9iYWxzLnR0WkZvcm1hdHRlcjtcblxuICAgICAgaWYgKGogPT09IG51bGwpIHtcbiAgICAgICAgdmFsID0gdy5nbG9iYWxzLnNlcmllc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgIHhWYWwgPSBmaWx0ZXJlZFNlcmllc1hbaV1bal07XG5cbiAgICAgICAgICBpZiAoZmlsdGVyZWRTZXJpZXNYW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gYSBzZXJpZXMgKHBvc3NpYmx5IHRoZSBmaXJzdCBvbmUpIG1pZ2h0IGJlIGNvbGxhcHNlZCwgc28gZ2V0IHRoZSBuZXh0IGFjdGl2ZSBpbmRleFxuICAgICAgICAgICAgdmFyIGZpcnN0QWN0aXZlU2VyaWVzSW5kZXggPSB0aGlzLnRvb2x0aXBVdGlsLmdldEZpcnN0QWN0aXZlWEFycmF5KGZpbHRlcmVkU2VyaWVzWCk7XG4gICAgICAgICAgICB4VmFsID0gZmlsdGVyZWRTZXJpZXNYW2ZpcnN0QWN0aXZlU2VyaWVzSW5kZXhdW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4VmFsID0gdHlwZW9mIHcuZ2xvYmFscy5sYWJlbHNbal0gIT09ICd1bmRlZmluZWQnID8gdy5nbG9iYWxzLmxhYmVsc1tqXSA6ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBidWZmZXJYVmFsID0geFZhbDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljICYmIHcuY29uZmlnLnhheGlzLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgdmFyIHhGb3JtYXQgPSBuZXcgRm9ybWF0dGVycyh0aGlzLmN0eCk7XG4gICAgICAgIHhWYWwgPSB4Rm9ybWF0LnhMYWJlbEZvcm1hdCh3Lmdsb2JhbHMudHRLZXlGb3JtYXR0ZXIsIGJ1ZmZlclhWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFZhbCA9IHcuZ2xvYmFscy54TGFiZWxGb3JtYXR0ZXIoYnVmZmVyWFZhbCwgY3VzdG9tRm9ybWF0dGVyT3B0cyk7XG4gICAgICB9IC8vIG92ZXJyaWRlIGRlZmF1bHQgeC1heGlzIGZvcm1hdHRlciB3aXRoIHRvb2x0aXAgZm9ybWF0dGVyXG5cblxuICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAueC5mb3JtYXR0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB4VmFsID0gdy5nbG9iYWxzLnR0S2V5Rm9ybWF0dGVyKGJ1ZmZlclhWYWwsIGN1c3RvbUZvcm1hdHRlck9wdHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLnNlcmllc1oubGVuZ3RoID4gMCAmJiB3Lmdsb2JhbHMuc2VyaWVzWlswXS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHpWYWwgPSB6Rm9ybWF0dGVyKHcuZ2xvYmFscy5zZXJpZXNaW2ldW2pdLCB3KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy54YXhpcy50b29sdGlwLmZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB4QXhpc1RUVmFsID0gdy5nbG9iYWxzLnhheGlzVG9vbHRpcEZvcm1hdHRlcihidWZmZXJYVmFsLCBjdXN0b21Gb3JtYXR0ZXJPcHRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhBeGlzVFRWYWwgPSB4VmFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgeFZhbDogeFZhbCxcbiAgICAgICAgeEF4aXNUVFZhbDogeEF4aXNUVFZhbCxcbiAgICAgICAgelZhbDogelZhbFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ3VzdG9tVG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDdXN0b21Ub29sdGlwKF9yZWY2KSB7XG4gICAgICB2YXIgaSA9IF9yZWY2LmksXG4gICAgICAgICAgaiA9IF9yZWY2Lmo7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0b29sdGlwRWwgPSB0aGlzLnR0Q3R4LmdldEVsVG9vbHRpcCgpOyAvLyBvdmVycmlkZSBldmVyeXRoaW5nIHdpdGggYSBjdXN0b20gaHRtbCB0b29sdGlwIGFuZCByZXBsYWNlIGl0XG5cbiAgICAgIHRvb2x0aXBFbC5pbm5lckhUTUwgPSB3LmNvbmZpZy50b29sdGlwLmN1c3RvbSh7XG4gICAgICAgIHNlcmllczogdy5nbG9iYWxzLnNlcmllcyxcbiAgICAgICAgc2VyaWVzSW5kZXg6IGksXG4gICAgICAgIGRhdGFQb2ludEluZGV4OiBqLFxuICAgICAgICB3OiB3XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGFiZWxzO1xufSgpO1xuXG4vKipcbiAqIEFwZXhDaGFydHMgVG9vbHRpcC5Qb3NpdGlvbiBDbGFzcyB0byBtb3ZlIHRoZSB0b29sdGlwIGJhc2VkIG9uIHggYW5kIHkgcG9zaXRpb24uXG4gKlxuICogQG1vZHVsZSBUb29sdGlwLlBvc2l0aW9uXG4gKiovXG5cbnZhciBQb3NpdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvc2l0aW9uKHRvb2x0aXBDb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvc2l0aW9uKTtcblxuICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgICB0aGlzLmN0eCA9IHRvb2x0aXBDb250ZXh0LmN0eDtcbiAgICB0aGlzLncgPSB0b29sdGlwQ29udGV4dC53O1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgbW92ZSB0aGUgY3Jvc3NoYWlyICh0aGUgdmVydGljYWwvaG9yeiBsaW5lIHRoYXQgbW92ZXMgYWxvbmcgd2l0aCBtb3VzZSlcbiAgICogQWxvbmcgd2l0aCB0aGlzLCB0aGlzIGZ1bmN0aW9uIGFsc28gY2FsbHMgdGhlIHhheGlzTW92ZSBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgUG9zaXRpb25cbiAgICogQHBhcmFtIHtpbnR9IC0gY3ggPSBwb2ludCdzIHggcG9zaXRpb24sIHdoZXJldmVyIHBvaW50J3MgeCBpcywgeW91IG5lZWQgdG8gbW92ZSBjcm9zc2hhaXJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUG9zaXRpb24sIFt7XG4gICAga2V5OiBcIm1vdmVYQ3Jvc3NoYWlyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlWENyb3NzaGFpcnMoY3gpIHtcbiAgICAgIHZhciBqID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdHRDdHguZ2V0RWxYQ3Jvc3NoYWlycygpO1xuICAgICAgdmFyIHggPSBjeCAtIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggLyAyO1xuICAgICAgdmFyIHRpY2tBbW91bnQgPSB3Lmdsb2JhbHMubGFiZWxzLnNsaWNlKCkubGVuZ3RoO1xuXG4gICAgICBpZiAoaiAhPT0gbnVsbCkge1xuICAgICAgICB4ID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHRpY2tBbW91bnQgKiBqO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ3RpY2tXaWR0aCcgfHwgdy5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ2JhcldpZHRoJykge1xuICAgICAgICBpZiAoeCArIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgICAgeCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLSB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaiAhPT0gbnVsbCkge1xuICAgICAgICAgIHggPSB4ICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHRpY2tBbW91bnQgLyAyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICB4ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgIHggPSB3Lmdsb2JhbHMuZ3JpZFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoeGNyb3NzaGFpcnMgIT09IG51bGwpIHtcbiAgICAgICAgeGNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd4JywgeCk7XG4gICAgICAgIHhjcm9zc2hhaXJzLnNldEF0dHJpYnV0ZSgneDEnLCB4KTtcbiAgICAgICAgeGNyb3NzaGFpcnMuc2V0QXR0cmlidXRlKCd4MicsIHgpO1xuICAgICAgICB4Y3Jvc3NoYWlycy5zZXRBdHRyaWJ1dGUoJ3kyJywgdy5nbG9iYWxzLmdyaWRIZWlnaHQpO1xuICAgICAgICB4Y3Jvc3NoYWlycy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR0Q3R4LmJseGF4aXNUb29sdGlwKSB7XG4gICAgICAgIHZhciB0eCA9IHg7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggPT09ICd0aWNrV2lkdGgnIHx8IHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggPT09ICdiYXJXaWR0aCcpIHtcbiAgICAgICAgICB0eCA9IHggKyB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW92ZVhBeGlzVG9vbHRpcCh0eCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgd2lsbCBtb3ZlIHRoZSBjcm9zc2hhaXIgKHRoZSB2ZXJ0aWNhbC9ob3J6IGxpbmUgdGhhdCBtb3ZlcyBhbG9uZyB3aXRoIG1vdXNlKVxuICAgICAqIEFsb25nIHdpdGggdGhpcywgdGhpcyBmdW5jdGlvbiBhbHNvIGNhbGxzIHRoZSB4YXhpc01vdmUgZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2ludH0gLSBjeCA9IHBvaW50J3MgeCBwb3NpdGlvbiwgd2hlcmV2ZXIgcG9pbnQncyB4IGlzLCB5b3UgbmVlZCB0byBtb3ZlIGNyb3NzaGFpclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVlDcm9zc2hhaXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVZQ3Jvc3NoYWlycyhjeSkge1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcblxuICAgICAgaWYgKHR0Q3R4Lnljcm9zc2hhaXJzICE9PSBudWxsKSB7XG4gICAgICAgIEdyYXBoaWNzLnNldEF0dHJzKHR0Q3R4Lnljcm9zc2hhaXJzLCB7XG4gICAgICAgICAgeTE6IGN5LFxuICAgICAgICAgIHkyOiBjeVxuICAgICAgICB9KTtcbiAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnModHRDdHgueWNyb3NzaGFpcnNIaWRkZW4sIHtcbiAgICAgICAgICB5MTogY3ksXG4gICAgICAgICAgeTI6IGN5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiogQXhpc1Rvb2x0aXAgaXMgdGhlIHNtYWxsIHJlY3RhbmdsZSB3aGljaCBhcHBlYXJzIG9uIHggYXhpcyB3aXRoIHggdmFsdWUsIHdoZW4gdXNlciBtb3Zlc1xuICAgICAqIEBtZW1iZXJvZiBQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7aW50fSAtIGN4ID0gcG9pbnQncyB4IHBvc2l0aW9uLCB3aGVyZXZlciBwb2ludCdzIHggaXMsIHlvdSBuZWVkIHRvIG1vdmVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVYQXhpc1Rvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVhBeGlzVG9vbHRpcChjeCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuXG4gICAgICBpZiAodHRDdHgueGF4aXNUb29sdGlwICE9PSBudWxsKSB7XG4gICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgdmFyIGN5ID0gdHRDdHgueGF4aXNPZmZZICsgdy5jb25maWcueGF4aXMudG9vbHRpcC5vZmZzZXRZICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVkgKyAxICsgdy5jb25maWcueGF4aXMub2Zmc2V0WTtcbiAgICAgICAgdmFyIHhheGlzVFRUZXh0ID0gdHRDdHgueGF4aXNUb29sdGlwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgeGF4aXNUVFRleHRXaWR0aCA9IHhheGlzVFRUZXh0LndpZHRoO1xuICAgICAgICBjeCA9IGN4IC0geGF4aXNUVFRleHRXaWR0aCAvIDI7XG5cbiAgICAgICAgaWYgKCFpc05hTihjeCkpIHtcbiAgICAgICAgICBjeCA9IGN4ICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVg7XG4gICAgICAgICAgdmFyIHRleHRSZWN0ID0gMDtcbiAgICAgICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3ModGhpcy5jdHgpO1xuICAgICAgICAgIHRleHRSZWN0ID0gZ3JhcGhpY3MuZ2V0VGV4dFJlY3RzKHR0Q3R4LnhheGlzVG9vbHRpcFRleHQuaW5uZXJIVE1MKTtcbiAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXBUZXh0LnN0eWxlLm1pbldpZHRoID0gdGV4dFJlY3Qud2lkdGggKyAncHgnO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5zdHlsZS5sZWZ0ID0gY3ggKyAncHgnO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5zdHlsZS50b3AgPSBjeSArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVlBeGlzVG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlWUF4aXNUb29sdGlwKGluZGV4KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG5cbiAgICAgIGlmICh0dEN0eC55YXhpc1RURWxzID09PSBudWxsKSB7XG4gICAgICAgIHR0Q3R4LnlheGlzVFRFbHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHljcm9zc2hhaXJzSGlkZGVuUmVjdFkxID0gcGFyc2VJbnQodHRDdHgueWNyb3NzaGFpcnNIaWRkZW4uZ2V0QXR0cmlidXRlKCd5MScpKTtcbiAgICAgIHZhciBjeSA9IHcuZ2xvYmFscy50cmFuc2xhdGVZICsgeWNyb3NzaGFpcnNIaWRkZW5SZWN0WTE7XG4gICAgICB2YXIgeUF4aXNUVFJlY3QgPSB0dEN0eC55YXhpc1RURWxzW2luZGV4XS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB5QXhpc1RUSGVpZ2h0ID0geUF4aXNUVFJlY3QuaGVpZ2h0O1xuICAgICAgdmFyIGN4ID0gdy5nbG9iYWxzLnRyYW5zbGF0ZVlBeGlzWFtpbmRleF0gLSAyO1xuXG4gICAgICBpZiAody5jb25maWcueWF4aXNbaW5kZXhdLm9wcG9zaXRlKSB7XG4gICAgICAgIGN4ID0gY3ggLSAyNjtcbiAgICAgIH1cblxuICAgICAgY3kgPSBjeSAtIHlBeGlzVFRIZWlnaHQgLyAyO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmlnbm9yZVlBeGlzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgdHRDdHgueWF4aXNUVEVsc1tpbmRleF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIHR0Q3R4LnlheGlzVFRFbHNbaW5kZXhdLnN0eWxlLnRvcCA9IGN5ICsgJ3B4JztcbiAgICAgICAgdHRDdHgueWF4aXNUVEVsc1tpbmRleF0uc3R5bGUubGVmdCA9IGN4ICsgdy5jb25maWcueWF4aXNbaW5kZXhdLnRvb2x0aXAub2Zmc2V0WCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0dEN0eC55YXhpc1RURWxzW2luZGV4XS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICoqIG1vdmVzIHRoZSB3aG9sZSB0b29sdGlwIGJ5IGNoYW5naW5nIHgsIHkgYXR0cnNcbiAgICAgKiBAbWVtYmVyb2YgUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2ludH0gLSBjeCA9IHBvaW50J3MgeCBwb3NpdGlvbiwgd2hlcmV2ZXIgcG9pbnQncyB4IGlzLCB5b3UgbmVlZCB0byBtb3ZlIHRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge2ludH0gLSBjeSA9IHBvaW50J3MgeSBwb3NpdGlvbiwgd2hlcmV2ZXIgcG9pbnQncyB5IGlzLCB5b3UgbmVlZCB0byBtb3ZlIHRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge2ludH0gLSByID0gcG9pbnQncyByYWRpdXNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUb29sdGlwKGN4LCBjeSkge1xuICAgICAgdmFyIHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgdG9vbHRpcEVsID0gdHRDdHguZ2V0RWxUb29sdGlwKCk7XG4gICAgICB2YXIgdG9vbHRpcFJlY3QgPSB0dEN0eC50b29sdGlwUmVjdDtcbiAgICAgIHZhciBwb2ludFIgPSByICE9PSBudWxsID8gcGFyc2VJbnQocikgOiAxO1xuICAgICAgdmFyIHggPSBwYXJzZUludChjeCkgKyBwb2ludFIgKyA1O1xuICAgICAgdmFyIHkgPSBwYXJzZUludChjeSkgKyBwb2ludFIgLyAyOyAvLyAtIHRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMlxuXG4gICAgICBpZiAoeCA+IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyKSB7XG4gICAgICAgIHggPSB4IC0gdG9vbHRpcFJlY3QudHRXaWR0aCAtIHBvaW50UiAtIDE1O1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA+IHcuZ2xvYmFscy5ncmlkV2lkdGggLSB0b29sdGlwUmVjdC50dFdpZHRoIC0gMTApIHtcbiAgICAgICAgeCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLSB0b29sdGlwUmVjdC50dFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IC0yMCkge1xuICAgICAgICB4ID0gLTIwO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcudG9vbHRpcC5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgdmFyIGVsR3JpZCA9IHR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHkgPSB0dEN0eC5lLmNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3AgLSB0b29sdGlwUmVjdC50dEhlaWdodCAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdQb3NpdGlvbnMgPSB0aGlzLnBvc2l0aW9uQ2hlY2tzKHRvb2x0aXBSZWN0LCB4LCB5KTtcbiAgICAgIHggPSBuZXdQb3NpdGlvbnMueDtcbiAgICAgIHkgPSBuZXdQb3NpdGlvbnMueTtcblxuICAgICAgaWYgKCFpc05hTih4KSkge1xuICAgICAgICB4ID0geCArIHcuZ2xvYmFscy50cmFuc2xhdGVYO1xuICAgICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICB0b29sdGlwRWwuc3R5bGUudG9wID0geSArICdweCc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc2l0aW9uQ2hlY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uQ2hlY2tzKHRvb2x0aXBSZWN0LCB4LCB5KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKHRvb2x0aXBSZWN0LnR0SGVpZ2h0ICsgeSA+IHcuZ2xvYmFscy5ncmlkSGVpZ2h0KSB7XG4gICAgICAgIHkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIHRvb2x0aXBSZWN0LnR0SGVpZ2h0ICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5IDwgMCkge1xuICAgICAgICB5ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZU1hcmtlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU1hcmtlcnMoaSwgaikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuXG4gICAgICBpZiAody5nbG9iYWxzLm1hcmtlcnMuc2l6ZVtpXSA+IDApIHtcbiAgICAgICAgdmFyIGFsbFBvaW50cyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIgLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KGksIFwiJ10gLmFwZXhjaGFydHMtbWFya2VyXCIpKTtcblxuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IGFsbFBvaW50cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgIGlmIChwYXJzZUludChhbGxQb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdyZWwnKSkgPT09IGopIHtcbiAgICAgICAgICAgIHR0Q3R4Lm1hcmtlci5yZXNldFBvaW50c1NpemUoKTtcbiAgICAgICAgICAgIHR0Q3R4Lm1hcmtlci5lbmxhcmdlQ3VycmVudFBvaW50KGosIGFsbFBvaW50c1twXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0dEN0eC5tYXJrZXIucmVzZXRQb2ludHNTaXplKCk7XG4gICAgICAgIHRoaXMubW92ZUR5bmFtaWNQb2ludE9uSG92ZXIoaiwgaSk7XG4gICAgICB9XG4gICAgfSAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgd2hlbiB5b3UgbmVlZCB0byBzaG93IG1hcmtlcnMvcG9pbnRzIG9ubHkgb24gaG92ZXIgLVxuICAgIC8vIERJRkZFUkVOVCBYIFZBTFVFUyBpbiBtdWx0aXBsZSBzZXJpZXNcblxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVEeW5hbWljUG9pbnRPbkhvdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVEeW5hbWljUG9pbnRPbkhvdmVyKGosIGNhcHR1cmVkU2VyaWVzKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgY3ggPSAwO1xuICAgICAgdmFyIGN5ID0gMDtcbiAgICAgIHZhciBwb2ludHNBcnIgPSB3Lmdsb2JhbHMucG9pbnRzQXJyYXk7XG4gICAgICB2YXIgaG92ZXJTaXplID0gdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplO1xuXG4gICAgICBpZiAoaG92ZXJTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaG92ZXJTaXplID0gdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZVtjYXB0dXJlZFNlcmllc10gKyB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLnNpemVPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGN4ID0gcG9pbnRzQXJyW2NhcHR1cmVkU2VyaWVzXVtqXVswXTtcbiAgICAgIGN5ID0gcG9pbnRzQXJyW2NhcHR1cmVkU2VyaWVzXVtqXVsxXSA/IHBvaW50c0FycltjYXB0dXJlZFNlcmllc11bal1bMV0gOiAwO1xuICAgICAgdmFyIHBvaW50ID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpyZWFsSW5kZXg9J1wiLmNvbmNhdChjYXB0dXJlZFNlcmllcywgXCInXSAuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyBjaXJjbGVcIikpO1xuICAgICAgcG9pbnQuc2V0QXR0cmlidXRlKCdyJywgaG92ZXJTaXplKTtcbiAgICAgIHBvaW50LnNldEF0dHJpYnV0ZSgnY3gnLCBjeCk7XG4gICAgICBwb2ludC5zZXRBdHRyaWJ1dGUoJ2N5JywgY3kpOyAvLyBwb2ludC5zdHlsZS5vcGFjaXR5ID0gdy5jb25maWcubWFya2Vycy5ob3Zlci5vcGFjaXR5XG5cbiAgICAgIHRoaXMubW92ZVhDcm9zc2hhaXJzKGN4KTtcblxuICAgICAgaWYgKCF0dEN0eC5maXhlZFRvb2x0aXApIHtcbiAgICAgICAgdGhpcy5tb3ZlVG9vbHRpcChjeCwgY3ksIGhvdmVyU2l6ZSk7XG4gICAgICB9XG4gICAgfSAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgd2hlbiB5b3UgbmVlZCB0byBzaG93IG1hcmtlcnMvcG9pbnRzIG9ubHkgb24gaG92ZXIgLVxuICAgIC8vIFNBTUUgWCBWQUxVRVMgaW4gbXVsdGlwbGUgc2VyaWVzXG5cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlRHluYW1pY1BvaW50c09uSG92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUR5bmFtaWNQb2ludHNPbkhvdmVyKGopIHtcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgdyA9IHR0Q3R4Lnc7XG4gICAgICB2YXIgY3ggPSAwO1xuICAgICAgdmFyIGN5ID0gMDtcbiAgICAgIHZhciBhY3RpdmVTZXJpZXMgPSAwO1xuICAgICAgdmFyIHBvaW50c0FyciA9IHcuZ2xvYmFscy5wb2ludHNBcnJheTtcbiAgICAgIHZhciBzZXJpZXMgPSBuZXcgU2VyaWVzKHRoaXMuY3R4KTtcbiAgICAgIGFjdGl2ZVNlcmllcyA9IHNlcmllcy5nZXRBY3RpdmVTZXJpZXNJbmRleCgpO1xuICAgICAgdmFyIGhvdmVyU2l6ZSA9IHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZTtcblxuICAgICAgaWYgKGhvdmVyU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhvdmVyU2l6ZSA9IHcuZ2xvYmFscy5tYXJrZXJzLnNpemVbYWN0aXZlU2VyaWVzXSArIHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZU9mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvaW50c0FyclthY3RpdmVTZXJpZXNdKSB7XG4gICAgICAgIGN4ID0gcG9pbnRzQXJyW2FjdGl2ZVNlcmllc11bal1bMF07XG4gICAgICAgIGN5ID0gcG9pbnRzQXJyW2FjdGl2ZVNlcmllc11bal1bMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludHMgPSBudWxsO1xuICAgICAgdmFyIGFsbFBvaW50cyA9IHR0Q3R4LmdldEFsbE1hcmtlcnMoKTtcblxuICAgICAgaWYgKGFsbFBvaW50cyAhPT0gbnVsbCkge1xuICAgICAgICBwb2ludHMgPSBhbGxQb2ludHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyBjaXJjbGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvaW50cyAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBvaW50cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgIHZhciBwb2ludEFyciA9IHBvaW50c0FycltwXTtcblxuICAgICAgICAgIGlmIChwb2ludEFyciAmJiBwb2ludEFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwY3kgPSBwb2ludHNBcnJbcF1bal1bMV07XG4gICAgICAgICAgICBwb2ludHNbcF0uc2V0QXR0cmlidXRlKCdjeCcsIGN4KTtcbiAgICAgICAgICAgIHZhciByZWFsSW5kZXggPSBwYXJzZUludChwb2ludHNbcF0ucGFyZW50Tm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKTtcblxuICAgICAgICAgICAgaWYgKHBjeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwb2ludHNbcmVhbEluZGV4XSAmJiBwb2ludHNbcmVhbEluZGV4XS5zZXRBdHRyaWJ1dGUoJ3InLCBob3ZlclNpemUpO1xuICAgICAgICAgICAgICBwb2ludHNbcmVhbEluZGV4XSAmJiBwb2ludHNbcmVhbEluZGV4XS5zZXRBdHRyaWJ1dGUoJ2N5JywgcGN5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvaW50c1tyZWFsSW5kZXhdICYmIHBvaW50c1tyZWFsSW5kZXhdLnNldEF0dHJpYnV0ZSgncicsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1vdmVYQ3Jvc3NoYWlycyhjeCk7XG5cbiAgICAgIGlmICghdHRDdHguZml4ZWRUb29sdGlwKSB7XG4gICAgICAgIHZhciB0Y3kgPSBjeSB8fCB3Lmdsb2JhbHMuZ3JpZEhlaWdodDtcbiAgICAgICAgdGhpcy5tb3ZlVG9vbHRpcChjeCwgdGN5LCBob3ZlclNpemUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlU3RpY2t5VG9vbHRpcE92ZXJCYXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVTdGlja3lUb29sdGlwT3ZlckJhcnMoaikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgdmFyIGpCYXIgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtYmFyLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXNbcmVsPScxJ10gcGF0aFtqPSdcIi5jb25jYXQoaiwgXCInXSwgLmFwZXhjaGFydHMtY2FuZGxlc3RpY2stc2VyaWVzIC5hcGV4Y2hhcnRzLXNlcmllc1tyZWw9JzEnXSBwYXRoW2o9J1wiKS5jb25jYXQoaiwgXCInXVwiKSk7XG4gICAgICB2YXIgYmN4ID0gakJhciA/IHBhcnNlRmxvYXQoakJhci5nZXRBdHRyaWJ1dGUoJ2N4JykpIDogMDtcbiAgICAgIHZhciBiY3kgPSAwO1xuICAgICAgdmFyIGJ3ID0gakJhciA/IHBhcnNlRmxvYXQoakJhci5nZXRBdHRyaWJ1dGUoJ2JhcldpZHRoJykpIDogMDtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5pc1hOdW1lcmljKSB7XG4gICAgICAgIGJjeCA9IGJjeCAtIGJ3IC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJjeCA9IHR0Q3R4LnhBeGlzVGlja3NQb3NpdGlvbnNbaiAtIDFdICsgdHRDdHguZGF0YVBvaW50c0RpdmlkZWRXaWR0aCAvIDI7XG5cbiAgICAgICAgaWYgKGlzTmFOKGJjeCkpIHtcbiAgICAgICAgICBiY3ggPSB0dEN0eC54QXhpc1RpY2tzUG9zaXRpb25zW2pdIC0gdHRDdHguZGF0YVBvaW50c0RpdmlkZWRXaWR0aCAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdG9vbHRpcCB3aWxsIG1vdmUgdmVydGljYWxseSBhbG9uZyB3aXRoIG1vdXNlIGFzIGl0IGlzIGEgc2hhcmVkIHRvb2x0aXBcblxuXG4gICAgICB2YXIgZWxHcmlkID0gdHRDdHguZ2V0RWxHcmlkKCk7XG4gICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBiY3kgPSB0dEN0eC5lLmNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3AgLSB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCAvIDI7XG4gICAgICB0aGlzLm1vdmVYQ3Jvc3NoYWlycyhiY3gpO1xuXG4gICAgICBpZiAoIXR0Q3R4LmZpeGVkVG9vbHRpcCkge1xuICAgICAgICB2YXIgdGN5ID0gYmN5IHx8IHcuZ2xvYmFscy5ncmlkSGVpZ2h0O1xuICAgICAgICB0aGlzLm1vdmVUb29sdGlwKGJjeCwgdGN5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9zaXRpb247XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBUb29sdGlwLk1hcmtlciBDbGFzcyB0byBkcmF3IHRleHRzIG9uIHRoZSB0b29sdGlwLlxuICpcbiAqIEBtb2R1bGUgVG9vbHRpcC5NYXJrZXJcbiAqKi9cblxudmFyIE1hcmtlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcmtlcih0b29sdGlwQ29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXJrZXIpO1xuXG4gICAgdGhpcy53ID0gdG9vbHRpcENvbnRleHQudztcbiAgICB0aGlzLnR0Q3R4ID0gdG9vbHRpcENvbnRleHQ7XG4gICAgdGhpcy5jdHggPSB0b29sdGlwQ29udGV4dC5jdHg7XG4gICAgdGhpcy50b29sdGlwUG9zaXRpb24gPSBuZXcgUG9zaXRpb24odG9vbHRpcENvbnRleHQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hcmtlciwgW3tcbiAgICBrZXk6IFwiZHJhd0R5bmFtaWNQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0R5bmFtaWNQb2ludHMoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgbWFya2VyID0gbmV3IE1hcmtlcnModGhpcy5jdHgpO1xuICAgICAgdmFyIGVsc1NlcmllcyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsc1Nlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSBwYXJzZUludChlbHNTZXJpZXNbaV0uZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKTtcbiAgICAgICAgdmFyIHBvaW50c01haW4gPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKFwiLmFwZXhjaGFydHMtc2VyaWVzW2RhdGFcXFxcOnJlYWxJbmRleD0nXCIuY29uY2F0KHNlcmllc0luZGV4LCBcIiddIC5hcGV4Y2hhcnRzLXNlcmllcy1tYXJrZXJzLXdyYXBcIikpO1xuXG4gICAgICAgIGlmIChwb2ludHNNYWluICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gaXQgY2FuIGJlIG51bGwgYXMgd2UgaGF2ZSB0b29sdGlwcyBpbiBkb251dC9iYXIgY2hhcnRzXG4gICAgICAgICAgdmFyIHBvaW50ID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBQb2ludENsYXNzZXMgPSBcImFwZXhjaGFydHMtbWFya2VyIHdcIi5jb25jYXQoKE1hdGgucmFuZG9tKCkgKyAxKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDQpKTtcblxuICAgICAgICAgIGlmICgody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2xpbmUnIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdhcmVhJykgJiYgIXcuZ2xvYmFscy5jb21ib0NoYXJ0cyAmJiAhdy5jb25maWcudG9vbHRpcC5pbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIFBvaW50Q2xhc3NlcyArPSAnIG5vLXBvaW50ZXItZXZlbnRzJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZWxQb2ludE9wdGlvbnMgPSBtYXJrZXIuZ2V0TWFya2VyQ29uZmlnKFBvaW50Q2xhc3Nlcywgc2VyaWVzSW5kZXgpO1xuICAgICAgICAgIHBvaW50ID0gZ3JhcGhpY3MuZHJhd01hcmtlcigwLCAwLCBlbFBvaW50T3B0aW9ucyk7XG4gICAgICAgICAgcG9pbnQubm9kZS5zZXRBdHRyaWJ1dGUoJ2RlZmF1bHQtbWFya2VyLXNpemUnLCAwKTtcbiAgICAgICAgICB2YXIgZWxQb2ludHNHID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHcuZ2xvYmFscy5TVkdOUywgJ2cnKTtcbiAgICAgICAgICBlbFBvaW50c0cuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycycpO1xuICAgICAgICAgIGVsUG9pbnRzRy5hcHBlbmRDaGlsZChwb2ludC5ub2RlKTtcbiAgICAgICAgICBwb2ludHNNYWluLmFwcGVuZENoaWxkKGVsUG9pbnRzRyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5sYXJnZUN1cnJlbnRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmxhcmdlQ3VycmVudFBvaW50KHJlbCwgcG9pbnQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSAhPT0gJ2J1YmJsZScpIHtcbiAgICAgICAgdGhpcy5uZXdQb2ludFNpemUocmVsLCBwb2ludCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeCA9IHBvaW50LmdldEF0dHJpYnV0ZSgnY3gnKTtcbiAgICAgIHZhciBjeSA9IHBvaW50LmdldEF0dHJpYnV0ZSgnY3knKTtcbiAgICAgIHRoaXMudG9vbHRpcFBvc2l0aW9uLm1vdmVYQ3Jvc3NoYWlycyhjeCk7XG5cbiAgICAgIGlmICghdGhpcy5maXhlZFRvb2x0aXApIHtcbiAgICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYWRhcicpIHtcbiAgICAgICAgICB2YXIgZWxHcmlkID0gdGhpcy50dEN0eC5nZXRFbEdyaWQoKTtcbiAgICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgY3ggPSB0aGlzLnR0Q3R4LmUuY2xpZW50WCAtIHNlcmllc0JvdW5kLmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvb2x0aXBQb3NpdGlvbi5tb3ZlVG9vbHRpcChjeCwgY3ksIHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVubGFyZ2VQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5sYXJnZVBvaW50cyhqKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgdmFyIGNvbCA9IGo7XG4gICAgICB2YXIgcG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzOm5vdCguYXBleGNoYXJ0cy1zZXJpZXMtY29sbGFwc2VkKSAuYXBleGNoYXJ0cy1tYXJrZXInKTtcbiAgICAgIHZhciBuZXdTaXplID0gdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBvaW50cy5sZW5ndGg7IHArKykge1xuICAgICAgICB2YXIgcmVsID0gcG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgncmVsJyk7XG4gICAgICAgIHZhciBpbmRleCA9IHBvaW50c1twXS5nZXRBdHRyaWJ1dGUoJ2luZGV4Jyk7XG5cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld1NpemUgPSB3Lmdsb2JhbHMubWFya2Vycy5zaXplW2luZGV4XSArIHcuY29uZmlnLm1hcmtlcnMuaG92ZXIuc2l6ZU9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2wgPT09IHBhcnNlSW50KHJlbCkpIHtcbiAgICAgICAgICBtZS5uZXdQb2ludFNpemUoY29sLCBwb2ludHNbcF0pO1xuICAgICAgICAgIHZhciBjeCA9IHBvaW50c1twXS5nZXRBdHRyaWJ1dGUoJ2N4Jyk7XG4gICAgICAgICAgdmFyIGN5ID0gcG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgnY3knKTtcbiAgICAgICAgICBtZS50b29sdGlwUG9zaXRpb24ubW92ZVhDcm9zc2hhaXJzKGN4KTtcblxuICAgICAgICAgIGlmICghdHRDdHguZml4ZWRUb29sdGlwKSB7XG4gICAgICAgICAgICBtZS50b29sdGlwUG9zaXRpb24ubW92ZVRvb2x0aXAoY3gsIGN5LCBuZXdTaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUub2xkUG9pbnRTaXplKHBvaW50c1twXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV3UG9pbnRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5ld1BvaW50U2l6ZShyZWwsIHBvaW50KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBuZXdTaXplID0gdy5jb25maWcubWFya2Vycy5ob3Zlci5zaXplO1xuICAgICAgdmFyIGVsUG9pbnQgPSBudWxsO1xuXG4gICAgICBpZiAocmVsID09PSAwKSB7XG4gICAgICAgIGVsUG9pbnQgPSBwb2ludC5wYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbFBvaW50ID0gcG9pbnQucGFyZW50Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGVsUG9pbnQuZ2V0QXR0cmlidXRlKCdpbmRleCcpKTtcblxuICAgICAgaWYgKG5ld1NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdTaXplID0gdy5nbG9iYWxzLm1hcmtlcnMuc2l6ZVtpbmRleF0gKyB3LmNvbmZpZy5tYXJrZXJzLmhvdmVyLnNpemVPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGVsUG9pbnQuc2V0QXR0cmlidXRlKCdyJywgbmV3U2l6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9sZFBvaW50U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbGRQb2ludFNpemUocG9pbnQpIHtcbiAgICAgIHZhciBzaXplID0gcGFyc2VJbnQocG9pbnQuZ2V0QXR0cmlidXRlKCdkZWZhdWx0LW1hcmtlci1zaXplJykpO1xuICAgICAgcG9pbnQuc2V0QXR0cmlidXRlKCdyJywgc2l6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0UG9pbnRzU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFBvaW50c1NpemUoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBwb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXM6bm90KC5hcGV4Y2hhcnRzLXNlcmllcy1jb2xsYXBzZWQpIC5hcGV4Y2hhcnRzLW1hcmtlcicpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBvaW50cy5sZW5ndGg7IHArKykge1xuICAgICAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KHBvaW50c1twXS5nZXRBdHRyaWJ1dGUoJ2RlZmF1bHQtbWFya2VyLXNpemUnKSk7XG5cbiAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKHNpemUpKSB7XG4gICAgICAgICAgcG9pbnRzW3BdLnNldEF0dHJpYnV0ZSgncicsIHNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50c1twXS5zZXRBdHRyaWJ1dGUoJ3InLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXJrZXI7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBUb29sdGlwLkludGVyc2VjdCBDbGFzcy5cbiAqXG4gKiBAbW9kdWxlIFRvb2x0aXAuSW50ZXJzZWN0XG4gKiovXG5cbnZhciBJbnRlcnNlY3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnRlcnNlY3QodG9vbHRpcENvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW50ZXJzZWN0KTtcblxuICAgIHRoaXMudyA9IHRvb2x0aXBDb250ZXh0Lnc7XG4gICAgdGhpcy50dEN0eCA9IHRvb2x0aXBDb250ZXh0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEludGVyc2VjdCwgW3tcbiAgICBrZXk6IFwiZ2V0QXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyKGUsIGF0dHIpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGUudGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUhlYXRUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUhlYXRUb29sdGlwKF9yZWYpIHtcbiAgICAgIHZhciBlID0gX3JlZi5lLFxuICAgICAgICAgIG9wdCA9IF9yZWYub3B0LFxuICAgICAgICAgIHggPSBfcmVmLngsXG4gICAgICAgICAgeSA9IF9yZWYueTtcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgdyA9IHRoaXMudztcblxuICAgICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1oZWF0bWFwLXJlY3QnKSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0QXR0cihlLCAnaScpO1xuICAgICAgICB2YXIgaiA9IHRoaXMuZ2V0QXR0cihlLCAnaicpO1xuICAgICAgICB2YXIgY3ggPSB0aGlzLmdldEF0dHIoZSwgJ2N4Jyk7XG4gICAgICAgIHZhciBjeSA9IHRoaXMuZ2V0QXR0cihlLCAnY3knKTtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRBdHRyKGUsICd3aWR0aCcpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRBdHRyKGUsICdoZWlnaHQnKTtcbiAgICAgICAgdHRDdHgudG9vbHRpcExhYmVscy5kcmF3U2VyaWVzVGV4dHMoe1xuICAgICAgICAgIHR0SXRlbXM6IG9wdC50dEl0ZW1zLFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgajogaixcbiAgICAgICAgICBzaGFyZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB4ID0gY3ggKyB0dEN0eC50b29sdGlwUmVjdC50dFdpZHRoIC8gMiArIHdpZHRoO1xuICAgICAgICB5ID0gY3kgKyB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCAvIDIgLSBoZWlnaHQgLyAyO1xuICAgICAgICB0dEN0eC50b29sdGlwUG9zaXRpb24ubW92ZVhDcm9zc2hhaXJzKGN4ICsgd2lkdGggLyAyKTtcblxuICAgICAgICBpZiAoeCA+IHcuZ2xvYmFscy5ncmlkV2lkdGggLyAyKSB7XG4gICAgICAgICAgeCA9IGN4IC0gdHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aCAvIDIgKyB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0dEN0eC53LmNvbmZpZy50b29sdGlwLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIHZhciBlbEdyaWQgPSB0dEN0eC5nZXRFbEdyaWQoKTtcbiAgICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHggPSB0dEN0eC5lLmNsaWVudFggLSBzZXJpZXNCb3VuZC5sZWZ0XG5cbiAgICAgICAgICB5ID0gdHRDdHguZS5jbGllbnRZIC0gc2VyaWVzQm91bmQudG9wICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVkgLyAyIC0gMTA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTWFya2VyVG9vbHRpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNYXJrZXJUb29sdGlwKF9yZWYyKSB7XG4gICAgICB2YXIgZSA9IF9yZWYyLmUsXG4gICAgICAgICAgb3B0ID0gX3JlZjIub3B0LFxuICAgICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICAgIHkgPSBfcmVmMi55O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4O1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgajtcblxuICAgICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1tYXJrZXInKSkge1xuICAgICAgICB2YXIgY3ggPSBwYXJzZUludChvcHQucGF0aHMuZ2V0QXR0cmlidXRlKCdjeCcpKTtcbiAgICAgICAgdmFyIGN5ID0gcGFyc2VJbnQob3B0LnBhdGhzLmdldEF0dHJpYnV0ZSgnY3knKSk7XG4gICAgICAgIHZhciB2YWwgPSBwYXJzZUZsb2F0KG9wdC5wYXRocy5nZXRBdHRyaWJ1dGUoJ3ZhbCcpKTtcbiAgICAgICAgaiA9IHBhcnNlSW50KG9wdC5wYXRocy5nZXRBdHRyaWJ1dGUoJ3JlbCcpKTtcbiAgICAgICAgaSA9IHBhcnNlSW50KG9wdC5wYXRocy5wYXJlbnROb2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSAtIDE7XG5cbiAgICAgICAgaWYgKHR0Q3R4LmludGVyc2VjdCkge1xuICAgICAgICAgIHZhciBlbCA9IFV0aWxzLmZpbmRBbmNlc3RvcihvcHQucGF0aHMsICdhcGV4Y2hhcnRzLXNlcmllcycpO1xuXG4gICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBpID0gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCdkYXRhOnJlYWxJbmRleCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0dEN0eC50b29sdGlwTGFiZWxzLmRyYXdTZXJpZXNUZXh0cyh7XG4gICAgICAgICAgdHRJdGVtczogb3B0LnR0SXRlbXMsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHNoYXJlZDogdHRDdHguaW50ZXJzZWN0ID8gZmFsc2UgOiB3LmNvbmZpZy50b29sdGlwLnNoYXJlZFxuICAgICAgICB9KTtcbiAgICAgICAgdHRDdHgubWFya2VyLmVubGFyZ2VDdXJyZW50UG9pbnQoaiwgb3B0LnBhdGhzKTtcbiAgICAgICAgeCA9IGN4O1xuICAgICAgICB5ID0gY3kgLSB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCAqIDEuNDtcblxuICAgICAgICBpZiAodHRDdHgudy5jb25maWcudG9vbHRpcC5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICB2YXIgZWxHcmlkID0gdHRDdHguZ2V0RWxHcmlkKCk7XG4gICAgICAgICAgdmFyIHNlcmllc0JvdW5kID0gZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHkgPSB0dEN0eC5lLmNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICAgIHkgPSBjeTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVCYXJUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUJhclRvb2x0aXAoX3JlZjMpIHtcbiAgICAgIHZhciBlID0gX3JlZjMuZSxcbiAgICAgICAgICBvcHQgPSBfcmVmMy5vcHQ7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgdG9vbHRpcEVsID0gdHRDdHguZ2V0RWxUb29sdGlwKCk7XG4gICAgICB2YXIgYnggPSAwO1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgdmFyIHkgPSAwOyAvLyBsZXQgYlcgPSAwXG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBzdHJva2VXaWR0aDtcbiAgICAgIHZhciBiYXJYWSA9IHRoaXMuZ2V0QmFyVG9vbHRpcFhZKHtcbiAgICAgICAgZTogZSxcbiAgICAgICAgb3B0OiBvcHRcbiAgICAgIH0pO1xuICAgICAgaSA9IGJhclhZLmk7XG4gICAgICB2YXIgYmFySGVpZ2h0ID0gYmFyWFkuYmFySGVpZ2h0O1xuICAgICAgdmFyIGogPSBiYXJYWS5qO1xuXG4gICAgICBpZiAodHRDdHguaXNCYXJIb3Jpem9udGFsICYmIHR0Q3R4Lmhhc0JhcnMoKSB8fCAhdy5jb25maWcudG9vbHRpcC5zaGFyZWQpIHtcbiAgICAgICAgeCA9IGJhclhZLng7XG4gICAgICAgIHkgPSBiYXJYWS55O1xuICAgICAgICBzdHJva2VXaWR0aCA9IEFycmF5LmlzQXJyYXkody5jb25maWcuc3Ryb2tlLndpZHRoKSA/IHcuY29uZmlnLnN0cm9rZS53aWR0aFtpXSA6IHcuY29uZmlnLnN0cm9rZS53aWR0aDsgLy8gYlcgPSBiYXJYWS5iYXJXaWR0aFxuXG4gICAgICAgIGJ4ID0geDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdy5nbG9iYWxzLmNvbWJvQ2hhcnRzICYmICF3LmNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICAgIGJ4ID0gYnggLyAyO1xuICAgICAgICB9XG4gICAgICB9IC8vIHkgaXMgTmFOLCBtYWtlIGl0IHRvdWNoIHRoZSBib3R0b20gb2YgZ3JpZCBhcmVhXG5cblxuICAgICAgaWYgKGlzTmFOKHkpKSB7XG4gICAgICAgIHkgPSB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQ7XG4gICAgICB9IC8vIHggZXhjZWVkcyBncmlkV2lkdGhcblxuXG4gICAgICBpZiAoeCArIHR0Q3R4LnRvb2x0aXBSZWN0LnR0V2lkdGggPiB3Lmdsb2JhbHMuZ3JpZFdpZHRoKSB7XG4gICAgICAgIHggPSB4IC0gdHRDdHgudG9vbHRpcFJlY3QudHRXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoeCA8IDApIHtcbiAgICAgICAgeCA9IHggKyB0dEN0eC50b29sdGlwUmVjdC50dFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAodHRDdHgudy5jb25maWcudG9vbHRpcC5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgdmFyIGVsR3JpZCA9IHR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHkgPSB0dEN0eC5lLmNsaWVudFkgLSBzZXJpZXNCb3VuZC50b3A7XG4gICAgICB9IC8vIGlmIHRvb2x0aXAgaXMgc3RpbGwgbnVsbCwgcXVlcnlTZWxlY3RvclxuXG5cbiAgICAgIGlmICh0dEN0eC50b29sdGlwID09PSBudWxsKSB7XG4gICAgICAgIHR0Q3R4LnRvb2x0aXAgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy10b29sdGlwJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdy5jb25maWcudG9vbHRpcC5zaGFyZWQpIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy5jb21ib0NoYXJ0c0hhc0JhcnMpIHtcbiAgICAgICAgICB0dEN0eC50b29sdGlwUG9zaXRpb24ubW92ZVhDcm9zc2hhaXJzKGJ4ICsgc3Ryb2tlV2lkdGggLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0dEN0eC50b29sdGlwUG9zaXRpb24ubW92ZVhDcm9zc2hhaXJzKGJ4KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBtb3ZlIHRvb2x0aXAgaGVyZVxuXG5cbiAgICAgIGlmICghdHRDdHguZml4ZWRUb29sdGlwICYmICghdy5jb25maWcudG9vbHRpcC5zaGFyZWQgfHwgdHRDdHguaXNCYXJIb3Jpem9udGFsICYmIHR0Q3R4Lmhhc0JhcnMoKSkpIHtcbiAgICAgICAgaWYgKGlzUmV2ZXJzZWQpIHtcbiAgICAgICAgICB4ID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAtIHg7XG4gICAgICAgIH1cblxuICAgICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyB3Lmdsb2JhbHMudHJhbnNsYXRlWCArICdweCc7XG4gICAgICAgIHZhciBzZXJpZXNJbmRleCA9IHBhcnNlSW50KG9wdC5wYXRocy5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSk7XG4gICAgICAgIHZhciBpc1JldmVyc2VkID0gdy5nbG9iYWxzLmlzTXVsdGlwbGVZQXhpcyA/IHcuY29uZmlnLnlheGlzW3Nlcmllc0luZGV4XS5yZXZlcnNlZCA6IHcuY29uZmlnLnlheGlzWzBdLnJldmVyc2VkO1xuXG4gICAgICAgIGlmIChpc1JldmVyc2VkICYmICEodHRDdHguaXNCYXJIb3Jpem9udGFsICYmIHR0Q3R4Lmhhc0JhcnMoKSkpIHtcbiAgICAgICAgICB5ID0geSArIGJhckhlaWdodCAtICh3Lmdsb2JhbHMuc2VyaWVzW2ldW2pdIDwgMCA/IGJhckhlaWdodCA6IDApICogMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCArIHkgPiB3Lmdsb2JhbHMuZ3JpZEhlaWdodCkge1xuICAgICAgICAgIHkgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0ICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVk7XG4gICAgICAgICAgdG9vbHRpcEVsLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvb2x0aXBFbC5zdHlsZS50b3AgPSB5ICsgdy5nbG9iYWxzLnRyYW5zbGF0ZVkgLSB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCAvIDIgKyAncHgnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJhclRvb2x0aXBYWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXJUb29sdGlwWFkoX3JlZjQpIHtcbiAgICAgIHZhciBlID0gX3JlZjQuZSxcbiAgICAgICAgICBvcHQgPSBfcmVmNC5vcHQ7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBqID0gbnVsbDtcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgeSA9IDA7XG4gICAgICB2YXIgYmFyV2lkdGggPSAwO1xuICAgICAgdmFyIGJhckhlaWdodCA9IDA7XG4gICAgICB2YXIgY2wgPSBlLnRhcmdldC5jbGFzc0xpc3Q7XG5cbiAgICAgIGlmIChjbC5jb250YWlucygnYXBleGNoYXJ0cy1iYXItYXJlYScpIHx8IGNsLmNvbnRhaW5zKCdhcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLWFyZWEnKSkge1xuICAgICAgICB2YXIgYmFyID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBiYXJSZWN0ID0gYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBvcHQuZWxHcmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgYmggPSBiYXJSZWN0LmhlaWdodDtcbiAgICAgICAgYmFySGVpZ2h0ID0gYmFyUmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciBidyA9IGJhclJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBjeCA9IHBhcnNlSW50KGJhci5nZXRBdHRyaWJ1dGUoJ2N4JykpO1xuICAgICAgICB2YXIgY3kgPSBwYXJzZUludChiYXIuZ2V0QXR0cmlidXRlKCdjeScpKTtcbiAgICAgICAgYmFyV2lkdGggPSBwYXJzZUZsb2F0KGJhci5nZXRBdHRyaWJ1dGUoJ2JhcldpZHRoJykpO1xuICAgICAgICB2YXIgY2xpZW50WCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WDtcbiAgICAgICAgaiA9IHBhcnNlSW50KGJhci5nZXRBdHRyaWJ1dGUoJ2onKSk7XG4gICAgICAgIGkgPSBwYXJzZUludChiYXIucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSAtIDE7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5jb21ib0NoYXJ0cykge1xuICAgICAgICAgIGkgPSBwYXJzZUludChiYXIucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGE6cmVhbEluZGV4JykpO1xuICAgICAgICB9IC8vIGlmICh3LmNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICAvLyB0aGlzIGNoZWNrIG5vdCBuZWVkZWQgIGF0IHRoZSBtb21lbnRcbiAgICAgICAgLy8gICBjb25zdCB5RGl2aXNvciA9IHcuZ2xvYmFscy5ncmlkSGVpZ2h0IC8gKHcuZ2xvYmFscy5zZXJpZXMubGVuZ3RoKVxuICAgICAgICAvLyAgIGNvbnN0IGhvdmVyWSA9IHR0Q3R4LmNsaWVudFkgLSB0dEN0eC5zZXJpZXNCb3VuZC50b3BcbiAgICAgICAgLy8gICBqID0gTWF0aC5jZWlsKGhvdmVyWSAvIHlEaXZpc29yKVxuICAgICAgICAvLyB9XG5cblxuICAgICAgICB0dEN0eC50b29sdGlwTGFiZWxzLmRyYXdTZXJpZXNUZXh0cyh7XG4gICAgICAgICAgdHRJdGVtczogb3B0LnR0SXRlbXMsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBqOiBqLFxuICAgICAgICAgIHNoYXJlZDogdHRDdHguc2hvd09uSW50ZXJzZWN0ID8gZmFsc2UgOiB3LmNvbmZpZy50b29sdGlwLnNoYXJlZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICBpZiAody5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHggPSBjbGllbnRYIC0gc2VyaWVzQm91bmQubGVmdCArIDE1O1xuICAgICAgICAgICAgeSA9IGN5IC0gdHRDdHguZGF0YVBvaW50c0RpdmlkZWRIZWlnaHQgKyBiaCAvIDIgLSB0dEN0eC50b29sdGlwUmVjdC50dEhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3Lmdsb2JhbHMuaXNYTnVtZXJpYykge1xuICAgICAgICAgICAgICB4ID0gY3ggLSBidyAvIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB4ID0gY3ggLSB0dEN0eC5kYXRhUG9pbnRzRGl2aWRlZFdpZHRoICsgYncgLyAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5ID0gZS5jbGllbnRZIC0gc2VyaWVzQm91bmQudG9wIC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyIC0gMTU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgeCA9IGN4O1xuXG4gICAgICAgICAgICBpZiAoeCA8IHR0Q3R4Lnh5UmF0aW9zLmJhc2VMaW5lSW52ZXJ0ZWRZKSB7XG4gICAgICAgICAgICAgIHggPSBjeCAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0V2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHkgPSBjeSAtIHR0Q3R4LmRhdGFQb2ludHNEaXZpZGVkSGVpZ2h0ICsgYmggLyAyIC0gdHRDdHgudG9vbHRpcFJlY3QudHRIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBjb2x1bW5zXG4gICAgICAgICAgICBpZiAody5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAgICAgeCA9IGN4IC0gYncgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeCA9IGN4IC0gdHRDdHguZGF0YVBvaW50c0RpdmlkZWRXaWR0aCArIGJ3IC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeSA9IGN5OyAvLyAtIHR0Q3R4LnRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMiArIDEwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGJhckhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICBiYXJXaWR0aDogYmFyV2lkdGgsXG4gICAgICAgIGk6IGksXG4gICAgICAgIGo6IGpcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEludGVyc2VjdDtcbn0oKTtcblxuLyoqXG4gKiBBcGV4Q2hhcnRzIFRvb2x0aXAuQXhlc1Rvb2x0aXAgQ2xhc3MuXG4gKlxuICogQG1vZHVsZSBUb29sdGlwLkF4ZXNUb29sdGlwXG4gKiovXG52YXIgQXhlc1Rvb2x0aXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBeGVzVG9vbHRpcCh0b29sdGlwQ29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBeGVzVG9vbHRpcCk7XG5cbiAgICB0aGlzLncgPSB0b29sdGlwQ29udGV4dC53O1xuICAgIHRoaXMudHRDdHggPSB0b29sdGlwQ29udGV4dDtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWRkcyB0aGUgc2Vjb25kYXJ5IHRvb2x0aXAgd2hpY2ggYXBwZWFycyBiZWxvdyB4IGF4aXNcbiAgICogQG1lbWJlcm9mIFRvb2x0aXBcbiAgICoqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEF4ZXNUb29sdGlwLCBbe1xuICAgIGtleTogXCJkcmF3WGF4aXNUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdYYXhpc1Rvb2x0aXAoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB0dEN0eCA9IHRoaXMudHRDdHg7XG4gICAgICB2YXIgaXNCb3R0b20gPSB3LmNvbmZpZy54YXhpcy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gICAgICB0dEN0eC54YXhpc09mZlkgPSBpc0JvdHRvbSA/IHcuZ2xvYmFscy5ncmlkSGVpZ2h0ICsgMSA6IDE7XG4gICAgICB2YXIgdG9vbHRpcENzc0NsYXNzID0gaXNCb3R0b20gPyAnYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAgYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtYm90dG9tJyA6ICdhcGV4Y2hhcnRzLXhheGlzdG9vbHRpcCBhcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10b3AnO1xuICAgICAgdmFyIHJlbmRlclRvID0gdy5nbG9iYWxzLmRvbS5lbFdyYXA7XG5cbiAgICAgIGlmICh0dEN0eC5ibHhheGlzVG9vbHRpcCkge1xuICAgICAgICB2YXIgeGF4aXNUb29sdGlwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteGF4aXN0b29sdGlwJyk7XG5cbiAgICAgICAgaWYgKHhheGlzVG9vbHRpcCA9PT0gbnVsbCkge1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdG9vbHRpcENzc0NsYXNzKTtcbiAgICAgICAgICByZW5kZXJUby5hcHBlbmRDaGlsZCh0dEN0eC54YXhpc1Rvb2x0aXApO1xuICAgICAgICAgIHR0Q3R4LnhheGlzVG9vbHRpcFRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXBUZXh0LmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMteGF4aXN0b29sdGlwLXRleHQnKTtcbiAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXBUZXh0LnN0eWxlLmZvbnRGYW1pbHkgPSB3LmNvbmZpZy54YXhpcy50b29sdGlwLnN0eWxlLmZvbnRGYW1pbHkgfHwgdy5jb25maWcuY2hhcnQuZm9udEZhbWlseTtcbiAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXBUZXh0LnN0eWxlLmZvbnRTaXplID0gdy5jb25maWcueGF4aXMudG9vbHRpcC5zdHlsZS5mb250U2l6ZTtcbiAgICAgICAgICB0dEN0eC54YXhpc1Rvb2x0aXAuYXBwZW5kQ2hpbGQodHRDdHgueGF4aXNUb29sdGlwVGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYWRkcyB0aGUgc2Vjb25kYXJ5IHRvb2x0aXAgd2hpY2ggYXBwZWFycyBiZWxvdyB4IGF4aXNcbiAgICAgKiBAbWVtYmVyb2YgVG9vbHRpcFxuICAgICAqKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRyYXdZYXhpc1Rvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1lheGlzVG9vbHRpcCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3LmNvbmZpZy55YXhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXNSaWdodCA9IHcuY29uZmlnLnlheGlzW2ldLm9wcG9zaXRlIHx8IHcuY29uZmlnLnlheGlzW2ldLmNyb3NzaGFpcnMub3Bwb3NpdGU7XG4gICAgICAgIHR0Q3R4LnlheGlzT2ZmWCA9IGlzUmlnaHQgPyB3Lmdsb2JhbHMuZ3JpZFdpZHRoICsgMSA6IDE7XG4gICAgICAgIHZhciB0b29sdGlwQ3NzQ2xhc3MgPSBpc1JpZ2h0ID8gXCJhcGV4Y2hhcnRzLXlheGlzdG9vbHRpcCBhcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1cIi5jb25jYXQoaSwgXCIgYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtcmlnaHRcIikgOiBcImFwZXhjaGFydHMteWF4aXN0b29sdGlwIGFwZXhjaGFydHMteWF4aXN0b29sdGlwLVwiLmNvbmNhdChpLCBcIiBhcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1sZWZ0XCIpO1xuICAgICAgICB2YXIgcmVuZGVyVG8gPSB3Lmdsb2JhbHMuZG9tLmVsV3JhcDtcblxuICAgICAgICBpZiAodHRDdHguYmx5YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgICB2YXIgeWF4aXNUb29sdGlwID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcihcIi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcCBhcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1cIi5jb25jYXQoaSkpO1xuXG4gICAgICAgICAgaWYgKHlheGlzVG9vbHRpcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHRDdHgueWF4aXNUb29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0dEN0eC55YXhpc1Rvb2x0aXAuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRvb2x0aXBDc3NDbGFzcyk7XG4gICAgICAgICAgICByZW5kZXJUby5hcHBlbmRDaGlsZCh0dEN0eC55YXhpc1Rvb2x0aXApO1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHR0Q3R4LnlheGlzVG9vbHRpcFRleHQgPSBbXTtcbiAgICAgICAgICAgIHR0Q3R4LnlheGlzVG9vbHRpcFRleHQucHVzaChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgICAgICB0dEN0eC55YXhpc1Rvb2x0aXBUZXh0W2ldLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMteWF4aXN0b29sdGlwLXRleHQnKTtcbiAgICAgICAgICAgIHR0Q3R4LnlheGlzVG9vbHRpcC5hcHBlbmRDaGlsZCh0dEN0eC55YXhpc1Rvb2x0aXBUZXh0W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRvb2x0aXBcbiAgICAgKiovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRYQ3Jvc3NoYWlyV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WENyb3NzaGFpcldpZHRoKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4OyAvLyBzZXQgeGNyb3NzaGFpcnMgd2lkdGhcblxuICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdHRDdHguZ2V0RWxYQ3Jvc3NoYWlycygpO1xuICAgICAgdHRDdHgueGNyb3NzaGFpcnNXaWR0aCA9IHBhcnNlSW50KHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGgpO1xuXG4gICAgICBpZiAoIXcuZ2xvYmFscy5jb21ib0NoYXJ0cykge1xuICAgICAgICBpZiAody5jb25maWcueGF4aXMuY3Jvc3NoYWlycy53aWR0aCA9PT0gJ3RpY2tXaWR0aCcpIHtcbiAgICAgICAgICB2YXIgY291bnQgPSB3Lmdsb2JhbHMubGFiZWxzLmxlbmd0aDtcbiAgICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIGNvdW50O1xuICAgICAgICB9IGVsc2UgaWYgKHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggPT09ICdiYXJXaWR0aCcpIHtcbiAgICAgICAgICB2YXIgYmFyID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtYmFyLWFyZWEnKTtcblxuICAgICAgICAgIGlmIChiYXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBiYXJXaWR0aCA9IHBhcnNlRmxvYXQoYmFyLmdldEF0dHJpYnV0ZSgnYmFyV2lkdGgnKSk7XG4gICAgICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gYmFyV2lkdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9iYXIgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1iYXItYXJlYScpO1xuXG4gICAgICAgIGlmIChfYmFyICE9PSBudWxsICYmIHcuY29uZmlnLnhheGlzLmNyb3NzaGFpcnMud2lkdGggPT09ICdiYXJXaWR0aCcpIHtcbiAgICAgICAgICB2YXIgX2JhcldpZHRoID0gcGFyc2VGbG9hdChfYmFyLmdldEF0dHJpYnV0ZSgnYmFyV2lkdGgnKSk7XG5cbiAgICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gX2JhcldpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLndpZHRoID09PSAndGlja1dpZHRoJykge1xuICAgICAgICAgICAgdmFyIF9jb3VudCA9IHcuZ2xvYmFscy5sYWJlbHMubGVuZ3RoO1xuICAgICAgICAgICAgdHRDdHgueGNyb3NzaGFpcnNXaWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLyBfY291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlID09PSAnYmFyJyAmJiB3LmNvbmZpZy5wbG90T3B0aW9ucy5iYXIuaG9yaXpvbnRhbCkge1xuICAgICAgICB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHhjcm9zc2hhaXJzICE9PSBudWxsICYmIHR0Q3R4Lnhjcm9zc2hhaXJzV2lkdGggPiAwKSB7XG4gICAgICAgIHhjcm9zc2hhaXJzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0dEN0eC54Y3Jvc3NoYWlyc1dpZHRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlWUNyb3NzaGFpclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVZQ3Jvc3NoYWlyKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHRDdHggPSB0aGlzLnR0Q3R4OyAvLyBzZXQgeWNyb3NzaGFpcnMgaGVpZ2h0XG5cbiAgICAgIHR0Q3R4Lnljcm9zc2hhaXJzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteWNyb3NzaGFpcnMnKTtcbiAgICAgIHR0Q3R4Lnljcm9zc2hhaXJzSGlkZGVuID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMteWNyb3NzaGFpcnMtaGlkZGVuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdZYXhpc1Rvb2x0aXBUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdZYXhpc1Rvb2x0aXBUZXh0KGluZGV4LCBjbGllbnRZLCB4eVJhdGlvcykge1xuICAgICAgdmFyIHR0Q3R4ID0gdGhpcy50dEN0eDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGxiRm9ybWF0dGVyID0gdy5nbG9iYWxzLnlMYWJlbEZvcm1hdHRlcnNbaW5kZXhdO1xuXG4gICAgICBpZiAodHRDdHguYmx5YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgdmFyIGVsR3JpZCA9IHR0Q3R4LmdldEVsR3JpZCgpO1xuICAgICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBob3ZlclkgPSAoY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcCkgKiB4eVJhdGlvcy55UmF0aW9baW5kZXhdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdy5nbG9iYWxzLm1heFlBcnJbaW5kZXhdIC0gdy5nbG9iYWxzLm1pbllBcnJbaW5kZXhdO1xuICAgICAgICB2YXIgdmFsID0gdy5nbG9iYWxzLm1pbllBcnJbaW5kZXhdICsgKGhlaWdodCAtIGhvdmVyWSk7XG4gICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlWUNyb3NzaGFpcnMoY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcCk7XG4gICAgICAgIHR0Q3R4LnlheGlzVG9vbHRpcFRleHRbaW5kZXhdLmlubmVySFRNTCA9IGxiRm9ybWF0dGVyKHZhbCk7XG4gICAgICAgIHR0Q3R4LnRvb2x0aXBQb3NpdGlvbi5tb3ZlWUF4aXNUb29sdGlwKGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXhlc1Rvb2x0aXA7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBDb3JlIFRvb2x0aXAgQ2xhc3MgdG8gaGFuZGxlIHRoZSB0b29sdGlwIGdlbmVyYXRpb24uXG4gKlxuICogQG1vZHVsZSBUb29sdGlwXG4gKiovXG5cbnZhciBUb29sdGlwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9vbHRpcChjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgICB2YXIgdyA9IHRoaXMudztcbiAgICB0aGlzLnRvb2x0aXBVdGlsID0gbmV3IFV0aWxzJDEodGhpcyk7XG4gICAgdGhpcy50b29sdGlwTGFiZWxzID0gbmV3IExhYmVscyh0aGlzKTtcbiAgICB0aGlzLnRvb2x0aXBQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbih0aGlzKTtcbiAgICB0aGlzLm1hcmtlciA9IG5ldyBNYXJrZXIodGhpcyk7XG4gICAgdGhpcy5pbnRlcnNlY3QgPSBuZXcgSW50ZXJzZWN0KHRoaXMpO1xuICAgIHRoaXMuYXhlc1Rvb2x0aXAgPSBuZXcgQXhlc1Rvb2x0aXAodGhpcyk7XG4gICAgdGhpcy5zaG93T25JbnRlcnNlY3QgPSB3LmNvbmZpZy50b29sdGlwLmludGVyc2VjdDtcbiAgICB0aGlzLnNob3dUb29sdGlwVGl0bGUgPSB3LmNvbmZpZy50b29sdGlwLnguc2hvdztcbiAgICB0aGlzLmZpeGVkVG9vbHRpcCA9IHcuY29uZmlnLnRvb2x0aXAuZml4ZWQuZW5hYmxlZDtcbiAgICB0aGlzLnhheGlzVG9vbHRpcCA9IG51bGw7XG4gICAgdGhpcy55YXhpc1RURWxzID0gbnVsbDtcbiAgICB0aGlzLmlzQmFySG9yaXpvbnRhbCA9IHcuY29uZmlnLnBsb3RPcHRpb25zLmJhci5ob3Jpem9udGFsO1xuICAgIHRoaXMuaXNCYXJTaGFyZWQgPSAhdy5jb25maWcucGxvdE9wdGlvbnMuYmFyLmhvcml6b250YWwgJiYgdy5jb25maWcudG9vbHRpcC5zaGFyZWQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVG9vbHRpcCwgW3tcbiAgICBrZXk6IFwiZ2V0RWxUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsVG9vbHRpcChjdHgpIHtcbiAgICAgIGlmICghY3R4KSBjdHggPSB0aGlzO1xuICAgICAgcmV0dXJuIGN0eC53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy10b29sdGlwJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVsWENyb3NzaGFpcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxYQ3Jvc3NoYWlycygpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXhjcm9zc2hhaXJzJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVsR3JpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbEdyaWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1ncmlkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdUb29sdGlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdUb29sdGlwKHh5UmF0aW9zKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHRoaXMueHlSYXRpb3MgPSB4eVJhdGlvcztcbiAgICAgIHRoaXMuYmx4YXhpc1Rvb2x0aXAgPSB3LmNvbmZpZy54YXhpcy50b29sdGlwLmVuYWJsZWQgJiYgdy5nbG9iYWxzLmF4aXNDaGFydHM7XG4gICAgICB0aGlzLmJseWF4aXNUb29sdGlwID0gdy5jb25maWcueWF4aXNbMF0udG9vbHRpcC5lbmFibGVkICYmIHcuZ2xvYmFscy5heGlzQ2hhcnRzO1xuICAgICAgdGhpcy5hbGxUb29sdGlwU2VyaWVzR3JvdXBzID0gW107XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcFRpdGxlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b29sdGlwRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAnKTtcbiAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKHcuY29uZmlnLnRvb2x0aXAudGhlbWUpO1xuICAgICAgdy5nbG9iYWxzLmRvbS5lbFdyYXAuYXBwZW5kQ2hpbGQodG9vbHRpcEVsKTtcblxuICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgIHRoaXMuYXhlc1Rvb2x0aXAuZHJhd1hheGlzVG9vbHRpcCgpO1xuICAgICAgICB0aGlzLmF4ZXNUb29sdGlwLmRyYXdZYXhpc1Rvb2x0aXAoKTtcbiAgICAgICAgdGhpcy5heGVzVG9vbHRpcC5zZXRYQ3Jvc3NoYWlyV2lkdGgoKTtcbiAgICAgICAgdGhpcy5heGVzVG9vbHRpcC5oYW5kbGVZQ3Jvc3NoYWlyKCk7XG4gICAgICAgIHZhciB4QXhpcyA9IG5ldyBYQXhpcyh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMueEF4aXNUaWNrc1Bvc2l0aW9ucyA9IHhBeGlzLmdldFhBeGlzVGlja3NQb3NpdGlvbnMoKTtcbiAgICAgIH0gLy8gd2UgZm9yY2VmdWxseSBzZXQgaW50ZXJzZWN0IHRydWUgZm9yIHRoZXNlIGNvbmRpdGlvbnNcblxuXG4gICAgICBpZiAody5nbG9iYWxzLmNvbWJvQ2hhcnRzICYmICF3LmNvbmZpZy50b29sdGlwLnNoYXJlZCB8fCB3LmNvbmZpZy50b29sdGlwLmludGVyc2VjdCAmJiAhdy5jb25maWcudG9vbHRpcC5zaGFyZWQgfHwgdy5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgJiYgIXcuY29uZmlnLnRvb2x0aXAuc2hhcmVkKSB7XG4gICAgICAgIHRoaXMuc2hvd09uSW50ZXJzZWN0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuY29uZmlnLm1hcmtlcnMuc2l6ZSA9PT0gMCB8fCB3Lmdsb2JhbHMubWFya2Vycy5sYXJnZXN0U2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyB3aGVuIHVzZXIgZG9uJ3Qgd2FudCB0byBzaG93IHBvaW50cyBhbGwgdGhlIHRpbWUsIGJ1dCBvbmx5IG9uIHdoZW4gaG92ZXJpbmcgb24gc2VyaWVzXG4gICAgICAgIHRoaXMubWFya2VyLmRyYXdEeW5hbWljUG9pbnRzKHRoaXMpO1xuICAgICAgfSAvLyBubyB2aXNpYmxlIHNlcmllcywgZXhpdFxuXG5cbiAgICAgIGlmICh3Lmdsb2JhbHMuY29sbGFwc2VkU2VyaWVzLmxlbmd0aCA9PT0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGgpIHJldHVybjtcbiAgICAgIHRoaXMuZGF0YVBvaW50c0RpdmlkZWRIZWlnaHQgPSB3Lmdsb2JhbHMuZ3JpZEhlaWdodCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuICAgICAgdGhpcy5kYXRhUG9pbnRzRGl2aWRlZFdpZHRoID0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIHcuZ2xvYmFscy5kYXRhUG9pbnRzO1xuXG4gICAgICBpZiAodGhpcy5zaG93VG9vbHRpcFRpdGxlKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudG9vbHRpcFRpdGxlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC10aXRsZScpO1xuICAgICAgICB0aGlzLnRvb2x0aXBUaXRsZS5zdHlsZS5mb250RmFtaWx5ID0gdy5jb25maWcudG9vbHRpcC5zdHlsZS5mb250RmFtaWx5IHx8IHcuY29uZmlnLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgIHRoaXMudG9vbHRpcFRpdGxlLnN0eWxlLmZvbnRTaXplID0gdy5jb25maWcudG9vbHRpcC5zdHlsZS5mb250U2l6ZTtcbiAgICAgICAgdG9vbHRpcEVsLmFwcGVuZENoaWxkKHRoaXMudG9vbHRpcFRpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR0SXRlbXNDbnQgPSB3Lmdsb2JhbHMuc2VyaWVzLmxlbmd0aDsgLy8gd2hldGhlciBzaGFyZWQgb3Igbm90LCBkZWZhdWx0IGlzIHNoYXJlZFxuXG4gICAgICBpZiAoKHcuZ2xvYmFscy54eUNoYXJ0cyB8fCB3Lmdsb2JhbHMuY29tYm9DaGFydHMpICYmIHcuY29uZmlnLnRvb2x0aXAuc2hhcmVkKSB7XG4gICAgICAgIGlmICghdGhpcy5zaG93T25JbnRlcnNlY3QpIHtcbiAgICAgICAgICB0dEl0ZW1zQ250ID0gdy5nbG9iYWxzLnNlcmllcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHRJdGVtc0NudCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50dEl0ZW1zID0gdGhpcy5jcmVhdGVUVEVsZW1lbnRzKHR0SXRlbXNDbnQpO1xuICAgICAgdGhpcy5hZGRTVkdFdmVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVFRFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUVEVsZW1lbnRzKHR0SXRlbXNDbnQpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR0SXRlbXMgPSBbXTtcbiAgICAgIHZhciB0b29sdGlwRWwgPSB0aGlzLmdldEVsVG9vbHRpcCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR0SXRlbXNDbnQ7IGkrKykge1xuICAgICAgICB2YXIgZ1R4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBnVHh0LmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAnKTtcbiAgICAgICAgdmFyIHBvaW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBwb2ludC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAtbWFya2VyJyk7XG4gICAgICAgIHBvaW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHcuZ2xvYmFscy5jb2xvcnNbaV07XG4gICAgICAgIGdUeHQuYXBwZW5kQ2hpbGQocG9pbnQpO1xuICAgICAgICB2YXIgZ1laID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGdZWi5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dCcpO1xuICAgICAgICBnWVouc3R5bGUuZm9udEZhbWlseSA9IHcuY29uZmlnLnRvb2x0aXAuc3R5bGUuZm9udEZhbWlseSB8fCB3LmNvbmZpZy5jaGFydC5mb250RmFtaWx5O1xuICAgICAgICBnWVouc3R5bGUuZm9udFNpemUgPSB3LmNvbmZpZy50b29sdGlwLnN0eWxlLmZvbnRTaXplOyAvLyB5IHZhbHVlcyBncm91cFxuXG4gICAgICAgIHZhciBnWVZhbFRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZ1lWYWxUZXh0LmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC15LWdyb3VwJyk7XG4gICAgICAgIHZhciB0eHRMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgdHh0TGFiZWwuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwLXRleHQtbGFiZWwnKTtcbiAgICAgICAgZ1lWYWxUZXh0LmFwcGVuZENoaWxkKHR4dExhYmVsKTtcbiAgICAgICAgdmFyIHR4dFZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICB0eHRWYWx1ZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC12YWx1ZScpO1xuICAgICAgICBnWVZhbFRleHQuYXBwZW5kQ2hpbGQodHh0VmFsdWUpOyAvLyB6IHZhbHVlcyBncm91cFxuXG4gICAgICAgIHZhciBnWlZhbFRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZ1pWYWxUZXh0LmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtdG9vbHRpcC16LWdyb3VwJyk7XG4gICAgICAgIHZhciB0eHRaTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHR4dFpMYWJlbC5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LWxhYmVsJyk7XG4gICAgICAgIGdaVmFsVGV4dC5hcHBlbmRDaGlsZCh0eHRaTGFiZWwpO1xuICAgICAgICB2YXIgdHh0WlZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICB0eHRaVmFsdWUuY2xhc3NMaXN0LmFkZCgnYXBleGNoYXJ0cy10b29sdGlwLXRleHQtei12YWx1ZScpO1xuICAgICAgICBnWlZhbFRleHQuYXBwZW5kQ2hpbGQodHh0WlZhbHVlKTtcbiAgICAgICAgZ1laLmFwcGVuZENoaWxkKGdZVmFsVGV4dCk7XG4gICAgICAgIGdZWi5hcHBlbmRDaGlsZChnWlZhbFRleHQpO1xuICAgICAgICBnVHh0LmFwcGVuZENoaWxkKGdZWik7XG4gICAgICAgIHRvb2x0aXBFbC5hcHBlbmRDaGlsZChnVHh0KTtcbiAgICAgICAgdHRJdGVtcy5wdXNoKGdUeHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHRJdGVtcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU1ZHRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNWR0V2ZW50cygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHR5cGUgPSB3LmNvbmZpZy5jaGFydC50eXBlO1xuICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMuZ2V0RWxUb29sdGlwKCk7XG4gICAgICB2YXIgYmFyT3JDYW5kbGVzdGljayA9ICEhKHR5cGUgPT09ICdiYXInIHx8IHR5cGUgPT09ICdjYW5kbGVzdGljaycpO1xuICAgICAgdmFyIGhvdmVyQXJlYSA9IHcuZ2xvYmFscy5kb20uUGFwZXIubm9kZTtcbiAgICAgIHZhciBlbEdyaWQgPSB0aGlzLmdldEVsR3JpZCgpO1xuXG4gICAgICBpZiAoZWxHcmlkKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzQm91bmQgPSBlbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b29sdGlwWSA9IFtdO1xuICAgICAgdmFyIHRvb2x0aXBYID0gW107XG4gICAgICB2YXIgc2VyaWVzSG92ZXJQYXJhbXMgPSB7XG4gICAgICAgIGhvdmVyQXJlYTogaG92ZXJBcmVhLFxuICAgICAgICBlbEdyaWQ6IGVsR3JpZCxcbiAgICAgICAgdG9vbHRpcEVsOiB0b29sdGlwRWwsXG4gICAgICAgIHRvb2x0aXBZOiB0b29sdGlwWSxcbiAgICAgICAgdG9vbHRpcFg6IHRvb2x0aXBYLFxuICAgICAgICB0dEl0ZW1zOiB0aGlzLnR0SXRlbXNcbiAgICAgIH07XG4gICAgICB2YXIgcG9pbnRzO1xuXG4gICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhcmVhJyB8fCB0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXInIHx8IHR5cGUgPT09ICdidWJibGUnKSB7XG4gICAgICAgICAgcG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbChcIi5hcGV4Y2hhcnRzLXNlcmllc1tkYXRhXFxcXDpsb25nZXN0U2VyaWVzPSd0cnVlJ10gLmFwZXhjaGFydHMtbWFya2VyXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGJhck9yQ2FuZGxlc3RpY2spIHtcbiAgICAgICAgICBwb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXMgLmFwZXhjaGFydHMtYmFyLWFyZWEnLCAnLmFwZXhjaGFydHMtc2VyaWVzIC5hcGV4Y2hhcnRzLWNhbmRsZXN0aWNrLWFyZWEnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaGVhdG1hcCcpIHtcbiAgICAgICAgICBwb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXMgLmFwZXhjaGFydHMtaGVhdG1hcCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyYWRhcicpIHtcbiAgICAgICAgICBwb2ludHMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXMgLmFwZXhjaGFydHMtbWFya2VyJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBvaW50cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgdG9vbHRpcFkucHVzaChwb2ludHNbcF0uZ2V0QXR0cmlidXRlKCdjeScpKTtcbiAgICAgICAgICAgIHRvb2x0aXBYLnB1c2gocG9pbnRzW3BdLmdldEF0dHJpYnV0ZSgnY3gnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWxpZFNoYXJlZENoYXJ0VHlwZXMgPSB3Lmdsb2JhbHMueHlDaGFydHMgJiYgIXRoaXMuc2hvd09uSW50ZXJzZWN0IHx8IHcuZ2xvYmFscy5jb21ib0NoYXJ0cyAmJiAhdGhpcy5zaG93T25JbnRlcnNlY3QgfHwgYmFyT3JDYW5kbGVzdGljayAmJiB0aGlzLmhhc0JhcnMoKSAmJiB3LmNvbmZpZy50b29sdGlwLnNoYXJlZDtcblxuICAgICAgaWYgKHZhbGlkU2hhcmVkQ2hhcnRUeXBlcykge1xuICAgICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMoW2hvdmVyQXJlYV0sIHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoYmFyT3JDYW5kbGVzdGljayAmJiAhdy5nbG9iYWxzLmNvbWJvQ2hhcnRzKSB7XG4gICAgICAgIHRoaXMuYWRkQmFyc0V2ZW50TGlzdGVuZXJzKHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2J1YmJsZScgfHwgdHlwZSA9PT0gJ3NjYXR0ZXInIHx8IHR5cGUgPT09ICdyYWRhcicgfHwgdGhpcy5zaG93T25JbnRlcnNlY3QgJiYgKHR5cGUgPT09ICdhcmVhJyB8fCB0eXBlID09PSAnbGluZScpKSB7XG4gICAgICAgIHRoaXMuYWRkUG9pbnRzRXZlbnRzTGlzdGVuZXJzKHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoIXcuZ2xvYmFscy5heGlzQ2hhcnRzIHx8IHR5cGUgPT09ICdoZWF0bWFwJykge1xuICAgICAgICB2YXIgc2VyaWVzQWxsID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzJyk7XG4gICAgICAgIHRoaXMuYWRkUGF0aHNFdmVudExpc3RlbmVycyhzZXJpZXNBbGwsIHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd09uSW50ZXJzZWN0KSB7XG4gICAgICAgIHZhciBsaW5lUG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtbGluZS1zZXJpZXMgLmFwZXhjaGFydHMtbWFya2VyJyk7XG5cbiAgICAgICAgaWYgKGxpbmVQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGlmIHdlIGZpbmQgYW55IGxpbmVTZXJpZXMsIGFkZEV2ZW50TGlzdGVuZXJzIGZvciB0aGVtXG4gICAgICAgICAgdGhpcy5hZGRQYXRoc0V2ZW50TGlzdGVuZXJzKGxpbmVQb2ludHMsIHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmVhUG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtYXJlYS1zZXJpZXMgLmFwZXhjaGFydHMtbWFya2VyJyk7XG5cbiAgICAgICAgaWYgKGFyZWFQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGlmIHdlIGZpbmQgYW55IGFyZWFTZXJpZXMsIGFkZEV2ZW50TGlzdGVuZXJzIGZvciB0aGVtXG4gICAgICAgICAgdGhpcy5hZGRQYXRoc0V2ZW50TGlzdGVuZXJzKGFyZWFQb2ludHMsIHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICAgICAgfSAvLyBjb21ibyBjaGFydHMgbWF5IGhhdmUgYmFycywgc28gYWRkIGV2ZW50IGxpc3RlbmVycyBoZXJlIHRvb1xuXG5cbiAgICAgICAgaWYgKHRoaXMuaGFzQmFycygpICYmICF3LmNvbmZpZy50b29sdGlwLnNoYXJlZCkge1xuICAgICAgICAgIHRoaXMuYWRkQmFyc0V2ZW50TGlzdGVuZXJzKHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Rml4ZWRUb29sdGlwUmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Rml4ZWRUb29sdGlwUmVjdCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHRvb2x0aXBFbCA9IHRoaXMuZ2V0RWxUb29sdGlwKCk7XG4gICAgICB2YXIgdG9vbHRpcFJlY3QgPSB0b29sdGlwRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgdHRXaWR0aCA9IHRvb2x0aXBSZWN0LndpZHRoICsgMTA7XG4gICAgICB2YXIgdHRIZWlnaHQgPSB0b29sdGlwUmVjdC5oZWlnaHQgKyAxMDtcbiAgICAgIHZhciB4ID0gdy5jb25maWcudG9vbHRpcC5maXhlZC5vZmZzZXRYO1xuICAgICAgdmFyIHkgPSB3LmNvbmZpZy50b29sdGlwLmZpeGVkLm9mZnNldFk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy50b29sdGlwLmZpeGVkLnBvc2l0aW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncmlnaHQnKSA+IC0xKSB7XG4gICAgICAgIHggPSB4ICsgdy5nbG9iYWxzLnN2Z1dpZHRoIC0gdHRXaWR0aCArIDEwO1xuICAgICAgfVxuXG4gICAgICBpZiAody5jb25maWcudG9vbHRpcC5maXhlZC5wb3NpdGlvbi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2JvdHRvbScpID4gLTEpIHtcbiAgICAgICAgeSA9IHkgKyB3Lmdsb2JhbHMuc3ZnSGVpZ2h0IC0gdHRIZWlnaHQgLSAxMDtcbiAgICAgIH1cblxuICAgICAgdG9vbHRpcEVsLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcbiAgICAgIHRvb2x0aXBFbC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHR0V2lkdGg6IHR0V2lkdGgsXG4gICAgICAgIHR0SGVpZ2h0OiB0dEhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUG9pbnRzRXZlbnRzTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBvaW50c0V2ZW50c0xpc3RlbmVycyhzZXJpZXNIb3ZlclBhcmFtcykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgcG9pbnRzID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvckFsbCgnLmFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMgLmFwZXhjaGFydHMtbWFya2VyJyk7XG4gICAgICB0aGlzLmFkZFBhdGhzRXZlbnRMaXN0ZW5lcnMocG9pbnRzLCBzZXJpZXNIb3ZlclBhcmFtcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEJhcnNFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRCYXJzRXZlbnRMaXN0ZW5lcnMoc2VyaWVzSG92ZXJQYXJhbXMpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGJhcnMgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1iYXItYXJlYSwgLmFwZXhjaGFydHMtY2FuZGxlc3RpY2stYXJlYScpO1xuICAgICAgdGhpcy5hZGRQYXRoc0V2ZW50TGlzdGVuZXJzKGJhcnMsIHNlcmllc0hvdmVyUGFyYW1zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUGF0aHNFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQYXRoc0V2ZW50TGlzdGVuZXJzKHBhdGhzLCBvcHRzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHApIHtcbiAgICAgICAgdmFyIGV4dGVuZGVkT3B0cyA9IHtcbiAgICAgICAgICBwYXRoczogcGF0aHNbcF0sXG4gICAgICAgICAgdG9vbHRpcEVsOiBvcHRzLnRvb2x0aXBFbCxcbiAgICAgICAgICB0b29sdGlwWTogb3B0cy50b29sdGlwWSxcbiAgICAgICAgICB0b29sdGlwWDogb3B0cy50b29sdGlwWCxcbiAgICAgICAgICBlbEdyaWQ6IG9wdHMuZWxHcmlkLFxuICAgICAgICAgIGhvdmVyQXJlYTogb3B0cy5ob3ZlckFyZWEsXG4gICAgICAgICAgdHRJdGVtczogb3B0cy50dEl0ZW1zXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLncuZ2xvYmFscy50b29sdGlwT3B0cyA9IGV4dGVuZGVkT3B0cztcbiAgICAgICAgdmFyIGV2ZW50cyA9IFsnbW91c2Vtb3ZlJywgJ3RvdWNobW92ZScsICdtb3VzZW91dCcsICd0b3VjaGVuZCddO1xuICAgICAgICBldmVudHMubWFwKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIHJldHVybiBwYXRoc1twXS5hZGRFdmVudExpc3RlbmVyKGV2LCBzZWxmLnNlcmllc0hvdmVyLmJpbmQoc2VsZiwgZXh0ZW5kZWRPcHRzKSwge1xuICAgICAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYXRocy5sZW5ndGg7IHArKykge1xuICAgICAgICBfbG9vcChwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgKiogVGhlIGFjdHVhbCBzZXJpZXMgaG92ZXIgZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlcmllc0hvdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmllc0hvdmVyKG9wdCwgZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGFydEdyb3VwcyA9IFtdO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7IC8vIGlmIHVzZXIgaGFzIG1vcmUgdGhhbiBvbmUgY2hhcnRzIGluIGdyb3VwLCB3ZSBuZWVkIHRvIHN5bmNcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0Lmdyb3VwKSB7XG4gICAgICAgIGNoYXJ0R3JvdXBzID0gdGhpcy5jdHguZ2V0R3JvdXBlZENoYXJ0cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMgJiYgKHcuZ2xvYmFscy5taW5YID09PSAtSW5maW5pdHkgJiYgdy5nbG9iYWxzLm1heFggPT09IEluZmluaXR5IHx8IHcuZ2xvYmFscy5kYXRhUG9pbnRzID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFydEdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgY2hhcnRHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgICB2YXIgdG9vbHRpcEVsID0gX3RoaXMyLmdldEVsVG9vbHRpcChjaCk7XG5cbiAgICAgICAgICB2YXIgbmV3T3B0cyA9IHtcbiAgICAgICAgICAgIHBhdGhzOiBvcHQucGF0aHMsXG4gICAgICAgICAgICB0b29sdGlwRWw6IHRvb2x0aXBFbCxcbiAgICAgICAgICAgIHRvb2x0aXBZOiBvcHQudG9vbHRpcFksXG4gICAgICAgICAgICB0b29sdGlwWDogb3B0LnRvb2x0aXBYLFxuICAgICAgICAgICAgZWxHcmlkOiBvcHQuZWxHcmlkLFxuICAgICAgICAgICAgaG92ZXJBcmVhOiBvcHQuaG92ZXJBcmVhLFxuICAgICAgICAgICAgdHRJdGVtczogY2gudy5nbG9iYWxzLnRvb2x0aXAudHRJdGVtcyAvLyBhbGwgdGhlIGNoYXJ0cyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBtaW5YIGFuZCBtYXhYIChzYW1lIHhheGlzKSBmb3IgbXVsdGlwbGUgdG9vbHRpcHMgdG8gd29yayBjb3JyZWN0bHlcblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoY2gudy5nbG9iYWxzLm1pblggPT09IF90aGlzMi53Lmdsb2JhbHMubWluWCAmJiBjaC53Lmdsb2JhbHMubWF4WCA9PT0gX3RoaXMyLncuZ2xvYmFscy5tYXhYKSB7XG4gICAgICAgICAgICBjaC53Lmdsb2JhbHMudG9vbHRpcC5zZXJpZXNIb3ZlckJ5Q29udGV4dCh7XG4gICAgICAgICAgICAgIGNoYXJ0Q3R4OiBjaCxcbiAgICAgICAgICAgICAgdHRDdHg6IGNoLncuZ2xvYmFscy50b29sdGlwLFxuICAgICAgICAgICAgICBvcHQ6IG5ld09wdHMsXG4gICAgICAgICAgICAgIGU6IGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlcmllc0hvdmVyQnlDb250ZXh0KHtcbiAgICAgICAgICBjaGFydEN0eDogdGhpcy5jdHgsXG4gICAgICAgICAgdHRDdHg6IHRoaXMudy5nbG9iYWxzLnRvb2x0aXAsXG4gICAgICAgICAgb3B0OiBvcHQsXG4gICAgICAgICAgZTogZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWVzSG92ZXJCeUNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWVzSG92ZXJCeUNvbnRleHQoX3JlZikge1xuICAgICAgdmFyIGNoYXJ0Q3R4ID0gX3JlZi5jaGFydEN0eCxcbiAgICAgICAgICB0dEN0eCA9IF9yZWYudHRDdHgsXG4gICAgICAgICAgb3B0ID0gX3JlZi5vcHQsXG4gICAgICAgICAgZSA9IF9yZWYuZTtcbiAgICAgIHZhciB3ID0gY2hhcnRDdHgudztcbiAgICAgIHZhciB0b29sdGlwRWwgPSB0aGlzLmdldEVsVG9vbHRpcCgpOyAvLyB0b29sdGlwUmVjdCBpcyBjYWxjdWxhdGVkIG9uIGV2ZXJ5IG1vdXNlbW92ZSwgYmVjYXVzZSB0aGUgdGV4dCBpcyBkeW5hbWljXG5cbiAgICAgIHR0Q3R4LnRvb2x0aXBSZWN0ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB0dFdpZHRoOiB0b29sdGlwRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsXG4gICAgICAgIHR0SGVpZ2h0OiB0b29sdGlwRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgdHRDdHguZSA9IGU7IC8vIGhpZ2hsaWdodCB0aGUgY3VycmVudCBob3ZlcmVkIGJhcnNcblxuICAgICAgaWYgKHR0Q3R4Lmhhc0JhcnMoKSAmJiAhdy5nbG9iYWxzLmNvbWJvQ2hhcnRzICYmICF0dEN0eC5pc0JhclNoYXJlZCkge1xuICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC5vbkRhdGFzZXRIb3Zlci5oaWdobGlnaHREYXRhU2VyaWVzKSB7XG4gICAgICAgICAgdmFyIHNlcmllcyA9IG5ldyBTZXJpZXMoY2hhcnRDdHgpO1xuICAgICAgICAgIHNlcmllcy50b2dnbGVTZXJpZXNPbkhvdmVyKGUsIGUudGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0dEN0eC5maXhlZFRvb2x0aXApIHtcbiAgICAgICAgdHRDdHguZHJhd0ZpeGVkVG9vbHRpcFJlY3QoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcuZ2xvYmFscy5heGlzQ2hhcnRzKSB7XG4gICAgICAgIHR0Q3R4LmF4aXNDaGFydHNUb29sdGlwcyh7XG4gICAgICAgICAgZTogZSxcbiAgICAgICAgICBvcHQ6IG9wdCxcbiAgICAgICAgICB0b29sdGlwUmVjdDogdHRDdHgudG9vbHRpcFJlY3RcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub24tcGxvdCBjaGFydHMgaS5lIHBpZS9kb251dC9jaXJjbGVcbiAgICAgICAgdHRDdHgubm9uQXhpc0NoYXJ0c1Rvb2x0aXBzKHtcbiAgICAgICAgICBlOiBlLFxuICAgICAgICAgIG9wdDogb3B0LFxuICAgICAgICAgIHRvb2x0aXBSZWN0OiB0dEN0eC50b29sdGlwUmVjdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIHRvb2x0aXAgaGFuZGxpbmcgZm9yIGxpbmUvYXJlYS9iYXIvY29sdW1ucy9zY2F0dGVyXG5cbiAgfSwge1xuICAgIGtleTogXCJheGlzQ2hhcnRzVG9vbHRpcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXhpc0NoYXJ0c1Rvb2x0aXBzKF9yZWYyKSB7XG4gICAgICB2YXIgZSA9IF9yZWYyLmUsXG4gICAgICAgICAgb3B0ID0gX3JlZjIub3B0O1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgaiwgeCwgeTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjYXBqID0gbnVsbDtcbiAgICAgIHZhciBzZXJpZXNCb3VuZCA9IG9wdC5lbEdyaWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgY2xpZW50WCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WDtcbiAgICAgIHZhciBjbGllbnRZID0gZS50eXBlID09PSAndG91Y2htb3ZlJyA/IGUudG91Y2hlc1swXS5jbGllbnRZIDogZS5jbGllbnRZO1xuICAgICAgdGhpcy5jbGllbnRZID0gY2xpZW50WTtcbiAgICAgIHRoaXMuY2xpZW50WCA9IGNsaWVudFg7XG5cbiAgICAgIGlmIChjbGllbnRZIDwgc2VyaWVzQm91bmQudG9wIHx8IGNsaWVudFkgPiBzZXJpZXNCb3VuZC50b3AgKyBzZXJpZXNCb3VuZC5oZWlnaHQpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVNb3VzZU91dChvcHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b29sdGlwRWwgPSB0aGlzLmdldEVsVG9vbHRpcCgpO1xuICAgICAgdmFyIHhjcm9zc2hhaXJzID0gdGhpcy5nZXRFbFhDcm9zc2hhaXJzKCk7XG4gICAgICB2YXIgaXNTdGlja3lUb29sdGlwID0gdy5nbG9iYWxzLnh5Q2hhcnRzIHx8IHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdiYXInICYmICF0aGlzLmlzQmFySG9yaXpvbnRhbCAmJiB0aGlzLmhhc0JhcnMoKSAmJiB3LmNvbmZpZy50b29sdGlwLnNoYXJlZCB8fCB3Lmdsb2JhbHMuY29tYm9DaGFydHMgJiYgdGhpcy5oYXNCYXJzO1xuXG4gICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2JhcicgJiYgdGhpcy5pc0Jhckhvcml6b250YWwgJiYgdGhpcy5oYXNCYXJzKCkpIHtcbiAgICAgICAgaXNTdGlja3lUb29sdGlwID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgaWYgKHhjcm9zc2hhaXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgeGNyb3NzaGFpcnMuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi55Y3Jvc3NoYWlycyAhPT0gbnVsbCAmJiBzZWxmLmJseWF4aXNUb29sdGlwKSB7XG4gICAgICAgICAgc2VsZi55Y3Jvc3NoYWlycy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1N0aWNreVRvb2x0aXAgJiYgIXNlbGYuc2hvd09uSW50ZXJzZWN0KSB7XG4gICAgICAgICAgY2FwaiA9IHNlbGYudG9vbHRpcFV0aWwuZ2V0TmVhcmVzdFZhbHVlcyh7XG4gICAgICAgICAgICBjb250ZXh0OiBzZWxmLFxuICAgICAgICAgICAgaG92ZXJBcmVhOiBvcHQuaG92ZXJBcmVhLFxuICAgICAgICAgICAgZWxHcmlkOiBvcHQuZWxHcmlkLFxuICAgICAgICAgICAgY2xpZW50WDogY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGNsaWVudFksXG4gICAgICAgICAgICBoYXNCYXJzOiBzZWxmLmhhc0JhcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBqID0gY2Fwai5qO1xuICAgICAgICAgIHZhciBjYXB0dXJlZFNlcmllcyA9IGNhcGouY2FwdHVyZWRTZXJpZXM7XG5cbiAgICAgICAgICBpZiAoY2Fwai5ob3ZlclggPCAwIHx8IGNhcGouaG92ZXJYID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGVNb3VzZU91dChvcHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjYXB0dXJlZFNlcmllcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGlnbm9yZU51bGwgPSB3Lmdsb2JhbHMuc2VyaWVzW2NhcHR1cmVkU2VyaWVzXVtqXSA9PT0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGlnbm9yZU51bGwpIHtcbiAgICAgICAgICAgICAgb3B0LnRvb2x0aXBFbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5zZXJpZXNbY2FwdHVyZWRTZXJpZXNdW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBpZiAody5jb25maWcudG9vbHRpcC5zaGFyZWQgJiYgdGhpcy50b29sdGlwVXRpbC5pc1hvdmVybGFwKGopICYmIHRoaXMudG9vbHRpcFV0aWwuaXNpbml0aWFsU2VyaWVzU2FtZUxlbigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoc2VsZiwgY2FwdHVyZWRTZXJpZXMsIGosIG9wdC50dEl0ZW1zKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShzZWxmLCBjYXB0dXJlZFNlcmllcywgaiwgb3B0LnR0SXRlbXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMudG9vbHRpcFV0aWwuaXNYb3ZlcmxhcChqKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3JlYXRlKHNlbGYsIDAsIGosIG9wdC50dEl0ZW1zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb3VsZG4ndCBjYXB0dXJlIGFueSBzZXJpZXMuIGNoZWNrIGlmIHNoYXJlZCBYIGlzIHNhbWUsXG4gICAgICAgICAgICAvLyBpZiB5ZXMsIGRyYXcgYSBncm91cGVkIHRvb2x0aXBcbiAgICAgICAgICAgIGlmICh0aGlzLnRvb2x0aXBVdGlsLmlzWG92ZXJsYXAoaikpIHtcbiAgICAgICAgICAgICAgc2VsZi5jcmVhdGUoc2VsZiwgMCwgaiwgb3B0LnR0SXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQudHlwZSA9PT0gJ2hlYXRtYXAnKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyWFkgPSB0aGlzLmludGVyc2VjdC5oYW5kbGVIZWF0VG9vbHRpcCh7XG4gICAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICAgIG9wdDogb3B0LFxuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHggPSBtYXJrZXJYWS54O1xuICAgICAgICAgICAgeSA9IG1hcmtlclhZLnk7XG4gICAgICAgICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgICAgICAgICAgdG9vbHRpcEVsLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNCYXJzKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0LmhhbmRsZUJhclRvb2x0aXAoe1xuICAgICAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICAgICAgb3B0OiBvcHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc01hcmtlcnMpIHtcbiAgICAgICAgICAgICAgLy8gaW50ZXJzZWN0IC0gbGluZS9hcmVhL3NjYXR0ZXIvYnViYmxlXG4gICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0LmhhbmRsZU1hcmtlclRvb2x0aXAoe1xuICAgICAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICAgICAgb3B0OiBvcHQsXG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJseWF4aXNUb29sdGlwKSB7XG4gICAgICAgICAgZm9yICh2YXIgeXQgPSAwOyB5dCA8IHcuY29uZmlnLnlheGlzLmxlbmd0aDsgeXQrKykge1xuICAgICAgICAgICAgc2VsZi5heGVzVG9vbHRpcC5kcmF3WWF4aXNUb29sdGlwVGV4dCh5dCwgY2xpZW50WSwgc2VsZi54eVJhdGlvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0LnRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnIHx8IGUudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlT3V0KG9wdCk7XG4gICAgICB9XG4gICAgfSAvLyB0b29sdGlwIGhhbmRsaW5nIGZvciBwaWUvZG9udXRzXG5cbiAgfSwge1xuICAgIGtleTogXCJub25BeGlzQ2hhcnRzVG9vbHRpcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9uQXhpc0NoYXJ0c1Rvb2x0aXBzKF9yZWYzKSB7XG4gICAgICB2YXIgZSA9IF9yZWYzLmUsXG4gICAgICAgICAgb3B0ID0gX3JlZjMub3B0LFxuICAgICAgICAgIHRvb2x0aXBSZWN0ID0gX3JlZjMudG9vbHRpcFJlY3Q7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciByZWwgPSBvcHQucGF0aHMuZ2V0QXR0cmlidXRlKCdyZWwnKTtcbiAgICAgIHZhciB0b29sdGlwRWwgPSB0aGlzLmdldEVsVG9vbHRpcCgpO1xuICAgICAgdmFyIHRyWCA9IDA7XG4gICAgICB2YXIgdHJZID0gMDtcbiAgICAgIHZhciBlbFBpZSA9IG51bGw7XG4gICAgICB2YXIgY2xpZW50WCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgPyBlLnRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WDtcblxuICAgICAgaWYgKHcuY29uZmlnLmNoYXJ0LnR5cGUgPT09ICdyYWRpYWxCYXInKSB7XG4gICAgICAgIGVsUGllID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtcmFkaWFsYmFyJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbFBpZSA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXBpZScpO1xuICAgICAgICB0clggPSBwYXJzZUludChlbFBpZS5nZXRBdHRyaWJ1dGUoJ2RhdGE6aW5uZXJUcmFuc2xhdGVYJykpO1xuICAgICAgICB0clkgPSBwYXJzZUludChlbFBpZS5nZXRBdHRyaWJ1dGUoJ2RhdGE6aW5uZXJUcmFuc2xhdGVZJykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWVzQm91bmQgPSBlbFBpZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICB0b29sdGlwRWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIHRoaXMudG9vbHRpcExhYmVscy5kcmF3U2VyaWVzVGV4dHMoe1xuICAgICAgICAgIHR0SXRlbXM6IG9wdC50dEl0ZW1zLFxuICAgICAgICAgIGk6IHBhcnNlSW50KHJlbCkgLSAxLFxuICAgICAgICAgIHNoYXJlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB4ID0gY2xpZW50WCAtIHNlcmllc0JvdW5kLmxlZnQgLSB0b29sdGlwUmVjdC50dFdpZHRoIC8gMi4yICsgdHJYO1xuICAgICAgICB2YXIgeSA9IGUuY2xpZW50WSAtIHNlcmllc0JvdW5kLnRvcCAtIHRvb2x0aXBSZWN0LnR0SGVpZ2h0IC8gMiAtIDE1ICsgdHJZO1xuXG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHggKyB0b29sdGlwUmVjdC50dFdpZHRoID4gdy5nbG9iYWxzLmdyaWRXaWR0aCkge1xuICAgICAgICAgIHggPSBjbGllbnRYIC0gc2VyaWVzQm91bmQubGVmdCAtIHRvb2x0aXBSZWN0LnR0V2lkdGggKyB0clg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeSA8IDApIHkgPSB0b29sdGlwUmVjdC50dEhlaWdodCArIDIwO1xuICAgICAgICB0b29sdGlwRWwuc3R5bGUubGVmdCA9IHggKyB3Lmdsb2JhbHMudHJhbnNsYXRlWCArICdweCc7XG4gICAgICAgIHRvb2x0aXBFbC5zdHlsZS50b3AgPSB5ICsgJ3B4JztcbiAgICAgIH0gZWxzZSBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnIHx8IGUudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgICB0b29sdGlwRWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlYWN0aXZhdGVIb3ZlckZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWFjdGl2YXRlSG92ZXJGaWx0ZXIoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBncmFwaGljcyA9IG5ldyBHcmFwaGljcyh0aGlzLmN0eCk7XG4gICAgICB2YXIgYWxsUGF0aHMgPSB3Lmdsb2JhbHMuZG9tLlBhcGVyLnNlbGVjdChcIi5hcGV4Y2hhcnRzLWJhci1hcmVhXCIpO1xuXG4gICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGFsbFBhdGhzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgIGdyYXBoaWNzLnBhdGhNb3VzZUxlYXZlKGFsbFBhdGhzW2JdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTW91c2VPdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VPdXQob3B0KSB7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4Y3Jvc3NoYWlycyA9IHRoaXMuZ2V0RWxYQ3Jvc3NoYWlycygpO1xuICAgICAgb3B0LnRvb2x0aXBFbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIHRoaXMuZGVhY3RpdmF0ZUhvdmVyRmlsdGVyKCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50eXBlICE9PSAnYnViYmxlJykge1xuICAgICAgICB0aGlzLm1hcmtlci5yZXNldFBvaW50c1NpemUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHhjcm9zc2hhaXJzICE9PSBudWxsKSB7XG4gICAgICAgIHhjcm9zc2hhaXJzLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy55Y3Jvc3NoYWlycyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnljcm9zc2hhaXJzLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ibHhheGlzVG9vbHRpcCkge1xuICAgICAgICB0aGlzLnhheGlzVG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmx5YXhpc1Rvb2x0aXApIHtcbiAgICAgICAgaWYgKHRoaXMueWF4aXNUVEVscyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMueWF4aXNUVEVscyA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnlheGlzVFRFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnlheGlzVFRFbHNbaV0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsTWFya2VycygpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJyAuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBbGxNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbE1hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yQWxsKCcuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyAuYXBleGNoYXJ0cy1tYXJrZXInKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzTWFya2Vyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNNYXJrZXJzKCkge1xuICAgICAgdmFyIG1hcmtlcnMgPSB0aGlzLmdldEVsTWFya2VycygpO1xuICAgICAgcmV0dXJuIG1hcmtlcnMubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWxCYXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsQmFycygpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hcGV4Y2hhcnRzLWJhci1zZXJpZXMsICAuYXBleGNoYXJ0cy1jYW5kbGVzdGljay1zZXJpZXMnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQmFyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNCYXJzKCkge1xuICAgICAgdmFyIGJhcnMgPSB0aGlzLmdldEVsQmFycygpO1xuICAgICAgcmV0dXJuIGJhcnMubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShjb250ZXh0LCBjYXB0dXJlZFNlcmllcywgaiwgdHRJdGVtcykge1xuICAgICAgdmFyIHNoYXJlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogbnVsbDtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHNlbGYgPSBjb250ZXh0O1xuICAgICAgaWYgKHNoYXJlZCA9PT0gbnVsbCkgc2hhcmVkID0gdy5jb25maWcudG9vbHRpcC5zaGFyZWQ7XG4gICAgICB2YXIgaGFzTWFya2VycyA9IHRoaXMuaGFzTWFya2VycygpO1xuICAgICAgdmFyIGJhcnMgPSB0aGlzLmdldEVsQmFycygpO1xuXG4gICAgICBpZiAoc2hhcmVkKSB7XG4gICAgICAgIHNlbGYudG9vbHRpcExhYmVscy5kcmF3U2VyaWVzVGV4dHMoe1xuICAgICAgICAgIHR0SXRlbXM6IHR0SXRlbXMsXG4gICAgICAgICAgaTogY2FwdHVyZWRTZXJpZXMsXG4gICAgICAgICAgajogaixcbiAgICAgICAgICBzaGFyZWQ6IHRoaXMuc2hvd09uSW50ZXJzZWN0ID8gZmFsc2UgOiB3LmNvbmZpZy50b29sdGlwLnNoYXJlZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgICAgIGlmICh3Lmdsb2JhbHMubWFya2Vycy5sYXJnZXN0U2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHNlbGYubWFya2VyLmVubGFyZ2VQb2ludHMoaik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYudG9vbHRpcFBvc2l0aW9uLm1vdmVEeW5hbWljUG9pbnRzT25Ib3ZlcihqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNCYXJzKCkpIHtcbiAgICAgICAgICB0aGlzLmJhclNlcmllc0hlaWdodCA9IHRoaXMudG9vbHRpcFV0aWwuZ2V0QmFyc0hlaWdodChiYXJzKTtcblxuICAgICAgICAgIGlmICh0aGlzLmJhclNlcmllc0hlaWdodCA+IDApIHtcbiAgICAgICAgICAgIC8vIGhvdmVyIHN0YXRlLCBhY3RpdmF0ZSBzbmFwIGZpbHRlclxuICAgICAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgICAgIHZhciBwYXRocyA9IHcuZ2xvYmFscy5kb20uUGFwZXIuc2VsZWN0KFwiLmFwZXhjaGFydHMtYmFyLWFyZWFbaj0nXCIuY29uY2F0KGosIFwiJ11cIikpOyAvLyBkZS1hY3RpdmF0ZSBmaXJzdFxuXG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGVIb3ZlckZpbHRlcigpO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwUG9zaXRpb24ubW92ZVN0aWNreVRvb2x0aXBPdmVyQmFycyhqKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBwYXRocy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgICBncmFwaGljcy5wYXRoTW91c2VFbnRlcihwYXRoc1tiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnRvb2x0aXBMYWJlbHMuZHJhd1Nlcmllc1RleHRzKHtcbiAgICAgICAgICBzaGFyZWQ6IGZhbHNlLFxuICAgICAgICAgIHR0SXRlbXM6IHR0SXRlbXMsXG4gICAgICAgICAgaTogY2FwdHVyZWRTZXJpZXMsXG4gICAgICAgICAgajogalxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5oYXNCYXJzKCkpIHtcbiAgICAgICAgICBzZWxmLnRvb2x0aXBQb3NpdGlvbi5tb3ZlU3RpY2t5VG9vbHRpcE92ZXJCYXJzKGopO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc01hcmtlcnMpIHtcbiAgICAgICAgICBzZWxmLnRvb2x0aXBQb3NpdGlvbi5tb3ZlTWFya2VycyhjYXB0dXJlZFNlcmllcywgaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9vbHRpcDtcbn0oKTtcblxudmFyIGljb1BhbiA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiBmaWxsPVxcXCIjMDAwMDAwXFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiIHdpZHRoPVxcXCIyNFxcXCI+XFxuICAgIDxkZWZzPlxcbiAgICAgICAgPHBhdGggZD1cXFwiTTAgMGgyNHYyNEgwelxcXCIgaWQ9XFxcImFcXFwiLz5cXG4gICAgPC9kZWZzPlxcbiAgICA8Y2xpcFBhdGggaWQ9XFxcImJcXFwiPlxcbiAgICAgICAgPHVzZSBvdmVyZmxvdz1cXFwidmlzaWJsZVxcXCIgeGxpbms6aHJlZj1cXFwiI2FcXFwiLz5cXG4gICAgPC9jbGlwUGF0aD5cXG4gICAgPHBhdGggY2xpcC1wYXRoPVxcXCJ1cmwoI2IpXFxcIiBkPVxcXCJNMjMgNS41VjIwYzAgMi4yLTEuOCA0LTQgNGgtNy4zYy0xLjA4IDAtMi4xLS40My0yLjg1LTEuMTlMMSAxNC44M3MxLjI2LTEuMjMgMS4zLTEuMjVjLjIyLS4xOS40OS0uMjkuNzktLjI5LjIyIDAgLjQyLjA2LjYuMTYuMDQuMDEgNC4zMSAyLjQ2IDQuMzEgMi40NlY0YzAtLjgzLjY3LTEuNSAxLjUtMS41UzExIDMuMTcgMTEgNHY3aDFWMS41YzAtLjgzLjY3LTEuNSAxLjUtMS41UzE1IC42NyAxNSAxLjVWMTFoMVYyLjVjMC0uODMuNjctMS41IDEuNS0xLjVzMS41LjY3IDEuNSAxLjVWMTFoMVY1LjVjMC0uODMuNjctMS41IDEuNS0xLjVzMS41LjY3IDEuNSAxLjV6XFxcIi8+XFxuPC9zdmc+XCI7XG5cbnZhciBpY29ab29tID0gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgZmlsbD1cXFwiIzAwMDAwMFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB3aWR0aD1cXFwiMjRcXFwiPlxcbiAgICA8cGF0aCBkPVxcXCJNMTUuNSAxNGgtLjc5bC0uMjgtLjI3QzE1LjQxIDEyLjU5IDE2IDExLjExIDE2IDkuNSAxNiA1LjkxIDEzLjA5IDMgOS41IDNTMyA1LjkxIDMgOS41IDUuOTEgMTYgOS41IDE2YzEuNjEgMCAzLjA5LS41OSA0LjIzLTEuNTdsLjI3LjI4di43OWw1IDQuOTlMMjAuNDkgMTlsLTQuOTktNXptLTYgMEM3LjAxIDE0IDUgMTEuOTkgNSA5LjVTNy4wMSA1IDkuNSA1IDE0IDcuMDEgMTQgOS41IDExLjk5IDE0IDkuNSAxNHpcXFwiLz5cXG4gICAgPHBhdGggZD1cXFwiTTAgMGgyNHYyNEgwVjB6XFxcIiBmaWxsPVxcXCJub25lXFxcIi8+XFxuICAgIDxwYXRoIGQ9XFxcIk0xMiAxMGgtMnYySDl2LTJIN1Y5aDJWN2gxdjJoMnYxelxcXCIvPlxcbjwvc3ZnPlwiO1xuXG52YXIgaWNvUmVzZXQgPSBcIjxzdmcgZmlsbD1cXFwiIzAwMDAwMFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB3aWR0aD1cXFwiMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+XFxuICAgIDxwYXRoIGQ9XFxcIk0xMCAyMHYtNmg0djZoNXYtOGgzTDEyIDMgMiAxMmgzdjh6XFxcIi8+XFxuICAgIDxwYXRoIGQ9XFxcIk0wIDBoMjR2MjRIMHpcXFwiIGZpbGw9XFxcIm5vbmVcXFwiLz5cXG48L3N2Zz5cIjtcblxudmFyIGljb1pvb21JbiA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG4gICAgPHBhdGggZD1cXFwiTTAgMGgyNHYyNEgwelxcXCIgZmlsbD1cXFwibm9uZVxcXCIvPlxcbiAgICA8cGF0aCBkPVxcXCJNMTMgN2gtMnY0SDd2Mmg0djRoMnYtNGg0di0yaC00Vjd6bS0xLTVDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4elxcXCIvPlxcbjwvc3ZnPlxcblwiO1xuXG52YXIgaWNvWm9vbU91dCA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG4gICAgPHBhdGggZD1cXFwiTTAgMGgyNHYyNEgwelxcXCIgZmlsbD1cXFwibm9uZVxcXCIvPlxcbiAgICA8cGF0aCBkPVxcXCJNNyAxMXYyaDEwdi0ySDd6bTUtOUM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6XFxcIi8+XFxuPC9zdmc+XFxuXCI7XG5cbnZhciBpY29TZWxlY3QgPSBcIjxzdmcgZmlsbD1cXFwiIzZFODE5MlxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB3aWR0aD1cXFwiMjRcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+XFxuICAgIDxwYXRoIGQ9XFxcIk0wIDBoMjR2MjRIMHpcXFwiIGZpbGw9XFxcIm5vbmVcXFwiLz5cXG4gICAgPHBhdGggZD1cXFwiTTMgNWgyVjNjLTEuMSAwLTIgLjktMiAyem0wIDhoMnYtMkgzdjJ6bTQgOGgydi0ySDd2MnpNMyA5aDJWN0gzdjJ6bTEwLTZoLTJ2MmgyVjN6bTYgMHYyaDJjMC0xLjEtLjktMi0yLTJ6TTUgMjF2LTJIM2MwIDEuMS45IDIgMiAyem0tMi00aDJ2LTJIM3Yyek05IDNIN3YyaDJWM3ptMiAxOGgydi0yaC0ydjJ6bTgtOGgydi0yaC0ydjJ6bTAgOGMxLjEgMCAyLS45IDItMmgtMnYyem0wLTEyaDJWN2gtMnYyem0wIDhoMnYtMmgtMnYyem0tNCA0aDJ2LTJoLTJ2MnptMC0xNmgyVjNoLTJ2MnpcXFwiLz5cXG48L3N2Zz5cIjtcblxudmFyIGljb01lbnUgPSBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+PHBhdGggZmlsbD1cXFwibm9uZVxcXCIgZD1cXFwiTTAgMGgyNHYyNEgwVjB6XFxcIi8+PHBhdGggZD1cXFwiTTMgMThoMTh2LTJIM3Yyem0wLTVoMTh2LTJIM3Yyem0wLTd2MmgxOFY2SDN6XFxcIi8+PC9zdmc+XCI7XG5cbi8qKlxuICogQXBleENoYXJ0cyBUb29sYmFyIENsYXNzIGZvciBjcmVhdGluZyB0b29sYmFyIGluIGF4aXMgYmFzZWQgY2hhcnRzLlxuICpcbiAqIEBtb2R1bGUgVG9vbGJhclxuICoqL1xuXG52YXIgVG9vbGJhciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvb2xiYXIoY3R4KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2xiYXIpO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy53ID0gY3R4Lnc7XG4gICAgdGhpcy5ldiA9IHRoaXMudy5jb25maWcuY2hhcnQuZXZlbnRzO1xuICAgIHRoaXMubG9jYWxlVmFsdWVzID0gdGhpcy53Lmdsb2JhbHMubG9jYWxlLnRvb2xiYXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVG9vbGJhciwgW3tcbiAgICBrZXk6IFwiY3JlYXRlVG9vbGJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUb29sYmFyKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgZWxUb29sYmFyV3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZWxUb29sYmFyV3JhcC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2FwZXhjaGFydHMtdG9vbGJhcicpO1xuICAgICAgdy5nbG9iYWxzLmRvbS5lbFdyYXAuYXBwZW5kQ2hpbGQoZWxUb29sYmFyV3JhcCk7XG4gICAgICB0aGlzLmVsWm9vbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbFpvb21JbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbFpvb21PdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxQYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxTZWxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxab29tUmVzZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxNZW51SWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5lbE1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxDdXN0b21JY29ucyA9IFtdO1xuICAgICAgdGhpcy50ID0gdy5jb25maWcuY2hhcnQudG9vbGJhci50b29scztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50LmN1c3RvbUljb25zKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudC5jdXN0b21JY29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZWxDdXN0b21JY29ucy5wdXNoKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVsTWVudUl0ZW1zID0gW107XG4gICAgICB2YXIgdG9vbGJhckNvbnRyb2xzID0gW107XG5cbiAgICAgIGlmICh0aGlzLnQuem9vbWluICYmIHcuY29uZmlnLmNoYXJ0Lnpvb20uZW5hYmxlZCkge1xuICAgICAgICB0b29sYmFyQ29udHJvbHMucHVzaCh7XG4gICAgICAgICAgZWw6IHRoaXMuZWxab29tSW4sXG4gICAgICAgICAgaWNvbjogdHlwZW9mIHRoaXMudC56b29taW4gPT09ICdzdHJpbmcnID8gdGhpcy50Lnpvb21pbiA6IGljb1pvb21JbixcbiAgICAgICAgICB0aXRsZTogdGhpcy5sb2NhbGVWYWx1ZXMuem9vbUluLFxuICAgICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy16b29tLWluLWljb24nXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50Lnpvb21vdXQgJiYgdy5jb25maWcuY2hhcnQuem9vbS5lbmFibGVkKSB7XG4gICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICBlbDogdGhpcy5lbFpvb21PdXQsXG4gICAgICAgICAgaWNvbjogdHlwZW9mIHRoaXMudC56b29tb3V0ID09PSAnc3RyaW5nJyA/IHRoaXMudC56b29tb3V0IDogaWNvWm9vbU91dCxcbiAgICAgICAgICB0aXRsZTogdGhpcy5sb2NhbGVWYWx1ZXMuem9vbU91dCxcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtem9vbS1vdXQtaWNvbidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnQuem9vbSAmJiB3LmNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQpIHtcbiAgICAgICAgdG9vbGJhckNvbnRyb2xzLnB1c2goe1xuICAgICAgICAgIGVsOiB0aGlzLmVsWm9vbSxcbiAgICAgICAgICBpY29uOiB0eXBlb2YgdGhpcy50Lnpvb20gPT09ICdzdHJpbmcnID8gdGhpcy50Lnpvb20gOiBpY29ab29tLFxuICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5zZWxlY3Rpb25ab29tLFxuICAgICAgICAgIGNsYXNzOiB3Lmdsb2JhbHMuaXNUb3VjaERldmljZSA/ICdoaWRkZW4nIDogJ2FwZXhjaGFydHMtem9vbS1pY29uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudC5zZWxlY3Rpb24gJiYgdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLmVuYWJsZWQpIHtcbiAgICAgICAgdG9vbGJhckNvbnRyb2xzLnB1c2goe1xuICAgICAgICAgIGVsOiB0aGlzLmVsU2VsZWN0aW9uLFxuICAgICAgICAgIGljb246IHR5cGVvZiB0aGlzLnQuc2VsZWN0aW9uID09PSAnc3RyaW5nJyA/IHRoaXMudC5zZWxlY3Rpb24gOiBpY29TZWxlY3QsXG4gICAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLnNlbGVjdGlvbixcbiAgICAgICAgICBjbGFzczogdy5nbG9iYWxzLmlzVG91Y2hEZXZpY2UgPyAnaGlkZGVuJyA6ICdhcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudC5wYW4gJiYgdy5jb25maWcuY2hhcnQuem9vbS5lbmFibGVkKSB7XG4gICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICBlbDogdGhpcy5lbFBhbixcbiAgICAgICAgICBpY29uOiB0eXBlb2YgdGhpcy50LnBhbiA9PT0gJ3N0cmluZycgPyB0aGlzLnQucGFuIDogaWNvUGFuLFxuICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5wYW4sXG4gICAgICAgICAgY2xhc3M6IHcuZ2xvYmFscy5pc1RvdWNoRGV2aWNlID8gJ2hpZGRlbicgOiAnYXBleGNoYXJ0cy1wYW4taWNvbidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnQucmVzZXQgJiYgdy5jb25maWcuY2hhcnQuem9vbS5lbmFibGVkKSB7XG4gICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICBlbDogdGhpcy5lbFpvb21SZXNldCxcbiAgICAgICAgICBpY29uOiB0eXBlb2YgdGhpcy50LnJlc2V0ID09PSAnc3RyaW5nJyA/IHRoaXMudC5yZXNldCA6IGljb1Jlc2V0LFxuICAgICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5yZXNldCxcbiAgICAgICAgICBjbGFzczogJ2FwZXhjaGFydHMtcmVzZXQtem9vbS1pY29uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudC5kb3dubG9hZCkge1xuICAgICAgICB0b29sYmFyQ29udHJvbHMucHVzaCh7XG4gICAgICAgICAgZWw6IHRoaXMuZWxNZW51SWNvbixcbiAgICAgICAgICBpY29uOiB0eXBlb2YgdGhpcy50LmRvd25sb2FkID09PSAnc3RyaW5nJyA/IHRoaXMudC5kb3dubG9hZCA6IGljb01lbnUsXG4gICAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLm1lbnUsXG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLW1lbnUtaWNvbidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmVsQ3VzdG9tSWNvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRvb2xiYXJDb250cm9scy5wdXNoKHtcbiAgICAgICAgICBlbDogdGhpcy5lbEN1c3RvbUljb25zW19pXSxcbiAgICAgICAgICBpY29uOiB0aGlzLnQuY3VzdG9tSWNvbnNbX2ldLmljb24sXG4gICAgICAgICAgdGl0bGU6IHRoaXMudC5jdXN0b21JY29uc1tfaV0udGl0bGUsXG4gICAgICAgICAgaW5kZXg6IHRoaXMudC5jdXN0b21JY29uc1tfaV0uaW5kZXgsXG4gICAgICAgICAgY2xhc3M6ICdhcGV4Y2hhcnRzLXRvb2xiYXItY3VzdG9tLWljb24gJyArIHRoaXMudC5jdXN0b21JY29uc1tfaV0uY2xhc3NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRvb2xiYXJDb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uICh0LCBpbmRleCkge1xuICAgICAgICBpZiAodC5pbmRleCkge1xuICAgICAgICAgIFV0aWxzLm1vdmVJbmRleEluQXJyYXkodG9vbGJhckNvbnRyb2xzLCBpbmRleCwgdC5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB0b29sYmFyQ29udHJvbHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyh0b29sYmFyQ29udHJvbHNbX2kyXS5lbCwge1xuICAgICAgICAgIGNsYXNzOiB0b29sYmFyQ29udHJvbHNbX2kyXS5jbGFzcyxcbiAgICAgICAgICB0aXRsZTogdG9vbGJhckNvbnRyb2xzW19pMl0udGl0bGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRvb2xiYXJDb250cm9sc1tfaTJdLmVsLmlubmVySFRNTCA9IHRvb2xiYXJDb250cm9sc1tfaTJdLmljb247XG4gICAgICAgIGVsVG9vbGJhcldyYXAuYXBwZW5kQ2hpbGQodG9vbGJhckNvbnRyb2xzW19pMl0uZWwpO1xuICAgICAgfVxuXG4gICAgICBlbFRvb2xiYXJXcmFwLmFwcGVuZENoaWxkKHRoaXMuZWxNZW51KTtcbiAgICAgIEdyYXBoaWNzLnNldEF0dHJzKHRoaXMuZWxNZW51LCB7XG4gICAgICAgIGNsYXNzOiAnYXBleGNoYXJ0cy1tZW51J1xuICAgICAgfSk7XG4gICAgICB2YXIgbWVudUl0ZW1zID0gW3tcbiAgICAgICAgbmFtZTogJ2V4cG9ydFNWRycsXG4gICAgICAgIHRpdGxlOiB0aGlzLmxvY2FsZVZhbHVlcy5leHBvcnRUb1NWR1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnZXhwb3J0UE5HJyxcbiAgICAgICAgdGl0bGU6IHRoaXMubG9jYWxlVmFsdWVzLmV4cG9ydFRvUE5HXG4gICAgICB9XTtcblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbWVudUl0ZW1zLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgdGhpcy5lbE1lbnVJdGVtcy5wdXNoKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgdGhpcy5lbE1lbnVJdGVtc1tfaTNdLmlubmVySFRNTCA9IG1lbnVJdGVtc1tfaTNdLnRpdGxlO1xuICAgICAgICBHcmFwaGljcy5zZXRBdHRycyh0aGlzLmVsTWVudUl0ZW1zW19pM10sIHtcbiAgICAgICAgICBjbGFzczogXCJhcGV4Y2hhcnRzLW1lbnUtaXRlbSBcIi5jb25jYXQobWVudUl0ZW1zW19pM10ubmFtZSksXG4gICAgICAgICAgdGl0bGU6IG1lbnVJdGVtc1tfaTNdLnRpdGxlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsTWVudS5hcHBlbmRDaGlsZCh0aGlzLmVsTWVudUl0ZW1zW19pM10pO1xuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLnpvb21FbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZWxab29tLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9IGVsc2UgaWYgKHcuZ2xvYmFscy5wYW5FbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZWxQYW4uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSBpZiAody5nbG9iYWxzLnNlbGVjdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5lbFNlbGVjdGlvbi5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZFRvb2xiYXJFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb29sYmFyRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVG9vbGJhckV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5lbFpvb21SZXNldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbVJlc2V0LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5lbFNlbGVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlU2VsZWN0aW9uLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5lbFpvb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZVpvb21pbmcuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVsWm9vbUluLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVab29tSW4uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVsWm9vbU91dC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbU91dC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZWxQYW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZVBhbm5pbmcuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVsTWVudUljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmVsTWVudUl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgaWYgKG0uY2xhc3NMaXN0LmNvbnRhaW5zKCdleHBvcnRTVkcnKSkge1xuICAgICAgICAgIG0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpcy5kb3dubG9hZFNWRy5iaW5kKF90aGlzKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobS5jbGFzc0xpc3QuY29udGFpbnMoJ2V4cG9ydFBORycpKSB7XG4gICAgICAgICAgbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzLmRvd25sb2FkUE5HLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50LmN1c3RvbUljb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWxDdXN0b21JY29uc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudC5jdXN0b21JY29uc1tpXS5jbGljayk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVTZWxlY3Rpb24oKSB7XG4gICAgICB0aGlzLnRvZ2dsZU90aGVyQ29udHJvbHMoKTtcbiAgICAgIHRoaXMudy5nbG9iYWxzLnNlbGVjdGlvbkVuYWJsZWQgPSAhdGhpcy53Lmdsb2JhbHMuc2VsZWN0aW9uRW5hYmxlZDtcblxuICAgICAgaWYgKCF0aGlzLmVsU2VsZWN0aW9uLmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0ZWQnKSkge1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsU2VsZWN0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVpvb21pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlWm9vbWluZygpIHtcbiAgICAgIHRoaXMudG9nZ2xlT3RoZXJDb250cm9scygpO1xuICAgICAgdGhpcy53Lmdsb2JhbHMuem9vbUVuYWJsZWQgPSAhdGhpcy53Lmdsb2JhbHMuem9vbUVuYWJsZWQ7XG5cbiAgICAgIGlmICghdGhpcy5lbFpvb20uY2xhc3NMaXN0LmNvbnRhaW5zKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgIHRoaXMuZWxab29tLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsWm9vbS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb29sYmFySWNvbnNSZWZlcmVuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9vbGJhckljb25zUmVmZXJlbmNlKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICghdGhpcy5lbFpvb20pIHtcbiAgICAgICAgdGhpcy5lbFpvb20gPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy16b29tLWljb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmVsUGFuKSB7XG4gICAgICAgIHRoaXMuZWxQYW4gPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1wYW4taWNvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZWxTZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5lbFNlbGVjdGlvbiA9IHcuZ2xvYmFscy5kb20uYmFzZUVsLnF1ZXJ5U2VsZWN0b3IoJy5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVpvb21pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlWm9vbWluZygpIHtcbiAgICAgIHRoaXMudG9nZ2xlT3RoZXJDb250cm9scygpO1xuICAgICAgdGhpcy53Lmdsb2JhbHMuem9vbUVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5lbFpvb20pIHtcbiAgICAgICAgdGhpcy5lbFpvb20uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxQYW4pIHtcbiAgICAgICAgdGhpcy5lbFBhbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVQYW5uaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVBhbm5pbmcoKSB7XG4gICAgICB0aGlzLnRvZ2dsZU90aGVyQ29udHJvbHMoKTtcbiAgICAgIHRoaXMudy5nbG9iYWxzLnBhbkVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5lbFBhbikge1xuICAgICAgICB0aGlzLmVsUGFuLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVsWm9vbSkge1xuICAgICAgICB0aGlzLmVsWm9vbS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVQYW5uaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVBhbm5pbmcoKSB7XG4gICAgICB0aGlzLnRvZ2dsZU90aGVyQ29udHJvbHMoKTtcbiAgICAgIHRoaXMudy5nbG9iYWxzLnBhbkVuYWJsZWQgPSAhdGhpcy53Lmdsb2JhbHMucGFuRW5hYmxlZDtcblxuICAgICAgaWYgKCF0aGlzLmVsUGFuLmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0ZWQnKSkge1xuICAgICAgICB0aGlzLmVsUGFuLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsUGFuLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZU90aGVyQ29udHJvbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlT3RoZXJDb250cm9scygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLnBhbkVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHcuZ2xvYmFscy56b29tRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdy5nbG9iYWxzLnNlbGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZ2V0VG9vbGJhckljb25zUmVmZXJlbmNlKCk7XG5cbiAgICAgIGlmICh0aGlzLmVsUGFuKSB7XG4gICAgICAgIHRoaXMuZWxQYW4uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxTZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5lbFNlbGVjdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lbFpvb20pIHtcbiAgICAgICAgdGhpcy5lbFpvb20uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlWm9vbUluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVpvb21JbigpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIGNlbnRlclggPSAody5nbG9iYWxzLm1pblggKyB3Lmdsb2JhbHMubWF4WCkgLyAyO1xuICAgICAgdmFyIG5ld01pblggPSAody5nbG9iYWxzLm1pblggKyBjZW50ZXJYKSAvIDI7XG4gICAgICB2YXIgbmV3TWF4WCA9ICh3Lmdsb2JhbHMubWF4WCArIGNlbnRlclgpIC8gMjtcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuZGlzYWJsZVpvb21Jbikge1xuICAgICAgICB0aGlzLnpvb21VcGRhdGVPcHRpb25zKG5ld01pblgsIG5ld01heFgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVab29tT3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVpvb21PdXQoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMudzsgLy8gYXZvaWQgem9vbWluZyBvdXQgYmV5b25kIDEwMDAgd2hpY2ggbWF5IHJlc3VsdCBpbiBOYU4gdmFsdWVzIGJlaW5nIHByaW50ZWQgb24geC1heGlzXG5cbiAgICAgIGlmICh3LmNvbmZpZy54YXhpcy50eXBlID09PSAnZGF0ZXRpbWUnICYmIG5ldyBEYXRlKHcuZ2xvYmFscy5taW5YKS5nZXRVVENGdWxsWWVhcigpIDwgMTAwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjZW50ZXJYID0gKHcuZ2xvYmFscy5taW5YICsgdy5nbG9iYWxzLm1heFgpIC8gMjtcbiAgICAgIHZhciBuZXdNaW5YID0gdy5nbG9iYWxzLm1pblggLSAoY2VudGVyWCAtIHcuZ2xvYmFscy5taW5YKTtcbiAgICAgIHZhciBuZXdNYXhYID0gdy5nbG9iYWxzLm1heFggLSAoY2VudGVyWCAtIHcuZ2xvYmFscy5tYXhYKTtcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuZGlzYWJsZVpvb21PdXQpIHtcbiAgICAgICAgdGhpcy56b29tVXBkYXRlT3B0aW9ucyhuZXdNaW5YLCBuZXdNYXhYKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbVVwZGF0ZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbVVwZGF0ZU9wdGlvbnMobmV3TWluWCwgbmV3TWF4WCkge1xuICAgICAgdmFyIHhheGlzID0ge1xuICAgICAgICBtaW46IG5ld01pblgsXG4gICAgICAgIG1heDogbmV3TWF4WFxuICAgICAgfTtcbiAgICAgIHZhciBiZWZvcmVab29tUmFuZ2UgPSB0aGlzLmdldEJlZm9yZVpvb21SYW5nZSh4YXhpcyk7XG5cbiAgICAgIGlmIChiZWZvcmVab29tUmFuZ2UpIHtcbiAgICAgICAgeGF4aXMgPSBiZWZvcmVab29tUmFuZ2UueGF4aXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudy5nbG9iYWxzLnpvb21lZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuY3R4Ll91cGRhdGVPcHRpb25zKHtcbiAgICAgICAgeGF4aXM6IHhheGlzXG4gICAgICB9LCBmYWxzZSwgdGhpcy53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZCk7XG5cbiAgICAgIHRoaXMuem9vbUNhbGxiYWNrKHhheGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb21DYWxsYmFjayh4YXhpcywgeWF4aXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ldi56b29tZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5ldi56b29tZWQodGhpcy5jdHgsIHtcbiAgICAgICAgICB4YXhpczogeGF4aXMsXG4gICAgICAgICAgeWF4aXM6IHlheGlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCZWZvcmVab29tUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmVmb3JlWm9vbVJhbmdlKHhheGlzLCB5YXhpcykge1xuICAgICAgdmFyIG5ld1JhbmdlID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmV2LmJlZm9yZVpvb20gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbmV3UmFuZ2UgPSB0aGlzLmV2LmJlZm9yZVpvb20odGhpcywge1xuICAgICAgICAgIHhheGlzOiB4YXhpcyxcbiAgICAgICAgICB5YXhpczogeWF4aXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdSYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlTWVudVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNZW51KCkge1xuICAgICAgaWYgKHRoaXMuZWxNZW51LmNsYXNzTGlzdC5jb250YWlucygnb3BlbicpKSB7XG4gICAgICAgIHRoaXMuZWxNZW51LmNsYXNzTGlzdC5yZW1vdmUoJ29wZW4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWxNZW51LmNsYXNzTGlzdC5hZGQoJ29wZW4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG93bmxvYWRQTkdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG93bmxvYWRQTkcoKSB7XG4gICAgICB2YXIgZG93bmxvYWRQTkcgPSBuZXcgRXhwb3J0cyh0aGlzLmN0eCk7XG4gICAgICBkb3dubG9hZFBORy5leHBvcnRUb1BuZyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnRvZ2dsZU1lbnUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG93bmxvYWRTVkdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG93bmxvYWRTVkcoKSB7XG4gICAgICB2YXIgZG93bmxvYWRTVkcgPSBuZXcgRXhwb3J0cyh0aGlzLmN0eCk7XG4gICAgICBkb3dubG9hZFNWRy5leHBvcnRUb1NWRygpO1xuICAgICAgdGhpcy50b2dnbGVNZW51KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVpvb21SZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVab29tUmVzZXQoZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGFydHMgPSB0aGlzLmN0eC5nZXRTeW5jZWRDaGFydHMoKTtcbiAgICAgIGNoYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgdyA9IGNoLnc7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5taW5YICE9PSB3Lmdsb2JhbHMuaW5pdGlhbG1pblggJiYgdy5nbG9iYWxzLm1heFggIT09IHcuZ2xvYmFscy5pbml0aWFsbWF4WCkge1xuICAgICAgICAgIGNoLnJldmVydERlZmF1bHRBeGlzTWluTWF4KCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy56b29tZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF90aGlzMi56b29tQ2FsbGJhY2soe1xuICAgICAgICAgICAgICBtaW46IHcuY29uZmlnLnhheGlzLm1pbixcbiAgICAgICAgICAgICAgbWF4OiB3LmNvbmZpZy54YXhpcy5tYXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuZ2xvYmFscy56b29tZWQgPSBmYWxzZTtcblxuICAgICAgICAgIGNoLl91cGRhdGVTZXJpZXMody5nbG9iYWxzLmluaXRpYWxTZXJpZXMsIHcuY29uZmlnLmNoYXJ0LmFuaW1hdGlvbnMuZHluYW1pY0FuaW1hdGlvbi5lbmFibGVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLmVsWm9vbVJlc2V0KSB7XG4gICAgICAgIHRoaXMuZWxab29tUmVzZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZVpvb21SZXNldC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbFNlbGVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlU2VsZWN0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsWm9vbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlWm9vbWluZy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbFpvb21Jbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbUluLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmVsWm9vbU91dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlWm9vbU91dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbFBhbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMudG9nZ2xlUGFubmluZy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbE1lbnVJY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy50b2dnbGVNZW51LmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsWm9vbSA9IG51bGw7XG4gICAgICB0aGlzLmVsWm9vbUluID0gbnVsbDtcbiAgICAgIHRoaXMuZWxab29tT3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuZWxQYW4gPSBudWxsO1xuICAgICAgdGhpcy5lbFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLmVsWm9vbVJlc2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuZWxNZW51SWNvbiA9IG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRvb2xiYXI7XG59KCk7XG5cbi8qKlxuICogQXBleENoYXJ0cyBab29tIENsYXNzIGZvciBoYW5kbGluZyB6b29taW5nIGFuZCBwYW5uaW5nIG9uIGF4ZXMgYmFzZWQgY2hhcnRzLlxuICpcbiAqIEBtb2R1bGUgWm9vbVBhblNlbGVjdGlvblxuICoqL1xuXG52YXIgWm9vbVBhblNlbGVjdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1Rvb2xiYXIpIHtcbiAgX2luaGVyaXRzKFpvb21QYW5TZWxlY3Rpb24sIF9Ub29sYmFyKTtcblxuICBmdW5jdGlvbiBab29tUGFuU2VsZWN0aW9uKGN0eCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBab29tUGFuU2VsZWN0aW9uKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFpvb21QYW5TZWxlY3Rpb24pLmNhbGwodGhpcywgY3R4KSk7XG4gICAgX3RoaXMuY3R4ID0gY3R4O1xuICAgIF90aGlzLncgPSBjdHgudztcbiAgICBfdGhpcy5kcmFnZ2VkID0gZmFsc2U7XG4gICAgX3RoaXMuZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3MoX3RoaXMuY3R4KTtcbiAgICBfdGhpcy5ldmVudExpc3QgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAnbW91c2V1cCcsICd0b3VjaGVuZCddO1xuICAgIF90aGlzLmNsaWVudFggPSAwO1xuICAgIF90aGlzLmNsaWVudFkgPSAwO1xuICAgIF90aGlzLnN0YXJ0WCA9IDA7XG4gICAgX3RoaXMuZW5kWCA9IDA7XG4gICAgX3RoaXMuZHJhZ1ggPSAwO1xuICAgIF90aGlzLnN0YXJ0WSA9IDA7XG4gICAgX3RoaXMuZW5kWSA9IDA7XG4gICAgX3RoaXMuZHJhZ1kgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhab29tUGFuU2VsZWN0aW9uLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoX3JlZikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciB4eVJhdGlvcyA9IF9yZWYueHlSYXRpb3M7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB0aGlzLnh5UmF0aW9zID0geHlSYXRpb3M7XG4gICAgICB0aGlzLnpvb21SZWN0ID0gdGhpcy5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uUmVjdCA9IHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgICB0aGlzLmdyaWRSZWN0ID0gdy5nbG9iYWxzLmRvbS5iYXNlRWwucXVlcnlTZWxlY3RvcignLmFwZXhjaGFydHMtZ3JpZCcpO1xuICAgICAgdGhpcy56b29tUmVjdC5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FwZXhjaGFydHMtem9vbS1yZWN0Jyk7XG4gICAgICB0aGlzLnNlbGVjdGlvblJlY3Qubm9kZS5jbGFzc0xpc3QuYWRkKCdhcGV4Y2hhcnRzLXNlbGVjdGlvbi1yZWN0Jyk7XG4gICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZCh0aGlzLnpvb21SZWN0KTtcbiAgICAgIHcuZ2xvYmFscy5kb20uZWxHcmFwaGljYWwuYWRkKHRoaXMuc2VsZWN0aW9uUmVjdCk7XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24udHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgIHRoaXMuc2xEcmFnZ2FibGVSZWN0ID0gdGhpcy5zZWxlY3Rpb25SZWN0LmRyYWdnYWJsZSh7XG4gICAgICAgICAgbWluWDogMCxcbiAgICAgICAgICBtaW5ZOiAwLFxuICAgICAgICAgIG1heFg6IHcuZ2xvYmFscy5ncmlkV2lkdGgsXG4gICAgICAgICAgbWF4WTogdy5nbG9iYWxzLmdyaWRIZWlnaHRcbiAgICAgICAgfSkub24oJ2RyYWdtb3ZlJywgdGhpcy5zZWxlY3Rpb25EcmFnZ2luZy5iaW5kKHRoaXMsICdkcmFnZ2luZycpKTtcbiAgICAgIH0gZWxzZSBpZiAody5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnR5cGUgPT09ICd5Jykge1xuICAgICAgICB0aGlzLnNsRHJhZ2dhYmxlUmVjdCA9IHRoaXMuc2VsZWN0aW9uUmVjdC5kcmFnZ2FibGUoe1xuICAgICAgICAgIG1pblg6IDAsXG4gICAgICAgICAgbWF4WDogdy5nbG9iYWxzLmdyaWRXaWR0aFxuICAgICAgICB9KS5vbignZHJhZ21vdmUnLCB0aGlzLnNlbGVjdGlvbkRyYWdnaW5nLmJpbmQodGhpcywgJ2RyYWdnaW5nJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zbERyYWdnYWJsZVJlY3QgPSB0aGlzLnNlbGVjdGlvblJlY3QuZHJhZ2dhYmxlKCkub24oJ2RyYWdtb3ZlJywgdGhpcy5zZWxlY3Rpb25EcmFnZ2luZy5iaW5kKHRoaXMsICdkcmFnZ2luZycpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmVzZWxlY3RlZFNlbGVjdGlvbigpO1xuICAgICAgdGhpcy5ob3ZlckFyZWEgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKHcuZ2xvYmFscy5jaGFydENsYXNzKTtcbiAgICAgIHRoaXMuaG92ZXJBcmVhLmNsYXNzTGlzdC5hZGQoJ3pvb21hYmxlJyk7XG4gICAgICB0aGlzLmV2ZW50TGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczIuaG92ZXJBcmVhLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG1lLnN2Z01vdXNlRXZlbnRzLmJpbmQobWUsIHh5UmF0aW9zKSwge1xuICAgICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzIHdoaWNoIHdlcmUgcHJldmlvdXNseSBhZGRlZCBvbiBob3ZlciBhcmVhXG5cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHRoaXMuZXZlbnRMaXN0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpczMuaG92ZXJBcmVhKSB7XG4gICAgICAgICAgX3RoaXMzLmhvdmVyQXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBtZS5zdmdNb3VzZUV2ZW50cy5iaW5kKG1lLCBtZS54eVJhdGlvcyksIHtcbiAgICAgICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuc2xEcmFnZ2FibGVSZWN0KSB7XG4gICAgICAgIHRoaXMuc2xEcmFnZ2FibGVSZWN0LmRyYWdnYWJsZShmYWxzZSk7XG4gICAgICAgIHRoaXMuc2xEcmFnZ2FibGVSZWN0Lm9mZigpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJlY3Qub2ZmKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uUmVjdCA9IG51bGw7XG4gICAgICB0aGlzLnpvb21SZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMuZ3JpZFJlY3QgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdmdNb3VzZUV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdmdNb3VzZUV2ZW50cyh4eVJhdGlvcywgZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLmN0eC50b29sYmFyO1xuICAgICAgdmFyIHpvb210eXBlID0gdy5nbG9iYWxzLnpvb21FbmFibGVkID8gdy5jb25maWcuY2hhcnQuem9vbS50eXBlIDogdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnR5cGU7XG5cbiAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXMuc2hpZnRXYXNQcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgdG9vbGJhci5lbmFibGVQYW5uaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zaGlmdFdhc1ByZXNzZWQpIHtcbiAgICAgICAgICB0b29sYmFyLmVuYWJsZVpvb21pbmcoKTtcbiAgICAgICAgICB0aGlzLnNoaWZ0V2FzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWxzZVBvc2l0aXZlcyA9IGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1zZWxlY3Rpb24tcmVjdCcpIHx8IGUudGFyZ2V0LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcGV4Y2hhcnRzLXRvb2xiYXInKTtcbiAgICAgIGlmIChmYWxzZVBvc2l0aXZlcykgcmV0dXJuO1xuICAgICAgbWUuY2xpZW50WCA9IGUudHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgZS50eXBlID09PSAndG91Y2hzdGFydCcgPyBlLnRvdWNoZXNbMF0uY2xpZW50WCA6IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WDtcbiAgICAgIG1lLmNsaWVudFkgPSBlLnR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gZS50b3VjaGVzWzBdLmNsaWVudFkgOiBlLnR5cGUgPT09ICd0b3VjaGVuZCcgPyBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkgOiBlLmNsaWVudFk7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nICYmIGUud2hpY2ggPT09IDEpIHtcbiAgICAgICAgdmFyIGdyaWRSZWN0RGltID0gbWUuZ3JpZFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG1lLnN0YXJ0WCA9IG1lLmNsaWVudFggLSBncmlkUmVjdERpbS5sZWZ0O1xuICAgICAgICBtZS5zdGFydFkgPSBtZS5jbGllbnRZIC0gZ3JpZFJlY3REaW0udG9wO1xuICAgICAgICBtZS5kcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIG1lLncuZ2xvYmFscy5tb3VzZWRvd24gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyAmJiBlLndoaWNoID09PSAxIHx8IGUudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgbWUuZHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5wYW5FbmFibGVkKSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnNlbGVjdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICBpZiAobWUudy5nbG9iYWxzLm1vdXNlZG93bikge1xuICAgICAgICAgICAgbWUucGFuRHJhZ2dpbmcoe1xuICAgICAgICAgICAgICBjb250ZXh0OiBtZSxcbiAgICAgICAgICAgICAgem9vbXR5cGU6IHpvb210eXBlLFxuICAgICAgICAgICAgICB4eVJhdGlvczogeHlSYXRpb3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWUudy5nbG9iYWxzLm1vdXNlZG93biAmJiB3Lmdsb2JhbHMuem9vbUVuYWJsZWQgfHwgbWUudy5nbG9iYWxzLm1vdXNlZG93biAmJiB3Lmdsb2JhbHMuc2VsZWN0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgbWUuc2VsZWN0aW9uID0gbWUuc2VsZWN0aW9uRHJhd2luZyh7XG4gICAgICAgICAgICAgIGNvbnRleHQ6IG1lLFxuICAgICAgICAgICAgICB6b29tdHlwZTogem9vbXR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgIC8vIHdlIHdpbGwgYmUgY2FsbGluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gZWFjaCBtb3VzZWRvd24vbW91c2Vtb3ZlL21vdXNldXBcbiAgICAgICAgdmFyIF9ncmlkUmVjdERpbSA9IG1lLmdyaWRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGlmIChtZS53Lmdsb2JhbHMubW91c2Vkb3duKSB7XG4gICAgICAgICAgLy8gdXNlciByZWxlYXNlZCB0aGUgZHJhZywgbm93IGRvIGFsbCB0aGUgY2FsY3VsYXRpb25zXG4gICAgICAgICAgbWUuZW5kWCA9IG1lLmNsaWVudFggLSBfZ3JpZFJlY3REaW0ubGVmdDtcbiAgICAgICAgICBtZS5lbmRZID0gbWUuY2xpZW50WSAtIF9ncmlkUmVjdERpbS50b3A7XG4gICAgICAgICAgbWUuZHJhZ1ggPSBNYXRoLmFicyhtZS5lbmRYIC0gbWUuc3RhcnRYKTtcbiAgICAgICAgICBtZS5kcmFnWSA9IE1hdGguYWJzKG1lLmVuZFkgLSBtZS5zdGFydFkpO1xuXG4gICAgICAgICAgaWYgKHcuZ2xvYmFscy56b29tRW5hYmxlZCB8fCB3Lmdsb2JhbHMuc2VsZWN0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgbWUuc2VsZWN0aW9uRHJhd24oe1xuICAgICAgICAgICAgICBjb250ZXh0OiBtZSxcbiAgICAgICAgICAgICAgem9vbXR5cGU6IHpvb210eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5nbG9iYWxzLnpvb21FbmFibGVkKSB7XG4gICAgICAgICAgbWUuaGlkZVNlbGVjdGlvblJlY3QodGhpcy5zZWxlY3Rpb25SZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmRyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbWUudy5nbG9iYWxzLm1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1ha2VTZWxlY3Rpb25SZWN0RHJhZ2dhYmxlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VTZWxlY3Rpb25SZWN0RHJhZ2dhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VTZWxlY3Rpb25SZWN0RHJhZ2dhYmxlKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uUmVjdCkgcmV0dXJuO1xuICAgICAgdmFyIHJlY3REaW0gPSB0aGlzLnNlbGVjdGlvblJlY3Qubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHJlY3REaW0ud2lkdGggPiAwICYmIHJlY3REaW0uaGVpZ2h0ID4gMCkge1xuICAgICAgICB0aGlzLnNsRHJhZ2dhYmxlUmVjdC5zZWxlY3RpemUoKS5yZXNpemUoe1xuICAgICAgICAgIGNvbnN0cmFpbnQ6IHtcbiAgICAgICAgICAgIG1pblg6IDAsXG4gICAgICAgICAgICBtaW5ZOiAwLFxuICAgICAgICAgICAgbWF4WDogdy5nbG9iYWxzLmdyaWRXaWR0aCxcbiAgICAgICAgICAgIG1heFk6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9KS5vbigncmVzaXppbmcnLCB0aGlzLnNlbGVjdGlvbkRyYWdnaW5nLmJpbmQodGhpcywgJ3Jlc2l6aW5nJykpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVzZWxlY3RlZFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVzZWxlY3RlZFNlbGVjdGlvbigpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHh5UmF0aW9zID0gdGhpcy54eVJhdGlvcztcblxuICAgICAgaWYgKCF3Lmdsb2JhbHMuem9vbUVuYWJsZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMuc2VsZWN0aW9uICE9PSAndW5kZWZpbmVkJyAmJiB3Lmdsb2JhbHMuc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uUmVjdCh3Lmdsb2JhbHMuc2VsZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAody5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnhheGlzLm1pbiAhPT0gdW5kZWZpbmVkICYmIHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi54YXhpcy5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHggPSAody5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnhheGlzLm1pbiAtIHcuZ2xvYmFscy5taW5YKSAvIHh5UmF0aW9zLnhSYXRpbztcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHcuZ2xvYmFscy5ncmlkV2lkdGggLSAody5nbG9iYWxzLm1heFggLSB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWF4KSAvIHh5UmF0aW9zLnhSYXRpbyAtIHg7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmVjdCA9IHtcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IHcuZ2xvYmFscy5ncmlkSGVpZ2h0LFxuICAgICAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgICAgICB0cmFuc2xhdGVZOiAwLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25FbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uUmVjdChzZWxlY3Rpb25SZWN0KTtcbiAgICAgICAgICAgIHRoaXMubWFrZVNlbGVjdGlvblJlY3REcmFnZ2FibGUoKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zZWxlY3Rpb24odGhpcy5jdHgsIHtcbiAgICAgICAgICAgICAgICB4YXhpczoge1xuICAgICAgICAgICAgICAgICAgbWluOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWluLFxuICAgICAgICAgICAgICAgICAgbWF4OiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24ueGF4aXMubWF4XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB5YXhpczoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdTZWxlY3Rpb25SZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25SZWN0KF9yZWYyKSB7XG4gICAgICB2YXIgeCA9IF9yZWYyLngsXG4gICAgICAgICAgeSA9IF9yZWYyLnksXG4gICAgICAgICAgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQsXG4gICAgICAgICAgdHJhbnNsYXRlWCA9IF9yZWYyLnRyYW5zbGF0ZVgsXG4gICAgICAgICAgdHJhbnNsYXRlWSA9IF9yZWYyLnRyYW5zbGF0ZVk7XG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB6b29tUmVjdCA9IHRoaXMuem9vbVJlY3Q7XG4gICAgICB2YXIgc2VsZWN0aW9uUmVjdCA9IHRoaXMuc2VsZWN0aW9uUmVjdDtcblxuICAgICAgaWYgKHRoaXMuZHJhZ2dlZCB8fCB3Lmdsb2JhbHMuc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBzY2FsaW5nQXR0cnMgPSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyB0cmFuc2xhdGVYICsgJywgJyArIHRyYW5zbGF0ZVkgKyAnKScgLy8gY2hhbmdlIHN0eWxlcyBiYXNlZCBvbiB6b29tIG9yIHNlbGVjdGlvblxuICAgICAgICAgIC8vIHpvb20gaXMgRW5hYmxlZCBhbmQgdXNlciBoYXMgZHJhZ2dlZCwgc28gZHJhdyBibHVlIHJlY3RcblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMuem9vbUVuYWJsZWQgJiYgdGhpcy5kcmFnZ2VkKSB7XG4gICAgICAgICAgem9vbVJlY3QuYXR0cih7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgZmlsbDogdy5jb25maWcuY2hhcnQuem9vbS56b29tZWRBcmVhLmZpbGwuY29sb3IsXG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5Jzogdy5jb25maWcuY2hhcnQuem9vbS56b29tZWRBcmVhLmZpbGwub3BhY2l0eSxcbiAgICAgICAgICAgIHN0cm9rZTogdy5jb25maWcuY2hhcnQuem9vbS56b29tZWRBcmVhLnN0cm9rZS5jb2xvcixcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiB3LmNvbmZpZy5jaGFydC56b29tLnpvb21lZEFyZWEuc3Ryb2tlLndpZHRoLFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5Jzogdy5jb25maWcuY2hhcnQuem9vbS56b29tZWRBcmVhLnN0cm9rZS5vcGFjaXR5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoem9vbVJlY3Qubm9kZSwgc2NhbGluZ0F0dHJzKTtcbiAgICAgICAgfSAvLyBzZWxlY3Rpb24gaXMgZW5hYmxlZFxuXG5cbiAgICAgICAgaWYgKHcuZ2xvYmFscy5zZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgc2VsZWN0aW9uUmVjdC5hdHRyKHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoID4gMCA/IHdpZHRoIDogMCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0ID4gMCA/IGhlaWdodCA6IDAsXG4gICAgICAgICAgICBmaWxsOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uZmlsbC5jb2xvcixcbiAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uZmlsbC5vcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlOiB3LmNvbmZpZy5jaGFydC5zZWxlY3Rpb24uc3Ryb2tlLmNvbG9yLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5zdHJva2Uud2lkdGgsXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6IHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5zdHJva2UuZGFzaEFycmF5LFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5Jzogdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uLnN0cm9rZS5vcGFjaXR5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgR3JhcGhpY3Muc2V0QXR0cnMoc2VsZWN0aW9uUmVjdC5ub2RlLCBzY2FsaW5nQXR0cnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhpZGVTZWxlY3Rpb25SZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVTZWxlY3Rpb25SZWN0KHJlY3QpIHtcbiAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0aW9uRHJhd2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3Rpb25EcmF3aW5nKF9yZWYzKSB7XG4gICAgICB2YXIgY29udGV4dCA9IF9yZWYzLmNvbnRleHQsXG4gICAgICAgICAgem9vbXR5cGUgPSBfcmVmMy56b29tdHlwZTtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIG1lID0gY29udGV4dDtcbiAgICAgIHZhciBncmlkUmVjdERpbSA9IHRoaXMuZ3JpZFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc3RhcnRYID0gbWUuc3RhcnRYIC0gMTtcbiAgICAgIHZhciBzdGFydFkgPSBtZS5zdGFydFk7XG4gICAgICB2YXIgc2VsZWN0aW9uV2lkdGggPSBtZS5jbGllbnRYIC0gZ3JpZFJlY3REaW0ubGVmdCAtIHN0YXJ0WDtcbiAgICAgIHZhciBzZWxlY3Rpb25IZWlnaHQgPSBtZS5jbGllbnRZIC0gZ3JpZFJlY3REaW0udG9wIC0gc3RhcnRZO1xuICAgICAgdmFyIHRyYW5zbGF0ZVggPSAwO1xuICAgICAgdmFyIHRyYW5zbGF0ZVkgPSAwO1xuICAgICAgdmFyIHNlbGVjdGlvblJlY3QgPSB7fTtcblxuICAgICAgaWYgKE1hdGguYWJzKHNlbGVjdGlvbldpZHRoICsgc3RhcnRYKSA+IHcuZ2xvYmFscy5ncmlkV2lkdGggfHwgbWUuY2xpZW50WCAtIGdyaWRSZWN0RGltLmxlZnQgPCAwKSB7XG4gICAgICAgIC8vIHVzZXIgZHJhZ2dlZCB0aGUgbW91c2Ugb3V0c2lkZSBkcmF3aW5nIGFyZWFcbiAgICAgICAgLy8gVE9ETzogdGVzdCB0aGUgc2VsZWN0aW9uUmVjdCBhbmQgbWFrZSBzdXJlIGl0IGRvZXNuJ3QgY3Jvc3NlcyBkcmF3aW5nIGFyZWFcbiAgICAgICAgbWUuaGlkZVNlbGVjdGlvblJlY3QodGhpcy56b29tUmVjdCk7XG4gICAgICAgIG1lLmRyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgbWUudy5nbG9iYWxzLm1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgfSAvLyBpbnZlcnNlIHNlbGVjdGlvbiBYXG5cblxuICAgICAgaWYgKHN0YXJ0WCA+IG1lLmNsaWVudFggLSBncmlkUmVjdERpbS5sZWZ0KSB7XG4gICAgICAgIHNlbGVjdGlvbldpZHRoID0gTWF0aC5hYnMoc2VsZWN0aW9uV2lkdGgpO1xuICAgICAgICB0cmFuc2xhdGVYID0gLXNlbGVjdGlvbldpZHRoO1xuICAgICAgfSAvLyBpbnZlcnNlIHNlbGVjdGlvbiBZXG5cblxuICAgICAgaWYgKHN0YXJ0WSA+IG1lLmNsaWVudFkgLSBncmlkUmVjdERpbS50b3ApIHtcbiAgICAgICAgc2VsZWN0aW9uSGVpZ2h0ID0gTWF0aC5hYnMoc2VsZWN0aW9uSGVpZ2h0KTtcbiAgICAgICAgdHJhbnNsYXRlWSA9IC1zZWxlY3Rpb25IZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh6b29tdHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgIHNlbGVjdGlvblJlY3QgPSB7XG4gICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IHNlbGVjdGlvbldpZHRoLFxuICAgICAgICAgIGhlaWdodDogdy5nbG9iYWxzLmdyaWRIZWlnaHQsXG4gICAgICAgICAgdHJhbnNsYXRlWDogdHJhbnNsYXRlWCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHpvb210eXBlID09PSAneScpIHtcbiAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IHN0YXJ0WSxcbiAgICAgICAgICB3aWR0aDogdy5nbG9iYWxzLmdyaWRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNlbGVjdGlvbkhlaWdodCxcbiAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IHRyYW5zbGF0ZVlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvblJlY3QgPSB7XG4gICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgIHk6IHN0YXJ0WSxcbiAgICAgICAgICB3aWR0aDogc2VsZWN0aW9uV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzZWxlY3Rpb25IZWlnaHQsXG4gICAgICAgICAgdHJhbnNsYXRlWDogdHJhbnNsYXRlWCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiB0cmFuc2xhdGVZXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1lLmRyYXdTZWxlY3Rpb25SZWN0KHNlbGVjdGlvblJlY3QpO1xuICAgICAgcmV0dXJuIHNlbGVjdGlvblJlY3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdGlvbkRyYWdnaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdGlvbkRyYWdnaW5nKHR5cGUsIGUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgdyA9IHRoaXMudztcbiAgICAgIHZhciB4eVJhdGlvcyA9IHRoaXMueHlSYXRpb3M7XG4gICAgICB2YXIgc2VsUmVjdCA9IHRoaXMuc2VsZWN0aW9uUmVjdDtcbiAgICAgIHZhciB0aW1lckludGVydmFsID0gMDtcblxuICAgICAgaWYgKHR5cGUgPT09ICdyZXNpemluZycpIHtcbiAgICAgICAgdGltZXJJbnRlcnZhbCA9IDMwO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gYSBzbWFsbCBkZWJvdW5jZXIgaXMgcmVxdWlyZWQgd2hlbiByZXNpemluZyB0byBhdm9pZCBmcmVlemluZyB0aGUgY2hhcnRcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudy5nbG9iYWxzLnNlbGVjdGlvblJlc2l6ZVRpbWVyKTtcbiAgICAgICAgdGhpcy53Lmdsb2JhbHMuc2VsZWN0aW9uUmVzaXplVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGdyaWRSZWN0RGltID0gX3RoaXM0LmdyaWRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgdmFyIHNlbGVjdGlvblJlY3QgPSBzZWxSZWN0Lm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgdmFyIG1pblggPSB3Lmdsb2JhbHMueEF4aXNTY2FsZS5uaWNlTWluICsgKHNlbGVjdGlvblJlY3QubGVmdCAtIGdyaWRSZWN0RGltLmxlZnQpICogeHlSYXRpb3MueFJhdGlvO1xuICAgICAgICAgIHZhciBtYXhYID0gdy5nbG9iYWxzLnhBeGlzU2NhbGUubmljZU1pbiArIChzZWxlY3Rpb25SZWN0LnJpZ2h0IC0gZ3JpZFJlY3REaW0ubGVmdCkgKiB4eVJhdGlvcy54UmF0aW87XG4gICAgICAgICAgdmFyIG1pblkgPSB3Lmdsb2JhbHMueUF4aXNTY2FsZVswXS5uaWNlTWluICsgKGdyaWRSZWN0RGltLmJvdHRvbSAtIHNlbGVjdGlvblJlY3QuYm90dG9tKSAqIHh5UmF0aW9zLnlSYXRpb1swXTtcbiAgICAgICAgICB2YXIgbWF4WSA9IHcuZ2xvYmFscy55QXhpc1NjYWxlWzBdLm5pY2VNYXggLSAoc2VsZWN0aW9uUmVjdC50b3AgLSBncmlkUmVjdERpbS50b3ApICogeHlSYXRpb3MueVJhdGlvWzBdO1xuICAgICAgICAgIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5zZWxlY3Rpb24oX3RoaXM0LmN0eCwge1xuICAgICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgICAgbWluOiBtaW5YLFxuICAgICAgICAgICAgICBtYXg6IG1heFhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5YXhpczoge1xuICAgICAgICAgICAgICBtaW46IG1pblksXG4gICAgICAgICAgICAgIG1heDogbWF4WVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aW1lckludGVydmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0aW9uRHJhd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0aW9uRHJhd24oX3JlZjQpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gX3JlZjQuY29udGV4dCxcbiAgICAgICAgICB6b29tdHlwZSA9IF9yZWY0Lnpvb210eXBlO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbWUgPSBjb250ZXh0O1xuICAgICAgdmFyIHh5UmF0aW9zID0gdGhpcy54eVJhdGlvcztcbiAgICAgIHZhciB0b29sYmFyID0gdGhpcy5jdHgudG9vbGJhcjtcblxuICAgICAgaWYgKG1lLnN0YXJ0WCA+IG1lLmVuZFgpIHtcbiAgICAgICAgdmFyIHRlbXBYID0gbWUuc3RhcnRYO1xuICAgICAgICBtZS5zdGFydFggPSBtZS5lbmRYO1xuICAgICAgICBtZS5lbmRYID0gdGVtcFg7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZS5zdGFydFkgPiBtZS5lbmRZKSB7XG4gICAgICAgIHZhciB0ZW1wWSA9IG1lLnN0YXJ0WTtcbiAgICAgICAgbWUuc3RhcnRZID0gbWUuZW5kWTtcbiAgICAgICAgbWUuZW5kWSA9IHRlbXBZO1xuICAgICAgfVxuXG4gICAgICB2YXIgeExvd2VzdFZhbHVlID0gdy5nbG9iYWxzLnhBeGlzU2NhbGUubmljZU1pbiArIG1lLnN0YXJ0WCAqIHh5UmF0aW9zLnhSYXRpbztcbiAgICAgIHZhciB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLnhBeGlzU2NhbGUubmljZU1pbiArIG1lLmVuZFggKiB4eVJhdGlvcy54UmF0aW87IC8vIFRPRE86IHdlIHdpbGwgY29uc2lkZXIgdGhlIDFzdCB5IGF4aXMgdmFsdWVzIGhlcmUgZm9yIGdldHRpbmcgaGlnaGVzdCBhbmQgbG93ZXN0IHlcblxuICAgICAgdmFyIHlIaWdoZXN0VmFsdWUgPSBbXTtcbiAgICAgIHZhciB5TG93ZXN0VmFsdWUgPSBbXTtcbiAgICAgIHcuY29uZmlnLnlheGlzLmZvckVhY2goZnVuY3Rpb24gKHlheGUsIGluZGV4KSB7XG4gICAgICAgIHlIaWdoZXN0VmFsdWUucHVzaChNYXRoLmZsb29yKHcuZ2xvYmFscy55QXhpc1NjYWxlW2luZGV4XS5uaWNlTWF4IC0geHlSYXRpb3MueVJhdGlvW2luZGV4XSAqIG1lLnN0YXJ0WSkpO1xuICAgICAgICB5TG93ZXN0VmFsdWUucHVzaChNYXRoLmZsb29yKHcuZ2xvYmFscy55QXhpc1NjYWxlW2luZGV4XS5uaWNlTWF4IC0geHlSYXRpb3MueVJhdGlvW2luZGV4XSAqIG1lLmVuZFkpKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWUuZHJhZ2dlZCAmJiAobWUuZHJhZ1ggPiAxMCB8fCBtZS5kcmFnWSA+IDEwKSAmJiB4TG93ZXN0VmFsdWUgIT09IHhIaWdoZXN0VmFsdWUpIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy56b29tRW5hYmxlZCkge1xuICAgICAgICAgIHZhciB5YXhpcyA9IFV0aWxzLmNsb25lKHcuY29uZmlnLnlheGlzKTsgLy8gYmVmb3JlIHpvb21pbmcgaW4vb3V0LCBzdG9yZSB0aGUgbGFzdCB5YXhpcyBhbmQgeGF4aXMgcmFuZ2UsIHNvIHRoYXQgd2hlbiB1c2VyIGhpdHMgdGhlIFJFU0VUIGJ1dHRvbiwgd2UgZ2V0IHRoZSBvcmlnaW5hbCByYW5nZVxuICAgICAgICAgIC8vIGFsc28gLSBtYWtlIHN1cmUgdXNlciBpcyBub3QgYWxyZWFkeSB6b29tZWQgaW4vb3V0IC0gb3RoZXJ3aXNlIHdlIHdpbGwgc3RvcmUgem9vbWVkIHZhbHVlcyBpbiBsYXN0QXhpc1xuXG4gICAgICAgICAgaWYgKCF3Lmdsb2JhbHMuem9vbWVkKSB7XG4gICAgICAgICAgICB3Lmdsb2JhbHMubGFzdFhBeGlzID0gVXRpbHMuY2xvbmUody5jb25maWcueGF4aXMpO1xuICAgICAgICAgICAgdy5nbG9iYWxzLmxhc3RZQXhpcyA9IFV0aWxzLmNsb25lKHcuY29uZmlnLnlheGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgeGF4aXMgPSB7XG4gICAgICAgICAgICBtaW46IHhMb3dlc3RWYWx1ZSxcbiAgICAgICAgICAgIG1heDogeEhpZ2hlc3RWYWx1ZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoem9vbXR5cGUgPT09ICd4eScgfHwgem9vbXR5cGUgPT09ICd5Jykge1xuICAgICAgICAgICAgeWF4aXMuZm9yRWFjaChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgeWF4aXNbaW5kZXhdLm1pbiA9IHlMb3dlc3RWYWx1ZVtpbmRleF07XG4gICAgICAgICAgICAgIHlheGlzW2luZGV4XS5tYXggPSB5SGlnaGVzdFZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC56b29tLmF1dG9TY2FsZVlheGlzKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBuZXcgUmFuZ2UobWUuY3R4KTtcbiAgICAgICAgICAgIHlheGlzID0gc2NhbGUuYXV0b1NjYWxlWShtZS5jdHgsIHtcbiAgICAgICAgICAgICAgeGF4aXM6IHhheGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9vbGJhcikge1xuICAgICAgICAgICAgdmFyIGJlZm9yZVpvb21SYW5nZSA9IHRvb2xiYXIuZ2V0QmVmb3JlWm9vbVJhbmdlKHhheGlzLCB5YXhpcyk7XG5cbiAgICAgICAgICAgIGlmIChiZWZvcmVab29tUmFuZ2UpIHtcbiAgICAgICAgICAgICAgeGF4aXMgPSBiZWZvcmVab29tUmFuZ2UueGF4aXMgPyBiZWZvcmVab29tUmFuZ2UueGF4aXMgOiB4YXhpcztcbiAgICAgICAgICAgICAgeWF4aXMgPSBiZWZvcmVab29tUmFuZ2UueWF4aXMgPyBiZWZvcmVab29tUmFuZ2UueWF4ZSA6IHlheGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh6b29tdHlwZSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBtZS5jdHguX3VwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgICB4YXhpczogeGF4aXNcbiAgICAgICAgICAgIH0sIGZhbHNlLCBtZS53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh6b29tdHlwZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICBtZS5jdHguX3VwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgICB5YXhpczogeWF4aXNcbiAgICAgICAgICAgIH0sIGZhbHNlLCBtZS53LmNvbmZpZy5jaGFydC5hbmltYXRpb25zLmR5bmFtaWNBbmltYXRpb24uZW5hYmxlZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lLmN0eC5fdXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICAgIHhheGlzOiB4YXhpcyxcbiAgICAgICAgICAgICAgeWF4aXM6IHlheGlzXG4gICAgICAgICAgICB9LCBmYWxzZSwgbWUudy5jb25maWcuY2hhcnQuYW5pbWF0aW9ucy5keW5hbWljQW5pbWF0aW9uLmVuYWJsZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2Ygdy5jb25maWcuY2hhcnQuZXZlbnRzLnpvb21lZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdG9vbGJhci56b29tQ2FsbGJhY2soeGF4aXMsIHlheGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMuem9vbWVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3Lmdsb2JhbHMuc2VsZWN0aW9uRW5hYmxlZCkge1xuICAgICAgICAgIHZhciBfeWF4aXMgPSBudWxsO1xuICAgICAgICAgIHZhciBfeGF4aXMgPSBudWxsO1xuICAgICAgICAgIF94YXhpcyA9IHtcbiAgICAgICAgICAgIG1pbjogeExvd2VzdFZhbHVlLFxuICAgICAgICAgICAgbWF4OiB4SGlnaGVzdFZhbHVlXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh6b29tdHlwZSA9PT0gJ3h5JyB8fCB6b29tdHlwZSA9PT0gJ3knKSB7XG4gICAgICAgICAgICBfeWF4aXMgPSBVdGlscy5jbG9uZSh3LmNvbmZpZy55YXhpcyk7XG5cbiAgICAgICAgICAgIF95YXhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5YXhlLCBpbmRleCkge1xuICAgICAgICAgICAgICBfeWF4aXNbaW5kZXhdLm1pbiA9IHlMb3dlc3RWYWx1ZVtpbmRleF07XG4gICAgICAgICAgICAgIF95YXhpc1tpbmRleF0ubWF4ID0geUhpZ2hlc3RWYWx1ZVtpbmRleF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3Lmdsb2JhbHMuc2VsZWN0aW9uID0gbWUuc2VsZWN0aW9uO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2VsZWN0aW9uKG1lLmN0eCwge1xuICAgICAgICAgICAgICB4YXhpczogX3hheGlzLFxuICAgICAgICAgICAgICB5YXhpczogX3lheGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFuRHJhZ2dpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFuRHJhZ2dpbmcoX3JlZjUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gX3JlZjUuY29udGV4dCxcbiAgICAgICAgICB6b29tdHlwZSA9IF9yZWY1Lnpvb210eXBlO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbWUgPSBjb250ZXh0O1xuICAgICAgdmFyIG1vdmVEaXJlY3Rpb247IC8vIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyBkYXRhIHRvIGNvbXBhcmUgYWdhaW5zdFxuXG4gICAgICBpZiAodHlwZW9mIHcuZ2xvYmFscy5sYXN0Q2xpZW50UG9zaXRpb24ueCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBjaGFuZ2UgZnJvbSBsYXN0IHBvc2l0aW9uIHRvIHRoaXMgcG9zaXRpb25cbiAgICAgICAgdmFyIGRlbHRhWCA9IHcuZ2xvYmFscy5sYXN0Q2xpZW50UG9zaXRpb24ueCAtIG1lLmNsaWVudFg7XG4gICAgICAgIHZhciBkZWx0YVkgPSB3Lmdsb2JhbHMubGFzdENsaWVudFBvc2l0aW9uLnkgLSBtZS5jbGllbnRZOyAvLyBjaGVjayB3aGljaCBkaXJlY3Rpb24gaGFkIHRoZSBoaWdoZXN0IGFtcGxpdHVkZSBhbmQgdGhlbiBmaWd1cmUgb3V0IGRpcmVjdGlvbiBieSBjaGVja2luZyBpZiB0aGUgdmFsdWUgaXMgZ3JlYXRlciBvciBsZXNzIHRoYW4gemVyb1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhkZWx0YVgpID4gTWF0aC5hYnMoZGVsdGFZKSAmJiBkZWx0YVggPiAwKSB7XG4gICAgICAgICAgbW92ZURpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkZWx0YVgpID4gTWF0aC5hYnMoZGVsdGFZKSAmJiBkZWx0YVggPCAwKSB7XG4gICAgICAgICAgbW92ZURpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZGVsdGFZKSA+IE1hdGguYWJzKGRlbHRhWCkgJiYgZGVsdGFZID4gMCkge1xuICAgICAgICAgIG1vdmVEaXJlY3Rpb24gPSAndXAnO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRlbHRhWSkgPiBNYXRoLmFicyhkZWx0YVgpICYmIGRlbHRhWSA8IDApIHtcbiAgICAgICAgICBtb3ZlRGlyZWN0aW9uID0gJ2Rvd24nO1xuICAgICAgICB9XG4gICAgICB9IC8vIHNldCB0aGUgbmV3IGxhc3QgcG9zaXRpb24gdG8gdGhlIGN1cnJlbnQgZm9yIG5leHQgdGltZSAodG8gZ2V0IHRoZSBwb3NpdGlvbiBvZiBkcmFnKVxuXG5cbiAgICAgIHcuZ2xvYmFscy5sYXN0Q2xpZW50UG9zaXRpb24gPSB7XG4gICAgICAgIHg6IG1lLmNsaWVudFgsXG4gICAgICAgIHk6IG1lLmNsaWVudFlcbiAgICAgIH07XG4gICAgICB2YXIgeExvd2VzdFZhbHVlID0gdy5nbG9iYWxzLm1pblg7XG4gICAgICB2YXIgeEhpZ2hlc3RWYWx1ZSA9IHcuZ2xvYmFscy5tYXhYO1xuICAgICAgdGhpcy5wYW5TY3JvbGxlZChtb3ZlRGlyZWN0aW9uLCB4TG93ZXN0VmFsdWUsIHhIaWdoZXN0VmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYW5TY3JvbGxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYW5TY3JvbGxlZChtb3ZlRGlyZWN0aW9uLCB4TG93ZXN0VmFsdWUsIHhIaWdoZXN0VmFsdWUpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdmFyIHh5UmF0aW9zID0gdGhpcy54eVJhdGlvcztcbiAgICAgIHZhciB5YXhpcyA9IFV0aWxzLmNsb25lKHcuY29uZmlnLnlheGlzKTtcblxuICAgICAgaWYgKG1vdmVEaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4TG93ZXN0VmFsdWUgPSB3Lmdsb2JhbHMubWluWCArIHcuZ2xvYmFscy5ncmlkV2lkdGggLyAxNSAqIHh5UmF0aW9zLnhSYXRpbztcbiAgICAgICAgeEhpZ2hlc3RWYWx1ZSA9IHcuZ2xvYmFscy5tYXhYICsgdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDE1ICogeHlSYXRpb3MueFJhdGlvO1xuICAgICAgfSBlbHNlIGlmIChtb3ZlRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIHhMb3dlc3RWYWx1ZSA9IHcuZ2xvYmFscy5taW5YIC0gdy5nbG9iYWxzLmdyaWRXaWR0aCAvIDE1ICogeHlSYXRpb3MueFJhdGlvO1xuICAgICAgICB4SGlnaGVzdFZhbHVlID0gdy5nbG9iYWxzLm1heFggLSB3Lmdsb2JhbHMuZ3JpZFdpZHRoIC8gMTUgKiB4eVJhdGlvcy54UmF0aW87XG4gICAgICB9XG5cbiAgICAgIGlmICh4TG93ZXN0VmFsdWUgPCB3Lmdsb2JhbHMuaW5pdGlhbG1pblggfHwgeEhpZ2hlc3RWYWx1ZSA+IHcuZ2xvYmFscy5pbml0aWFsbWF4WCkge1xuICAgICAgICB4TG93ZXN0VmFsdWUgPSB3Lmdsb2JhbHMubWluWDtcbiAgICAgICAgeEhpZ2hlc3RWYWx1ZSA9IHcuZ2xvYmFscy5tYXhYO1xuICAgICAgfVxuXG4gICAgICB2YXIgeGF4aXMgPSB7XG4gICAgICAgIG1pbjogeExvd2VzdFZhbHVlLFxuICAgICAgICBtYXg6IHhIaWdoZXN0VmFsdWVcbiAgICAgIH07XG5cbiAgICAgIGlmICh3LmNvbmZpZy5jaGFydC56b29tLmF1dG9TY2FsZVlheGlzKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IG5ldyBSYW5nZShtZS5jdHgpO1xuICAgICAgICB5YXhpcyA9IHNjYWxlLmF1dG9TY2FsZVkobWUuY3R4LCB7XG4gICAgICAgICAgeGF4aXM6IHhheGlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5fdXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHhheGlzOiB7XG4gICAgICAgICAgbWluOiB4TG93ZXN0VmFsdWUsXG4gICAgICAgICAgbWF4OiB4SGlnaGVzdFZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIHlheGlzOiB5YXhpc1xuICAgICAgfSwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgaWYgKHR5cGVvZiB3LmNvbmZpZy5jaGFydC5ldmVudHMuc2Nyb2xsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdy5jb25maWcuY2hhcnQuZXZlbnRzLnNjcm9sbGVkKHRoaXMuY3R4LCB7XG4gICAgICAgICAgeGF4aXM6IHtcbiAgICAgICAgICAgIG1pbjogeExvd2VzdFZhbHVlLFxuICAgICAgICAgICAgbWF4OiB4SGlnaGVzdFZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gWm9vbVBhblNlbGVjdGlvbjtcbn0oVG9vbGJhcik7XG5cbnZhciBUaXRsZVN1YnRpdGxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGl0bGVTdWJ0aXRsZShjdHgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGl0bGVTdWJ0aXRsZSk7XG5cbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLncgPSBjdHgudztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaXRsZVN1YnRpdGxlLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB0aGlzLmRyYXdUaXRsZVN1YnRpdGxlKCd0aXRsZScpO1xuICAgICAgdGhpcy5kcmF3VGl0bGVTdWJ0aXRsZSgnc3VidGl0bGUnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1RpdGxlU3VidGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1RpdGxlU3VidGl0bGUodHlwZSkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgdHNDb25maWcgPSB0eXBlID09PSAndGl0bGUnID8gdy5jb25maWcudGl0bGUgOiB3LmNvbmZpZy5zdWJ0aXRsZTtcbiAgICAgIHZhciB4ID0gdy5nbG9iYWxzLnN2Z1dpZHRoIC8gMjtcbiAgICAgIHZhciB5ID0gdHNDb25maWcub2Zmc2V0WTtcbiAgICAgIHZhciB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG5cbiAgICAgIGlmICh0c0NvbmZpZy5hbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHggPSAxMDtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICB9IGVsc2UgaWYgKHRzQ29uZmlnLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHggPSB3Lmdsb2JhbHMuc3ZnV2lkdGggLSAxMDtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgfVxuXG4gICAgICB4ID0geCArIHRzQ29uZmlnLm9mZnNldFg7XG4gICAgICB5ID0geSArIHBhcnNlSW50KHRzQ29uZmlnLnN0eWxlLmZvbnRTaXplKSArIDI7XG5cbiAgICAgIGlmICh0c0NvbmZpZy50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKHRoaXMuY3R4KTtcbiAgICAgICAgdmFyIHRpdGxlVGV4dCA9IGdyYXBoaWNzLmRyYXdUZXh0KHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgdGV4dDogdHNDb25maWcudGV4dCxcbiAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxuICAgICAgICAgIGZvbnRTaXplOiB0c0NvbmZpZy5zdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiB0c0NvbmZpZy5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGZvcmVDb2xvcjogdHNDb25maWcuc3R5bGUuY29sb3IsXG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9KTtcbiAgICAgICAgdGl0bGVUZXh0Lm5vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIFwiYXBleGNoYXJ0cy1cIi5jb25jYXQodHlwZSwgXCItdGV4dFwiKSk7XG4gICAgICAgIHcuZ2xvYmFscy5kb20uUGFwZXIuYWRkKHRpdGxlVGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRpdGxlU3VidGl0bGU7XG59KCk7XG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KHJvb3QsIHJvb3QuZG9jdW1lbnQpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGV4cG9ydHMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJvb3QuZG9jdW1lbnQgPyBmYWN0b3J5KHJvb3QsIHJvb3QuZG9jdW1lbnQpIDogZnVuY3Rpb24gKHcpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KHcsIHcuZG9jdW1lbnQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5TVkcgPSBmYWN0b3J5KHJvb3QsIHJvb3QuZG9jdW1lbnQpO1xuICB9XG59KSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZCwgZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQpIHtcbiAgLy8gRmluZCBnbG9iYWwgcmVmZXJlbmNlIC0gdXNlcyAndGhpcycgYnkgZGVmYXVsdCB3aGVuIGF2YWlsYWJsZSxcbiAgLy8gZmFsbHMgYmFjayB0byAnd2luZG93JyBvdGhlcndpc2UgKGZvciBidW5kbGVycyBsaWtlIFdlYnBhY2spXG4gIHZhciBnbG9iYWxSZWYgPSB0eXBlb2YgdGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzIDogd2luZG93OyAvLyBUaGUgbWFpbiB3cmFwcGluZyBlbGVtZW50XG5cbiAgdmFyIFNWRyA9IGdsb2JhbFJlZi5TVkcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmIChTVkcuc3VwcG9ydGVkKSB7XG4gICAgICBlbGVtZW50ID0gbmV3IFNWRy5Eb2MoZWxlbWVudCk7XG5cbiAgICAgIGlmICghU1ZHLnBhcnNlci5kcmF3KSB7XG4gICAgICAgIFNWRy5wcmVwYXJlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgfTsgLy8gRGVmYXVsdCBuYW1lc3BhY2VzXG5cblxuICBTVkcubnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICBTVkcueG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuICBTVkcueGxpbmsgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG4gIFNWRy5zdmdqcyA9ICdodHRwOi8vc3ZnanMuY29tL3N2Z2pzJzsgLy8gU3ZnIHN1cHBvcnQgdGVzdFxuXG4gIFNWRy5zdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7IC8vICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmXG4gICAgLy8gICAgICEhIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkcubnMsJ3N2ZycpLmNyZWF0ZVNWR1JlY3RcbiAgfSgpOyAvLyBEb24ndCBib3RoZXIgdG8gY29udGludWUgaWYgU1ZHIGlzIG5vdCBzdXBwb3J0ZWRcblxuXG4gIGlmICghU1ZHLnN1cHBvcnRlZCkgcmV0dXJuIGZhbHNlOyAvLyBFbGVtZW50IGlkIHNlcXVlbmNlXG5cbiAgU1ZHLmRpZCA9IDEwMDA7IC8vIEdldCBuZXh0IG5hbWVkIGVsZW1lbnQgaWRcblxuICBTVkcuZWlkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gJ1N2Z2pzJyArIGNhcGl0YWxpemUobmFtZSkgKyBTVkcuZGlkKys7XG4gIH07IC8vIE1ldGhvZCBmb3IgZWxlbWVudCBjcmVhdGlvblxuXG5cbiAgU1ZHLmNyZWF0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gY3JlYXRlIGVsZW1lbnRcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCBuYW1lKTsgLy8gYXBwbHkgdW5pcXVlIGlkXG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmVpZChuYW1lKSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH07IC8vIE1ldGhvZCBmb3IgZXh0ZW5kaW5nIG9iamVjdHNcblxuXG4gIFNWRy5leHRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZHVsZXMsIG1ldGhvZHMsIGtleSwgaTsgLy8gR2V0IGxpc3Qgb2YgbW9kdWxlc1xuXG4gICAgbW9kdWxlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgLy8gR2V0IG9iamVjdCB3aXRoIGV4dGVuc2lvbnNcblxuICAgIG1ldGhvZHMgPSBtb2R1bGVzLnBvcCgpO1xuXG4gICAgZm9yIChpID0gbW9kdWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKG1vZHVsZXNbaV0pIHtcbiAgICAgICAgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICAgIG1vZHVsZXNbaV0ucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIE1ha2Ugc3VyZSBTVkcuU2V0IGluaGVyaXRzIGFueSBuZXdseSBhZGRlZCBtZXRob2RzXG5cblxuICAgIGlmIChTVkcuU2V0ICYmIFNWRy5TZXQuaW5oZXJpdCkge1xuICAgICAgU1ZHLlNldC5pbmhlcml0KCk7XG4gICAgfVxuICB9OyAvLyBJbnZlbnQgbmV3IGVsZW1lbnRcblxuXG4gIFNWRy5pbnZlbnQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgLy8gQ3JlYXRlIGVsZW1lbnQgaW5pdGlhbGl6ZXJcbiAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0eXBlb2YgY29uZmlnLmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbmZpZy5jcmVhdGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZShjb25maWcuY3JlYXRlKSk7XG4gICAgfTsgLy8gSW5oZXJpdCBwcm90b3R5cGVcblxuICAgIGlmIChjb25maWcuaW5oZXJpdCkge1xuICAgICAgaW5pdGlhbGl6ZXIucHJvdG90eXBlID0gbmV3IGNvbmZpZy5pbmhlcml0KCk7XG4gICAgfSAvLyBFeHRlbmQgd2l0aCBtZXRob2RzXG5cblxuICAgIGlmIChjb25maWcuZXh0ZW5kKSB7XG4gICAgICBTVkcuZXh0ZW5kKGluaXRpYWxpemVyLCBjb25maWcuZXh0ZW5kKTtcbiAgICB9IC8vIEF0dGFjaCBjb25zdHJ1Y3QgbWV0aG9kIHRvIHBhcmVudFxuXG5cbiAgICBpZiAoY29uZmlnLmNvbnN0cnVjdCkge1xuICAgICAgU1ZHLmV4dGVuZChjb25maWcucGFyZW50IHx8IFNWRy5Db250YWluZXIsIGNvbmZpZy5jb25zdHJ1Y3QpO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0aWFsaXplcjtcbiAgfTsgLy8gQWRvcHQgZXhpc3Rpbmcgc3ZnIGVsZW1lbnRzXG5cblxuICBTVkcuYWRvcHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIGNoZWNrIGZvciBwcmVzZW5jZSBvZiBub2RlXG4gICAgaWYgKCFub2RlKSByZXR1cm4gbnVsbDsgLy8gbWFrZSBzdXJlIGEgbm9kZSBpc24ndCBhbHJlYWR5IGFkb3B0ZWRcblxuICAgIGlmIChub2RlLmluc3RhbmNlKSByZXR1cm4gbm9kZS5pbnN0YW5jZTsgLy8gaW5pdGlhbGl6ZSB2YXJpYWJsZXNcblxuICAgIHZhciBlbGVtZW50OyAvLyBhZG9wdCB3aXRoIGVsZW1lbnQtc3BlY2lmaWMgc2V0dGluZ3NcblxuICAgIGlmIChub2RlLm5vZGVOYW1lID09ICdzdmcnKSB7XG4gICAgICBlbGVtZW50ID0gbm9kZS5wYXJlbnROb2RlIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQgPyBuZXcgU1ZHLk5lc3RlZCgpIDogbmV3IFNWRy5Eb2MoKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gJ2xpbmVhckdyYWRpZW50Jykge1xuICAgICAgZWxlbWVudCA9IG5ldyBTVkcuR3JhZGllbnQoJ2xpbmVhcicpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSAncmFkaWFsR3JhZGllbnQnKSB7XG4gICAgICBlbGVtZW50ID0gbmV3IFNWRy5HcmFkaWVudCgncmFkaWFsJyk7XG4gICAgfSBlbHNlIGlmIChTVkdbY2FwaXRhbGl6ZShub2RlLm5vZGVOYW1lKV0pIHtcbiAgICAgIGVsZW1lbnQgPSBuZXcgU1ZHW2NhcGl0YWxpemUobm9kZS5ub2RlTmFtZSldKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkVsZW1lbnQobm9kZSk7XG4gICAgfSAvLyBlbnN1cmUgcmVmZXJlbmNlc1xuXG5cbiAgICBlbGVtZW50LnR5cGUgPSBub2RlLm5vZGVOYW1lO1xuICAgIGVsZW1lbnQubm9kZSA9IG5vZGU7XG4gICAgbm9kZS5pbnN0YW5jZSA9IGVsZW1lbnQ7IC8vIFNWRy5DbGFzcyBzcGVjaWZpYyBwcmVwYXJhdGlvbnNcblxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU1ZHLkRvYykge1xuICAgICAgZWxlbWVudC5uYW1lc3BhY2UoKS5kZWZzKCk7XG4gICAgfSAvLyBwdWxsIHN2Z2pzIGRhdGEgZnJvbSB0aGUgZG9tIChnZXRBdHRyaWJ1dGVOUyBkb2Vzbid0IHdvcmsgaW4gaHRtbDUpXG5cblxuICAgIGVsZW1lbnQuc2V0RGF0YShKU09OLnBhcnNlKG5vZGUuZ2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHx8IHt9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTsgLy8gSW5pdGlhbGl6ZSBwYXJzaW5nIGVsZW1lbnRcblxuXG4gIFNWRy5wcmVwYXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFNlbGVjdCBkb2N1bWVudCBib2R5IGFuZCBjcmVhdGUgaW52aXNpYmxlIHN2ZyBlbGVtZW50XG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdLFxuICAgICAgICBkcmF3ID0gKGJvZHkgPyBuZXcgU1ZHLkRvYyhib2R5KSA6IFNWRy5hZG9wdChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLm5lc3RlZCgpKS5zaXplKDIsIDApOyAvLyBDcmVhdGUgcGFyc2VyIG9iamVjdFxuXG4gICAgU1ZHLnBhcnNlciA9IHtcbiAgICAgIGJvZHk6IGJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgZHJhdzogZHJhdy5zdHlsZSgnb3BhY2l0eTowO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTEwMCU7dG9wOi0xMDAlO292ZXJmbG93OmhpZGRlbicpLm5vZGUsXG4gICAgICBwb2x5OiBkcmF3LnBvbHlsaW5lKCkubm9kZSxcbiAgICAgIHBhdGg6IGRyYXcucGF0aCgpLm5vZGUsXG4gICAgICBuYXRpdmU6IFNWRy5jcmVhdGUoJ3N2ZycpXG4gICAgfTtcbiAgfTtcblxuICBTVkcucGFyc2VyID0ge1xuICAgIG5hdGl2ZTogU1ZHLmNyZWF0ZSgnc3ZnJylcbiAgfTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIVNWRy5wYXJzZXIuZHJhdykge1xuICAgICAgU1ZHLnByZXBhcmUoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTsgLy8gU3RvcmFnZSBmb3IgcmVndWxhciBleHByZXNzaW9uc1xuXG4gIFNWRy5yZWdleCA9IHtcbiAgICAvLyBQYXJzZSB1bml0IHZhbHVlXG4gICAgbnVtYmVyQW5kVW5pdDogL14oWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/KShbYS16JV0qKSQvaSxcbiAgICAvLyBQYXJzZSBoZXggdmFsdWVcbiAgICBoZXg6IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2ksXG4gICAgLy8gUGFyc2UgcmdiIHZhbHVlXG4gICAgcmdiOiAvcmdiXFwoKFxcZCspLChcXGQrKSwoXFxkKylcXCkvLFxuICAgIC8vIFBhcnNlIHJlZmVyZW5jZSBpZFxuICAgIHJlZmVyZW5jZTogLyMoW2EtejAtOVxcLV9dKykvaSxcbiAgICAvLyBzcGxpdHMgYSB0cmFuc2Zvcm1hdGlvbiBjaGFpblxuICAgIHRyYW5zZm9ybXM6IC9cXClcXHMqLD9cXHMqLyxcbiAgICAvLyBXaGl0ZXNwYWNlXG4gICAgd2hpdGVzcGFjZTogL1xccy9nLFxuICAgIC8vIFRlc3QgaGV4IHZhbHVlXG4gICAgaXNIZXg6IC9eI1thLWYwLTldezMsNn0kL2ksXG4gICAgLy8gVGVzdCByZ2IgdmFsdWVcbiAgICBpc1JnYjogL15yZ2JcXCgvLFxuICAgIC8vIFRlc3QgY3NzIGRlY2xhcmF0aW9uXG4gICAgaXNDc3M6IC9bXjpdKzpbXjtdKzs/LyxcbiAgICAvLyBUZXN0IGZvciBibGFuayBzdHJpbmdcbiAgICBpc0JsYW5rOiAvXihcXHMrKT8kLyxcbiAgICAvLyBUZXN0IGZvciBudW1lcmljIHN0cmluZ1xuICAgIGlzTnVtYmVyOiAvXlsrLV0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSxcbiAgICAvLyBUZXN0IGZvciBwZXJjZW50IHZhbHVlXG4gICAgaXNQZXJjZW50OiAvXi0/W1xcZFxcLl0rJSQvLFxuICAgIC8vIFRlc3QgZm9yIGltYWdlIHVybFxuICAgIGlzSW1hZ2U6IC9cXC4oanBnfGpwZWd8cG5nfGdpZnxzdmcpKFxcP1tePV0rLiopPy9pLFxuICAgIC8vIHNwbGl0IGF0IHdoaXRlc3BhY2UgYW5kIGNvbW1hXG4gICAgZGVsaW1pdGVyOiAvW1xccyxdKy8sXG4gICAgLy8gVGhlIGZvbGxvd2luZyByZWdleCBhcmUgdXNlZCB0byBwYXJzZSB0aGUgZCBhdHRyaWJ1dGUgb2YgYSBwYXRoXG4gICAgLy8gTWF0Y2hlcyBhbGwgaHlwaGVucyB3aGljaCBhcmUgbm90IGFmdGVyIGFuIGV4cG9uZW50XG4gICAgaHlwaGVuOiAvKFteZV0pXFwtL2dpLFxuICAgIC8vIFJlcGxhY2VzIGFuZCB0ZXN0cyBmb3IgYWxsIHBhdGggbGV0dGVyc1xuICAgIHBhdGhMZXR0ZXJzOiAvW01MSFZDU1FUQVpdL2dpLFxuICAgIC8vIHllcyB3ZSBuZWVkIHRoaXMgb25lLCB0b29cbiAgICBpc1BhdGhMZXR0ZXI6IC9bTUxIVkNTUVRBWl0vaSxcbiAgICAvLyBtYXRjaGVzIDAuMTU0LjIzLjQ1XG4gICAgbnVtYmVyc1dpdGhEb3RzOiAvKChcXGQ/XFwuXFxkKyg/OmVbKy1dP1xcZCspPykoKD86XFwuXFxkKyg/OmVbKy1dP1xcZCspPykrKSkrL2dpLFxuICAgIC8vIG1hdGNoZXMgLlxuICAgIGRvdHM6IC9cXC4vZ1xuICB9O1xuICBTVkcudXRpbHMgPSB7XG4gICAgLy8gTWFwIGZ1bmN0aW9uXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAoYXJyYXksIGJsb2NrKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBpbCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYmxvY2soYXJyYXlbaV0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8vIEZpbHRlciBmdW5jdGlvblxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGFycmF5LCBibG9jaykge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgaWwgPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGlmIChibG9jayhhcnJheVtpXSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIC8vIERlZ3JlZXMgdG8gcmFkaWFuc1xuICAgIHJhZGlhbnM6IGZ1bmN0aW9uIHJhZGlhbnMoZCkge1xuICAgICAgcmV0dXJuIGQgJSAzNjAgKiBNYXRoLlBJIC8gMTgwO1xuICAgIH0sXG4gICAgLy8gUmFkaWFucyB0byBkZWdyZWVzXG4gICAgZGVncmVlczogZnVuY3Rpb24gZGVncmVlcyhyKSB7XG4gICAgICByZXR1cm4gciAqIDE4MCAvIE1hdGguUEkgJSAzNjA7XG4gICAgfSxcbiAgICBmaWx0ZXJTVkdFbGVtZW50czogZnVuY3Rpb24gZmlsdGVyU1ZHRWxlbWVudHMobm9kZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihub2RlcywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50O1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBTVkcuZGVmYXVsdHMgPSB7XG4gICAgLy8gRGVmYXVsdCBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgYXR0cnM6IHtcbiAgICAgIC8vIGZpbGwgYW5kIHN0cm9rZVxuICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICAgICAnc3Ryb2tlLW9wYWNpdHknOiAxLFxuICAgICAgJ3N0cm9rZS13aWR0aCc6IDAsXG4gICAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ21pdGVyJyxcbiAgICAgICdzdHJva2UtbGluZWNhcCc6ICdidXR0JyxcbiAgICAgIGZpbGw6ICcjMDAwMDAwJyxcbiAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIC8vIHBvc2l0aW9uXG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIGN4OiAwLFxuICAgICAgY3k6IDAsXG4gICAgICAvLyBzaXplXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIC8vIHJhZGl1c1xuICAgICAgcjogMCxcbiAgICAgIHJ4OiAwLFxuICAgICAgcnk6IDAsXG4gICAgICAvLyBncmFkaWVudFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgJ3N0b3Atb3BhY2l0eSc6IDEsXG4gICAgICAnc3RvcC1jb2xvcic6ICcjMDAwMDAwJyxcbiAgICAgIC8vIHRleHRcbiAgICAgICdmb250LXNpemUnOiAxNixcbiAgICAgICdmb250LWZhbWlseSc6ICdIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJyxcbiAgICAgICd0ZXh0LWFuY2hvcic6ICdzdGFydCdcbiAgICB9IC8vIE1vZHVsZSBmb3IgY29sb3IgY29udmVydGlvbnNcblxuICB9O1xuXG4gIFNWRy5Db2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHZhciBtYXRjaDsgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuXG4gICAgdGhpcy5yID0gMDtcbiAgICB0aGlzLmcgPSAwO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgaWYgKCFjb2xvcikgcmV0dXJuOyAvLyBwYXJzZSBjb2xvclxuXG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChTVkcucmVnZXguaXNSZ2IudGVzdChjb2xvcikpIHtcbiAgICAgICAgLy8gZ2V0IHJnYiB2YWx1ZXNcbiAgICAgICAgbWF0Y2ggPSBTVkcucmVnZXgucmdiLmV4ZWMoY29sb3IucmVwbGFjZShTVkcucmVnZXgud2hpdGVzcGFjZSwgJycpKTsgLy8gcGFyc2UgbnVtZXJpYyB2YWx1ZXNcblxuICAgICAgICB0aGlzLnIgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgfSBlbHNlIGlmIChTVkcucmVnZXguaXNIZXgudGVzdChjb2xvcikpIHtcbiAgICAgICAgLy8gZ2V0IGhleCB2YWx1ZXNcbiAgICAgICAgbWF0Y2ggPSBTVkcucmVnZXguaGV4LmV4ZWMoZnVsbEhleChjb2xvcikpOyAvLyBwYXJzZSBudW1lcmljIHZhbHVlc1xuXG4gICAgICAgIHRoaXMuciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxNik7XG4gICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxNik7XG4gICAgICAgIHRoaXMuYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxNik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKGNvbG9yKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuciA9IGNvbG9yLnI7XG4gICAgICB0aGlzLmcgPSBjb2xvci5nO1xuICAgICAgdGhpcy5iID0gY29sb3IuYjtcbiAgICB9XG4gIH07XG5cbiAgU1ZHLmV4dGVuZChTVkcuQ29sb3IsIHtcbiAgICAvLyBEZWZhdWx0IHRvIGhleCBjb252ZXJzaW9uXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcbiAgICB9LFxuICAgIC8vIEJ1aWxkIGhleCB2YWx1ZVxuICAgIHRvSGV4OiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgIHJldHVybiAnIycgKyBjb21wVG9IZXgodGhpcy5yKSArIGNvbXBUb0hleCh0aGlzLmcpICsgY29tcFRvSGV4KHRoaXMuYik7XG4gICAgfSxcbiAgICAvLyBCdWlsZCByZ2IgdmFsdWVcbiAgICB0b1JnYjogZnVuY3Rpb24gdG9SZ2IoKSB7XG4gICAgICByZXR1cm4gJ3JnYignICsgW3RoaXMuciwgdGhpcy5nLCB0aGlzLmJdLmpvaW4oKSArICcpJztcbiAgICB9LFxuICAgIC8vIENhbGN1bGF0ZSB0cnVlIGJyaWdodG5lc3NcbiAgICBicmlnaHRuZXNzOiBmdW5jdGlvbiBicmlnaHRuZXNzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuciAvIDI1NSAqIDAuMzAgKyB0aGlzLmcgLyAyNTUgKiAwLjU5ICsgdGhpcy5iIC8gMjU1ICogMC4xMTtcbiAgICB9LFxuICAgIC8vIE1ha2UgY29sb3IgbW9ycGhhYmxlXG4gICAgbW9ycGg6IGZ1bmN0aW9uIG1vcnBoKGNvbG9yKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5Db2xvcihjb2xvcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEdldCBtb3JwaGVkIGNvbG9yIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpczsgLy8gbm9ybWFsaXNlIHBvc1xuXG4gICAgICBwb3MgPSBwb3MgPCAwID8gMCA6IHBvcyA+IDEgPyAxIDogcG9zOyAvLyBnZW5lcmF0ZSBtb3JwaGVkIGNvbG9yXG5cbiAgICAgIHJldHVybiBuZXcgU1ZHLkNvbG9yKHtcbiAgICAgICAgcjogfn4odGhpcy5yICsgKHRoaXMuZGVzdGluYXRpb24uciAtIHRoaXMucikgKiBwb3MpLFxuICAgICAgICBnOiB+fih0aGlzLmcgKyAodGhpcy5kZXN0aW5hdGlvbi5nIC0gdGhpcy5nKSAqIHBvcyksXG4gICAgICAgIGI6IH5+KHRoaXMuYiArICh0aGlzLmRlc3RpbmF0aW9uLmIgLSB0aGlzLmIpICogcG9zKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTsgLy8gVGVzdGVyc1xuICAvLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3Igc3RyaW5nXG5cbiAgU1ZHLkNvbG9yLnRlc3QgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICBjb2xvciArPSAnJztcbiAgICByZXR1cm4gU1ZHLnJlZ2V4LmlzSGV4LnRlc3QoY29sb3IpIHx8IFNWRy5yZWdleC5pc1JnYi50ZXN0KGNvbG9yKTtcbiAgfTsgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIHJnYiBvYmplY3RcblxuXG4gIFNWRy5Db2xvci5pc1JnYiA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHJldHVybiBjb2xvciAmJiB0eXBlb2YgY29sb3IuciA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmcgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5iID09PSAnbnVtYmVyJztcbiAgfTsgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIGNvbG9yXG5cblxuICBTVkcuQ29sb3IuaXNDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHJldHVybiBTVkcuQ29sb3IuaXNSZ2IoY29sb3IpIHx8IFNWRy5Db2xvci50ZXN0KGNvbG9yKTtcbiAgfTsgLy8gTW9kdWxlIGZvciBhcnJheSBjb252ZXJzaW9uXG5cblxuICBTVkcuQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIGZhbGxiYWNrKSB7XG4gICAgYXJyYXkgPSAoYXJyYXkgfHwgW10pLnZhbHVlT2YoKTsgLy8gaWYgYXJyYXkgaXMgZW1wdHkgYW5kIGZhbGxiYWNrIGlzIHByb3ZpZGVkLCB1c2UgZmFsbGJhY2tcblxuICAgIGlmIChhcnJheS5sZW5ndGggPT0gMCAmJiBmYWxsYmFjaykge1xuICAgICAgYXJyYXkgPSBmYWxsYmFjay52YWx1ZU9mKCk7XG4gICAgfSAvLyBwYXJzZSBhcnJheVxuXG5cbiAgICB0aGlzLnZhbHVlID0gdGhpcy5wYXJzZShhcnJheSk7XG4gIH07XG5cbiAgU1ZHLmV4dGVuZChTVkcuQXJyYXksIHtcbiAgICAvLyBNYWtlIGFycmF5IG1vcnBoYWJsZVxuICAgIG1vcnBoOiBmdW5jdGlvbiBtb3JwaChhcnJheSkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IHRoaXMucGFyc2UoYXJyYXkpOyAvLyBub3JtYWxpemUgbGVuZ3RoIG9mIGFycmF5c1xuXG4gICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggIT0gdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHRoaXMudmFsdWVbdGhpcy52YWx1ZS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGxhc3REZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb25bdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGggLSAxXTtcblxuICAgICAgICB3aGlsZSAodGhpcy52YWx1ZS5sZW5ndGggPiB0aGlzLmRlc3RpbmF0aW9uLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ucHVzaChsYXN0RGVzdGluYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRoaXMudmFsdWUubGVuZ3RoIDwgdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlLnB1c2gobGFzdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIENsZWFuIHVwIGFueSBkdXBsaWNhdGUgcG9pbnRzXG4gICAgc2V0dGxlOiBmdW5jdGlvbiBzZXR0bGUoKSB7XG4gICAgICAvLyBmaW5kIGFsbCB1bmlxdWUgdmFsdWVzXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgc2VlbiA9IFtdOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHRoaXMudmFsdWVbaV0pID09IC0xKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKHRoaXMudmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIHNldCBuZXcgdmFsdWVcblxuXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSA9IHNlZW47XG4gICAgfSxcbiAgICAvLyBHZXQgbW9ycGhlZCBhcnJheSBhdCBnaXZlbiBwb3NpdGlvblxuICAgIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcbiAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXM7IC8vIGdlbmVyYXRlIG1vcnBoZWQgYXJyYXlcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy52YWx1ZS5sZW5ndGgsIGFycmF5ID0gW107IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGFycmF5LnB1c2godGhpcy52YWx1ZVtpXSArICh0aGlzLmRlc3RpbmF0aW9uW2ldIC0gdGhpcy52YWx1ZVtpXSkgKiBwb3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFNWRy5BcnJheShhcnJheSk7XG4gICAgfSxcbiAgICAvLyBDb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlLmpvaW4oJyAnKTtcbiAgICB9LFxuICAgIC8vIFJlYWwgdmFsdWVcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfSxcbiAgICAvLyBQYXJzZSB3aGl0ZXNwYWNlIHNlcGFyYXRlZCBzdHJpbmdcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYXJyYXkpIHtcbiAgICAgIGFycmF5ID0gYXJyYXkudmFsdWVPZigpOyAvLyBpZiBhbHJlYWR5IGlzIGFuIGFycmF5LCBubyBuZWVkIHRvIHBhcnNlIGl0XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkgcmV0dXJuIGFycmF5O1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoYXJyYXkpO1xuICAgIH0sXG4gICAgLy8gU3RyaXAgdW5uZWNlc3Nhcnkgd2hpdGVzcGFjZVxuICAgIHNwbGl0OiBmdW5jdGlvbiBzcGxpdChzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KTtcbiAgICB9LFxuICAgIC8vIFJldmVyc2UgYXJyYXlcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgdGhpcy52YWx1ZS5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICBjbG9uZS52YWx1ZSA9IGFycmF5X2Nsb25lKHRoaXMudmFsdWUpO1xuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgfSk7IC8vIFBvbHkgcG9pbnRzIGFycmF5XG5cbiAgU1ZHLlBvaW50QXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIGZhbGxiYWNrKSB7XG4gICAgU1ZHLkFycmF5LmNhbGwodGhpcywgYXJyYXksIGZhbGxiYWNrIHx8IFtbMCwgMF1dKTtcbiAgfTsgLy8gSW5oZXJpdCBmcm9tIFNWRy5BcnJheVxuXG5cbiAgU1ZHLlBvaW50QXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheSgpO1xuICBTVkcuUG9pbnRBcnJheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkcuUG9pbnRBcnJheTtcbiAgU1ZHLmV4dGVuZChTVkcuUG9pbnRBcnJheSwge1xuICAgIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgLy8gY29udmVydCB0byBhIHBvbHkgcG9pbnQgc3RyaW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgYXJyYXkucHVzaCh0aGlzLnZhbHVlW2ldLmpvaW4oJywnKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheS5qb2luKCcgJyk7XG4gICAgfSxcbiAgICAvLyBDb252ZXJ0IGFycmF5IHRvIGxpbmUgb2JqZWN0XG4gICAgdG9MaW5lOiBmdW5jdGlvbiB0b0xpbmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogdGhpcy52YWx1ZVswXVswXSxcbiAgICAgICAgeTE6IHRoaXMudmFsdWVbMF1bMV0sXG4gICAgICAgIHgyOiB0aGlzLnZhbHVlWzFdWzBdLFxuICAgICAgICB5MjogdGhpcy52YWx1ZVsxXVsxXVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIEdldCBtb3JwaGVkIGFycmF5IGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpczsgLy8gZ2VuZXJhdGUgbW9ycGhlZCBwb2ludCBzdHJpbmdcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy52YWx1ZS5sZW5ndGgsIGFycmF5ID0gW107IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGFycmF5LnB1c2goW3RoaXMudmFsdWVbaV1bMF0gKyAodGhpcy5kZXN0aW5hdGlvbltpXVswXSAtIHRoaXMudmFsdWVbaV1bMF0pICogcG9zLCB0aGlzLnZhbHVlW2ldWzFdICsgKHRoaXMuZGVzdGluYXRpb25baV1bMV0gLSB0aGlzLnZhbHVlW2ldWzFdKSAqIHBvc10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludEFycmF5KGFycmF5KTtcbiAgICB9LFxuICAgIC8vIFBhcnNlIHBvaW50IHN0cmluZyBhbmQgZmxhdCBhcnJheVxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShhcnJheSkge1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgYXJyYXkgPSBhcnJheS52YWx1ZU9mKCk7IC8vIGlmIGl0IGlzIGFuIGFycmF5XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAvLyBhbmQgaXQgaXMgbm90IGZsYXQsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcGFyc2UgaXRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbMF0pKSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHVzZSBhIGNsb25lXG4gICAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5zbGljZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5WzBdLnggIT0gbnVsbCkge1xuICAgICAgICAgIC8vIGFsbG93IHBvaW50IG9iamVjdHMgdG8gYmUgcGFzc2VkXG4gICAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWwueCwgZWwueV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVsc2UsIGl0IGlzIGNvbnNpZGVyZWQgYXMgYSBzdHJpbmdcbiAgICAgICAgLy8gcGFyc2UgcG9pbnRzXG4gICAgICAgIGFycmF5ID0gYXJyYXkudHJpbSgpLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KTtcbiAgICAgIH0gLy8gdmFsaWRhdGUgcG9pbnRzIC0gaHR0cHM6Ly9zdmd3Zy5vcmcvc3ZnMi1kcmFmdC9zaGFwZXMuaHRtbCNEYXRhVHlwZVBvaW50c1xuICAgICAgLy8gT2RkIG51bWJlciBvZiBjb29yZGluYXRlcyBpcyBhbiBlcnJvci4gSW4gc3VjaCBjYXNlcywgZHJvcCB0aGUgbGFzdCBvZGQgY29vcmRpbmF0ZS5cblxuXG4gICAgICBpZiAoYXJyYXkubGVuZ3RoICUgMiAhPT0gMCkgYXJyYXkucG9wKCk7IC8vIHdyYXAgcG9pbnRzIGluIHR3by10dXBsZXMgYW5kIHBhcnNlIHBvaW50cyBhcyBmbG9hdHNcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSA9IGkgKyAyKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFthcnJheVtpXSwgYXJyYXlbaSArIDFdXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfSxcbiAgICAvLyBNb3ZlIHBvaW50IHN0cmluZ1xuICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgICAgdmFyIGJveCA9IHRoaXMuYmJveCgpOyAvLyBnZXQgcmVsYXRpdmUgb2Zmc2V0XG5cbiAgICAgIHggLT0gYm94Lng7XG4gICAgICB5IC09IGJveC55OyAvLyBtb3ZlIGV2ZXJ5IHBvaW50XG5cbiAgICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXSA9IFt0aGlzLnZhbHVlW2ldWzBdICsgeCwgdGhpcy52YWx1ZVtpXVsxXSArIHldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gUmVzaXplIHBvbHkgc3RyaW5nXG4gICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBib3ggPSB0aGlzLmJib3goKTsgLy8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb2YgYWxsIHBvaW50cyBhY2NvcmRpbmcgdG8gbmV3IHNpemVcblxuICAgICAgZm9yIChpID0gdGhpcy52YWx1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoYm94LndpZHRoKSB0aGlzLnZhbHVlW2ldWzBdID0gKHRoaXMudmFsdWVbaV1bMF0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICBpZiAoYm94LmhlaWdodCkgdGhpcy52YWx1ZVtpXVsxXSA9ICh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEdldCBib3VuZGluZyBib3ggb2YgcG9pbnRzXG4gICAgYmJveDogZnVuY3Rpb24gYmJveCgpIHtcbiAgICAgIGlmICghU1ZHLnBhcnNlci5kcmF3KSB7XG4gICAgICAgIFNWRy5wcmVwYXJlKCk7XG4gICAgICB9XG5cbiAgICAgIFNWRy5wYXJzZXIucG9seS5zZXRBdHRyaWJ1dGUoJ3BvaW50cycsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICByZXR1cm4gU1ZHLnBhcnNlci5wb2x5LmdldEJCb3goKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgcGF0aEhhbmRsZXJzID0ge1xuICAgIE06IGZ1bmN0aW9uIE0oYywgcCwgcDApIHtcbiAgICAgIHAueCA9IHAwLnggPSBjWzBdO1xuICAgICAgcC55ID0gcDAueSA9IGNbMV07XG4gICAgICByZXR1cm4gWydNJywgcC54LCBwLnldO1xuICAgIH0sXG4gICAgTDogZnVuY3Rpb24gTChjLCBwKSB7XG4gICAgICBwLnggPSBjWzBdO1xuICAgICAgcC55ID0gY1sxXTtcbiAgICAgIHJldHVybiBbJ0wnLCBjWzBdLCBjWzFdXTtcbiAgICB9LFxuICAgIEg6IGZ1bmN0aW9uIEgoYywgcCkge1xuICAgICAgcC54ID0gY1swXTtcbiAgICAgIHJldHVybiBbJ0gnLCBjWzBdXTtcbiAgICB9LFxuICAgIFY6IGZ1bmN0aW9uIFYoYywgcCkge1xuICAgICAgcC55ID0gY1swXTtcbiAgICAgIHJldHVybiBbJ1YnLCBjWzBdXTtcbiAgICB9LFxuICAgIEM6IGZ1bmN0aW9uIEMoYywgcCkge1xuICAgICAgcC54ID0gY1s0XTtcbiAgICAgIHAueSA9IGNbNV07XG4gICAgICByZXR1cm4gWydDJywgY1swXSwgY1sxXSwgY1syXSwgY1szXSwgY1s0XSwgY1s1XV07XG4gICAgfSxcbiAgICBTOiBmdW5jdGlvbiBTKGMsIHApIHtcbiAgICAgIHAueCA9IGNbMl07XG4gICAgICBwLnkgPSBjWzNdO1xuICAgICAgcmV0dXJuIFsnUycsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM11dO1xuICAgIH0sXG4gICAgUTogZnVuY3Rpb24gUShjLCBwKSB7XG4gICAgICBwLnggPSBjWzJdO1xuICAgICAgcC55ID0gY1szXTtcbiAgICAgIHJldHVybiBbJ1EnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdXTtcbiAgICB9LFxuICAgIFQ6IGZ1bmN0aW9uIFQoYywgcCkge1xuICAgICAgcC54ID0gY1swXTtcbiAgICAgIHAueSA9IGNbMV07XG4gICAgICByZXR1cm4gWydUJywgY1swXSwgY1sxXV07XG4gICAgfSxcbiAgICBaOiBmdW5jdGlvbiBaKGMsIHAsIHAwKSB7XG4gICAgICBwLnggPSBwMC54O1xuICAgICAgcC55ID0gcDAueTtcbiAgICAgIHJldHVybiBbJ1onXTtcbiAgICB9LFxuICAgIEE6IGZ1bmN0aW9uIEEoYywgcCkge1xuICAgICAgcC54ID0gY1s1XTtcbiAgICAgIHAueSA9IGNbNl07XG4gICAgICByZXR1cm4gWydBJywgY1swXSwgY1sxXSwgY1syXSwgY1szXSwgY1s0XSwgY1s1XSwgY1s2XV07XG4gICAgfVxuICB9O1xuICB2YXIgbWxodnF0Y3NhID0gJ21saHZxdGNzYXonLnNwbGl0KCcnKTtcblxuICBmb3IgKHZhciBpID0gMCwgaWwgPSBtbGh2cXRjc2EubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIHBhdGhIYW5kbGVyc1ttbGh2cXRjc2FbaV1dID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYywgcCwgcDApIHtcbiAgICAgICAgaWYgKGkgPT0gJ0gnKSBjWzBdID0gY1swXSArIHAueDtlbHNlIGlmIChpID09ICdWJykgY1swXSA9IGNbMF0gKyBwLnk7ZWxzZSBpZiAoaSA9PSAnQScpIHtcbiAgICAgICAgICBjWzVdID0gY1s1XSArIHAueCwgY1s2XSA9IGNbNl0gKyBwLnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsID0gYy5sZW5ndGg7IGogPCBqbDsgKytqKSB7XG4gICAgICAgICAgICBjW2pdID0gY1tqXSArIChqICUgMiA/IHAueSA6IHAueCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoSGFuZGxlcnNbaV0oYywgcCwgcDApO1xuICAgICAgfTtcbiAgICB9KG1saHZxdGNzYVtpXS50b1VwcGVyQ2FzZSgpKTtcbiAgfSAvLyBQYXRoIHBvaW50cyBhcnJheVxuXG5cbiAgU1ZHLlBhdGhBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgZmFsbGJhY2spIHtcbiAgICBTVkcuQXJyYXkuY2FsbCh0aGlzLCBhcnJheSwgZmFsbGJhY2sgfHwgW1snTScsIDAsIDBdXSk7XG4gIH07IC8vIEluaGVyaXQgZnJvbSBTVkcuQXJyYXlcblxuXG4gIFNWRy5QYXRoQXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheSgpO1xuICBTVkcuUGF0aEFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWRy5QYXRoQXJyYXk7XG4gIFNWRy5leHRlbmQoU1ZHLlBhdGhBcnJheSwge1xuICAgIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGFycmF5VG9TdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgfSxcbiAgICAvLyBNb3ZlIHBhdGggc3RyaW5nXG4gICAgbW92ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICAvLyBnZXQgYm91bmRpbmcgYm94IG9mIGN1cnJlbnQgc2l0dWF0aW9uXG4gICAgICB2YXIgYm94ID0gdGhpcy5iYm94KCk7IC8vIGdldCByZWxhdGl2ZSBvZmZzZXRcblxuICAgICAgeCAtPSBib3gueDtcbiAgICAgIHkgLT0gYm94Lnk7XG5cbiAgICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XG4gICAgICAgIC8vIG1vdmUgZXZlcnkgcG9pbnRcbiAgICAgICAgZm9yICh2YXIgbCwgaSA9IHRoaXMudmFsdWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBsID0gdGhpcy52YWx1ZVtpXVswXTtcblxuICAgICAgICAgIGlmIChsID09ICdNJyB8fCBsID09ICdMJyB8fCBsID09ICdUJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB4O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsyXSArPSB5O1xuICAgICAgICAgIH0gZWxzZSBpZiAobCA9PSAnSCcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gKz0geDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ1YnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdICs9IHk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsID09ICdDJyB8fCBsID09ICdTJyB8fCBsID09ICdRJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB4O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVsyXSArPSB5O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVszXSArPSB4O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs0XSArPSB5O1xuXG4gICAgICAgICAgICBpZiAobCA9PSAnQycpIHtcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs1XSArPSB4O1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzZdICs9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsID09ICdBJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs2XSArPSB4O1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs3XSArPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIFJlc2l6ZSBwYXRoIHN0cmluZ1xuICAgIHNpemU6IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgLy8gZ2V0IGJvdW5kaW5nIGJveCBvZiBjdXJyZW50IHNpdHVhdGlvblxuICAgICAgdmFyIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBib3ggPSB0aGlzLmJib3goKTsgLy8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb2YgYWxsIHBvaW50cyBhY2NvcmRpbmcgdG8gbmV3IHNpemVcblxuICAgICAgZm9yIChpID0gdGhpcy52YWx1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsID0gdGhpcy52YWx1ZVtpXVswXTtcblxuICAgICAgICBpZiAobCA9PSAnTScgfHwgbCA9PSAnTCcgfHwgbCA9PSAnVCcpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSAodGhpcy52YWx1ZVtpXVsyXSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdIJykge1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAodGhpcy52YWx1ZVtpXVsxXSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAnVicpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueSkgKiBoZWlnaHQgLyBib3guaGVpZ2h0ICsgYm94Lnk7XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAnQycgfHwgbCA9PSAnUycgfHwgbCA9PSAnUScpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKHRoaXMudmFsdWVbaV1bMV0gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSAodGhpcy52YWx1ZVtpXVsyXSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzNdID0gKHRoaXMudmFsdWVbaV1bM10gLSBib3gueCkgKiB3aWR0aCAvIGJveC53aWR0aCArIGJveC54O1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bNF0gPSAodGhpcy52YWx1ZVtpXVs0XSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcblxuICAgICAgICAgIGlmIChsID09ICdDJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXVs1XSA9ICh0aGlzLnZhbHVlW2ldWzVdIC0gYm94LngpICogd2lkdGggLyBib3gud2lkdGggKyBib3gueDtcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gPSAodGhpcy52YWx1ZVtpXVs2XSAtIGJveC55KSAqIGhlaWdodCAvIGJveC5oZWlnaHQgKyBib3gueTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAnQScpIHtcbiAgICAgICAgICAvLyByZXNpemUgcmFkaWlcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gdGhpcy52YWx1ZVtpXVsxXSAqIHdpZHRoIC8gYm94LndpZHRoO1xuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSB0aGlzLnZhbHVlW2ldWzJdICogaGVpZ2h0IC8gYm94LmhlaWdodDsgLy8gbW92ZSBwb3NpdGlvbiB2YWx1ZXNcblxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gPSAodGhpcy52YWx1ZVtpXVs2XSAtIGJveC54KSAqIHdpZHRoIC8gYm94LndpZHRoICsgYm94Lng7XG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs3XSA9ICh0aGlzLnZhbHVlW2ldWzddIC0gYm94LnkpICogaGVpZ2h0IC8gYm94LmhlaWdodCArIGJveC55O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gVGVzdCBpZiB0aGUgcGFzc2VkIHBhdGggYXJyYXkgdXNlIHRoZSBzYW1lIHBhdGggZGF0YSBjb21tYW5kcyBhcyB0aGlzIHBhdGggYXJyYXlcbiAgICBlcXVhbENvbW1hbmRzOiBmdW5jdGlvbiBlcXVhbENvbW1hbmRzKHBhdGhBcnJheSkge1xuICAgICAgdmFyIGksIGlsLCBlcXVhbENvbW1hbmRzO1xuICAgICAgcGF0aEFycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkocGF0aEFycmF5KTtcbiAgICAgIGVxdWFsQ29tbWFuZHMgPSB0aGlzLnZhbHVlLmxlbmd0aCA9PT0gcGF0aEFycmF5LnZhbHVlLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aDsgZXF1YWxDb21tYW5kcyAmJiBpIDwgaWw7IGkrKykge1xuICAgICAgICBlcXVhbENvbW1hbmRzID0gdGhpcy52YWx1ZVtpXVswXSA9PT0gcGF0aEFycmF5LnZhbHVlW2ldWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXF1YWxDb21tYW5kcztcbiAgICB9LFxuICAgIC8vIE1ha2UgcGF0aCBhcnJheSBtb3JwaGFibGVcbiAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgocGF0aEFycmF5KSB7XG4gICAgICBwYXRoQXJyYXkgPSBuZXcgU1ZHLlBhdGhBcnJheShwYXRoQXJyYXkpO1xuXG4gICAgICBpZiAodGhpcy5lcXVhbENvbW1hbmRzKHBhdGhBcnJheSkpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IHBhdGhBcnJheTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEdldCBtb3JwaGVkIHBhdGggYXJyYXkgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXG4gICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNvdXJjZUFycmF5ID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBkZXN0aW5hdGlvbkFycmF5ID0gdGhpcy5kZXN0aW5hdGlvbi52YWx1ZSxcbiAgICAgICAgICBhcnJheSA9IFtdLFxuICAgICAgICAgIHBhdGhBcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KCksXG4gICAgICAgICAgaSxcbiAgICAgICAgICBpbCxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGpsOyAvLyBBbmltYXRlIGhhcyBzcGVjaWZpZWQgaW4gdGhlIFNWRyBzcGVjXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYXRocy5odG1sI1BhdGhFbGVtZW50XG5cbiAgICAgIGZvciAoaSA9IDAsIGlsID0gc291cmNlQXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IFtzb3VyY2VBcnJheVtpXVswXV07XG5cbiAgICAgICAgZm9yIChqID0gMSwgamwgPSBzb3VyY2VBcnJheVtpXS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgYXJyYXlbaV1bal0gPSBzb3VyY2VBcnJheVtpXVtqXSArIChkZXN0aW5hdGlvbkFycmF5W2ldW2pdIC0gc291cmNlQXJyYXlbaV1bal0pICogcG9zO1xuICAgICAgICB9IC8vIEZvciB0aGUgdHdvIGZsYWdzIG9mIHRoZSBlbGxpcHRpY2FsIGFyYyBjb21tYW5kLCB0aGUgU1ZHIHNwZWMgc2F5OlxuICAgICAgICAvLyBGbGFncyBhbmQgYm9vbGVhbnMgYXJlIGludGVycG9sYXRlZCBhcyBmcmFjdGlvbnMgYmV0d2VlbiB6ZXJvIGFuZCBvbmUsIHdpdGggYW55IG5vbi16ZXJvIHZhbHVlIGNvbnNpZGVyZWQgdG8gYmUgYSB2YWx1ZSBvZiBvbmUvdHJ1ZVxuICAgICAgICAvLyBFbGxpcHRpY2FsIGFyYyBjb21tYW5kIGFzIGFuIGFycmF5IGZvbGxvd2VkIGJ5IGNvcnJlc3BvbmRpbmcgaW5kZXhlczpcbiAgICAgICAgLy8gWydBJywgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxuICAgICAgICAvLyAgIDAgICAgMSAgIDIgICAgICAgIDMgICAgICAgICAgICAgICAgIDQgICAgICAgICAgICAgNSAgICAgIDYgIDdcblxuXG4gICAgICAgIGlmIChhcnJheVtpXVswXSA9PT0gJ0EnKSB7XG4gICAgICAgICAgYXJyYXlbaV1bNF0gPSArKGFycmF5W2ldWzRdICE9IDApO1xuICAgICAgICAgIGFycmF5W2ldWzVdID0gKyhhcnJheVtpXVs1XSAhPSAwKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBEaXJlY3RseSBtb2RpZnkgdGhlIHZhbHVlIG9mIGEgcGF0aCBhcnJheSwgdGhpcyBpcyBkb25lIHRoaXMgd2F5IGZvciBwZXJmb3JtYW5jZVxuXG5cbiAgICAgIHBhdGhBcnJheS52YWx1ZSA9IGFycmF5O1xuICAgICAgcmV0dXJuIHBhdGhBcnJheTtcbiAgICB9LFxuICAgIC8vIEFic29sdXRpemUgYW5kIHBhcnNlIHBhdGggdG8gYXJyYXlcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoYXJyYXkpIHtcbiAgICAgIC8vIGlmIGl0J3MgYWxyZWFkeSBhIHBhdGhhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxuICAgICAgaWYgKGFycmF5IGluc3RhbmNlb2YgU1ZHLlBhdGhBcnJheSkgcmV0dXJuIGFycmF5LnZhbHVlT2YoKTsgLy8gcHJlcGFyZSBmb3IgcGFyc2luZ1xuXG4gICAgICB2YXIgcyxcbiAgICAgICAgICBhcnIsXG4gICAgICAgICAgcGFyYW1DbnQgPSB7XG4gICAgICAgICdNJzogMixcbiAgICAgICAgJ0wnOiAyLFxuICAgICAgICAnSCc6IDEsXG4gICAgICAgICdWJzogMSxcbiAgICAgICAgJ0MnOiA2LFxuICAgICAgICAnUyc6IDQsXG4gICAgICAgICdRJzogNCxcbiAgICAgICAgJ1QnOiAyLFxuICAgICAgICAnQSc6IDcsXG4gICAgICAgICdaJzogMFxuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiBhcnJheSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXJyYXkgPSBhcnJheS5yZXBsYWNlKFNWRy5yZWdleC5udW1iZXJzV2l0aERvdHMsIHBhdGhSZWdSZXBsYWNlKSAvLyBjb252ZXJ0IDQ1LjEyMy4xMjMgdG8gNDUuMTIzIC4xMjNcbiAgICAgICAgLnJlcGxhY2UoU1ZHLnJlZ2V4LnBhdGhMZXR0ZXJzLCAnICQmICcpIC8vIHB1dCBzb21lIHJvb20gYmV0d2VlbiBsZXR0ZXJzIGFuZCBudW1iZXJzXG4gICAgICAgIC5yZXBsYWNlKFNWRy5yZWdleC5oeXBoZW4sICckMSAtJykgLy8gYWRkIHNwYWNlIGJlZm9yZSBoeXBoZW5cbiAgICAgICAgLnRyaW0oKSAvLyB0cmltXG4gICAgICAgIC5zcGxpdChTVkcucmVnZXguZGVsaW1pdGVyKTsgLy8gc3BsaXQgaW50byBhcnJheVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXkgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcbiAgICAgICAgICByZXR1cm4gW10uY29uY2F0LmNhbGwocHJldiwgY3Vycik7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgIH0gLy8gYXJyYXkgbm93IGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHBhcnRzIG9mIGEgcGF0aCBlLmcuIFsnTScsICcwJywgJzAnLCAnTCcsICczMCcsICczMCcgLi4uXVxuXG5cbiAgICAgIHZhciBhcnIgPSBbXSxcbiAgICAgICAgICBwID0gbmV3IFNWRy5Qb2ludCgpLFxuICAgICAgICAgIHAwID0gbmV3IFNWRy5Qb2ludCgpLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgLy8gVGVzdCBpZiB3ZSBoYXZlIGEgcGF0aCBsZXR0ZXJcbiAgICAgICAgaWYgKFNWRy5yZWdleC5pc1BhdGhMZXR0ZXIudGVzdChhcnJheVtpbmRleF0pKSB7XG4gICAgICAgICAgcyA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgICArK2luZGV4OyAvLyBJZiBsYXN0IGxldHRlciB3YXMgYSBtb3ZlIGNvbW1hbmQgYW5kIHdlIGdvdCBubyBuZXcsIGl0IGRlZmF1bHRzIHRvIFtMXWluZVxuICAgICAgICB9IGVsc2UgaWYgKHMgPT0gJ00nKSB7XG4gICAgICAgICAgcyA9ICdMJztcbiAgICAgICAgfSBlbHNlIGlmIChzID09ICdtJykge1xuICAgICAgICAgIHMgPSAnbCc7XG4gICAgICAgIH1cblxuICAgICAgICBhcnIucHVzaChwYXRoSGFuZGxlcnNbc10uY2FsbChudWxsLCBhcnJheS5zbGljZShpbmRleCwgaW5kZXggPSBpbmRleCArIHBhcmFtQ250W3MudG9VcHBlckNhc2UoKV0pLm1hcChwYXJzZUZsb2F0KSwgcCwgcDApKTtcbiAgICAgIH0gd2hpbGUgKGxlbiA+IGluZGV4KTtcblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIC8vIEdldCBib3VuZGluZyBib3ggb2YgcGF0aFxuICAgIGJib3g6IGZ1bmN0aW9uIGJib3goKSB7XG4gICAgICBpZiAoIVNWRy5wYXJzZXIuZHJhdykge1xuICAgICAgICBTVkcucHJlcGFyZSgpO1xuICAgICAgfVxuXG4gICAgICBTVkcucGFyc2VyLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy50b1N0cmluZygpKTtcbiAgICAgIHJldHVybiBTVkcucGFyc2VyLnBhdGguZ2V0QkJveCgpO1xuICAgIH1cbiAgfSk7IC8vIE1vZHVsZSBmb3IgdW5pdCBjb252ZXJ0aW9uc1xuXG4gIFNWRy5OdW1iZXIgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUsIHVuaXQpIHtcbiAgICAgIC8vIGluaXRpYWxpemUgZGVmYXVsdHNcbiAgICAgIHRoaXMudmFsdWUgPSAwO1xuICAgICAgdGhpcy51bml0ID0gdW5pdCB8fCAnJzsgLy8gcGFyc2UgdmFsdWVcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gZW5zdXJlIGEgdmFsaWQgbnVtZXJpYyB2YWx1ZVxuICAgICAgICB0aGlzLnZhbHVlID0gaXNOYU4odmFsdWUpID8gMCA6ICFpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA8IDAgPyAtMy40ZSszOCA6ICszLjRlKzM4IDogdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdW5pdCA9IHZhbHVlLm1hdGNoKFNWRy5yZWdleC5udW1iZXJBbmRVbml0KTtcblxuICAgICAgICBpZiAodW5pdCkge1xuICAgICAgICAgIC8vIG1ha2UgdmFsdWUgbnVtZXJpY1xuICAgICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHVuaXRbMV0pOyAvLyBub3JtYWxpemVcblxuICAgICAgICAgIGlmICh1bml0WzVdID09ICclJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSAvPSAxMDA7XG4gICAgICAgICAgfSBlbHNlIGlmICh1bml0WzVdID09ICdzJykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSAqPSAxMDAwO1xuICAgICAgICAgIH0gLy8gc3RvcmUgdW5pdFxuXG5cbiAgICAgICAgICB0aGlzLnVuaXQgPSB1bml0WzVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTVkcuTnVtYmVyKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgICB0aGlzLnVuaXQgPSB2YWx1ZS51bml0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gU3RyaW5nYWxpemVcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVuaXQgPT0gJyUnID8gfn4odGhpcy52YWx1ZSAqIDFlOCkgLyAxZTYgOiB0aGlzLnVuaXQgPT0gJ3MnID8gdGhpcy52YWx1ZSAvIDFlMyA6IHRoaXMudmFsdWUpICsgdGhpcy51bml0O1xuICAgICAgfSxcbiAgICAgIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgICAgfSxcbiAgICAgIC8vIENvbnZlcnQgdG8gcHJpbWl0aXZlXG4gICAgICB2YWx1ZU9mOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgbnVtYmVyXG4gICAgICBwbHVzOiBmdW5jdGlvbiBwbHVzKG51bWJlcikge1xuICAgICAgICBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcyArIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KTtcbiAgICAgIH0sXG4gICAgICAvLyBTdWJ0cmFjdCBudW1iZXJcbiAgICAgIG1pbnVzOiBmdW5jdGlvbiBtaW51cyhudW1iZXIpIHtcbiAgICAgICAgbnVtYmVyID0gbmV3IFNWRy5OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKHRoaXMgLSBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdCk7XG4gICAgICB9LFxuICAgICAgLy8gTXVsdGlwbHkgbnVtYmVyXG4gICAgICB0aW1lczogZnVuY3Rpb24gdGltZXMobnVtYmVyKSB7XG4gICAgICAgIG51bWJlciA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzICogbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpO1xuICAgICAgfSxcbiAgICAgIC8vIERpdmlkZSBudW1iZXJcbiAgICAgIGRpdmlkZTogZnVuY3Rpb24gZGl2aWRlKG51bWJlcikge1xuICAgICAgICBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcyAvIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KTtcbiAgICAgIH0sXG4gICAgICAvLyBDb252ZXJ0IHRvIGRpZmZlcmVudCB1bml0XG4gICAgICB0bzogZnVuY3Rpb24gdG8odW5pdCkge1xuICAgICAgICB2YXIgbnVtYmVyID0gbmV3IFNWRy5OdW1iZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB1bml0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG51bWJlci51bml0ID0gdW5pdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICB9LFxuICAgICAgLy8gTWFrZSBudW1iZXIgbW9ycGhhYmxlXG4gICAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgobnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpO1xuXG4gICAgICAgIGlmIChudW1iZXIucmVsYXRpdmUpIHtcbiAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLnZhbHVlICs9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgbW9ycGhlZCBudW1iZXIgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICAgIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzOyAvLyBHZW5lcmF0ZSBuZXcgbW9ycGhlZCBudW1iZXJcblxuICAgICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcy5kZXN0aW5hdGlvbikubWludXModGhpcykudGltZXMocG9zKS5wbHVzKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5FbGVtZW50ID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUobm9kZSkge1xuICAgICAgLy8gbWFrZSBzdHJva2UgdmFsdWUgYWNjZXNzaWJsZSBkeW5hbWljYWxseVxuICAgICAgdGhpcy5fc3Ryb2tlID0gU1ZHLmRlZmF1bHRzLmF0dHJzLnN0cm9rZTtcbiAgICAgIHRoaXMuX2V2ZW50ID0gbnVsbDsgLy8gaW5pdGlhbGl6ZSBkYXRhIG9iamVjdFxuXG4gICAgICB0aGlzLmRvbSA9IHt9OyAvLyBjcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlXG5cbiAgICAgIGlmICh0aGlzLm5vZGUgPSBub2RlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUubm9kZU5hbWU7XG4gICAgICAgIHRoaXMubm9kZS5pbnN0YW5jZSA9IHRoaXM7IC8vIHN0b3JlIGN1cnJlbnQgYXR0cmlidXRlIHZhbHVlXG5cbiAgICAgICAgdGhpcy5fc3Ryb2tlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpIHx8IHRoaXMuX3N0cm9rZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgICB4OiBmdW5jdGlvbiB4KF94KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnLCBfeCk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBvdmVyIHktYXhpc1xuICAgICAgeTogZnVuY3Rpb24geShfeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgX3kpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeC1heGlzXG4gICAgICBjeDogZnVuY3Rpb24gY3goeCkge1xuICAgICAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy54KCkgKyB0aGlzLndpZHRoKCkgLyAyIDogdGhpcy54KHggLSB0aGlzLndpZHRoKCkgLyAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICAgICAgY3k6IGZ1bmN0aW9uIGN5KHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMueSgpICsgdGhpcy5oZWlnaHQoKSAvIDIgOiB0aGlzLnkoeSAtIHRoaXMuaGVpZ2h0KCkgLyAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGVsZW1lbnQgdG8gZ2l2ZW4geCBhbmQgeSB2YWx1ZXNcbiAgICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy54KHgpLnkoeSk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBlbGVtZW50IGJ5IGl0cyBjZW50ZXJcbiAgICAgIGNlbnRlcjogZnVuY3Rpb24gY2VudGVyKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSk7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChfd2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignd2lkdGgnLCBfd2lkdGgpO1xuICAgICAgfSxcbiAgICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICAgICAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoX2hlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdoZWlnaHQnLCBfaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgIHNpemU6IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoKG5ldyBTVkcuTnVtYmVyKHAud2lkdGgpKS5oZWlnaHQobmV3IFNWRy5OdW1iZXIocC5oZWlnaHQpKTtcbiAgICAgIH0sXG4gICAgICAvLyBDbG9uZSBlbGVtZW50XG4gICAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUocGFyZW50KSB7XG4gICAgICAgIC8vIHdyaXRlIGRvbSBkYXRhIHRvIHRoZSBkb20gc28gdGhlIGNsb25lIGNhbiBwaWNrdXAgdGhlIGRhdGFcbiAgICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpOyAvLyBjbG9uZSBlbGVtZW50IGFuZCBhc3NpZ24gbmV3IGlkXG5cbiAgICAgICAgdmFyIGNsb25lID0gYXNzaWduTmV3SWQodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSk7IC8vIGluc2VydCB0aGUgY2xvbmUgaW4gdGhlIGdpdmVuIHBhcmVudCBvciBhZnRlciBteXNlbGZcblxuICAgICAgICBpZiAocGFyZW50KSBwYXJlbnQuYWRkKGNsb25lKTtlbHNlIHRoaXMuYWZ0ZXIoY2xvbmUpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICB9LFxuICAgICAgLy8gUmVtb3ZlIGVsZW1lbnRcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQoKSkge1xuICAgICAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFJlcGxhY2UgZWxlbWVudFxuICAgICAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZShlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuYWZ0ZXIoZWxlbWVudCkucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfSxcbiAgICAgIC8vIEFkZCBlbGVtZW50IHRvIGdpdmVuIGNvbnRhaW5lciBhbmQgcmV0dXJuIHNlbGZcbiAgICAgIGFkZFRvOiBmdW5jdGlvbiBhZGRUbyhwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5wdXQodGhpcyk7XG4gICAgICB9LFxuICAgICAgLy8gQWRkIGVsZW1lbnQgdG8gZ2l2ZW4gY29udGFpbmVyIGFuZCByZXR1cm4gY29udGFpbmVyXG4gICAgICBwdXRJbjogZnVuY3Rpb24gcHV0SW4ocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuYWRkKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCAvIHNldCBpZFxuICAgICAgaWQ6IGZ1bmN0aW9uIGlkKF9pZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdpZCcsIF9pZCk7XG4gICAgICB9LFxuICAgICAgLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGluc2lkZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50XG4gICAgICBpbnNpZGU6IGZ1bmN0aW9uIGluc2lkZSh4LCB5KSB7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLmJib3goKTtcbiAgICAgICAgcmV0dXJuIHggPiBib3gueCAmJiB5ID4gYm94LnkgJiYgeCA8IGJveC54ICsgYm94LndpZHRoICYmIHkgPCBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICB9LFxuICAgICAgLy8gU2hvdyBlbGVtZW50XG4gICAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScsICcnKTtcbiAgICAgIH0sXG4gICAgICAvLyBIaWRlIGVsZW1lbnRcbiAgICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgIH0sXG4gICAgICAvLyBJcyBlbGVtZW50IHZpc2libGU/XG4gICAgICB2aXNpYmxlOiBmdW5jdGlvbiB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScpICE9ICdub25lJztcbiAgICAgIH0sXG4gICAgICAvLyBSZXR1cm4gaWQgb24gc3RyaW5nIGNvbnZlcnNpb25cbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaWQnKTtcbiAgICAgIH0sXG4gICAgICAvLyBSZXR1cm4gYXJyYXkgb2YgY2xhc3NlcyBvbiB0aGUgbm9kZVxuICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgdmFyIGF0dHIgPSB0aGlzLmF0dHIoJ2NsYXNzJyk7XG4gICAgICAgIHJldHVybiBhdHRyID09IG51bGwgPyBbXSA6IGF0dHIudHJpbSgpLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpO1xuICAgICAgfSxcbiAgICAgIC8vIFJldHVybiB0cnVlIGlmIGNsYXNzIGV4aXN0cyBvbiB0aGUgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzKCkuaW5kZXhPZihuYW1lKSAhPSAtMTtcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgY2xhc3MgdG8gdGhlIG5vZGVcbiAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNDbGFzcyhuYW1lKSkge1xuICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuY2xhc3NlcygpO1xuICAgICAgICAgIGFycmF5LnB1c2gobmFtZSk7XG4gICAgICAgICAgdGhpcy5hdHRyKCdjbGFzcycsIGFycmF5LmpvaW4oJyAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgY2xhc3MgZnJvbSB0aGUgbm9kZVxuICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmF0dHIoJ2NsYXNzJywgdGhpcy5jbGFzc2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAhPSBuYW1lO1xuICAgICAgICAgIH0pLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBUb2dnbGUgdGhlIHByZXNlbmNlIG9mIGEgY2xhc3Mgb24gdGhlIG5vZGVcbiAgICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0NsYXNzKG5hbWUpID8gdGhpcy5yZW1vdmVDbGFzcyhuYW1lKSA6IHRoaXMuYWRkQ2xhc3MobmFtZSk7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IHJlZmVyZW5jZWQgZWxlbWVudCBmb3JtIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgcmVmZXJlbmNlOiBmdW5jdGlvbiByZWZlcmVuY2UoYXR0cikge1xuICAgICAgICByZXR1cm4gU1ZHLmdldCh0aGlzLmF0dHIoYXR0cikpO1xuICAgICAgfSxcbiAgICAgIC8vIFJldHVybnMgdGhlIHBhcmVudCBlbGVtZW50IGluc3RhbmNlXG4gICAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCh0eXBlKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzOyAvLyBjaGVjayBmb3IgcGFyZW50XG5cbiAgICAgICAgaWYgKCFwYXJlbnQubm9kZS5wYXJlbnROb2RlKSByZXR1cm4gbnVsbDsgLy8gZ2V0IHBhcmVudCBlbGVtZW50XG5cbiAgICAgICAgcGFyZW50ID0gU1ZHLmFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICBpZiAoIXR5cGUpIHJldHVybiBwYXJlbnQ7IC8vIGxvb3AgdHJvdWdoIGFuY2VzdG9ycyBpZiB0eXBlIGlzIGdpdmVuXG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQubm9kZSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHBhcmVudC5tYXRjaGVzKHR5cGUpIDogcGFyZW50IGluc3RhbmNlb2YgdHlwZSkgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICBpZiAoIXBhcmVudC5ub2RlLnBhcmVudE5vZGUgfHwgcGFyZW50Lm5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PSAnI2RvY3VtZW50JykgcmV0dXJuIG51bGw7IC8vICM3NTksICM3MjBcblxuICAgICAgICAgIHBhcmVudCA9IFNWRy5hZG9wdChwYXJlbnQubm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEdldCBwYXJlbnQgZG9jdW1lbnRcbiAgICAgIGRvYzogZnVuY3Rpb24gZG9jKCkge1xuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIFNWRy5Eb2MgPyB0aGlzIDogdGhpcy5wYXJlbnQoU1ZHLkRvYyk7XG4gICAgICB9LFxuICAgICAgLy8gcmV0dXJuIGFycmF5IG9mIGFsbCBhbmNlc3RvcnMgb2YgZ2l2ZW4gdHlwZSB1cCB0byB0aGUgcm9vdCBzdmdcbiAgICAgIHBhcmVudHM6IGZ1bmN0aW9uIHBhcmVudHModHlwZSkge1xuICAgICAgICB2YXIgcGFyZW50cyA9IFtdLFxuICAgICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCh0eXBlKTtcbiAgICAgICAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50Lm5vZGUpIGJyZWFrO1xuICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICB9IHdoaWxlIChwYXJlbnQucGFyZW50KTtcblxuICAgICAgICByZXR1cm4gcGFyZW50cztcbiAgICAgIH0sXG4gICAgICAvLyBtYXRjaGVzIHRoZSBlbGVtZW50IHZzIGEgY3NzIHNlbGVjdG9yXG4gICAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBfbWF0Y2hlcyh0aGlzLm5vZGUsIHNlbGVjdG9yKTtcbiAgICAgIH0sXG4gICAgICAvLyBSZXR1cm5zIHRoZSBzdmcgbm9kZSB0byBjYWxsIG5hdGl2ZSBzdmcgbWV0aG9kcyBvbiBpdFxuICAgICAgbmF0aXZlOiBmdW5jdGlvbiBuYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGU7XG4gICAgICB9LFxuICAgICAgLy8gSW1wb3J0IHJhdyBzdmdcbiAgICAgIHN2ZzogZnVuY3Rpb24gc3ZnKF9zdmcpIHtcbiAgICAgICAgLy8gY3JlYXRlIHRlbXBvcmFyeSBob2xkZXJcbiAgICAgICAgdmFyIHdlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdmcnKTsgLy8gYWN0IGFzIGEgc2V0dGVyIGlmIHN2ZyBpcyBnaXZlblxuXG4gICAgICAgIGlmIChfc3ZnICYmIHRoaXMgaW5zdGFuY2VvZiBTVkcuUGFyZW50KSB7XG4gICAgICAgICAgLy8gZHVtcCByYXcgc3ZnXG4gICAgICAgICAgd2VsbC5pbm5lckhUTUwgPSAnPHN2Zz4nICsgX3N2Zy5yZXBsYWNlKC9cXG4vLCAnJykucmVwbGFjZSgvPChbXFx3Oi1dKykoW148XSs/KVxcLz4vZywgJzwkMSQyPjwvJDE+JykgKyAnPC9zdmc+JzsgLy8gdHJhbnNwbGFudCBub2Rlc1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gd2VsbC5maXJzdENoaWxkLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHdlbGwuZmlyc3RDaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgICB9IC8vIG90aGVyd2lzZSBhY3QgYXMgYSBnZXR0ZXJcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNyZWF0ZSBhIHdyYXBwaW5nIHN2ZyBlbGVtZW50IGluIGNhc2Ugb2YgcGFydGlhbCBjb250ZW50XG4gICAgICAgICAgd2VsbC5hcHBlbmRDaGlsZChfc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3ZnJykpOyAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cblxuICAgICAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKTsgLy8gaW5zZXJ0IGEgY29weSBvZiB0aGlzIG5vZGVcblxuICAgICAgICAgIF9zdmcuYXBwZW5kQ2hpbGQodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSk7IC8vIHJldHVybiB0YXJnZXQgZWxlbWVudFxuXG5cbiAgICAgICAgICByZXR1cm4gd2VsbC5pbm5lckhUTUwucmVwbGFjZSgvXjxzdmc+LywgJycpLnJlcGxhY2UoLzxcXC9zdmc+JC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIHdyaXRlIHN2Z2pzIGRhdGEgdG8gdGhlIGRvbVxuICAgICAgd3JpdGVEYXRhVG9Eb206IGZ1bmN0aW9uIHdyaXRlRGF0YVRvRG9tKCkge1xuICAgICAgICAvLyBkdW1wIHZhcmlhYmxlcyByZWN1cnNpdmVseVxuICAgICAgICBpZiAodGhpcy5lYWNoIHx8IHRoaXMubGluZXMpIHtcbiAgICAgICAgICB2YXIgZm4gPSB0aGlzLmVhY2ggPyB0aGlzIDogdGhpcy5saW5lcygpO1xuICAgICAgICAgIGZuLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIHJlbW92ZSBwcmV2aW91c2x5IHNldCBkYXRhXG5cblxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKCdzdmdqczpkYXRhJyk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZG9tKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJywgSlNPTi5zdHJpbmdpZnkodGhpcy5kb20pKTtcbiAgICAgICAgfSAvLyBzZWUgIzQyOFxuXG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gc2V0IGdpdmVuIGRhdGEgdG8gdGhlIGVsZW1lbnRzIGRhdGEgcHJvcGVydHlcbiAgICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEobykge1xuICAgICAgICB0aGlzLmRvbSA9IG87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGlzOiBmdW5jdGlvbiBpcyhvYmopIHtcbiAgICAgICAgcmV0dXJuIF9pcyh0aGlzLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5lYXNpbmcgPSB7XG4gICAgJy0nOiBmdW5jdGlvbiBfKHBvcykge1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9LFxuICAgICc8Pic6IGZ1bmN0aW9uIF8ocG9zKSB7XG4gICAgICByZXR1cm4gLU1hdGguY29zKHBvcyAqIE1hdGguUEkpIC8gMiArIDAuNTtcbiAgICB9LFxuICAgICc+JzogZnVuY3Rpb24gXyhwb3MpIHtcbiAgICAgIHJldHVybiBNYXRoLnNpbihwb3MgKiBNYXRoLlBJIC8gMik7XG4gICAgfSxcbiAgICAnPCc6IGZ1bmN0aW9uIF8ocG9zKSB7XG4gICAgICByZXR1cm4gLU1hdGguY29zKHBvcyAqIE1hdGguUEkgLyAyKSArIDE7XG4gICAgfVxuICB9O1xuXG4gIFNWRy5tb3JwaCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gbmV3IFNWRy5Nb3JwaE9iaihmcm9tLCB0bykuYXQocG9zKTtcbiAgICB9O1xuICB9O1xuXG4gIFNWRy5TaXR1YXRpb24gPSBTVkcuaW52ZW50KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShvKSB7XG4gICAgICB0aGlzLmluaXQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmV2ZXJzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmV2ZXJzaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmR1cmF0aW9uID0gbmV3IFNWRy5OdW1iZXIoby5kdXJhdGlvbikudmFsdWVPZigpO1xuICAgICAgdGhpcy5kZWxheSA9IG5ldyBTVkcuTnVtYmVyKG8uZGVsYXkpLnZhbHVlT2YoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSArbmV3IERhdGUoKSArIHRoaXMuZGVsYXk7XG4gICAgICB0aGlzLmZpbmlzaCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICAgICAgdGhpcy5lYXNlID0gby5lYXNlOyAvLyB0aGlzLmxvb3AgaXMgaW5jcmVtZW50ZWQgZnJvbSAwIHRvIHRoaXMubG9vcHNcbiAgICAgIC8vIGl0IGlzIGFsc28gaW5jcmVtZW50ZWQgd2hlbiBpbiBhbiBpbmZpbml0ZSBsb29wICh3aGVuIHRoaXMubG9vcHMgaXMgdHJ1ZSlcblxuICAgICAgdGhpcy5sb29wID0gMDtcbiAgICAgIHRoaXMubG9vcHMgPSBmYWxzZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHsvLyBmdW5jdGlvblRvQ2FsbDogW2xpc3Qgb2YgbW9ycGhhYmxlIG9iamVjdHNdXG4gICAgICAgIC8vIGUuZy4gbW92ZTogW1NWRy5OdW1iZXIsIFNWRy5OdW1iZXJdXG4gICAgICB9O1xuICAgICAgdGhpcy5hdHRycyA9IHsvLyBob2xkcyBhbGwgYXR0cmlidXRlcyB3aGljaCBhcmUgbm90IHJlcHJlc2VudGVkIGZyb20gYSBmdW5jdGlvbiBzdmcuanMgcHJvdmlkZXNcbiAgICAgICAgLy8gZS5nLiBzb21lQXR0cjogU1ZHLk51bWJlclxuICAgICAgfTtcbiAgICAgIHRoaXMuc3R5bGVzID0gey8vIGhvbGRzIGFsbCBzdHlsZXMgd2hpY2ggc2hvdWxkIGJlIGFuaW1hdGVkXG4gICAgICAgIC8vIGUuZy4gZmlsbC1jb2xvcjogU1ZHLkNvbG9yXG4gICAgICB9O1xuICAgICAgdGhpcy50cmFuc2Zvcm1zID0gWy8vIGhvbGRzIGFsbCB0cmFuc2Zvcm1hdGlvbnMgYXMgdHJhbnNmb3JtYXRpb24gb2JqZWN0c1xuICAgICAgICAvLyBlLmcuIFtTVkcuUm90YXRlLCBTVkcuVHJhbnNsYXRlLCBTVkcuTWF0cml4XVxuICAgICAgXTtcbiAgICAgIHRoaXMub25jZSA9IHsvLyBmdW5jdGlvbnMgdG8gZmlyZSBhdCBhIHNwZWNpZmljIHBvc2l0aW9uXG4gICAgICAgIC8vIGUuZy4gXCIwLjVcIjogZnVuY3Rpb24gZm9vKCl7fVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBTVkcuRlggPSBTVkcuaW52ZW50KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICB0aGlzLl90YXJnZXQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5zaXR1YXRpb25zID0gW107XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zaXR1YXRpb24gPSBudWxsO1xuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdFBvcyA9IDA7XG4gICAgICB0aGlzLnBvcyA9IDA7IC8vIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBhbiBhbmltYXRpb24gaXMgaXRzIHBvc2l0aW9uIGluIHRoZSBjb250ZXh0IG9mIGl0cyBjb21wbGV0ZSBkdXJhdGlvbiAoaW5jbHVkaW5nIGRlbGF5IGFuZCBsb29wcylcbiAgICAgIC8vIFdoZW4gcGVyZm9ybWluZyBhIGRlbGF5LCBhYnNQb3MgaXMgYmVsb3cgMCBhbmQgd2hlbiBwZXJmb3JtaW5nIGEgbG9vcCwgaXRzIHZhbHVlIGlzIGFib3ZlIDFcblxuICAgICAgdGhpcy5hYnNQb3MgPSAwO1xuICAgICAgdGhpcy5fc3BlZWQgPSAxO1xuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvKipcbiAgICAgICAqIHNldHMgb3IgcmV0dXJucyB0aGUgdGFyZ2V0IG9mIHRoaXMgYW5pbWF0aW9uXG4gICAgICAgKiBAcGFyYW0gbyBvYmplY3QgfHwgbnVtYmVyIEluIGNhc2Ugb2YgT2JqZWN0IGl0IGhvbGRzIGFsbCBwYXJhbWV0ZXJzLiBJbiBjYXNlIG9mIG51bWJlciBpdHMgdGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAqIEBwYXJhbSBlYXNlIGZ1bmN0aW9uIHx8IHN0cmluZyBGdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgdXNlZCBmb3IgZWFzaW5nIG9yIGVhc2luZyBrZXl3b3JkXG4gICAgICAgKiBAcGFyYW0gZGVsYXkgTnVtYmVyIGluZGljYXRpbmcgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuICAgICAgICogQHJldHVybiB0YXJnZXQgfHwgdGhpc1xuICAgICAgICovXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKG8sIGVhc2UsIGRlbGF5KSB7XG4gICAgICAgIGlmIChfdHlwZW9mKG8pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGVhc2UgPSBvLmVhc2U7XG4gICAgICAgICAgZGVsYXkgPSBvLmRlbGF5O1xuICAgICAgICAgIG8gPSBvLmR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpdHVhdGlvbiA9IG5ldyBTVkcuU2l0dWF0aW9uKHtcbiAgICAgICAgICBkdXJhdGlvbjogbyB8fCAxMDAwLFxuICAgICAgICAgIGRlbGF5OiBkZWxheSB8fCAwLFxuICAgICAgICAgIGVhc2U6IFNWRy5lYXNpbmdbZWFzZSB8fCAnLSddIHx8IGVhc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVldWUoc2l0dWF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICogc2V0cyBhIGRlbGF5IGJlZm9yZSB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBxdWV1ZSBpcyBjYWxsZWRcbiAgICAgICogQHBhcmFtIGRlbGF5IER1cmF0aW9uIG9mIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICAgICAgKiBAcmV0dXJuIHRoaXMudGFyZ2V0KClcbiAgICAgICovXG4gICAgICBkZWxheTogZnVuY3Rpb24gZGVsYXkoX2RlbGF5KSB7XG4gICAgICAgIC8vIFRoZSBkZWxheSBpcyBwZXJmb3JtZWQgYnkgYW4gZW1wdHkgc2l0dWF0aW9uIHdpdGggaXRzIGR1cmF0aW9uXG4gICAgICAgIC8vIGF0dHJpYnV0ZSBzZXQgdG8gdGhlIGR1cmF0aW9uIG9mIHRoZSBkZWxheVxuICAgICAgICB2YXIgc2l0dWF0aW9uID0gbmV3IFNWRy5TaXR1YXRpb24oe1xuICAgICAgICAgIGR1cmF0aW9uOiBfZGVsYXksXG4gICAgICAgICAgZGVsYXk6IDAsXG4gICAgICAgICAgZWFzZTogU1ZHLmVhc2luZ1snLSddXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShzaXR1YXRpb24pO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAqIHNldHMgb3IgcmV0dXJucyB0aGUgdGFyZ2V0IG9mIHRoaXMgYW5pbWF0aW9uXG4gICAgICAqIEBwYXJhbSBudWxsIHx8IHRhcmdldCBTVkcuRWxlbWVudCB3aGljaCBzaG91bGQgYmUgc2V0IGFzIG5ldyB0YXJnZXRcbiAgICAgICogQHJldHVybiB0YXJnZXQgfHwgdGhpc1xuICAgICAgKi9cbiAgICAgIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KF90YXJnZXQpIHtcbiAgICAgICAgaWYgKF90YXJnZXQgJiYgX3RhcmdldCBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gX3RhcmdldDtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gICAgICB9LFxuICAgICAgLy8gcmV0dXJucyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gYXQgYSBnaXZlbiB0aW1lXG4gICAgICB0aW1lVG9BYnNQb3M6IGZ1bmN0aW9uIHRpbWVUb0Fic1Bvcyh0aW1lc3RhbXApIHtcbiAgICAgICAgcmV0dXJuICh0aW1lc3RhbXAgLSB0aGlzLnNpdHVhdGlvbi5zdGFydCkgLyAodGhpcy5zaXR1YXRpb24uZHVyYXRpb24gLyB0aGlzLl9zcGVlZCk7XG4gICAgICB9LFxuICAgICAgLy8gcmV0dXJucyB0aGUgdGltZXN0YW1wIGZyb20gYSBnaXZlbiBhYnNvbHV0ZSBwb3NpdG9uXG4gICAgICBhYnNQb3NUb1RpbWU6IGZ1bmN0aW9uIGFic1Bvc1RvVGltZShhYnNQb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l0dWF0aW9uLmR1cmF0aW9uIC8gdGhpcy5fc3BlZWQgKiBhYnNQb3MgKyB0aGlzLnNpdHVhdGlvbi5zdGFydDtcbiAgICAgIH0sXG4gICAgICAvLyBzdGFydHMgdGhlIGFuaW1hdGlvbmxvb3BcbiAgICAgIHN0YXJ0QW5pbUZyYW1lOiBmdW5jdGlvbiBzdGFydEFuaW1GcmFtZSgpIHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbUZyYW1lKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnN0ZXAoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0sXG4gICAgICAvLyBjYW5jZWxzIHRoZSBhbmltYXRpb25mcmFtZVxuICAgICAgc3RvcEFuaW1GcmFtZTogZnVuY3Rpb24gc3RvcEFuaW1GcmFtZSgpIHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgfSxcbiAgICAgIC8vIGtpY2tzIG9mZiB0aGUgYW5pbWF0aW9uIC0gb25seSBkb2VzIHNvbWV0aGluZyB3aGVuIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgbm90IGFjdGl2ZSBhbmQgYXQgbGVhc3Qgb25lIHNpdHVhdGlvbiBpcyBzZXRcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgLy8gZG9udCBzdGFydCBpZiBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSAmJiB0aGlzLnNpdHVhdGlvbikge1xuICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0YXJ0Q3VycmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gc3RhcnQgdGhlIGN1cnJlbnQgc2l0dWF0aW9uXG4gICAgICBzdGFydEN1cnJlbnQ6IGZ1bmN0aW9uIHN0YXJ0Q3VycmVudCgpIHtcbiAgICAgICAgdGhpcy5zaXR1YXRpb24uc3RhcnQgPSArbmV3IERhdGUoKSArIHRoaXMuc2l0dWF0aW9uLmRlbGF5IC8gdGhpcy5fc3BlZWQ7XG4gICAgICAgIHRoaXMuc2l0dWF0aW9uLmZpbmlzaCA9IHRoaXMuc2l0dWF0aW9uLnN0YXJ0ICsgdGhpcy5zaXR1YXRpb24uZHVyYXRpb24gLyB0aGlzLl9zcGVlZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdEFuaW1hdGlvbnMoKS5zdGVwKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICogYWRkcyBhIGZ1bmN0aW9uIC8gU2l0dWF0aW9uIHRvIHRoZSBhbmltYXRpb24gcXVldWVcbiAgICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uIC8gc2l0dWF0aW9uIHRvIGFkZFxuICAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgICovXG4gICAgICBxdWV1ZTogZnVuY3Rpb24gcXVldWUoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyB8fCBmbiBpbnN0YW5jZW9mIFNWRy5TaXR1YXRpb24pIHtcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbnMucHVzaChmbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2l0dWF0aW9uKSB0aGlzLnNpdHVhdGlvbiA9IHRoaXMuc2l0dWF0aW9ucy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgKiBwdWxscyBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgcXVldWUgYW5kIGV4ZWN1dGUgaXRcbiAgICAgICogQHJldHVybiB0aGlzXG4gICAgICAqL1xuICAgICAgZGVxdWV1ZTogZnVuY3Rpb24gZGVxdWV1ZSgpIHtcbiAgICAgICAgLy8gc3RvcCBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgICB0aGlzLnN0b3AoKTsgLy8gZ2V0IG5leHQgYW5pbWF0aW9uIGZyb20gcXVldWVcblxuICAgICAgICB0aGlzLnNpdHVhdGlvbiA9IHRoaXMuc2l0dWF0aW9ucy5zaGlmdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbikge1xuICAgICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbiBpbnN0YW5jZW9mIFNWRy5TaXR1YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMgbm90IGEgU1ZHLlNpdHVhdGlvbiwgdGhlbiBpdCBpcyBhIGZ1bmN0aW9uLCB3ZSBleGVjdXRlIGl0XG4gICAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIHVwZGF0ZXMgYWxsIGFuaW1hdGlvbnMgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbiAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IHdoZW4gb25lIHByb3BlcnR5IGNvdWxkIGJlIGNoYW5nZWQgZnJvbSBhbm90aGVyIHByb3BlcnR5XG4gICAgICBpbml0QW5pbWF0aW9uczogZnVuY3Rpb24gaW5pdEFuaW1hdGlvbnMoKSB7XG4gICAgICAgIHZhciBpLCBqLCBzb3VyY2U7XG4gICAgICAgIHZhciBzID0gdGhpcy5zaXR1YXRpb247XG4gICAgICAgIGlmIChzLmluaXQpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGZvciAoaSBpbiBzLmFuaW1hdGlvbnMpIHtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLnRhcmdldCgpW2ldKCk7XG5cbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgc291cmNlID0gW3NvdXJjZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHMuYW5pbWF0aW9uc1tpXSkpIHtcbiAgICAgICAgICAgIHMuYW5pbWF0aW9uc1tpXSA9IFtzLmFuaW1hdGlvbnNbaV1dO1xuICAgICAgICAgIH0gLy8gaWYocy5hbmltYXRpb25zW2ldLmxlbmd0aCA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAvLyAgc291cmNlLmNvbmNhdCA9IHNvdXJjZS5jb25jYXQocy5hbmltYXRpb25zW2ldLnNsaWNlKHNvdXJjZS5sZW5ndGgsIHMuYW5pbWF0aW9uc1tpXS5sZW5ndGgpKVxuICAgICAgICAgIC8vIH1cblxuXG4gICAgICAgICAgZm9yIChqID0gc291cmNlLmxlbmd0aDsgai0tOykge1xuICAgICAgICAgICAgLy8gVGhlIGNvbmRpdGlvbiBpcyBiZWNhdXNlIHNvbWUgbWV0aG9kcyByZXR1cm4gYSBub3JtYWwgbnVtYmVyIGluc3RlYWRcbiAgICAgICAgICAgIC8vIG9mIGEgU1ZHLk51bWJlclxuICAgICAgICAgICAgaWYgKHMuYW5pbWF0aW9uc1tpXVtqXSBpbnN0YW5jZW9mIFNWRy5OdW1iZXIpIHtcbiAgICAgICAgICAgICAgc291cmNlW2pdID0gbmV3IFNWRy5OdW1iZXIoc291cmNlW2pdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcy5hbmltYXRpb25zW2ldW2pdID0gc291cmNlW2pdLm1vcnBoKHMuYW5pbWF0aW9uc1tpXVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpIGluIHMuYXR0cnMpIHtcbiAgICAgICAgICBzLmF0dHJzW2ldID0gbmV3IFNWRy5Nb3JwaE9iaih0aGlzLnRhcmdldCgpLmF0dHIoaSksIHMuYXR0cnNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpIGluIHMuc3R5bGVzKSB7XG4gICAgICAgICAgcy5zdHlsZXNbaV0gPSBuZXcgU1ZHLk1vcnBoT2JqKHRoaXMudGFyZ2V0KCkuc3R5bGUoaSksIHMuc3R5bGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMuaW5pdGlhbFRyYW5zZm9ybWF0aW9uID0gdGhpcy50YXJnZXQoKS5tYXRyaXhpZnkoKTtcbiAgICAgICAgcy5pbml0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5zaXR1YXRpb25zID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGNsZWFyQ3VycmVudDogZnVuY3Rpb24gY2xlYXJDdXJyZW50KCkge1xuICAgICAgICB0aGlzLnNpdHVhdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqIHN0b3BzIHRoZSBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICogQHBhcmFtIGp1bXBUb0VuZCBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpbW1lZGlhdGVseS5cbiAgICAgICogQHBhcmFtIGNsZWFyUXVldWUgQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byByZW1vdmUgcXVldWVkIGFuaW1hdGlvbiBhcyB3ZWxsLlxuICAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgICovXG4gICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGp1bXBUb0VuZCwgY2xlYXJRdWV1ZSkge1xuICAgICAgICB2YXIgYWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGNsZWFyUXVldWUpIHtcbiAgICAgICAgICB0aGlzLmNsZWFyUXVldWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqdW1wVG9FbmQgJiYgdGhpcy5zaXR1YXRpb24pIHtcbiAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzaXR1YXRpb24gaWYgaXQgd2FzIG5vdFxuICAgICAgICAgICFhY3RpdmUgJiYgdGhpcy5zdGFydEN1cnJlbnQoKTtcbiAgICAgICAgICB0aGlzLmF0RW5kKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJDdXJyZW50KCk7XG4gICAgICB9LFxuXG4gICAgICAvKiogcmVzZXRzIHRoZSBlbGVtZW50IHRvIHRoZSBzdGF0ZSB3aGVyZSB0aGUgY3VycmVudCBlbGVtZW50IGhhcyBzdGFydGVkXG4gICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAgKi9cbiAgICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLnNpdHVhdGlvbjtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbiA9IHRlbXA7XG4gICAgICAgICAgdGhpcy5hdFN0YXJ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBTdG9wIHRoZSBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb24sIHJlbW92ZSBhbGwgcXVldWVkIGFuaW1hdGlvbnMsIGFuZCBjb21wbGV0ZSBhbGwgYW5pbWF0aW9ucyBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5zdG9wKHRydWUsIGZhbHNlKTtcblxuICAgICAgICB3aGlsZSAodGhpcy5kZXF1ZXVlKCkuc2l0dWF0aW9uICYmIHRoaXMuc3RvcCh0cnVlLCBmYWxzZSkpIHtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYXJRdWV1ZSgpLmNsZWFyQ3VycmVudCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBzZXQgdGhlIGludGVybmFsIGFuaW1hdGlvbiBwb2ludGVyIGF0IHRoZSBzdGFydCBwb3NpdGlvbiwgYmVmb3JlIGFueSBsb29wcywgYW5kIHVwZGF0ZXMgdGhlIHZpc3VhbGlzYXRpb25cbiAgICAgIGF0U3RhcnQ6IGZ1bmN0aW9uIGF0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0KDAsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIC8vIHNldCB0aGUgaW50ZXJuYWwgYW5pbWF0aW9uIHBvaW50ZXIgYXQgdGhlIGVuZCBwb3NpdGlvbiwgYWZ0ZXIgYWxsIHRoZSBsb29wcywgYW5kIHVwZGF0ZXMgdGhlIHZpc3VhbGlzYXRpb25cbiAgICAgIGF0RW5kOiBmdW5jdGlvbiBhdEVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uLmxvb3BzID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gSWYgaW4gYSBpbmZpbml0ZSBsb29wLCB3ZSBlbmQgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gICAgICAgICAgdGhpcy5zaXR1YXRpb24ubG9vcHMgPSB0aGlzLnNpdHVhdGlvbi5sb29wICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zaXR1YXRpb24ubG9vcHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gSWYgcGVyZm9ybWluZyBhIGZpbml0ZSBudW1iZXIgb2YgbG9vcHMsIHdlIGdvIGFmdGVyIGFsbCB0aGUgbG9vcHNcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdCh0aGlzLnNpdHVhdGlvbi5sb29wcywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgbm8gbG9vcHMsIHdlIGp1c3QgZ28gYXQgdGhlIGVuZFxuICAgICAgICAgIHJldHVybiB0aGlzLmF0KDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gc2V0IHRoZSBpbnRlcm5hbCBhbmltYXRpb24gcG9pbnRlciB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGFuZCB1cGRhdGVzIHRoZSB2aXN1YWxpc2F0aW9uXG4gICAgICAvLyBpZiBpc0Fic1BvcyBpcyB0cnVlLCBwb3MgaXMgdHJlYXRlZCBhcyBhbiBhYnNvbHV0ZSBwb3NpdGlvblxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcywgaXNBYnNQb3MpIHtcbiAgICAgICAgdmFyIGR1ckRpdlNwZCA9IHRoaXMuc2l0dWF0aW9uLmR1cmF0aW9uIC8gdGhpcy5fc3BlZWQ7XG4gICAgICAgIHRoaXMuYWJzUG9zID0gcG9zOyAvLyBJZiBwb3MgaXMgbm90IGFuIGFic29sdXRlIHBvc2l0aW9uLCB3ZSBjb252ZXJ0IGl0IGludG8gb25lXG5cbiAgICAgICAgaWYgKCFpc0Fic1Bvcykge1xuICAgICAgICAgIGlmICh0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCkgdGhpcy5hYnNQb3MgPSAxIC0gdGhpcy5hYnNQb3M7XG4gICAgICAgICAgdGhpcy5hYnNQb3MgKz0gdGhpcy5zaXR1YXRpb24ubG9vcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2l0dWF0aW9uLnN0YXJ0ID0gK25ldyBEYXRlKCkgLSB0aGlzLmFic1BvcyAqIGR1ckRpdlNwZDtcbiAgICAgICAgdGhpcy5zaXR1YXRpb24uZmluaXNoID0gdGhpcy5zaXR1YXRpb24uc3RhcnQgKyBkdXJEaXZTcGQ7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXAodHJ1ZSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICogc2V0cyBvciByZXR1cm5zIHRoZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uc1xuICAgICAgKiBAcGFyYW0gc3BlZWQgbnVsbCB8fCBOdW1iZXIgVGhlIG5ldyBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uc1xuICAgICAgKiBAcmV0dXJuIE51bWJlciB8fCB0aGlzXG4gICAgICAqL1xuICAgICAgc3BlZWQ6IGZ1bmN0aW9uIHNwZWVkKF9zcGVlZCkge1xuICAgICAgICBpZiAoX3NwZWVkID09PSAwKSByZXR1cm4gdGhpcy5wYXVzZSgpO1xuXG4gICAgICAgIGlmIChfc3BlZWQpIHtcbiAgICAgICAgICB0aGlzLl9zcGVlZCA9IF9zcGVlZDsgLy8gV2UgdXNlIGFuIGFic29sdXRlIHBvc2l0aW9uIGhlcmUgc28gdGhhdCBzcGVlZCBjYW4gYWZmZWN0IHRoZSBkZWxheSBiZWZvcmUgdGhlIGFuaW1hdGlvblxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXQodGhpcy5hYnNQb3MsIHRydWUpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIHRoaXMuX3NwZWVkO1xuICAgICAgfSxcbiAgICAgIC8vIE1ha2UgbG9vcGFibGVcbiAgICAgIGxvb3A6IGZ1bmN0aW9uIGxvb3AodGltZXMsIHJldmVyc2UpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKTsgLy8gc3RvcmUgdG90YWwgbG9vcHNcblxuICAgICAgICBjLmxvb3BzID0gdGltZXMgIT0gbnVsbCA/IHRpbWVzIDogdHJ1ZTtcbiAgICAgICAgYy5sb29wID0gMDtcbiAgICAgICAgaWYgKHJldmVyc2UpIGMucmV2ZXJzaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gcGF1c2VzIHRoZSBhbmltYXRpb25cbiAgICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gdW5wYXVzZSB0aGUgYW5pbWF0aW9uXG4gICAgICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICBpZiAoIXRoaXMucGF1c2VkKSByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTsgLy8gV2UgdXNlIGFuIGFic29sdXRlIHBvc2l0aW9uIGhlcmUgc28gdGhhdCB0aGUgZGVsYXkgYmVmb3JlIHRoZSBhbmltYXRpb24gY2FuIGJlIHBhdXNlZFxuXG4gICAgICAgIHJldHVybiB0aGlzLmF0KHRoaXMuYWJzUG9zLCB0cnVlKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgKiB0b2dnbGUgb3Igc2V0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIGFuaW1hdGlvblxuICAgICAgKiB0cnVlIHNldHMgZGlyZWN0aW9uIHRvIGJhY2t3YXJkcyB3aGlsZSBmYWxzZSBzZXRzIGl0IHRvIGZvcndhcmRzXG4gICAgICAqIEBwYXJhbSByZXZlcnNlZCBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byByZXZlcnNlIHRoZSBhbmltYXRpb24gb3Igbm90IChkZWZhdWx0OiB0b2dnbGUgdGhlIHJldmVyc2Ugc3RhdHVzKVxuICAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgICovXG4gICAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKHJldmVyc2VkKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5sYXN0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmV2ZXJzZWQgPT09ICd1bmRlZmluZWQnKSBjLnJldmVyc2VkID0gIWMucmV2ZXJzZWQ7ZWxzZSBjLnJldmVyc2VkID0gcmV2ZXJzZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAqIHJldHVybnMgYSBmbG9hdCBmcm9tIDAtMSBpbmRpY2F0aW5nIHRoZSBwcm9ncmVzcyBvZiB0aGUgY3VycmVudCBhbmltYXRpb25cbiAgICAgICogQHBhcmFtIGVhc2VkIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBzaG91bGQgYmUgZWFzZWQgb3Igbm90XG4gICAgICAqIEByZXR1cm4gbnVtYmVyXG4gICAgICAqL1xuICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKGVhc2VJdCkge1xuICAgICAgICByZXR1cm4gZWFzZUl0ID8gdGhpcy5zaXR1YXRpb24uZWFzZSh0aGlzLnBvcykgOiB0aGlzLnBvcztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgKiBhZGRzIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlzIGZpbmlzaGVkXG4gICAgICAqIEBwYXJhbSBmbiBGdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgZXhlY3V0ZWQgYXMgY2FsbGJhY2tcbiAgICAgICogQHJldHVybiBudW1iZXJcbiAgICAgICovXG4gICAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoZm4pIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKSxcbiAgICAgICAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKGUpIHtcbiAgICAgICAgICBpZiAoZS5kZXRhaWwuc2l0dWF0aW9uID09IGMpIHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgYyk7XG4gICAgICAgICAgICB0aGlzLm9mZignZmluaXNoZWQuZngnLCB3cmFwcGVyKTsgLy8gcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnRhcmdldCgpLm9uKCdmaW5pc2hlZC5meCcsIHdyYXBwZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgLy8gYWRkcyBhIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuZXZlciBvbmUgYW5pbWF0aW9uIHN0ZXAgaXMgcGVyZm9ybWVkXG4gICAgICBkdXJpbmc6IGZ1bmN0aW9uIGR1cmluZyhmbikge1xuICAgICAgICB2YXIgYyA9IHRoaXMubGFzdCgpLFxuICAgICAgICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoZSkge1xuICAgICAgICAgIGlmIChlLmRldGFpbC5zaXR1YXRpb24gPT0gYykge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBlLmRldGFpbC5wb3MsIFNWRy5tb3JwaChlLmRldGFpbC5wb3MpLCBlLmRldGFpbC5lYXNlZCwgYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9OyAvLyBzZWUgYWJvdmVcblxuXG4gICAgICAgIHRoaXMudGFyZ2V0KCkub2ZmKCdkdXJpbmcuZngnLCB3cmFwcGVyKS5vbignZHVyaW5nLmZ4Jywgd3JhcHBlcik7XG4gICAgICAgIHRoaXMuYWZ0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMub2ZmKCdkdXJpbmcuZngnLCB3cmFwcGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICAvLyBjYWxscyBhZnRlciBBTEwgYW5pbWF0aW9ucyBpbiB0aGUgcXVldWUgYXJlIGZpbmlzaGVkXG4gICAgICBhZnRlckFsbDogZnVuY3Rpb24gYWZ0ZXJBbGwoZm4pIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKGUpIHtcbiAgICAgICAgICBmbi5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMub2ZmKCdhbGxmaW5pc2hlZC5meCcsIHdyYXBwZXIpO1xuICAgICAgICB9OyAvLyBzZWUgYWJvdmVcblxuXG4gICAgICAgIHRoaXMudGFyZ2V0KCkub2ZmKCdhbGxmaW5pc2hlZC5meCcsIHdyYXBwZXIpLm9uKCdhbGxmaW5pc2hlZC5meCcsIHdyYXBwZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgLy8gY2FsbHMgb24gZXZlcnkgYW5pbWF0aW9uIHN0ZXAgZm9yIGFsbCBhbmltYXRpb25zXG4gICAgICBkdXJpbmdBbGw6IGZ1bmN0aW9uIGR1cmluZ0FsbChmbikge1xuICAgICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoZSkge1xuICAgICAgICAgIGZuLmNhbGwodGhpcywgZS5kZXRhaWwucG9zLCBTVkcubW9ycGgoZS5kZXRhaWwucG9zKSwgZS5kZXRhaWwuZWFzZWQsIGUuZGV0YWlsLnNpdHVhdGlvbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50YXJnZXQoKS5vZmYoJ2R1cmluZy5meCcsIHdyYXBwZXIpLm9uKCdkdXJpbmcuZngnLCB3cmFwcGVyKTtcbiAgICAgICAgdGhpcy5hZnRlckFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5vZmYoJ2R1cmluZy5meCcsIHdyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFydCgpO1xuICAgICAgfSxcbiAgICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpdHVhdGlvbnMubGVuZ3RoID8gdGhpcy5zaXR1YXRpb25zW3RoaXMuc2l0dWF0aW9ucy5sZW5ndGggLSAxXSA6IHRoaXMuc2l0dWF0aW9uO1xuICAgICAgfSxcbiAgICAgIC8vIGFkZHMgb25lIHByb3BlcnR5IHRvIHRoZSBhbmltYXRpb25zXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChtZXRob2QsIGFyZ3MsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5sYXN0KClbdHlwZSB8fCAnYW5pbWF0aW9ucyddW21ldGhvZF0gPSBhcmdzO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KCk7XG4gICAgICB9LFxuXG4gICAgICAvKiogcGVyZm9ybSBvbmUgc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAqICBAcGFyYW0gaWdub3JlVGltZSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byBpZ25vcmUgdGltZSBhbmQgdXNlIHBvc2l0aW9uIGRpcmVjdGx5IG9yIHJlY2FsY3VsYXRlIHBvc2l0aW9uIGJhc2VkIG9uIHRpbWVcbiAgICAgICogIEByZXR1cm4gdGhpc1xuICAgICAgKi9cbiAgICAgIHN0ZXA6IGZ1bmN0aW9uIHN0ZXAoaWdub3JlVGltZSkge1xuICAgICAgICAvLyBjb252ZXJ0IGN1cnJlbnQgdGltZSB0byBhbiBhYnNvbHV0ZSBwb3NpdGlvblxuICAgICAgICBpZiAoIWlnbm9yZVRpbWUpIHRoaXMuYWJzUG9zID0gdGhpcy50aW1lVG9BYnNQb3MoK25ldyBEYXRlKCkpOyAvLyBUaGlzIHBhcnQgY29udmVydCBhbiBhYnNvbHV0ZSBwb3NpdGlvbiB0byBhIHBvc2l0aW9uXG5cbiAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uLmxvb3BzICE9PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBhYnNQb3MsIGFic1Bvc0ludCwgbGFzdExvb3A7IC8vIElmIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBpcyBiZWxvdyAwLCB3ZSBqdXN0IHRyZWF0IGl0IGFzIGlmIGl0IHdhcyAwXG5cbiAgICAgICAgICBhYnNQb3MgPSBNYXRoLm1heCh0aGlzLmFic1BvcywgMCk7XG4gICAgICAgICAgYWJzUG9zSW50ID0gTWF0aC5mbG9vcihhYnNQb3MpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc2l0dWF0aW9uLmxvb3BzID09PSB0cnVlIHx8IGFic1Bvc0ludCA8IHRoaXMuc2l0dWF0aW9uLmxvb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGFic1BvcyAtIGFic1Bvc0ludDtcbiAgICAgICAgICAgIGxhc3RMb29wID0gdGhpcy5zaXR1YXRpb24ubG9vcDtcbiAgICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLmxvb3AgPSBhYnNQb3NJbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWJzUG9zID0gdGhpcy5zaXR1YXRpb24ubG9vcHM7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDE7IC8vIFRoZSAtMSBoZXJlIGlzIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byB0b2dnbGUgcmV2ZXJzZWQgd2hlbiBhbGwgdGhlIGxvb3BzIGhhdmUgYmVlbiBjb21wbGV0ZWRcblxuICAgICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wIC0gMTtcbiAgICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLmxvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ucmV2ZXJzaW5nKSB7XG4gICAgICAgICAgICAvLyBUb2dnbGUgcmV2ZXJzZWQgaWYgYW4gb2RkIG51bWJlciBvZiBsb29wcyBhcyBvY2N1cmVkIHNpbmNlIHRoZSBsYXN0IGNhbGwgb2Ygc3RlcFxuICAgICAgICAgICAgdGhpcy5zaXR1YXRpb24ucmV2ZXJzZWQgPSB0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCAhPSBCb29sZWFuKCh0aGlzLnNpdHVhdGlvbi5sb29wIC0gbGFzdExvb3ApICUgMik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBsb29wLCB0aGUgYWJzb2x1dGUgcG9zaXRpb24gbXVzdCBub3QgYmUgYWJvdmUgMVxuICAgICAgICAgIHRoaXMuYWJzUG9zID0gTWF0aC5taW4odGhpcy5hYnNQb3MsIDEpO1xuICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5hYnNQb3M7XG4gICAgICAgIH0gLy8gd2hpbGUgdGhlIGFic29sdXRlIHBvc2l0aW9uIGNhbiBiZSBiZWxvdyAwLCB0aGUgcG9zaXRpb24gbXVzdCBub3QgYmUgYmVsb3cgMFxuXG5cbiAgICAgICAgaWYgKHRoaXMucG9zIDwgMCkgdGhpcy5wb3MgPSAwO1xuICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ucmV2ZXJzZWQpIHRoaXMucG9zID0gMSAtIHRoaXMucG9zOyAvLyBhcHBseSBlYXNpbmdcblxuICAgICAgICB2YXIgZWFzZWQgPSB0aGlzLnNpdHVhdGlvbi5lYXNlKHRoaXMucG9zKTsgLy8gY2FsbCBvbmNlLWNhbGxiYWNrc1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zaXR1YXRpb24ub25jZSkge1xuICAgICAgICAgIGlmIChpID4gdGhpcy5sYXN0UG9zICYmIGkgPD0gZWFzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLm9uY2VbaV0uY2FsbCh0aGlzLnRhcmdldCgpLCB0aGlzLnBvcywgZWFzZWQpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2l0dWF0aW9uLm9uY2VbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZpcmUgZHVyaW5nIGNhbGxiYWNrIHdpdGggcG9zaXRpb24sIGVhc2VkIHBvc2l0aW9uIGFuZCBjdXJyZW50IHNpdHVhdGlvbiBhcyBwYXJhbWV0ZXJcblxuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkgdGhpcy50YXJnZXQoKS5maXJlKCdkdXJpbmcnLCB7XG4gICAgICAgICAgcG9zOiB0aGlzLnBvcyxcbiAgICAgICAgICBlYXNlZDogZWFzZWQsXG4gICAgICAgICAgZng6IHRoaXMsXG4gICAgICAgICAgc2l0dWF0aW9uOiB0aGlzLnNpdHVhdGlvblxuICAgICAgICB9KTsgLy8gdGhlIHVzZXIgbWF5IGNhbGwgc3RvcCBvciBmaW5pc2ggaW4gdGhlIGR1cmluZyBjYWxsYmFja1xuICAgICAgICAvLyBzbyBtYWtlIHN1cmUgdGhhdCB3ZSBzdGlsbCBoYXZlIGEgdmFsaWQgc2l0dWF0aW9uXG5cbiAgICAgICAgaWYgKCF0aGlzLnNpdHVhdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IC8vIGFwcGx5IHRoZSBhY3R1YWwgYW5pbWF0aW9uIHRvIGV2ZXJ5IHByb3BlcnR5XG5cblxuICAgICAgICB0aGlzLmVhY2hBdCgpOyAvLyBkbyBmaW5hbCBjb2RlIHdoZW4gc2l0dWF0aW9uIGlzIGZpbmlzaGVkXG5cbiAgICAgICAgaWYgKHRoaXMucG9zID09IDEgJiYgIXRoaXMuc2l0dWF0aW9uLnJldmVyc2VkIHx8IHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkICYmIHRoaXMucG9zID09IDApIHtcbiAgICAgICAgICAvLyBzdG9wIGFuaW1hdGlvbiBjYWxsYmFja1xuICAgICAgICAgIHRoaXMuc3RvcEFuaW1GcmFtZSgpOyAvLyBmaXJlIGZpbmlzaGVkIGNhbGxiYWNrIHdpdGggY3VycmVudCBzaXR1YXRpb24gYXMgcGFyYW1ldGVyXG5cbiAgICAgICAgICB0aGlzLnRhcmdldCgpLmZpcmUoJ2ZpbmlzaGVkJywge1xuICAgICAgICAgICAgZng6IHRoaXMsXG4gICAgICAgICAgICBzaXR1YXRpb246IHRoaXMuc2l0dWF0aW9uXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuc2l0dWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0KCkuZmlyZSgnYWxsZmluaXNoZWQnKTsgLy8gUmVjaGVjayB0aGUgbGVuZ3RoIHNpbmNlIHRoZSB1c2VyIG1heSBjYWxsIGFuaW1hdGUgaW4gdGhlIGFmdGVyQWxsIGNhbGxiYWNrXG5cbiAgICAgICAgICAgIGlmICghdGhpcy5zaXR1YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aGlzLnRhcmdldCgpLm9mZignLmZ4Jyk7IC8vIHRoZXJlIHNob3VsZG50IGJlIGFueSBiaW5kaW5nIGxlZnQsIGJ1dCB0byBtYWtlIHN1cmUuLi5cblxuICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gc3RhcnQgbmV4dCBhbmltYXRpb25cblxuXG4gICAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB0aGlzLmRlcXVldWUoKTtlbHNlIHRoaXMuY2xlYXJDdXJyZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucGF1c2VkICYmIHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgLy8gd2UgY29udGludWUgYW5pbWF0aW5nIHdoZW4gd2UgYXJlIG5vdCBhdCB0aGUgZW5kXG4gICAgICAgICAgdGhpcy5zdGFydEFuaW1GcmFtZSgpO1xuICAgICAgICB9IC8vIHNhdmUgbGFzdCBlYXNlZCBwb3NpdGlvbiBmb3Igb25jZSBjYWxsYmFjayB0cmlnZ2VyaW5nXG5cblxuICAgICAgICB0aGlzLmxhc3RQb3MgPSBlYXNlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gY2FsY3VsYXRlcyB0aGUgc3RlcCBmb3IgZXZlcnkgcHJvcGVydHkgYW5kIGNhbGxzIGJsb2NrIHdpdGggaXRcbiAgICAgIGVhY2hBdDogZnVuY3Rpb24gZWFjaEF0KCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgIGF0LFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldCgpLFxuICAgICAgICAgICAgcyA9IHRoaXMuc2l0dWF0aW9uOyAvLyBhcHBseSBhbmltYXRpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgdHJvdWdoIGEgbWV0aG9kXG5cbiAgICAgICAgZm9yIChpIGluIHMuYW5pbWF0aW9ucykge1xuICAgICAgICAgIGF0ID0gW10uY29uY2F0KHMuYW5pbWF0aW9uc1tpXSkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0YXJnZXRbaV0uYXBwbHkodGFyZ2V0LCBhdCk7XG4gICAgICAgIH0gLy8gYXBwbHkgYW5pbWF0aW9uIHdoaWNoIGhhcyB0byBiZSBhcHBsaWVkIHdpdGggYXR0cigpXG5cblxuICAgICAgICBmb3IgKGkgaW4gcy5hdHRycykge1xuICAgICAgICAgIGF0ID0gW2ldLmNvbmNhdChzLmF0dHJzW2ldKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGVsICE9PSAnc3RyaW5nJyAmJiBlbC5hdCA/IGVsLmF0KHMuZWFzZShzZWxmLnBvcyksIHNlbGYucG9zKSA6IGVsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRhcmdldC5hdHRyLmFwcGx5KHRhcmdldCwgYXQpO1xuICAgICAgICB9IC8vIGFwcGx5IGFuaW1hdGlvbiB3aGljaCBoYXMgdG8gYmUgYXBwbGllZCB3aXRoIHN0eWxlKClcblxuXG4gICAgICAgIGZvciAoaSBpbiBzLnN0eWxlcykge1xuICAgICAgICAgIGF0ID0gW2ldLmNvbmNhdChzLnN0eWxlc1tpXSkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUuYXBwbHkodGFyZ2V0LCBhdCk7XG4gICAgICAgIH0gLy8gYW5pbWF0ZSBpbml0aWFsVHJhbnNmb3JtYXRpb24gd2hpY2ggaGFzIHRvIGJlIGNoYWluZWRcblxuXG4gICAgICAgIGlmIChzLnRyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZ2V0IGluaXRpYWwgaW5pdGlhbFRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgYXQgPSBzLmluaXRpYWxUcmFuc2Zvcm1hdGlvbjtcblxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHMudHJhbnNmb3Jtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgLy8gZ2V0IG5leHQgdHJhbnNmb3JtYXRpb24gaW4gY2hhaW5cbiAgICAgICAgICAgIHZhciBhID0gcy50cmFuc2Zvcm1zW2ldOyAvLyBtdWx0aXBseSBtYXRyaXggZGlyZWN0bHlcblxuICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBTVkcuTWF0cml4KSB7XG4gICAgICAgICAgICAgIGlmIChhLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgYXQgPSBhdC5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgpLm1vcnBoKGEpLmF0KHMuZWFzZSh0aGlzLnBvcykpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdCA9IGF0Lm1vcnBoKGEpLmF0KHMuZWFzZSh0aGlzLnBvcykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIHdoZW4gdHJhbnNmb3JtYXRpb24gaXMgYWJzb2x1dGUgd2UgaGF2ZSB0byByZXNldCB0aGUgbmVlZGVkIHRyYW5zZm9ybWF0aW9uIGZpcnN0XG5cblxuICAgICAgICAgICAgaWYgKCFhLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgIGEudW5kbyhhdC5leHRyYWN0KCkpO1xuICAgICAgICAgICAgfSAvLyBhbmQgcmVhcHBseSBpdCBhZnRlclxuXG5cbiAgICAgICAgICAgIGF0ID0gYXQubXVsdGlwbHkoYS5hdChzLmVhc2UodGhpcy5wb3MpKSk7XG4gICAgICAgICAgfSAvLyBzZXQgbmV3IG1hdHJpeCBvbiBlbGVtZW50XG5cblxuICAgICAgICAgIHRhcmdldC5tYXRyaXgoYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gYWRkcyBhbiBvbmNlLWNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uIGFuZCBuZXZlciBhZ2FpblxuICAgICAgb25jZTogZnVuY3Rpb24gb25jZShwb3MsIGZuLCBpc0Vhc2VkKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5sYXN0KCk7XG4gICAgICAgIGlmICghaXNFYXNlZCkgcG9zID0gYy5lYXNlKHBvcyk7XG4gICAgICAgIGMub25jZVtwb3NdID0gZm47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9jYWxsU3RhcnQ6IGZ1bmN0aW9uIF9jYWxsU3RhcnQoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJlbnQ6IFNWRy5FbGVtZW50LFxuICAgIC8vIEFkZCBtZXRob2QgdG8gcGFyZW50IGVsZW1lbnRzXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBHZXQgZnggbW9kdWxlIG9yIGNyZWF0ZSBhIG5ldyBvbmUsIHRoZW4gYW5pbWF0ZSB3aXRoIGdpdmVuIGR1cmF0aW9uIGFuZCBlYXNlXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKG8sIGVhc2UsIGRlbGF5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5meCB8fCAodGhpcy5meCA9IG5ldyBTVkcuRlgodGhpcykpKS5hbmltYXRlKG8sIGVhc2UsIGRlbGF5KTtcbiAgICAgIH0sXG4gICAgICBkZWxheTogZnVuY3Rpb24gZGVsYXkoX2RlbGF5Mikge1xuICAgICAgICByZXR1cm4gKHRoaXMuZnggfHwgKHRoaXMuZnggPSBuZXcgU1ZHLkZYKHRoaXMpKSkuZGVsYXkoX2RlbGF5Mik7XG4gICAgICB9LFxuICAgICAgc3RvcDogZnVuY3Rpb24gc3RvcChqdW1wVG9FbmQsIGNsZWFyUXVldWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZngpIHtcbiAgICAgICAgICB0aGlzLmZ4LnN0b3AoanVtcFRvRW5kLCBjbGVhclF1ZXVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5meCkge1xuICAgICAgICAgIHRoaXMuZnguZmluaXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBQYXVzZSBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgICBpZiAodGhpcy5meCkge1xuICAgICAgICAgIHRoaXMuZngucGF1c2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFBsYXkgcGF1c2VkIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICBpZiAodGhpcy5meCkge1xuICAgICAgICAgIHRoaXMuZngucGxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gU2V0L0dldCB0aGUgc3BlZWQgb2YgdGhlIGFuaW1hdGlvbnNcbiAgICAgIHNwZWVkOiBmdW5jdGlvbiBzcGVlZChfc3BlZWQyKSB7XG4gICAgICAgIGlmICh0aGlzLmZ4KSB7XG4gICAgICAgICAgaWYgKF9zcGVlZDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnguc3BlZWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5meC5zcGVlZChfc3BlZWQyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBNb3JwaE9iaiBpcyB1c2VkIHdoZW5ldmVyIG5vIG1vcnBoYWJsZSBvYmplY3QgaXMgZ2l2ZW5cblxuICBTVkcuTW9ycGhPYmogPSBTVkcuaW52ZW50KHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShmcm9tLCB0bykge1xuICAgICAgLy8gcHJlcGFyZSBjb2xvciBmb3IgbW9ycGhpbmdcbiAgICAgIGlmIChTVkcuQ29sb3IuaXNDb2xvcih0bykpIHJldHVybiBuZXcgU1ZHLkNvbG9yKGZyb20pLm1vcnBoKHRvKTsgLy8gY2hlY2sgaWYgd2UgaGF2ZSBhIGxpc3Qgb2YgdmFsdWVzXG5cbiAgICAgIGlmIChTVkcucmVnZXguZGVsaW1pdGVyLnRlc3QoZnJvbSkpIHtcbiAgICAgICAgLy8gcHJlcGFyZSBwYXRoIGZvciBtb3JwaGluZ1xuICAgICAgICBpZiAoU1ZHLnJlZ2V4LnBhdGhMZXR0ZXJzLnRlc3QoZnJvbSkpIHJldHVybiBuZXcgU1ZHLlBhdGhBcnJheShmcm9tKS5tb3JwaCh0byk7IC8vIHByZXBhcmUgdmFsdWUgbGlzdCBmb3IgbW9ycGhpbmdcbiAgICAgICAgZWxzZSByZXR1cm4gbmV3IFNWRy5BcnJheShmcm9tKS5tb3JwaCh0byk7XG4gICAgICB9IC8vIHByZXBhcmUgbnVtYmVyIGZvciBtb3JwaGluZ1xuXG5cbiAgICAgIGlmIChTVkcucmVnZXgubnVtYmVyQW5kVW5pdC50ZXN0KHRvKSkgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKGZyb20pLm1vcnBoKHRvKTsgLy8gcHJlcGFyZSBmb3IgcGxhaW4gbW9ycGhpbmdcblxuICAgICAgdGhpcy52YWx1ZSA9IGZyb207XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gdG87XG4gICAgfSxcbiAgICBleHRlbmQ6IHtcbiAgICAgIGF0OiBmdW5jdGlvbiBhdChwb3MsIHJlYWwpIHtcbiAgICAgICAgcmV0dXJuIHJlYWwgPCAxID8gdGhpcy52YWx1ZSA6IHRoaXMuZGVzdGluYXRpb247XG4gICAgICB9LFxuICAgICAgdmFsdWVPZjogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRlgsIHtcbiAgICAvLyBBZGQgYW5pbWF0YWJsZSBhdHRyaWJ1dGVzXG4gICAgYXR0cjogZnVuY3Rpb24gYXR0cihhLCB2LCByZWxhdGl2ZSkge1xuICAgICAgLy8gYXBwbHkgYXR0cmlidXRlcyBpbmRpdmlkdWFsbHlcbiAgICAgIGlmIChfdHlwZW9mKGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICAgIHRoaXMuYXR0cihrZXksIGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkKGEsIHYsICdhdHRycycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEFkZCBhbmltYXRhYmxlIHN0eWxlc1xuICAgIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShzLCB2KSB7XG4gICAgICBpZiAoX3R5cGVvZihzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHMpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlKGtleSwgc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGQocywgdiwgJ3N0eWxlcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEFuaW1hdGFibGUgeC1heGlzXG4gICAgeDogZnVuY3Rpb24geChfeDIsIHJlbGF0aXZlKSB7XG4gICAgICBpZiAodGhpcy50YXJnZXQoKSBpbnN0YW5jZW9mIFNWRy5HKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgICB4OiBfeDJcbiAgICAgICAgfSwgcmVsYXRpdmUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG51bSA9IG5ldyBTVkcuTnVtYmVyKF94Mik7XG4gICAgICBudW0ucmVsYXRpdmUgPSByZWxhdGl2ZTtcbiAgICAgIHJldHVybiB0aGlzLmFkZCgneCcsIG51bSk7XG4gICAgfSxcbiAgICAvLyBBbmltYXRhYmxlIHktYXhpc1xuICAgIHk6IGZ1bmN0aW9uIHkoX3kyLCByZWxhdGl2ZSkge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0KCkgaW5zdGFuY2VvZiBTVkcuRykge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgICAgeTogX3kyXG4gICAgICAgIH0sIHJlbGF0aXZlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBudW0gPSBuZXcgU1ZHLk51bWJlcihfeTIpO1xuICAgICAgbnVtLnJlbGF0aXZlID0gcmVsYXRpdmU7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoJ3knLCBudW0pO1xuICAgIH0sXG4gICAgLy8gQW5pbWF0YWJsZSBjZW50ZXIgeC1heGlzXG4gICAgY3g6IGZ1bmN0aW9uIGN4KHgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZCgnY3gnLCBuZXcgU1ZHLk51bWJlcih4KSk7XG4gICAgfSxcbiAgICAvLyBBbmltYXRhYmxlIGNlbnRlciB5LWF4aXNcbiAgICBjeTogZnVuY3Rpb24gY3koeSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKCdjeScsIG5ldyBTVkcuTnVtYmVyKHkpKTtcbiAgICB9LFxuICAgIC8vIEFkZCBhbmltYXRhYmxlIG1vdmVcbiAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLngoeCkueSh5KTtcbiAgICB9LFxuICAgIC8vIEFkZCBhbmltYXRhYmxlIGNlbnRlclxuICAgIGNlbnRlcjogZnVuY3Rpb24gY2VudGVyKHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmN4KHgpLmN5KHkpO1xuICAgIH0sXG4gICAgLy8gQWRkIGFuaW1hdGFibGUgc2l6ZVxuICAgIHNpemU6IGZ1bmN0aW9uIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0KCkgaW5zdGFuY2VvZiBTVkcuVGV4dCkge1xuICAgICAgICAvLyBhbmltYXRlIGZvbnQgc2l6ZSBmb3IgVGV4dCBlbGVtZW50c1xuICAgICAgICB0aGlzLmF0dHIoJ2ZvbnQtc2l6ZScsIHdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFuaW1hdGUgYmJveCBiYXNlZCBzaXplIGZvciBhbGwgb3RoZXIgZWxlbWVudHNcbiAgICAgICAgdmFyIGJveDtcblxuICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgICBib3ggPSB0aGlzLnRhcmdldCgpLmJib3goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IGJveC53aWR0aCAvIGJveC5oZWlnaHQgKiBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgIGhlaWdodCA9IGJveC5oZWlnaHQgLyBib3gud2lkdGggKiB3aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkKCd3aWR0aCcsIG5ldyBTVkcuTnVtYmVyKHdpZHRoKSkuYWRkKCdoZWlnaHQnLCBuZXcgU1ZHLk51bWJlcihoZWlnaHQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBBZGQgYW5pbWF0YWJsZSB3aWR0aFxuICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChfd2lkdGgyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoJ3dpZHRoJywgbmV3IFNWRy5OdW1iZXIoX3dpZHRoMikpO1xuICAgIH0sXG4gICAgLy8gQWRkIGFuaW1hdGFibGUgaGVpZ2h0XG4gICAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoX2hlaWdodDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZCgnaGVpZ2h0JywgbmV3IFNWRy5OdW1iZXIoX2hlaWdodDIpKTtcbiAgICB9LFxuICAgIC8vIEFkZCBhbmltYXRhYmxlIHBsb3RcbiAgICBwbG90OiBmdW5jdGlvbiBwbG90KGEsIGIsIGMsIGQpIHtcbiAgICAgIC8vIExpbmVzIGNhbiBiZSBwbG90dGVkIHdpdGggNCBhcmd1bWVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxvdChbYSwgYiwgYywgZF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hZGQoJ3Bsb3QnLCBuZXcgKHRoaXMudGFyZ2V0KCkubW9ycGhBcnJheSkoYSkpO1xuICAgIH0sXG4gICAgLy8gQWRkIGxlYWRpbmcgbWV0aG9kXG4gICAgbGVhZGluZzogZnVuY3Rpb24gbGVhZGluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0KCkubGVhZGluZyA/IHRoaXMuYWRkKCdsZWFkaW5nJywgbmV3IFNWRy5OdW1iZXIodmFsdWUpKSA6IHRoaXM7XG4gICAgfSxcbiAgICAvLyBBZGQgYW5pbWF0YWJsZSB2aWV3Ym94XG4gICAgdmlld2JveDogZnVuY3Rpb24gdmlld2JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAodGhpcy50YXJnZXQoKSBpbnN0YW5jZW9mIFNWRy5Db250YWluZXIpIHtcbiAgICAgICAgdGhpcy5hZGQoJ3ZpZXdib3gnLCBuZXcgU1ZHLlZpZXdCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG8pIHtcbiAgICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLlN0b3ApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvID09PSAnbnVtYmVyJyB8fCBvIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBvcGFjaXR5OiBhcmd1bWVudHNbMl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvLm9wYWNpdHkgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLW9wYWNpdHknLCBvLm9wYWNpdHkpO1xuICAgICAgICBpZiAoby5jb2xvciAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3AtY29sb3InLCBvLmNvbG9yKTtcbiAgICAgICAgaWYgKG8ub2Zmc2V0ICE9IG51bGwpIHRoaXMuYXR0cignb2Zmc2V0Jywgby5vZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBTVkcuQm94ID0gU1ZHLmludmVudCh7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKF90eXBlb2YoeCkgPT09ICdvYmplY3QnICYmICEoeCBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSkge1xuICAgICAgICAvLyBjaHJvbWVzIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBoYXMgbm8geCBhbmQgeSBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gU1ZHLkJveC5jYWxsKHRoaXMsIHgubGVmdCAhPSBudWxsID8geC5sZWZ0IDogeC54LCB4LnRvcCAhPSBudWxsID8geC50b3AgOiB4LnksIHgud2lkdGgsIHguaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9IC8vIGFkZCBjZW50ZXIsIHJpZ2h0LCBib3R0b20uLi5cblxuXG4gICAgICBmdWxsQm94KHRoaXMpO1xuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBNZXJnZSByZWN0IGJveCB3aXRoIGFub3RoZXIsIHJldHVybiBhIG5ldyBpbnN0YW5jZVxuICAgICAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKGJveCkge1xuICAgICAgICB2YXIgYiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7IC8vIG1lcmdlIGJveGVzXG5cbiAgICAgICAgYi54ID0gTWF0aC5taW4odGhpcy54LCBib3gueCk7XG4gICAgICAgIGIueSA9IE1hdGgubWluKHRoaXMueSwgYm94LnkpO1xuICAgICAgICBiLndpZHRoID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgYm94LnggKyBib3gud2lkdGgpIC0gYi54O1xuICAgICAgICBiLmhlaWdodCA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBib3gueSArIGJveC5oZWlnaHQpIC0gYi55O1xuICAgICAgICByZXR1cm4gZnVsbEJveChiKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShtKSB7XG4gICAgICAgIHZhciB4TWluID0gSW5maW5pdHksXG4gICAgICAgICAgICB4TWF4ID0gLUluZmluaXR5LFxuICAgICAgICAgICAgeU1pbiA9IEluZmluaXR5LFxuICAgICAgICAgICAgeU1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgICAgIGJib3g7XG4gICAgICAgIHZhciBwdHMgPSBbbmV3IFNWRy5Qb2ludCh0aGlzLngsIHRoaXMueSksIG5ldyBTVkcuUG9pbnQodGhpcy54MiwgdGhpcy55KSwgbmV3IFNWRy5Qb2ludCh0aGlzLngsIHRoaXMueTIpLCBuZXcgU1ZHLlBvaW50KHRoaXMueDIsIHRoaXMueTIpXTtcbiAgICAgICAgcHRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBwID0gcC50cmFuc2Zvcm0obSk7XG4gICAgICAgICAgeE1pbiA9IE1hdGgubWluKHhNaW4sIHAueCk7XG4gICAgICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIHAueCk7XG4gICAgICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIHAueSk7XG4gICAgICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHAueSk7XG4gICAgICAgIH0pO1xuICAgICAgICBiYm94ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAgICAgYmJveC54ID0geE1pbjtcbiAgICAgICAgYmJveC53aWR0aCA9IHhNYXggLSB4TWluO1xuICAgICAgICBiYm94LnkgPSB5TWluO1xuICAgICAgICBiYm94LmhlaWdodCA9IHlNYXggLSB5TWluO1xuICAgICAgICBmdWxsQm94KGJib3gpO1xuICAgICAgICByZXR1cm4gYmJveDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuQkJveCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICBTVkcuQm94LmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7IC8vIGdldCB2YWx1ZXMgaWYgZWxlbWVudCBpcyBnaXZlblxuXG4gICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSB7XG4gICAgICAgIHZhciBib3g7IC8vIHllcyB0aGlzIGlzIHVnbHksIGJ1dCBGaXJlZm94IGNhbiBiZSBhIHBhaW4gd2hlbiBpdCBjb21lcyB0byBlbGVtZW50cyB0aGF0IGFyZSBub3QgeWV0IHJlbmRlcmVkXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucykge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBJRSAtIGl0IGRvZXMgbm90IHN1cHBvcnQgY29udGFpbnMoKSBmb3IgdG9wLWxldmVsIFNWR3NcbiAgICAgICAgICAgIHZhciB0b3BQYXJlbnQgPSBlbGVtZW50Lm5vZGU7XG5cbiAgICAgICAgICAgIHdoaWxlICh0b3BQYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICB0b3BQYXJlbnQgPSB0b3BQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvcFBhcmVudCAhPSBkb2N1bWVudCkgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IG5vdCBpbiB0aGUgZG9tJyk7XG4gICAgICAgICAgfSAvLyB0aGUgZWxlbWVudCBpcyBOT1QgaW4gdGhlIGRvbSwgdGhyb3cgZXJyb3JcbiAgICAgICAgICAvLyBkaXNhYmxpbmcgdGhlIGNoZWNrIGJlbG93IHdoaWNoIGZpeGVzIGlzc3VlICM3NlxuICAgICAgICAgIC8vIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQubm9kZSkpIHRocm93IG5ldyBFeGNlcHRpb24oJ0VsZW1lbnQgbm90IGluIHRoZSBkb20nKVxuICAgICAgICAgIC8vIGZpbmQgbmF0aXZlIGJib3hcblxuXG4gICAgICAgICAgYm94ID0gZWxlbWVudC5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU1ZHLlNoYXBlKSB7XG4gICAgICAgICAgICBpZiAoIVNWRy5wYXJzZXIuZHJhdykge1xuICAgICAgICAgICAgICAvLyBmaXhlcyBhcGV4Y2hhcnRzL3Z1ZS1hcGV4Y2hhcnRzICMxNFxuICAgICAgICAgICAgICBTVkcucHJlcGFyZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBlbGVtZW50LmNsb25lKFNWRy5wYXJzZXIuZHJhdy5pbnN0YW5jZSkuc2hvdygpO1xuICAgICAgICAgICAgYm94ID0gY2xvbmUubm9kZS5nZXRCQm94KCk7XG4gICAgICAgICAgICBjbG9uZS5yZW1vdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm94ID0ge1xuICAgICAgICAgICAgICB4OiBlbGVtZW50Lm5vZGUuY2xpZW50TGVmdCxcbiAgICAgICAgICAgICAgeTogZWxlbWVudC5ub2RlLmNsaWVudFRvcCxcbiAgICAgICAgICAgICAgd2lkdGg6IGVsZW1lbnQubm9kZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtZW50Lm5vZGUuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFNWRy5Cb3guY2FsbCh0aGlzLCBib3gpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVmaW5lIGFuY2VzdG9yXG4gICAgaW5oZXJpdDogU1ZHLkJveCxcbiAgICAvLyBEZWZpbmUgUGFyZW50XG4gICAgcGFyZW50OiBTVkcuRWxlbWVudCxcbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gR2V0IGJvdW5kaW5nIGJveFxuICAgICAgYmJveDogZnVuY3Rpb24gYmJveCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuQkJveCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuQkJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkcuQkJveDtcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIHRib3g6IGZ1bmN0aW9uIHRib3goKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VzZSBvZiBUQm94IGlzIGRlcHJlY2F0ZWQgYW5kIG1hcHBlZCB0byBSQm94LiBVc2UgLnJib3goKSBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIHRoaXMucmJveCh0aGlzLmRvYygpKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuUkJveCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICBTVkcuQm94LmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG5cbiAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpIHtcbiAgICAgICAgU1ZHLkJveC5jYWxsKHRoaXMsIGVsZW1lbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbmhlcml0OiBTVkcuQm94LFxuICAgIC8vIGRlZmluZSBQYXJlbnRcbiAgICBwYXJlbnQ6IFNWRy5FbGVtZW50LFxuICAgIGV4dGVuZDoge1xuICAgICAgYWRkT2Zmc2V0OiBmdW5jdGlvbiBhZGRPZmZzZXQoKSB7XG4gICAgICAgIC8vIG9mZnNldCBieSB3aW5kb3cgc2Nyb2xsIHBvc2l0aW9uLCBiZWNhdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBjaGFuZ2VzIHdoZW4gd2luZG93IGlzIHNjcm9sbGVkXG4gICAgICAgIHRoaXMueCArPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgIHRoaXMueSArPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQ29uc3RydWN0b3JcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIEdldCByZWN0IGJveFxuICAgICAgcmJveDogZnVuY3Rpb24gcmJveChlbCkge1xuICAgICAgICBpZiAoZWwpIHJldHVybiBuZXcgU1ZHLlJCb3godGhpcykudHJhbnNmb3JtKGVsLnNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlJCb3godGhpcykuYWRkT2Zmc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlJCb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1ZHLlJCb3g7XG4gIFNWRy5NYXRyaXggPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBiYXNlID0gYXJyYXlUb01hdHJpeChbMSwgMCwgMCwgMSwgMCwgMF0pOyAvLyBlbnN1cmUgc291cmNlIGFzIG9iamVjdFxuXG4gICAgICBzb3VyY2UgPSBzb3VyY2UgaW5zdGFuY2VvZiBTVkcuRWxlbWVudCA/IHNvdXJjZS5tYXRyaXhpZnkoKSA6IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gYXJyYXlUb01hdHJpeChzb3VyY2Uuc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpKSA6IGFyZ3VtZW50cy5sZW5ndGggPT0gNiA/IGFycmF5VG9NYXRyaXgoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IEFycmF5LmlzQXJyYXkoc291cmNlKSA/IGFycmF5VG9NYXRyaXgoc291cmNlKSA6IF90eXBlb2Yoc291cmNlKSA9PT0gJ29iamVjdCcgPyBzb3VyY2UgOiBiYXNlOyAvLyBtZXJnZSBzb3VyY2VcblxuICAgICAgZm9yIChpID0gYWJjZGVmLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHRoaXNbYWJjZGVmW2ldXSA9IHNvdXJjZVthYmNkZWZbaV1dICE9IG51bGwgPyBzb3VyY2VbYWJjZGVmW2ldXSA6IGJhc2VbYWJjZGVmW2ldXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBFeHRyYWN0IGluZGl2aWR1YWwgdHJhbnNmb3JtYXRpb25zXG4gICAgICBleHRyYWN0OiBmdW5jdGlvbiBleHRyYWN0KCkge1xuICAgICAgICAvLyBmaW5kIGRlbHRhIHRyYW5zZm9ybSBwb2ludHNcbiAgICAgICAgdmFyIHB4ID0gZGVsdGFUcmFuc2Zvcm1Qb2ludCh0aGlzLCAwLCAxKSxcbiAgICAgICAgICAgIHB5ID0gZGVsdGFUcmFuc2Zvcm1Qb2ludCh0aGlzLCAxLCAwKSxcbiAgICAgICAgICAgIHNrZXdYID0gMTgwIC8gTWF0aC5QSSAqIE1hdGguYXRhbjIocHgueSwgcHgueCkgLSA5MDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAvLyB0cmFuc2xhdGlvblxuICAgICAgICAgIHg6IHRoaXMuZSxcbiAgICAgICAgICB5OiB0aGlzLmYsXG4gICAgICAgICAgdHJhbnNmb3JtZWRYOiAodGhpcy5lICogTWF0aC5jb3Moc2tld1ggKiBNYXRoLlBJIC8gMTgwKSArIHRoaXMuZiAqIE1hdGguc2luKHNrZXdYICogTWF0aC5QSSAvIDE4MCkpIC8gTWF0aC5zcXJ0KHRoaXMuYSAqIHRoaXMuYSArIHRoaXMuYiAqIHRoaXMuYiksXG4gICAgICAgICAgdHJhbnNmb3JtZWRZOiAodGhpcy5mICogTWF0aC5jb3Moc2tld1ggKiBNYXRoLlBJIC8gMTgwKSArIHRoaXMuZSAqIE1hdGguc2luKC1za2V3WCAqIE1hdGguUEkgLyAxODApKSAvIE1hdGguc3FydCh0aGlzLmMgKiB0aGlzLmMgKyB0aGlzLmQgKiB0aGlzLmQpLFxuICAgICAgICAgIC8vIHNrZXdcbiAgICAgICAgICBza2V3WDogLXNrZXdYLFxuICAgICAgICAgIHNrZXdZOiAxODAgLyBNYXRoLlBJICogTWF0aC5hdGFuMihweS55LCBweS54KSxcbiAgICAgICAgICAvLyBzY2FsZVxuICAgICAgICAgIHNjYWxlWDogTWF0aC5zcXJ0KHRoaXMuYSAqIHRoaXMuYSArIHRoaXMuYiAqIHRoaXMuYiksXG4gICAgICAgICAgc2NhbGVZOiBNYXRoLnNxcnQodGhpcy5jICogdGhpcy5jICsgdGhpcy5kICogdGhpcy5kKSxcbiAgICAgICAgICAvLyByb3RhdGlvblxuICAgICAgICAgIHJvdGF0aW9uOiBza2V3WCxcbiAgICAgICAgICBhOiB0aGlzLmEsXG4gICAgICAgICAgYjogdGhpcy5iLFxuICAgICAgICAgIGM6IHRoaXMuYyxcbiAgICAgICAgICBkOiB0aGlzLmQsXG4gICAgICAgICAgZTogdGhpcy5lLFxuICAgICAgICAgIGY6IHRoaXMuZixcbiAgICAgICAgICBtYXRyaXg6IG5ldyBTVkcuTWF0cml4KHRoaXMpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gQ2xvbmUgbWF0cml4XG4gICAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3JwaCBvbmUgbWF0cml4IGludG8gYW5vdGhlclxuICAgICAgbW9ycGg6IGZ1bmN0aW9uIG1vcnBoKG1hdHJpeCkge1xuICAgICAgICAvLyBzdG9yZSBuZXcgZGVzdGluYXRpb25cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuTWF0cml4KG1hdHJpeCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBtb3JwaGVkIG1hdHJpeCBhdCBhIGdpdmVuIHBvc2l0aW9uXG4gICAgICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcbiAgICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpczsgLy8gY2FsY3VsYXRlIG1vcnBoZWQgbWF0cml4IGF0IGEgZ2l2ZW4gcG9zaXRpb25cblxuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgoe1xuICAgICAgICAgIGE6IHRoaXMuYSArICh0aGlzLmRlc3RpbmF0aW9uLmEgLSB0aGlzLmEpICogcG9zLFxuICAgICAgICAgIGI6IHRoaXMuYiArICh0aGlzLmRlc3RpbmF0aW9uLmIgLSB0aGlzLmIpICogcG9zLFxuICAgICAgICAgIGM6IHRoaXMuYyArICh0aGlzLmRlc3RpbmF0aW9uLmMgLSB0aGlzLmMpICogcG9zLFxuICAgICAgICAgIGQ6IHRoaXMuZCArICh0aGlzLmRlc3RpbmF0aW9uLmQgLSB0aGlzLmQpICogcG9zLFxuICAgICAgICAgIGU6IHRoaXMuZSArICh0aGlzLmRlc3RpbmF0aW9uLmUgLSB0aGlzLmUpICogcG9zLFxuICAgICAgICAgIGY6IHRoaXMuZiArICh0aGlzLmRlc3RpbmF0aW9uLmYgLSB0aGlzLmYpICogcG9zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgfSxcbiAgICAgIC8vIE11bHRpcGxpZXMgYnkgZ2l2ZW4gbWF0cml4XG4gICAgICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkobWF0cml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLm11bHRpcGx5KHBhcnNlTWF0cml4KG1hdHJpeCkubmF0aXZlKCkpKTtcbiAgICAgIH0sXG4gICAgICAvLyBJbnZlcnNlcyBtYXRyaXhcbiAgICAgIGludmVyc2U6IGZ1bmN0aW9uIGludmVyc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLmludmVyc2UoKSk7XG4gICAgICB9LFxuICAgICAgLy8gVHJhbnNsYXRlIG1hdHJpeFxuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5uYXRpdmUoKS50cmFuc2xhdGUoeCB8fCAwLCB5IHx8IDApKTtcbiAgICAgIH0sXG4gICAgICAvLyBTY2FsZSBtYXRyaXhcbiAgICAgIHNjYWxlOiBmdW5jdGlvbiBzY2FsZSh4LCB5LCBjeCwgY3kpIHtcbiAgICAgICAgLy8gc3VwcG9ydCB1bmlmb3JtYWwgc2NhbGVcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHkgPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMykge1xuICAgICAgICAgIGN5ID0gY3g7XG4gICAgICAgICAgY3ggPSB5O1xuICAgICAgICAgIHkgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJvdW5kKGN4LCBjeSwgbmV3IFNWRy5NYXRyaXgoeCwgMCwgMCwgeSwgMCwgMCkpO1xuICAgICAgfSxcbiAgICAgIC8vIFJvdGF0ZSBtYXRyaXhcbiAgICAgIHJvdGF0ZTogZnVuY3Rpb24gcm90YXRlKHIsIGN4LCBjeSkge1xuICAgICAgICAvLyBjb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICAgICAgICByID0gU1ZHLnV0aWxzLnJhZGlhbnMocik7XG4gICAgICAgIHJldHVybiB0aGlzLmFyb3VuZChjeCwgY3ksIG5ldyBTVkcuTWF0cml4KE1hdGguY29zKHIpLCBNYXRoLnNpbihyKSwgLU1hdGguc2luKHIpLCBNYXRoLmNvcyhyKSwgMCwgMCkpO1xuICAgICAgfSxcbiAgICAgIC8vIEZsaXAgbWF0cml4IG9uIHggb3IgeSwgYXQgYSBnaXZlbiBvZmZzZXRcbiAgICAgIGZsaXA6IGZ1bmN0aW9uIGZsaXAoYSwgbykge1xuICAgICAgICByZXR1cm4gYSA9PSAneCcgPyB0aGlzLnNjYWxlKC0xLCAxLCBvLCAwKSA6IGEgPT0gJ3knID8gdGhpcy5zY2FsZSgxLCAtMSwgMCwgbykgOiB0aGlzLnNjYWxlKC0xLCAtMSwgYSwgbyAhPSBudWxsID8gbyA6IGEpO1xuICAgICAgfSxcbiAgICAgIC8vIFNrZXdcbiAgICAgIHNrZXc6IGZ1bmN0aW9uIHNrZXcoeCwgeSwgY3gsIGN5KSB7XG4gICAgICAgIC8vIHN1cHBvcnQgdW5pZm9ybWFsIHNrZXdcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHkgPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMykge1xuICAgICAgICAgIGN5ID0gY3g7XG4gICAgICAgICAgY3ggPSB5O1xuICAgICAgICAgIHkgPSB4O1xuICAgICAgICB9IC8vIGNvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG5cblxuICAgICAgICB4ID0gU1ZHLnV0aWxzLnJhZGlhbnMoeCk7XG4gICAgICAgIHkgPSBTVkcudXRpbHMucmFkaWFucyh5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJvdW5kKGN4LCBjeSwgbmV3IFNWRy5NYXRyaXgoMSwgTWF0aC50YW4oeSksIE1hdGgudGFuKHgpLCAxLCAwLCAwKSk7XG4gICAgICB9LFxuICAgICAgLy8gU2tld1hcbiAgICAgIHNrZXdYOiBmdW5jdGlvbiBza2V3WCh4LCBjeCwgY3kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tldyh4LCAwLCBjeCwgY3kpO1xuICAgICAgfSxcbiAgICAgIC8vIFNrZXdZXG4gICAgICBza2V3WTogZnVuY3Rpb24gc2tld1koeSwgY3gsIGN5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNrZXcoMCwgeSwgY3gsIGN5KTtcbiAgICAgIH0sXG4gICAgICAvLyBUcmFuc2Zvcm0gYXJvdW5kIGEgY2VudGVyIHBvaW50XG4gICAgICBhcm91bmQ6IGZ1bmN0aW9uIGFyb3VuZChjeCwgY3ksIG1hdHJpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgxLCAwLCAwLCAxLCBjeCB8fCAwLCBjeSB8fCAwKSkubXVsdGlwbHkobWF0cml4KS5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgxLCAwLCAwLCAxLCAtY3ggfHwgMCwgLWN5IHx8IDApKTtcbiAgICAgIH0sXG4gICAgICAvLyBDb252ZXJ0IHRvIG5hdGl2ZSBTVkdNYXRyaXhcbiAgICAgIG5hdGl2ZTogZnVuY3Rpb24gbmF0aXZlKCkge1xuICAgICAgICAvLyBjcmVhdGUgbmV3IG1hdHJpeFxuICAgICAgICB2YXIgbWF0cml4ID0gU1ZHLnBhcnNlci5uYXRpdmUuY3JlYXRlU1ZHTWF0cml4KCk7IC8vIHVwZGF0ZSB3aXRoIGN1cnJlbnQgdmFsdWVzXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGFiY2RlZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIG1hdHJpeFthYmNkZWZbaV1dID0gdGhpc1thYmNkZWZbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgIH0sXG4gICAgICAvLyBDb252ZXJ0IG1hdHJpeCB0byBzdHJpbmdcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBtYXRyaXggZGlyZWN0bHksIGF2b2lkIHZhbHVlcyB0aGF0IGFyZSB0b28gc21hbGxcbiAgICAgICAgcmV0dXJuICdtYXRyaXgoJyArIGZsb2F0MzJTdHJpbmcodGhpcy5hKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5iKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5jKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5kKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5lKSArICcsJyArIGZsb2F0MzJTdHJpbmcodGhpcy5mKSArICcpJztcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIERlZmluZSBwYXJlbnRcbiAgICBwYXJlbnQ6IFNWRy5FbGVtZW50LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBHZXQgY3VycmVudCBtYXRyaXhcbiAgICAgIGN0bTogZnVuY3Rpb24gY3RtKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5ub2RlLmdldENUTSgpKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgY3VycmVudCBzY3JlZW4gbWF0cml4XG4gICAgICBzY3JlZW5DVE06IGZ1bmN0aW9uIHNjcmVlbkNUTSgpIHtcbiAgICAgICAgLyogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM0NDUzN1xuICAgICAgICAgICBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIEZGIGRvZXMgbm90IHJldHVybiB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgICAgICAgIGZvciB0aGUgaW5uZXIgY29vcmRpbmF0ZSBzeXN0ZW0gd2hlbiBnZXRTY3JlZW5DVE0oKSBpcyBjYWxsZWQgb24gbmVzdGVkIHN2Z3MuXG4gICAgICAgICAgIEhvd2V2ZXIgYWxsIG90aGVyIEJyb3dzZXJzIGRvIHRoYXQgKi9cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTVkcuTmVzdGVkKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLnJlY3QoMSwgMSk7XG4gICAgICAgICAgdmFyIG0gPSByZWN0Lm5vZGUuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgcmVjdC5yZW1vdmUoKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgobSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5ub2RlLmdldFNjcmVlbkNUTSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuUG9pbnQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoeCwgeSkge1xuICAgICAgdmFyIHNvdXJjZSxcbiAgICAgICAgICBiYXNlID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwIC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XG5cbiAgICAgIH07XG4gICAgICBzb3VyY2UgPSBBcnJheS5pc0FycmF5KHgpID8ge1xuICAgICAgICB4OiB4WzBdLFxuICAgICAgICB5OiB4WzFdXG4gICAgICB9IDogX3R5cGVvZih4KSA9PT0gJ29iamVjdCcgPyB7XG4gICAgICAgIHg6IHgueCxcbiAgICAgICAgeTogeC55XG4gICAgICB9IDogeCAhPSBudWxsID8ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5ICE9IG51bGwgPyB5IDogeFxuICAgICAgfSA6IGJhc2U7IC8vIElmIHkgaGFzIG5vIHZhbHVlLCB0aGVuIHggaXMgdXNlZCBoYXMgaXRzIHZhbHVlXG4gICAgICAvLyBtZXJnZSBzb3VyY2VcblxuICAgICAgdGhpcy54ID0gc291cmNlLng7XG4gICAgICB0aGlzLnkgPSBzb3VyY2UueTtcbiAgICB9LFxuICAgIC8vIEFkZCBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBDbG9uZSBwb2ludFxuICAgICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3JwaCBvbmUgcG9pbnQgaW50byBhbm90aGVyXG4gICAgICBtb3JwaDogZnVuY3Rpb24gbW9ycGgoeCwgeSkge1xuICAgICAgICAvLyBzdG9yZSBuZXcgZGVzdGluYXRpb25cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuUG9pbnQoeCwgeSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBtb3JwaGVkIHBvaW50IGF0IGEgZ2l2ZW4gcG9zaXRpb25cbiAgICAgIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxuICAgICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzOyAvLyBjYWxjdWxhdGUgbW9ycGhlZCBtYXRyaXggYXQgYSBnaXZlbiBwb3NpdGlvblxuXG4gICAgICAgIHZhciBwb2ludCA9IG5ldyBTVkcuUG9pbnQoe1xuICAgICAgICAgIHg6IHRoaXMueCArICh0aGlzLmRlc3RpbmF0aW9uLnggLSB0aGlzLngpICogcG9zLFxuICAgICAgICAgIHk6IHRoaXMueSArICh0aGlzLmRlc3RpbmF0aW9uLnkgLSB0aGlzLnkpICogcG9zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9LFxuICAgICAgLy8gQ29udmVydCB0byBuYXRpdmUgU1ZHUG9pbnRcbiAgICAgIG5hdGl2ZTogZnVuY3Rpb24gbmF0aXZlKCkge1xuICAgICAgICAvLyBjcmVhdGUgbmV3IHBvaW50XG4gICAgICAgIHZhciBwb2ludCA9IFNWRy5wYXJzZXIubmF0aXZlLmNyZWF0ZVNWR1BvaW50KCk7IC8vIHVwZGF0ZSB3aXRoIGN1cnJlbnQgdmFsdWVzXG5cbiAgICAgICAgcG9pbnQueCA9IHRoaXMueDtcbiAgICAgICAgcG9pbnQueSA9IHRoaXMueTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfSxcbiAgICAgIC8vIHRyYW5zZm9ybSBwb2ludCB3aXRoIG1hdHJpeFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obWF0cml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlBvaW50KHRoaXMubmF0aXZlKCkubWF0cml4VHJhbnNmb3JtKG1hdHJpeC5uYXRpdmUoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBHZXQgcG9pbnRcbiAgICBwb2ludDogZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgcmV0dXJuIG5ldyBTVkcuUG9pbnQoeCwgeSkudHJhbnNmb3JtKHRoaXMuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gU2V0IHN2ZyBlbGVtZW50IGF0dHJpYnV0ZVxuICAgIGF0dHI6IGZ1bmN0aW9uIGF0dHIoYSwgdiwgbikge1xuICAgICAgLy8gYWN0IGFzIGZ1bGwgZ2V0dGVyXG4gICAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIC8vIGdldCBhbiBvYmplY3Qgb2YgYXR0cmlidXRlc1xuICAgICAgICBhID0ge307XG4gICAgICAgIHYgPSB0aGlzLm5vZGUuYXR0cmlidXRlcztcblxuICAgICAgICBmb3IgKG4gPSB2Lmxlbmd0aCAtIDE7IG4gPj0gMDsgbi0tKSB7XG4gICAgICAgICAgYVt2W25dLm5vZGVOYW1lXSA9IFNWRy5yZWdleC5pc051bWJlci50ZXN0KHZbbl0ubm9kZVZhbHVlKSA/IHBhcnNlRmxvYXQodltuXS5ub2RlVmFsdWUpIDogdltuXS5ub2RlVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gYXBwbHkgZXZlcnkgYXR0cmlidXRlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXG4gICAgICAgIGZvciAodiBpbiBhKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKHYsIGFbdl0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHZhbHVlXG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoYSk7XG4gICAgICB9IGVsc2UgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAvLyBhY3QgYXMgYSBnZXR0ZXIgaWYgdGhlIGZpcnN0IGFuZCBvbmx5IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3RcbiAgICAgICAgdiA9IHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoYSk7XG4gICAgICAgIHJldHVybiB2ID09IG51bGwgPyBTVkcuZGVmYXVsdHMuYXR0cnNbYV0gOiBTVkcucmVnZXguaXNOdW1iZXIudGVzdCh2KSA/IHBhcnNlRmxvYXQodikgOiB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQlVHIEZJWDogc29tZSBicm93c2VycyB3aWxsIHJlbmRlciBhIHN0cm9rZSBpZiBhIGNvbG9yIGlzIGdpdmVuIGV2ZW4gdGhvdWdoIHN0cm9rZSB3aWR0aCBpcyAwXG4gICAgICAgIGlmIChhID09ICdzdHJva2Utd2lkdGgnKSB7XG4gICAgICAgICAgdGhpcy5hdHRyKCdzdHJva2UnLCBwYXJzZUZsb2F0KHYpID4gMCA/IHRoaXMuX3N0cm9rZSA6IG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGEgPT0gJ3N0cm9rZScpIHtcbiAgICAgICAgICB0aGlzLl9zdHJva2UgPSB2O1xuICAgICAgICB9IC8vIGNvbnZlcnQgaW1hZ2UgZmlsbCBhbmQgc3Ryb2tlIHRvIHBhdHRlcm5zXG5cblxuICAgICAgICBpZiAoYSA9PSAnZmlsbCcgfHwgYSA9PSAnc3Ryb2tlJykge1xuICAgICAgICAgIGlmIChTVkcucmVnZXguaXNJbWFnZS50ZXN0KHYpKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5kb2MoKS5kZWZzKCkuaW1hZ2UodiwgMCwgMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBTVkcuSW1hZ2UpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmRvYygpLmRlZnMoKS5wYXR0ZXJuKDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZGQodik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZW5zdXJlIGNvcnJlY3QgbnVtZXJpYyB2YWx1ZXMgKGFsc28gYWNjZXB0cyBOYU4gYW5kIEluZmluaXR5KVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHYgPSBuZXcgU1ZHLk51bWJlcih2KTtcbiAgICAgICAgfSAvLyBlbnN1cmUgZnVsbCBoZXggY29sb3JcbiAgICAgICAgZWxzZSBpZiAoU1ZHLkNvbG9yLmlzQ29sb3IodikpIHtcbiAgICAgICAgICAgIHYgPSBuZXcgU1ZHLkNvbG9yKHYpO1xuICAgICAgICAgIH0gLy8gcGFyc2UgYXJyYXkgdmFsdWVzXG4gICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgICB2ID0gbmV3IFNWRy5BcnJheSh2KTtcbiAgICAgICAgICAgIH0gLy8gaWYgdGhlIHBhc3NlZCBhdHRyaWJ1dGUgaXMgbGVhZGluZy4uLlxuXG5cbiAgICAgICAgaWYgKGEgPT0gJ2xlYWRpbmcnKSB7XG4gICAgICAgICAgLy8gLi4uIGNhbGwgdGhlIGxlYWRpbmcgbWV0aG9kIGluc3RlYWRcbiAgICAgICAgICBpZiAodGhpcy5sZWFkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmxlYWRpbmcodik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNldCBnaXZlbiBhdHRyaWJ1dGUgb24gbm9kZVxuICAgICAgICAgIHR5cGVvZiBuID09PSAnc3RyaW5nJyA/IHRoaXMubm9kZS5zZXRBdHRyaWJ1dGVOUyhuLCBhLCB2LnRvU3RyaW5nKCkpIDogdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShhLCB2LnRvU3RyaW5nKCkpO1xuICAgICAgICB9IC8vIHJlYnVpbGQgaWYgcmVxdWlyZWRcblxuXG4gICAgICAgIGlmICh0aGlzLnJlYnVpbGQgJiYgKGEgPT0gJ2ZvbnQtc2l6ZScgfHwgYSA9PSAneCcpKSB7XG4gICAgICAgICAgdGhpcy5yZWJ1aWxkKGEsIHYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBBZGQgdHJhbnNmb3JtYXRpb25zXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obywgcmVsYXRpdmUpIHtcbiAgICAgIC8vIGdldCB0YXJnZXQgaW4gY2FzZSBvZiB0aGUgZnggbW9kdWxlLCBvdGhlcndpc2UgcmVmZXJlbmNlIHRoaXNcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLFxuICAgICAgICAgIG1hdHJpeCxcbiAgICAgICAgICBiYm94OyAvLyBhY3QgYXMgYSBnZXR0ZXJcblxuICAgICAgaWYgKF90eXBlb2YobykgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGdldCBjdXJyZW50IG1hdHJpeFxuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCh0YXJnZXQpLmV4dHJhY3QoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG1hdHJpeFtvXSA6IG1hdHJpeDtcbiAgICAgIH0gLy8gZ2V0IGN1cnJlbnQgbWF0cml4XG5cblxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5NYXRyaXgodGFyZ2V0KTsgLy8gZW5zdXJlIHJlbGF0aXZlIGZsYWdcblxuICAgICAgcmVsYXRpdmUgPSAhIXJlbGF0aXZlIHx8ICEhby5yZWxhdGl2ZTsgLy8gYWN0IG9uIG1hdHJpeFxuXG4gICAgICBpZiAoby5hICE9IG51bGwpIHtcbiAgICAgICAgbWF0cml4ID0gcmVsYXRpdmUgLy8gcmVsYXRpdmVcbiAgICAgICAgPyBtYXRyaXgubXVsdGlwbHkobmV3IFNWRy5NYXRyaXgobykpIC8vIGFic29sdXRlXG4gICAgICAgIDogbmV3IFNWRy5NYXRyaXgobyk7IC8vIGFjdCBvbiByb3RhdGlvblxuICAgICAgfSBlbHNlIGlmIChvLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxuICAgICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KTsgLy8gYXBwbHkgdHJhbnNmb3JtYXRpb25cblxuICAgICAgICBtYXRyaXggPSByZWxhdGl2ZSAvLyByZWxhdGl2ZVxuICAgICAgICA/IG1hdHJpeC5yb3RhdGUoby5yb3RhdGlvbiwgby5jeCwgby5jeSkgLy8gYWJzb2x1dGVcbiAgICAgICAgOiBtYXRyaXgucm90YXRlKG8ucm90YXRpb24gLSBtYXRyaXguZXh0cmFjdCgpLnJvdGF0aW9uLCBvLmN4LCBvLmN5KTsgLy8gYWN0IG9uIHNjYWxlXG4gICAgICB9IGVsc2UgaWYgKG8uc2NhbGUgIT0gbnVsbCB8fCBvLnNjYWxlWCAhPSBudWxsIHx8IG8uc2NhbGVZICE9IG51bGwpIHtcbiAgICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxuICAgICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KTsgLy8gZW5zdXJlIHNjYWxlIHZhbHVlcyBvbiBib3RoIGF4ZXNcblxuICAgICAgICBvLnNjYWxlWCA9IG8uc2NhbGUgIT0gbnVsbCA/IG8uc2NhbGUgOiBvLnNjYWxlWCAhPSBudWxsID8gby5zY2FsZVggOiAxO1xuICAgICAgICBvLnNjYWxlWSA9IG8uc2NhbGUgIT0gbnVsbCA/IG8uc2NhbGUgOiBvLnNjYWxlWSAhPSBudWxsID8gby5zY2FsZVkgOiAxO1xuXG4gICAgICAgIGlmICghcmVsYXRpdmUpIHtcbiAgICAgICAgICAvLyBhYnNvbHV0ZTsgbXVsdGlwbHkgaW52ZXJzZWQgdmFsdWVzXG4gICAgICAgICAgdmFyIGUgPSBtYXRyaXguZXh0cmFjdCgpO1xuICAgICAgICAgIG8uc2NhbGVYID0gby5zY2FsZVggKiAxIC8gZS5zY2FsZVg7XG4gICAgICAgICAgby5zY2FsZVkgPSBvLnNjYWxlWSAqIDEgLyBlLnNjYWxlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeCA9IG1hdHJpeC5zY2FsZShvLnNjYWxlWCwgby5zY2FsZVksIG8uY3gsIG8uY3kpOyAvLyBhY3Qgb24gc2tld1xuICAgICAgfSBlbHNlIGlmIChvLnNrZXcgIT0gbnVsbCB8fCBvLnNrZXdYICE9IG51bGwgfHwgby5za2V3WSAhPSBudWxsKSB7XG4gICAgICAgIC8vIGVuc3VyZSBjZW50cmUgcG9pbnRcbiAgICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldCk7IC8vIGVuc3VyZSBza2V3IHZhbHVlcyBvbiBib3RoIGF4ZXNcblxuICAgICAgICBvLnNrZXdYID0gby5za2V3ICE9IG51bGwgPyBvLnNrZXcgOiBvLnNrZXdYICE9IG51bGwgPyBvLnNrZXdYIDogMDtcbiAgICAgICAgby5za2V3WSA9IG8uc2tldyAhPSBudWxsID8gby5za2V3IDogby5za2V3WSAhPSBudWxsID8gby5za2V3WSA6IDA7XG5cbiAgICAgICAgaWYgKCFyZWxhdGl2ZSkge1xuICAgICAgICAgIC8vIGFic29sdXRlOyByZXNldCBza2V3IHZhbHVlc1xuICAgICAgICAgIHZhciBlID0gbWF0cml4LmV4dHJhY3QoKTtcbiAgICAgICAgICBtYXRyaXggPSBtYXRyaXgubXVsdGlwbHkobmV3IFNWRy5NYXRyaXgoKS5za2V3KGUuc2tld1gsIGUuc2tld1ksIG8uY3gsIG8uY3kpLmludmVyc2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXggPSBtYXRyaXguc2tldyhvLnNrZXdYLCBvLnNrZXdZLCBvLmN4LCBvLmN5KTsgLy8gYWN0IG9uIGZsaXBcbiAgICAgIH0gZWxzZSBpZiAoby5mbGlwKSB7XG4gICAgICAgIGlmIChvLmZsaXAgPT0gJ3gnIHx8IG8uZmxpcCA9PSAneScpIHtcbiAgICAgICAgICBvLm9mZnNldCA9IG8ub2Zmc2V0ID09IG51bGwgPyB0YXJnZXQuYmJveCgpWydjJyArIG8uZmxpcF0gOiBvLm9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoby5vZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYmJveCA9IHRhcmdldC5iYm94KCk7XG4gICAgICAgICAgICBvLmZsaXAgPSBiYm94LmN4O1xuICAgICAgICAgICAgby5vZmZzZXQgPSBiYm94LmN5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvLmZsaXAgPSBvLm9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCgpLmZsaXAoby5mbGlwLCBvLm9mZnNldCk7IC8vIGFjdCBvbiB0cmFuc2xhdGVcbiAgICAgIH0gZWxzZSBpZiAoby54ICE9IG51bGwgfHwgby55ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgLy8gcmVsYXRpdmVcbiAgICAgICAgICBtYXRyaXggPSBtYXRyaXgudHJhbnNsYXRlKG8ueCwgby55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhYnNvbHV0ZVxuICAgICAgICAgIGlmIChvLnggIT0gbnVsbCkgbWF0cml4LmUgPSBvLng7XG4gICAgICAgICAgaWYgKG8ueSAhPSBudWxsKSBtYXRyaXguZiA9IG8ueTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBtYXRyaXgpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkZYLCB7XG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obywgcmVsYXRpdmUpIHtcbiAgICAgIC8vIGdldCB0YXJnZXQgaW4gY2FzZSBvZiB0aGUgZnggbW9kdWxlLCBvdGhlcndpc2UgcmVmZXJlbmNlIHRoaXNcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldCgpLFxuICAgICAgICAgIG1hdHJpeCxcbiAgICAgICAgICBiYm94OyAvLyBhY3QgYXMgYSBnZXR0ZXJcblxuICAgICAgaWYgKF90eXBlb2YobykgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGdldCBjdXJyZW50IG1hdHJpeFxuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCh0YXJnZXQpLmV4dHJhY3QoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG1hdHJpeFtvXSA6IG1hdHJpeDtcbiAgICAgIH0gLy8gZW5zdXJlIHJlbGF0aXZlIGZsYWdcblxuXG4gICAgICByZWxhdGl2ZSA9ICEhcmVsYXRpdmUgfHwgISFvLnJlbGF0aXZlOyAvLyBhY3Qgb24gbWF0cml4XG5cbiAgICAgIGlmIChvLmEgIT0gbnVsbCkge1xuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeChvKTsgLy8gYWN0IG9uIHJvdGF0aW9uXG4gICAgICB9IGVsc2UgaWYgKG8ucm90YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpOyAvLyBhcHBseSB0cmFuc2Zvcm1hdGlvblxuXG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuUm90YXRlKG8ucm90YXRpb24sIG8uY3gsIG8uY3kpOyAvLyBhY3Qgb24gc2NhbGVcbiAgICAgIH0gZWxzZSBpZiAoby5zY2FsZSAhPSBudWxsIHx8IG8uc2NhbGVYICE9IG51bGwgfHwgby5zY2FsZVkgIT0gbnVsbCkge1xuICAgICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpOyAvLyBlbnN1cmUgc2NhbGUgdmFsdWVzIG9uIGJvdGggYXhlc1xuXG4gICAgICAgIG8uc2NhbGVYID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVYICE9IG51bGwgPyBvLnNjYWxlWCA6IDE7XG4gICAgICAgIG8uc2NhbGVZID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVZICE9IG51bGwgPyBvLnNjYWxlWSA6IDE7XG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuU2NhbGUoby5zY2FsZVgsIG8uc2NhbGVZLCBvLmN4LCBvLmN5KTsgLy8gYWN0IG9uIHNrZXdcbiAgICAgIH0gZWxzZSBpZiAoby5za2V3WCAhPSBudWxsIHx8IG8uc2tld1kgIT0gbnVsbCkge1xuICAgICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XG4gICAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpOyAvLyBlbnN1cmUgc2tldyB2YWx1ZXMgb24gYm90aCBheGVzXG5cbiAgICAgICAgby5za2V3WCA9IG8uc2tld1ggIT0gbnVsbCA/IG8uc2tld1ggOiAwO1xuICAgICAgICBvLnNrZXdZID0gby5za2V3WSAhPSBudWxsID8gby5za2V3WSA6IDA7XG4gICAgICAgIG1hdHJpeCA9IG5ldyBTVkcuU2tldyhvLnNrZXdYLCBvLnNrZXdZLCBvLmN4LCBvLmN5KTsgLy8gYWN0IG9uIGZsaXBcbiAgICAgIH0gZWxzZSBpZiAoby5mbGlwKSB7XG4gICAgICAgIGlmIChvLmZsaXAgPT0gJ3gnIHx8IG8uZmxpcCA9PSAneScpIHtcbiAgICAgICAgICBvLm9mZnNldCA9IG8ub2Zmc2V0ID09IG51bGwgPyB0YXJnZXQuYmJveCgpWydjJyArIG8uZmxpcF0gOiBvLm9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoby5vZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYmJveCA9IHRhcmdldC5iYm94KCk7XG4gICAgICAgICAgICBvLmZsaXAgPSBiYm94LmN4O1xuICAgICAgICAgICAgby5vZmZzZXQgPSBiYm94LmN5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvLmZsaXAgPSBvLm9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCgpLmZsaXAoby5mbGlwLCBvLm9mZnNldCk7IC8vIGFjdCBvbiB0cmFuc2xhdGVcbiAgICAgIH0gZWxzZSBpZiAoby54ICE9IG51bGwgfHwgby55ICE9IG51bGwpIHtcbiAgICAgICAgbWF0cml4ID0gbmV3IFNWRy5UcmFuc2xhdGUoby54LCBvLnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1hdHJpeCkgcmV0dXJuIHRoaXM7XG4gICAgICBtYXRyaXgucmVsYXRpdmUgPSByZWxhdGl2ZTtcbiAgICAgIHRoaXMubGFzdCgpLnRyYW5zZm9ybXMucHVzaChtYXRyaXgpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFydCgpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBSZXNldCBhbGwgdHJhbnNmb3JtYXRpb25zXG4gICAgdW50cmFuc2Zvcm06IGZ1bmN0aW9uIHVudHJhbnNmb3JtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbnVsbCk7XG4gICAgfSxcbiAgICAvLyBtZXJnZSB0aGUgd2hvbGUgdHJhbnNmb3JtYXRpb24gY2hhaW4gaW50byBvbmUgbWF0cml4IGFuZCByZXR1cm5zIGl0XG4gICAgbWF0cml4aWZ5OiBmdW5jdGlvbiBtYXRyaXhpZnkoKSB7XG4gICAgICB2YXIgbWF0cml4ID0gKHRoaXMuYXR0cigndHJhbnNmb3JtJykgfHwgJycpLiAvLyBzcGxpdCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIHNwbGl0KFNWRy5yZWdleC50cmFuc2Zvcm1zKS5zbGljZSgwLCAtMSkubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgLy8gZ2VuZXJhdGUga2V5ID0+IHZhbHVlIHBhaXJzXG4gICAgICAgIHZhciBrdiA9IHN0ci50cmltKCkuc3BsaXQoJygnKTtcbiAgICAgICAgcmV0dXJuIFtrdlswXSwga3ZbMV0uc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICAgICAgICB9KV07XG4gICAgICB9KSAvLyBtZXJnZSBldmVyeSB0cmFuc2Zvcm1hdGlvbiBpbnRvIG9uZSBtYXRyaXhcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG1hdHJpeCwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1bMF0gPT0gJ21hdHJpeCcpIHJldHVybiBtYXRyaXgubXVsdGlwbHkoYXJyYXlUb01hdHJpeCh0cmFuc2Zvcm1bMV0pKTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeFt0cmFuc2Zvcm1bMF1dLmFwcGx5KG1hdHJpeCwgdHJhbnNmb3JtWzFdKTtcbiAgICAgIH0sIG5ldyBTVkcuTWF0cml4KCkpO1xuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuICAgIC8vIGFkZCBhbiBlbGVtZW50IHRvIGFub3RoZXIgcGFyZW50IHdpdGhvdXQgY2hhbmdpbmcgdGhlIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2NyZWVuXG4gICAgdG9QYXJlbnQ6IGZ1bmN0aW9uIHRvUGFyZW50KHBhcmVudCkge1xuICAgICAgaWYgKHRoaXMgPT0gcGFyZW50KSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBjdG0gPSB0aGlzLnNjcmVlbkNUTSgpO1xuICAgICAgdmFyIHBDdG0gPSBwYXJlbnQuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpO1xuICAgICAgdGhpcy5hZGRUbyhwYXJlbnQpLnVudHJhbnNmb3JtKCkudHJhbnNmb3JtKHBDdG0ubXVsdGlwbHkoY3RtKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIHNhbWUgYXMgYWJvdmUgd2l0aCBwYXJlbnQgZXF1YWxzIHJvb3Qtc3ZnXG4gICAgdG9Eb2M6IGZ1bmN0aW9uIHRvRG9jKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9QYXJlbnQodGhpcy5kb2MoKSk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlRyYW5zZm9ybWF0aW9uID0gU1ZHLmludmVudCh7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlLCBpbnZlcnNlZCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBpbnZlcnNlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICB0aGlzW3RoaXMuYXJndW1lbnRzW2ldXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHNvdXJjZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dID0gc291cmNlW3RoaXMuYXJndW1lbnRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmludmVyc2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChpbnZlcnNlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmludmVyc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgYXJndW1lbnRzOiBbXSxcbiAgICAgIG1ldGhvZDogJycsXG4gICAgICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBwYXJhbXMucHVzaCh0aGlzW3RoaXMuYXJndW1lbnRzW2ldXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IHRoaXMuX3VuZG8gfHwgbmV3IFNWRy5NYXRyaXgoKTtcbiAgICAgICAgbSA9IG5ldyBTVkcuTWF0cml4KCkubW9ycGgoU1ZHLk1hdHJpeC5wcm90b3R5cGVbdGhpcy5tZXRob2RdLmFwcGx5KG0sIHBhcmFtcykpLmF0KHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmludmVyc2VkID8gbS5pbnZlcnNlKCkgOiBtO1xuICAgICAgfSxcbiAgICAgIHVuZG86IGZ1bmN0aW9uIHVuZG8obykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBvW3RoaXMuYXJndW1lbnRzW2ldXSA9IHR5cGVvZiB0aGlzW3RoaXMuYXJndW1lbnRzW2ldXSA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogb1t0aGlzLmFyZ3VtZW50c1tpXV07XG4gICAgICAgIH0gLy8gVGhlIG1ldGhvZCBTVkcuTWF0cml4LmV4dHJhY3Qgd2hpY2ggd2FzIHVzZWQgYmVmb3JlIGNhbGxpbmcgdGhpc1xuICAgICAgICAvLyBtZXRob2QgdG8gb2J0YWluIGEgdmFsdWUgZm9yIHRoZSBwYXJhbWV0ZXIgbyBkb2Vzbid0IHJldHVybiBhIGN4IGFuZFxuICAgICAgICAvLyBhIGN5IHNvIHdlIHVzZSB0aGUgb25lcyB0aGF0IHdlcmUgcHJvdmlkZWQgdG8gdGhpcyBvYmplY3QgYXQgaXRzIGNyZWF0aW9uXG5cblxuICAgICAgICBvLmN4ID0gdGhpcy5jeDtcbiAgICAgICAgby5jeSA9IHRoaXMuY3k7XG4gICAgICAgIHRoaXMuX3VuZG8gPSBuZXcgU1ZHW2NhcGl0YWxpemUodGhpcy5tZXRob2QpXShvLCB0cnVlKS5hdCgxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlRyYW5zbGF0ZSA9IFNWRy5pbnZlbnQoe1xuICAgIHBhcmVudDogU1ZHLk1hdHJpeCxcbiAgICBpbmhlcml0OiBTVkcuVHJhbnNmb3JtYXRpb24sXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlLCBpbnZlcnNlZCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICBhcmd1bWVudHM6IFsndHJhbnNmb3JtZWRYJywgJ3RyYW5zZm9ybWVkWSddLFxuICAgICAgbWV0aG9kOiAndHJhbnNsYXRlJ1xuICAgIH1cbiAgfSk7XG4gIFNWRy5Sb3RhdGUgPSBTVkcuaW52ZW50KHtcbiAgICBwYXJlbnQ6IFNWRy5NYXRyaXgsXG4gICAgaW5oZXJpdDogU1ZHLlRyYW5zZm9ybWF0aW9uLFxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHNvdXJjZSwgaW52ZXJzZWQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgYXJndW1lbnRzOiBbJ3JvdGF0aW9uJywgJ2N4JywgJ2N5J10sXG4gICAgICBtZXRob2Q6ICdyb3RhdGUnLFxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgICB2YXIgbSA9IG5ldyBTVkcuTWF0cml4KCkucm90YXRlKG5ldyBTVkcuTnVtYmVyKCkubW9ycGgodGhpcy5yb3RhdGlvbiAtICh0aGlzLl91bmRvID8gdGhpcy5fdW5kby5yb3RhdGlvbiA6IDApKS5hdChwb3MpLCB0aGlzLmN4LCB0aGlzLmN5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52ZXJzZWQgPyBtLmludmVyc2UoKSA6IG07XG4gICAgICB9LFxuICAgICAgdW5kbzogZnVuY3Rpb24gdW5kbyhvKSB7XG4gICAgICAgIHRoaXMuX3VuZG8gPSBvO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuU2NhbGUgPSBTVkcuaW52ZW50KHtcbiAgICBwYXJlbnQ6IFNWRy5NYXRyaXgsXG4gICAgaW5oZXJpdDogU1ZHLlRyYW5zZm9ybWF0aW9uLFxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHNvdXJjZSwgaW52ZXJzZWQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgYXJndW1lbnRzOiBbJ3NjYWxlWCcsICdzY2FsZVknLCAnY3gnLCAnY3knXSxcbiAgICAgIG1ldGhvZDogJ3NjYWxlJ1xuICAgIH1cbiAgfSk7XG4gIFNWRy5Ta2V3ID0gU1ZHLmludmVudCh7XG4gICAgcGFyZW50OiBTVkcuTWF0cml4LFxuICAgIGluaGVyaXQ6IFNWRy5UcmFuc2Zvcm1hdGlvbixcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzb3VyY2UsIGludmVyc2VkKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBleHRlbmQ6IHtcbiAgICAgIGFyZ3VtZW50czogWydza2V3WCcsICdza2V3WScsICdjeCcsICdjeSddLFxuICAgICAgbWV0aG9kOiAnc2tldydcbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gRHluYW1pYyBzdHlsZSBnZW5lcmF0b3JcbiAgICBzdHlsZTogZnVuY3Rpb24gc3R5bGUocywgdikge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAvLyBnZXQgZnVsbCBzdHlsZVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQgfHwgJyc7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIC8vIGFwcGx5IGV2ZXJ5IHN0eWxlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXG4gICAgICAgIGlmIChfdHlwZW9mKHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodiBpbiBzKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKHYsIHNbdl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChTVkcucmVnZXguaXNDc3MudGVzdChzKSkge1xuICAgICAgICAgIC8vIHBhcnNlIGNzcyBzdHJpbmdcbiAgICAgICAgICBzID0gcy5zcGxpdCgvXFxzKjtcXHMqLykgLy8gZmlsdGVyIG91dCBzdWZmaXggOyBhbmQgc3R1ZmYgbGlrZSA7O1xuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWU7XG4gICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5zcGxpdCgvXFxzKjpcXHMqLyk7XG4gICAgICAgICAgfSk7IC8vIGFwcGx5IGV2ZXJ5IGRlZmluaXRpb24gaW5kaXZpZHVhbGx5XG5cbiAgICAgICAgICB3aGlsZSAodiA9IHMucG9wKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUodlswXSwgdlsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFjdCBhcyBhIGdldHRlciBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdFxuICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuc3R5bGVbY2FtZWxDYXNlKHMpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlW2NhbWVsQ2FzZShzKV0gPSB2ID09PSBudWxsIHx8IFNWRy5yZWdleC5pc0JsYW5rLnRlc3QodikgPyAnJyA6IHY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5QYXJlbnQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZWxlbWVudCk7XG4gICAgfSxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuRWxlbWVudCxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gUmV0dXJucyBhbGwgY2hpbGQgZWxlbWVudHNcbiAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIFNWRy51dGlscy5tYXAoU1ZHLnV0aWxzLmZpbHRlclNWR0VsZW1lbnRzKHRoaXMubm9kZS5jaGlsZE5vZGVzKSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgZ2l2ZW4gZWxlbWVudCBhdCBhIHBvc2l0aW9uXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChlbGVtZW50LCBpKSB7XG4gICAgICAgIGlmIChpID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudC5ub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50Lm5vZGUgIT0gdGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pIHtcbiAgICAgICAgICB0aGlzLm5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQubm9kZSwgdGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gQmFzaWNhbGx5IGRvZXMgdGhlIHNhbWUgYXMgYGFkZCgpYCBidXQgcmV0dXJucyB0aGUgYWRkZWQgZWxlbWVudCBpbnN0ZWFkXG4gICAgICBwdXQ6IGZ1bmN0aW9uIHB1dChlbGVtZW50LCBpKSB7XG4gICAgICAgIHRoaXMuYWRkKGVsZW1lbnQsIGkpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH0sXG4gICAgICAvLyBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgYSBjaGlsZFxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwO1xuICAgICAgfSxcbiAgICAgIC8vIEdldHMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudFxuICAgICAgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodGhpcy5ub2RlLmNoaWxkTm9kZXMpLmluZGV4T2YoZWxlbWVudC5ub2RlKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgYSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoaSkge1xuICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgZmlyc3QgY2hpbGRcbiAgICAgIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KDApO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCB0aGUgbGFzdCBjaGlsZFxuICAgICAgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpO1xuICAgICAgfSxcbiAgICAgIC8vIEl0ZXJhdGVzIG92ZXIgYWxsIGNoaWxkcmVuIGFuZCBpbnZva2VzIGEgZ2l2ZW4gYmxvY2tcbiAgICAgIGVhY2g6IGZ1bmN0aW9uIGVhY2goYmxvY2ssIGRlZXApIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpbCxcbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGlsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIGlmIChjaGlsZHJlbltpXSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSB7XG4gICAgICAgICAgICBibG9jay5hcHBseShjaGlsZHJlbltpXSwgW2ksIGNoaWxkcmVuXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRlZXAgJiYgY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBTVkcuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBjaGlsZHJlbltpXS5lYWNoKGJsb2NrLCBkZWVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgYSBnaXZlbiBjaGlsZFxuICAgICAgcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZChlbGVtZW50Lm5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgYWxsIGVsZW1lbnRzIGluIHRoaXMgY29udGFpbmVyXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlblxuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgICAgICAgfSAvLyByZW1vdmUgZGVmcyByZWZlcmVuY2VcblxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9kZWZzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgZGVmc1xuICAgICAgZGVmczogZnVuY3Rpb24gZGVmcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jKCkuZGVmcygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLlBhcmVudCwge1xuICAgIHVuZ3JvdXA6IGZ1bmN0aW9uIHVuZ3JvdXAocGFyZW50LCBkZXB0aCkge1xuICAgICAgaWYgKGRlcHRoID09PSAwIHx8IHRoaXMgaW5zdGFuY2VvZiBTVkcuRGVmcyB8fCB0aGlzLm5vZGUgPT0gU1ZHLnBhcnNlci5kcmF3KSByZXR1cm4gdGhpcztcbiAgICAgIHBhcmVudCA9IHBhcmVudCB8fCAodGhpcyBpbnN0YW5jZW9mIFNWRy5Eb2MgPyB0aGlzIDogdGhpcy5wYXJlbnQoU1ZHLlBhcmVudCkpO1xuICAgICAgZGVwdGggPSBkZXB0aCB8fCBJbmZpbml0eTtcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU1ZHLkRlZnMpIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFNWRy5QYXJlbnQpIHJldHVybiB0aGlzLnVuZ3JvdXAocGFyZW50LCBkZXB0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy50b1BhcmVudChwYXJlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm5vZGUuZmlyc3RDaGlsZCB8fCB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKHBhcmVudCwgZGVwdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVuZ3JvdXAocGFyZW50LCBkZXB0aCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLkNvbnRhaW5lciA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgICB9LFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5QYXJlbnRcbiAgfSk7XG4gIFNWRy5WaWV3Qm94ID0gU1ZHLmludmVudCh7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoc291cmNlKSB7XG4gICAgICB2YXIgYmFzZSA9IFswLCAwLCAwLCAwXTtcbiAgICAgIHZhciB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIGJveCxcbiAgICAgICAgICB2aWV3LFxuICAgICAgICAgIHdlLFxuICAgICAgICAgIGhlLFxuICAgICAgICAgIHdtID0gMSxcbiAgICAgICAgICAvLyB3aWR0aCBtdWx0aXBsaWVyXG4gICAgICBobSA9IDEsXG4gICAgICAgICAgLy8gaGVpZ2h0IG11bHRpcGxpZXJcbiAgICAgIHJlZyA9IC9bKy1dPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8vZ2k7XG5cbiAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBTVkcuRWxlbWVudCkge1xuICAgICAgICB3ZSA9IHNvdXJjZTtcbiAgICAgICAgaGUgPSBzb3VyY2U7XG4gICAgICAgIHZpZXcgPSAoc291cmNlLmF0dHIoJ3ZpZXdCb3gnKSB8fCAnJykubWF0Y2gocmVnKTtcbiAgICAgICAgYm94ID0gc291cmNlLmJib3g7IC8vIGdldCBkaW1lbnNpb25zIG9mIGN1cnJlbnQgbm9kZVxuXG4gICAgICAgIHdpZHRoID0gbmV3IFNWRy5OdW1iZXIoc291cmNlLndpZHRoKCkpO1xuICAgICAgICBoZWlnaHQgPSBuZXcgU1ZHLk51bWJlcihzb3VyY2UuaGVpZ2h0KCkpOyAvLyBmaW5kIG5lYXJlc3Qgbm9uLXBlcmNlbnR1YWwgZGltZW5zaW9uc1xuXG4gICAgICAgIHdoaWxlICh3aWR0aC51bml0ID09ICclJykge1xuICAgICAgICAgIHdtICo9IHdpZHRoLnZhbHVlO1xuICAgICAgICAgIHdpZHRoID0gbmV3IFNWRy5OdW1iZXIod2UgaW5zdGFuY2VvZiBTVkcuRG9jID8gd2UucGFyZW50KCkub2Zmc2V0V2lkdGggOiB3ZS5wYXJlbnQoKS53aWR0aCgpKTtcbiAgICAgICAgICB3ZSA9IHdlLnBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGhlaWdodC51bml0ID09ICclJykge1xuICAgICAgICAgIGhtICo9IGhlaWdodC52YWx1ZTtcbiAgICAgICAgICBoZWlnaHQgPSBuZXcgU1ZHLk51bWJlcihoZSBpbnN0YW5jZW9mIFNWRy5Eb2MgPyBoZS5wYXJlbnQoKS5vZmZzZXRIZWlnaHQgOiBoZS5wYXJlbnQoKS5oZWlnaHQoKSk7XG4gICAgICAgICAgaGUgPSBoZS5wYXJlbnQoKTtcbiAgICAgICAgfSAvLyBlbnN1cmUgZGVmYXVsdHNcblxuXG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHdtO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIGhtO1xuICAgICAgICB0aGlzLnpvb20gPSAxO1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgLy8gZ2V0IHdpZHRoIGFuZCBoZWlnaHQgZnJvbSB2aWV3Ym94XG4gICAgICAgICAgeCA9IHBhcnNlRmxvYXQodmlld1swXSk7XG4gICAgICAgICAgeSA9IHBhcnNlRmxvYXQodmlld1sxXSk7XG4gICAgICAgICAgd2lkdGggPSBwYXJzZUZsb2F0KHZpZXdbMl0pO1xuICAgICAgICAgIGhlaWdodCA9IHBhcnNlRmxvYXQodmlld1szXSk7IC8vIGNhbGN1bGF0ZSB6b29tIGFjY29yaW5nIHRvIHZpZXdib3hcblxuICAgICAgICAgIHRoaXMuem9vbSA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCA+IHdpZHRoIC8gaGVpZ2h0ID8gdGhpcy5oZWlnaHQgLyBoZWlnaHQgOiB0aGlzLndpZHRoIC8gd2lkdGg7IC8vIGNhbGN1bGF0ZSByZWFsIHBpeGVsIGRpbWVuc2lvbnMgb24gcGFyZW50IFNWRy5Eb2MgZWxlbWVudFxuXG4gICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW5zdXJlIHNvdXJjZSBhcyBvYmplY3RcbiAgICAgICAgc291cmNlID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UubWF0Y2gocmVnKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZWwpO1xuICAgICAgICB9KSA6IEFycmF5LmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IF90eXBlb2Yoc291cmNlKSA9PT0gJ29iamVjdCcgPyBbc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHRdIDogYXJndW1lbnRzLmxlbmd0aCA9PSA0ID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpIDogYmFzZTtcbiAgICAgICAgdGhpcy54ID0gc291cmNlWzBdO1xuICAgICAgICB0aGlzLnkgPSBzb3VyY2VbMV07XG4gICAgICAgIHRoaXMud2lkdGggPSBzb3VyY2VbMl07XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc291cmNlWzNdO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyAnICcgKyB0aGlzLnkgKyAnICcgKyB0aGlzLndpZHRoICsgJyAnICsgdGhpcy5oZWlnaHQ7XG4gICAgICB9LFxuICAgICAgbW9ycGg6IGZ1bmN0aW9uIG1vcnBoKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuVmlld0JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFNWRy5WaWV3Qm94KFt0aGlzLnggKyAodGhpcy5kZXN0aW5hdGlvbi54IC0gdGhpcy54KSAqIHBvcywgdGhpcy55ICsgKHRoaXMuZGVzdGluYXRpb24ueSAtIHRoaXMueSkgKiBwb3MsIHRoaXMud2lkdGggKyAodGhpcy5kZXN0aW5hdGlvbi53aWR0aCAtIHRoaXMud2lkdGgpICogcG9zLCB0aGlzLmhlaWdodCArICh0aGlzLmRlc3RpbmF0aW9uLmhlaWdodCAtIHRoaXMuaGVpZ2h0KSAqIHBvc10pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVmaW5lIHBhcmVudFxuICAgIHBhcmVudDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gZ2V0L3NldCB2aWV3Ym94XG4gICAgICB2aWV3Ym94OiBmdW5jdGlvbiB2aWV3Ym94KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkgLy8gYWN0IGFzIGEgZ2V0dGVyIGlmIHRoZXJlIGFyZSBubyBhcmd1bWVudHNcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNWRy5WaWV3Qm94KHRoaXMpO1xuICAgICAgICAgIH0gLy8gb3RoZXJ3aXNlIGFjdCBhcyBhIHNldHRlclxuXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigndmlld0JveCcsIG5ldyBTVkcuVmlld0JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgfVxuICB9KSAvLyBBZGQgZXZlbnRzIHRvIGVsZW1lbnRzXG4gIDtcbiAgWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgLy8gLCAnbW91c2VlbnRlcicgLT4gbm90IHN1cHBvcnRlZCBieSBJRVxuICAvLyAsICdtb3VzZWxlYXZlJyAtPiBub3Qgc3VwcG9ydGVkIGJ5IElFXG4gICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGxlYXZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBhZGQgZXZlbnQgdG8gU1ZHLkVsZW1lbnRcbiAgICBTVkcuRWxlbWVudC5wcm90b3R5cGVbZXZlbnRdID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgIC8vIGJpbmQgZXZlbnQgdG8gZWxlbWVudCByYXRoZXIgdGhhbiBlbGVtZW50IG5vZGVcbiAgICAgIFNWRy5vbih0aGlzLm5vZGUsIGV2ZW50LCBmKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pOyAvLyBJbml0aWFsaXplIGxpc3RlbmVycyBzdGFja1xuXG4gIFNWRy5saXN0ZW5lcnMgPSBbXTtcbiAgU1ZHLmhhbmRsZXJNYXAgPSBbXTtcbiAgU1ZHLmxpc3RlbmVySWQgPSAwOyAvLyBBZGQgZXZlbnQgYmluZGVyIGluIHRoZSBTVkcgbmFtZXNwYWNlXG5cbiAgU1ZHLm9uID0gZnVuY3Rpb24gKG5vZGUsIGV2ZW50LCBsaXN0ZW5lciwgYmluZGluZywgb3B0aW9ucykge1xuICAgIC8vIGNyZWF0ZSBsaXN0ZW5lciwgZ2V0IG9iamVjdC1pbmRleFxuICAgIHZhciBsID0gbGlzdGVuZXIuYmluZChiaW5kaW5nIHx8IG5vZGUuaW5zdGFuY2UgfHwgbm9kZSksXG4gICAgICAgIGluZGV4ID0gKFNWRy5oYW5kbGVyTWFwLmluZGV4T2Yobm9kZSkgKyAxIHx8IFNWRy5oYW5kbGVyTWFwLnB1c2gobm9kZSkpIC0gMSxcbiAgICAgICAgZXYgPSBldmVudC5zcGxpdCgnLicpWzBdLFxuICAgICAgICBucyA9IGV2ZW50LnNwbGl0KCcuJylbMV0gfHwgJyonOyAvLyBlbnN1cmUgdmFsaWQgb2JqZWN0XG5cbiAgICBTVkcubGlzdGVuZXJzW2luZGV4XSA9IFNWRy5saXN0ZW5lcnNbaW5kZXhdIHx8IHt9O1xuICAgIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSA9IFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSB8fCB7fTtcbiAgICBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdID0gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSB8fCB7fTtcblxuICAgIGlmICghbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZCkge1xuICAgICAgbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZCA9ICsrU1ZHLmxpc3RlbmVySWQ7XG4gICAgfSAvLyByZWZlcmVuY2UgbGlzdGVuZXJcblxuXG4gICAgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXVtsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkXSA9IGw7IC8vIGFkZCBsaXN0ZW5lclxuXG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2LCBsLCBvcHRpb25zIHx8IGZhbHNlKTtcbiAgfTsgLy8gQWRkIGV2ZW50IHVuYmluZGVyIGluIHRoZSBTVkcgbmFtZXNwYWNlXG5cblxuICBTVkcub2ZmID0gZnVuY3Rpb24gKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHZhciBpbmRleCA9IFNWRy5oYW5kbGVyTWFwLmluZGV4T2Yobm9kZSksXG4gICAgICAgIGV2ID0gZXZlbnQgJiYgZXZlbnQuc3BsaXQoJy4nKVswXSxcbiAgICAgICAgbnMgPSBldmVudCAmJiBldmVudC5zcGxpdCgnLicpWzFdLFxuICAgICAgICBuYW1lc3BhY2UgPSAnJztcbiAgICBpZiAoaW5kZXggPT0gLTEpIHJldHVybjtcblxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgbGlzdGVuZXIgPSBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkO1xuICAgICAgaWYgKCFsaXN0ZW5lcikgcmV0dXJuOyAvLyByZW1vdmUgbGlzdGVuZXIgcmVmZXJlbmNlXG5cbiAgICAgIGlmIChTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gJiYgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zIHx8ICcqJ10pIHtcbiAgICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zIHx8ICcqJ11bbGlzdGVuZXJdLCBmYWxzZSk7XG4gICAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnMgfHwgJyonXVtsaXN0ZW5lcl07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChucyAmJiBldikge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIGEgbmFtZXNwYWNlZCBldmVudFxuICAgICAgaWYgKFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSAmJiBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdKSB7XG4gICAgICAgIGZvciAobGlzdGVuZXIgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSkge1xuICAgICAgICAgIFNWRy5vZmYobm9kZSwgW2V2LCBuc10uam9pbignLicpLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5zKSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBuYW1lc3BhY2VcbiAgICAgIGZvciAoZXZlbnQgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF0pIHtcbiAgICAgICAgZm9yIChuYW1lc3BhY2UgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZlbnRdKSB7XG4gICAgICAgICAgaWYgKG5zID09PSBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIFNWRy5vZmYobm9kZSwgW2V2ZW50LCBuc10uam9pbignLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2KSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50XG4gICAgICBpZiAoU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdKSB7XG4gICAgICAgIGZvciAobmFtZXNwYWNlIGluIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSkge1xuICAgICAgICAgIFNWRy5vZmYobm9kZSwgW2V2LCBuYW1lc3BhY2VdLmpvaW4oJy4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBvbiBhIGdpdmVuIG5vZGVcbiAgICAgIGZvciAoZXZlbnQgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF0pIHtcbiAgICAgICAgU1ZHLm9mZihub2RlLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBTVkcubGlzdGVuZXJzW2luZGV4XTtcbiAgICAgIGRlbGV0ZSBTVkcuaGFuZGxlck1hcFtpbmRleF07XG4gICAgfVxuICB9OyAvL1xuXG5cbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIEJpbmQgZ2l2ZW4gZXZlbnQgdG8gbGlzdGVuZXJcbiAgICBvbjogZnVuY3Rpb24gb24oZXZlbnQsIGxpc3RlbmVyLCBiaW5kaW5nLCBvcHRpb25zKSB7XG4gICAgICBTVkcub24odGhpcy5ub2RlLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBVbmJpbmQgZXZlbnQgZnJvbSBsaXN0ZW5lclxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgU1ZHLm9mZih0aGlzLm5vZGUsIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIEZpcmUgZ2l2ZW4gZXZlbnRcbiAgICBmaXJlOiBmdW5jdGlvbiBmaXJlKGV2ZW50LCBkYXRhKSB7XG4gICAgICAvLyBEaXNwYXRjaCBldmVudFxuICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50KSB7XG4gICAgICAgIHRoaXMubm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50ID0gbmV3IFNWRy5DdXN0b21FdmVudChldmVudCwge1xuICAgICAgICAgIGRldGFpbDogZGF0YSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZXZlbnQgPSBldmVudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZXZlbnQ6IGZ1bmN0aW9uIGV2ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50O1xuICAgIH1cbiAgfSk7XG4gIFNWRy5EZWZzID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnZGVmcycsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxuICB9KTtcbiAgU1ZHLkcgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdnJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXG4gICAgICB4OiBmdW5jdGlvbiB4KF94Mykge1xuICAgICAgICByZXR1cm4gX3gzID09IG51bGwgPyB0aGlzLnRyYW5zZm9ybSgneCcpIDogdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICAgIHg6IF94MyAtIHRoaXMueCgpXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgb3ZlciB5LWF4aXNcbiAgICAgIHk6IGZ1bmN0aW9uIHkoX3kzKSB7XG4gICAgICAgIHJldHVybiBfeTMgPT0gbnVsbCA/IHRoaXMudHJhbnNmb3JtKCd5JykgOiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgICAgeTogX3kzIC0gdGhpcy55KClcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcbiAgICAgIGN4OiBmdW5jdGlvbiBjeCh4KSB7XG4gICAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmdib3goKS5jeCA6IHRoaXMueCh4IC0gdGhpcy5nYm94KCkud2lkdGggLyAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICAgICAgY3k6IGZ1bmN0aW9uIGN5KHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuZ2JveCgpLmN5IDogdGhpcy55KHkgLSB0aGlzLmdib3goKS5oZWlnaHQgLyAyKTtcbiAgICAgIH0sXG4gICAgICBnYm94OiBmdW5jdGlvbiBnYm94KCkge1xuICAgICAgICB2YXIgYmJveCA9IHRoaXMuYmJveCgpLFxuICAgICAgICAgICAgdHJhbnMgPSB0aGlzLnRyYW5zZm9ybSgpO1xuICAgICAgICBiYm94LnggKz0gdHJhbnMueDtcbiAgICAgICAgYmJveC54MiArPSB0cmFucy54O1xuICAgICAgICBiYm94LmN4ICs9IHRyYW5zLng7XG4gICAgICAgIGJib3gueSArPSB0cmFucy55O1xuICAgICAgICBiYm94LnkyICs9IHRyYW5zLnk7XG4gICAgICAgIGJib3guY3kgKz0gdHJhbnMueTtcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgZ3JvdXAgZWxlbWVudFxuICAgICAgZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5HKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5Eb2MgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAvLyBlbnN1cmUgdGhlIHByZXNlbmNlIG9mIGEgZG9tIGVsZW1lbnRcbiAgICAgICAgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpIDogZWxlbWVudDsgLy8gSWYgdGhlIHRhcmdldCBpcyBhbiBzdmcgZWxlbWVudCwgdXNlIHRoYXQgZWxlbWVudCBhcyB0aGUgbWFpbiB3cmFwcGVyLlxuICAgICAgICAvLyBUaGlzIGFsbG93cyBzdmcuanMgdG8gd29yayB3aXRoIHN2ZyBkb2N1bWVudHMgYXMgd2VsbC5cblxuICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnc3ZnJykpO1xuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgICB0aGlzLnNpemUoJzEwMCUnLCAnMTAwJScpO1xuICAgICAgICB9IC8vIHNldCBzdmcgZWxlbWVudCBhdHRyaWJ1dGVzIGFuZCBlbnN1cmUgZGVmcyBub2RlXG5cblxuICAgICAgICB0aGlzLm5hbWVzcGFjZSgpLmRlZnMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIEFkZCBuYW1lc3BhY2VzXG4gICAgICBuYW1lc3BhY2U6IGZ1bmN0aW9uIG5hbWVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cih7XG4gICAgICAgICAgeG1sbnM6IFNWRy5ucyxcbiAgICAgICAgICB2ZXJzaW9uOiAnMS4xJ1xuICAgICAgICB9KS5hdHRyKCd4bWxuczp4bGluaycsIFNWRy54bGluaywgU1ZHLnhtbG5zKS5hdHRyKCd4bWxuczpzdmdqcycsIFNWRy5zdmdqcywgU1ZHLnhtbG5zKTtcbiAgICAgIH0sXG4gICAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGRlZnMgZWxlbWVudFxuICAgICAgZGVmczogZnVuY3Rpb24gZGVmcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZzKSB7XG4gICAgICAgICAgdmFyIGRlZnM7IC8vIEZpbmQgb3IgY3JlYXRlIGEgZGVmcyBlbGVtZW50IGluIHRoaXMgaW5zdGFuY2VcblxuICAgICAgICAgIGlmIChkZWZzID0gdGhpcy5ub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkZWZzJylbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZnMgPSBTVkcuYWRvcHQoZGVmcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZnMgPSBuZXcgU1ZHLkRlZnMoKTtcbiAgICAgICAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgZGVmcyBub2RlIGlzIGF0IHRoZSBlbmQgb2YgdGhlIHN0YWNrXG5cblxuICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9kZWZzLm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZnM7XG4gICAgICB9LFxuICAgICAgLy8gY3VzdG9tIHBhcmVudCBtZXRob2RcbiAgICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZS5wYXJlbnROb2RlIHx8IHRoaXMubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lID09ICcjZG9jdW1lbnQnKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5wYXJlbnROb2RlO1xuICAgICAgfSxcbiAgICAgIC8vIEZpeCBmb3IgcG9zc2libGUgc3ViLXBpeGVsIG9mZnNldC4gU2VlOlxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjA4ODEyXG4gICAgICBzcG9mOiBmdW5jdGlvbiBzcG9mKCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5ub2RlLmdldFNjcmVlbkNUTSgpO1xuXG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlKCdsZWZ0JywgLXBvcy5lICUgMSArICdweCcpLnN0eWxlKCd0b3AnLCAtcG9zLmYgJSAxICsgJ3B4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmVzIHRoZSBkb2MgZnJvbSB0aGUgRE9NXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KCkpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlblxuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgICAgICAgfSAvLyByZW1vdmUgZGVmcyByZWZlcmVuY2VcblxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9kZWZzOyAvLyBhZGQgYmFjayBwYXJzZXJcblxuICAgICAgICBpZiAoU1ZHLnBhcnNlci5kcmF3ICYmICFTVkcucGFyc2VyLmRyYXcucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChTVkcucGFyc2VyLmRyYXcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKHBhcmVudCkge1xuICAgICAgICAvLyB3cml0ZSBkb20gZGF0YSB0byB0aGUgZG9tIHNvIHRoZSBjbG9uZSBjYW4gcGlja3VwIHRoZSBkYXRhXG4gICAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKTsgLy8gZ2V0IHJlZmVyZW5jZSB0byBub2RlXG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7IC8vIGNsb25lIGVsZW1lbnQgYW5kIGFzc2lnbiBuZXcgaWRcblxuICAgICAgICB2YXIgY2xvbmUgPSBhc3NpZ25OZXdJZChub2RlLmNsb25lTm9kZSh0cnVlKSk7IC8vIGluc2VydCB0aGUgY2xvbmUgaW4gdGhlIGdpdmVuIHBhcmVudCBvciBhZnRlciBteXNlbGZcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgKHBhcmVudC5ub2RlIHx8IHBhcmVudCkuYXBwZW5kQ2hpbGQoY2xvbmUubm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZS5ub2RlLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyAjIyMgVGhpcyBtb2R1bGUgYWRkcyBiYWNrd2FyZCAvIGZvcndhcmQgZnVuY3Rpb25hbGl0eSB0byBlbGVtZW50cy5cbiAgLy9cblxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gR2V0IGFsbCBzaWJsaW5ncywgaW5jbHVkaW5nIG15c2VsZlxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncygpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCk7XG4gICAgfSxcbiAgICAvLyBHZXQgdGhlIGN1cmVudCBwb3NpdGlvbiBzaWJsaW5nc1xuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmluZGV4KHRoaXMpO1xuICAgIH0sXG4gICAgLy8gR2V0IHRoZSBuZXh0IGVsZW1lbnQgKHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm9uZSlcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgKyAxXTtcbiAgICB9LFxuICAgIC8vIEdldCB0aGUgbmV4dCBlbGVtZW50ICh3aWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGlzIG5vbmUpXG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgLSAxXTtcbiAgICB9LFxuICAgIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBvbmUgc3RlcCBmb3J3YXJkXG4gICAgZm9yd2FyZDogZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpICsgMSxcbiAgICAgICAgICBwID0gdGhpcy5wYXJlbnQoKTsgLy8gbW92ZSBub2RlIG9uZSBzdGVwIGZvcndhcmRcblxuICAgICAgcC5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCBpKTsgLy8gbWFrZSBzdXJlIGRlZnMgbm9kZSBpcyBhbHdheXMgYXQgdGhlIHRvcFxuXG4gICAgICBpZiAocCBpbnN0YW5jZW9mIFNWRy5Eb2MpIHtcbiAgICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHAuZGVmcygpLm5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBvbmUgc3RlcCBiYWNrd2FyZFxuICAgIGJhY2t3YXJkOiBmdW5jdGlvbiBiYWNrd2FyZCgpIHtcbiAgICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpO1xuXG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCBpIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gU2VuZCBnaXZlbiBlbGVtZW50IGFsbCB0aGUgd2F5IHRvIHRoZSBmcm9udFxuICAgIGZyb250OiBmdW5jdGlvbiBmcm9udCgpIHtcbiAgICAgIHZhciBwID0gdGhpcy5wYXJlbnQoKTsgLy8gTW92ZSBub2RlIGZvcndhcmRcblxuICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7IC8vIE1ha2Ugc3VyZSBkZWZzIG5vZGUgaXMgYWx3YXlzIGF0IHRoZSB0b3BcblxuICAgICAgaWYgKHAgaW5zdGFuY2VvZiBTVkcuRG9jKSB7XG4gICAgICAgIHAubm9kZS5hcHBlbmRDaGlsZChwLmRlZnMoKS5ub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBTZW5kIGdpdmVuIGVsZW1lbnQgYWxsIHRoZSB3YXkgdG8gdGhlIGJhY2tcbiAgICBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xuICAgICAgaWYgKHRoaXMucG9zaXRpb24oKSA+IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBJbnNlcnRzIGEgZ2l2ZW4gZWxlbWVudCBiZWZvcmUgdGhlIHRhcmdldGVkIGVsZW1lbnRcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZShlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gSW5zdGVycyBhIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIHRhcmdldGVkIGVsZW1lbnRcbiAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgdGhpcy5wYXJlbnQoKS5hZGQoZWxlbWVudCwgaSArIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgU1ZHLk1hc2sgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdtYXNrJykpOyAvLyBrZWVwIHJlZmVyZW5jZXMgdG8gbWFza2VkIGVsZW1lbnRzXG5cbiAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gVW5tYXNrIGFsbCBtYXNrZWQgZWxlbWVudHMgYW5kIHJlbW92ZSBpdHNlbGZcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAvLyB1bm1hc2sgYWxsIHRhcmdldHNcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudGFyZ2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmICh0aGlzLnRhcmdldHNbaV0pIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0c1tpXS51bm1hc2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhcmdldHMgPSBbXTsgLy8gcmVtb3ZlIG1hc2sgZnJvbSBwYXJlbnRcblxuICAgICAgICBTVkcuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBtYXNraW5nIGVsZW1lbnRcbiAgICAgIG1hc2s6IGZ1bmN0aW9uIG1hc2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IFNWRy5NYXNrKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBEaXN0cmlidXRlIG1hc2sgdG8gc3ZnIGVsZW1lbnRcbiAgICBtYXNrV2l0aDogZnVuY3Rpb24gbWFza1dpdGgoZWxlbWVudCkge1xuICAgICAgLy8gdXNlIGdpdmVuIG1hc2sgb3IgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgdGhpcy5tYXNrZXIgPSBlbGVtZW50IGluc3RhbmNlb2YgU1ZHLk1hc2sgPyBlbGVtZW50IDogdGhpcy5wYXJlbnQoKS5tYXNrKCkuYWRkKGVsZW1lbnQpOyAvLyBzdG9yZSByZXZlcmVuY2Ugb24gc2VsZiBpbiBtYXNrXG5cbiAgICAgIHRoaXMubWFza2VyLnRhcmdldHMucHVzaCh0aGlzKTsgLy8gYXBwbHkgbWFza1xuXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXNrJywgJ3VybChcIiMnICsgdGhpcy5tYXNrZXIuYXR0cignaWQnKSArICdcIiknKTtcbiAgICB9LFxuICAgIC8vIFVubWFzayBlbGVtZW50XG4gICAgdW5tYXNrOiBmdW5jdGlvbiB1bm1hc2soKSB7XG4gICAgICBkZWxldGUgdGhpcy5tYXNrZXI7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXNrJywgbnVsbCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLkNsaXBQYXRoID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnY2xpcFBhdGgnKSk7IC8vIGtlZXAgcmVmZXJlbmNlcyB0byBjbGlwcGVkIGVsZW1lbnRzXG5cbiAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gVW5jbGlwIGFsbCBjbGlwcGVkIGVsZW1lbnRzIGFuZCByZW1vdmUgaXRzZWxmXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgLy8gdW5jbGlwIGFsbCB0YXJnZXRzXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRhcmdldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAodGhpcy50YXJnZXRzW2ldKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldHNbaV0udW5jbGlwKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50YXJnZXRzID0gW107IC8vIHJlbW92ZSBjbGlwUGF0aCBmcm9tIHBhcmVudFxuXG4gICAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGNsaXBwaW5nIGVsZW1lbnRcbiAgICAgIGNsaXA6IGZ1bmN0aW9uIGNsaXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IFNWRy5DbGlwUGF0aCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvL1xuXG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBEaXN0cmlidXRlIGNsaXBQYXRoIHRvIHN2ZyBlbGVtZW50XG4gICAgY2xpcFdpdGg6IGZ1bmN0aW9uIGNsaXBXaXRoKGVsZW1lbnQpIHtcbiAgICAgIC8vIHVzZSBnaXZlbiBjbGlwIG9yIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgIHRoaXMuY2xpcHBlciA9IGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuQ2xpcFBhdGggPyBlbGVtZW50IDogdGhpcy5wYXJlbnQoKS5jbGlwKCkuYWRkKGVsZW1lbnQpOyAvLyBzdG9yZSByZXZlcmVuY2Ugb24gc2VsZiBpbiBtYXNrXG5cbiAgICAgIHRoaXMuY2xpcHBlci50YXJnZXRzLnB1c2godGhpcyk7IC8vIGFwcGx5IG1hc2tcblxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignY2xpcC1wYXRoJywgJ3VybChcIiMnICsgdGhpcy5jbGlwcGVyLmF0dHIoJ2lkJykgKyAnXCIpJyk7XG4gICAgfSxcbiAgICAvLyBVbmNsaXAgZWxlbWVudFxuICAgIHVuY2xpcDogZnVuY3Rpb24gdW5jbGlwKCkge1xuICAgICAgZGVsZXRlIHRoaXMuY2xpcHBlcjtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsaXAtcGF0aCcsIG51bGwpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5HcmFkaWVudCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHR5cGUpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKHR5cGUgKyAnR3JhZGllbnQnKSk7IC8vIHN0b3JlIHR5cGVcblxuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9LFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIEFkZCBhIGNvbG9yIHN0b3BcbiAgICAgIGF0OiBmdW5jdGlvbiBhdChvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlN0b3AoKSkudXBkYXRlKG9mZnNldCwgY29sb3IsIG9wYWNpdHkpO1xuICAgICAgfSxcbiAgICAgIC8vIFVwZGF0ZSBncmFkaWVudFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoYmxvY2spIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBzdG9wc1xuICAgICAgICB0aGlzLmNsZWFyKCk7IC8vIGludm9rZSBwYXNzZWQgYmxvY2tcblxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFJldHVybiB0aGUgZmlsbCBpZFxuICAgICAgZmlsbDogZnVuY3Rpb24gZmlsbCgpIHtcbiAgICAgICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmlkKCkgKyAnKSc7XG4gICAgICB9LFxuICAgICAgLy8gQWxpYXMgc3RyaW5nIGNvbnZlcnRpb24gdG8gZmlsbFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxsKCk7XG4gICAgICB9LFxuICAgICAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxuICAgICAgYXR0cjogZnVuY3Rpb24gYXR0cihhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhID09ICd0cmFuc2Zvcm0nKSBhID0gJ2dyYWRpZW50VHJhbnNmb3JtJztcbiAgICAgICAgcmV0dXJuIFNWRy5Db250YWluZXIucHJvdG90eXBlLmF0dHIuY2FsbCh0aGlzLCBhLCBiLCBjKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgZ3JhZGllbnQgZWxlbWVudCBpbiBkZWZzXG4gICAgICBncmFkaWVudDogZnVuY3Rpb24gZ3JhZGllbnQodHlwZSwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLmdyYWRpZW50KHR5cGUsIGJsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBBZGQgYW5pbWF0YWJsZSBtZXRob2RzIHRvIGJvdGggZ3JhZGllbnQgYW5kIGZ4IG1vZHVsZVxuXG4gIFNWRy5leHRlbmQoU1ZHLkdyYWRpZW50LCBTVkcuRlgsIHtcbiAgICAvLyBGcm9tIHBvc2l0aW9uXG4gICAgZnJvbTogZnVuY3Rpb24gZnJvbSh4LCB5KSB7XG4gICAgICByZXR1cm4gKHRoaXMuX3RhcmdldCB8fCB0aGlzKS50eXBlID09ICdyYWRpYWwnID8gdGhpcy5hdHRyKHtcbiAgICAgICAgZng6IG5ldyBTVkcuTnVtYmVyKHgpLFxuICAgICAgICBmeTogbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgIH0pIDogdGhpcy5hdHRyKHtcbiAgICAgICAgeDE6IG5ldyBTVkcuTnVtYmVyKHgpLFxuICAgICAgICB5MTogbmV3IFNWRy5OdW1iZXIoeSlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gVG8gcG9zaXRpb25cbiAgICB0bzogZnVuY3Rpb24gdG8oeCwgeSkge1xuICAgICAgcmV0dXJuICh0aGlzLl90YXJnZXQgfHwgdGhpcykudHlwZSA9PSAncmFkaWFsJyA/IHRoaXMuYXR0cih7XG4gICAgICAgIGN4OiBuZXcgU1ZHLk51bWJlcih4KSxcbiAgICAgICAgY3k6IG5ldyBTVkcuTnVtYmVyKHkpXG4gICAgICB9KSA6IHRoaXMuYXR0cih7XG4gICAgICAgIHgyOiBuZXcgU1ZHLk51bWJlcih4KSxcbiAgICAgICAgeTI6IG5ldyBTVkcuTnVtYmVyKHkpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pOyAvLyBCYXNlIGdyYWRpZW50IGdlbmVyYXRpb25cblxuICBTVkcuZXh0ZW5kKFNWRy5EZWZzLCB7XG4gICAgLy8gZGVmaW5lIGdyYWRpZW50XG4gICAgZ3JhZGllbnQ6IGZ1bmN0aW9uIGdyYWRpZW50KHR5cGUsIGJsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5HcmFkaWVudCh0eXBlKSkudXBkYXRlKGJsb2NrKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuU3RvcCA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3N0b3AnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5FbGVtZW50LFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBhZGQgY29sb3Igc3RvcHNcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvID09PSAnbnVtYmVyJyB8fCBvIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xuICAgICAgICAgIG8gPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBvcGFjaXR5OiBhcmd1bWVudHNbMl1cbiAgICAgICAgICB9O1xuICAgICAgICB9IC8vIHNldCBhdHRyaWJ1dGVzXG5cblxuICAgICAgICBpZiAoby5vcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1vcGFjaXR5Jywgby5vcGFjaXR5KTtcbiAgICAgICAgaWYgKG8uY29sb3IgIT0gbnVsbCkgdGhpcy5hdHRyKCdzdG9wLWNvbG9yJywgby5jb2xvcik7XG4gICAgICAgIGlmIChvLm9mZnNldCAhPSBudWxsKSB0aGlzLmF0dHIoJ29mZnNldCcsIG5ldyBTVkcuTnVtYmVyKG8ub2Zmc2V0KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5QYXR0ZXJuID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAncGF0dGVybicsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXG4gICAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKCkge1xuICAgICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJztcbiAgICAgIH0sXG4gICAgICAvLyBVcGRhdGUgcGF0dGVybiBieSByZWJ1aWxkaW5nXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShibG9jaykge1xuICAgICAgICAvLyByZW1vdmUgY29udGVudFxuICAgICAgICB0aGlzLmNsZWFyKCk7IC8vIGludm9rZSBwYXNzZWQgYmxvY2tcblxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEFsaWFzIHN0cmluZyBjb252ZXJ0aW9uIHRvIGZpbGxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbCgpO1xuICAgICAgfSxcbiAgICAgIC8vIGN1c3RvbSBhdHRyIHRvIGhhbmRsZSB0cmFuc2Zvcm1cbiAgICAgIGF0dHI6IGZ1bmN0aW9uIGF0dHIoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSA9PSAndHJhbnNmb3JtJykgYSA9ICdwYXR0ZXJuVHJhbnNmb3JtJztcbiAgICAgICAgcmV0dXJuIFNWRy5Db250YWluZXIucHJvdG90eXBlLmF0dHIuY2FsbCh0aGlzLCBhLCBiLCBjKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgcGF0dGVybiBlbGVtZW50IGluIGRlZnNcbiAgICAgIHBhdHRlcm46IGZ1bmN0aW9uIHBhdHRlcm4od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnBhdHRlcm4od2lkdGgsIGhlaWdodCwgYmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcbiAgICAvLyBEZWZpbmUgZ3JhZGllbnRcbiAgICBwYXR0ZXJuOiBmdW5jdGlvbiBwYXR0ZXJuKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5QYXR0ZXJuKCkpLnVwZGF0ZShibG9jaykuYXR0cih7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHBhdHRlcm5Vbml0czogJ3VzZXJTcGFjZU9uVXNlJ1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlNoYXBlID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZWxlbWVudCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkVsZW1lbnRcbiAgfSk7XG4gIFNWRy5CYXJlID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGVsZW1lbnQsIGluaGVyaXQpIHtcbiAgICAgIC8vIGNvbnN0cnVjdCBlbGVtZW50XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZShlbGVtZW50KSk7IC8vIGluaGVyaXQgY3VzdG9tIG1ldGhvZHNcblxuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIGluaGVyaXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmhlcml0LnByb3RvdHlwZVttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZF0gPSBpbmhlcml0LnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkVsZW1lbnQsXG4gICAgLy8gQWRkIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIEluc2VydCBzb21lIHBsYWluIHRleHRcbiAgICAgIHdvcmRzOiBmdW5jdGlvbiB3b3Jkcyh0ZXh0KSB7XG4gICAgICAgIC8vIHJlbW92ZSBjb250ZW50c1xuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKTtcbiAgICAgICAgfSAvLyBjcmVhdGUgdGV4dCBub2RlXG5cblxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5QYXJlbnQsIHtcbiAgICAvLyBDcmVhdGUgYW4gZWxlbWVudCB0aGF0IGlzIG5vdCBkZXNjcmliZWQgYnkgU1ZHLmpzXG4gICAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudChfZWxlbWVudCwgaW5oZXJpdCkge1xuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQmFyZShfZWxlbWVudCwgaW5oZXJpdCkpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5TeW1ib2wgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdzeW1ib2wnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBjcmVhdGUgc3ltYm9sXG4gICAgICBzeW1ib2w6IGZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuU3ltYm9sKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5Vc2UgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICd1c2UnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gVXNlIGVsZW1lbnQgYXMgYSByZWZlcmVuY2VcbiAgICAgIGVsZW1lbnQ6IGZ1bmN0aW9uIGVsZW1lbnQoX2VsZW1lbnQyLCBmaWxlKSB7XG4gICAgICAgIC8vIFNldCBsaW5lZCBlbGVtZW50XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoZmlsZSB8fCAnJykgKyAnIycgKyBfZWxlbWVudDIsIFNWRy54bGluayk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGEgdXNlIGVsZW1lbnRcbiAgICAgIHVzZTogZnVuY3Rpb24gdXNlKGVsZW1lbnQsIGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuVXNlKCkpLmVsZW1lbnQoZWxlbWVudCwgZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlJlY3QgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdyZWN0JyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIHJlY3QgZWxlbWVudFxuICAgICAgcmVjdDogZnVuY3Rpb24gcmVjdCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlJlY3QoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuQ2lyY2xlID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnY2lyY2xlJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBjaXJjbGUgZWxlbWVudCwgYmFzZWQgb24gZWxsaXBzZVxuICAgICAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUoc2l6ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5DaXJjbGUoKSkucngobmV3IFNWRy5OdW1iZXIoc2l6ZSkuZGl2aWRlKDIpKS5tb3ZlKDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkNpcmNsZSwgU1ZHLkZYLCB7XG4gICAgLy8gUmFkaXVzIHggdmFsdWVcbiAgICByeDogZnVuY3Rpb24gcngoX3J4KSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdyJywgX3J4KTtcbiAgICB9LFxuICAgIC8vIEFsaWFzIHJhZGl1cyB4IHZhbHVlXG4gICAgcnk6IGZ1bmN0aW9uIHJ5KF9yeSkge1xuICAgICAgcmV0dXJuIHRoaXMucngoX3J5KTtcbiAgICB9XG4gIH0pO1xuICBTVkcuRWxsaXBzZSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ2VsbGlwc2UnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgcGFyZW50IG1ldGhvZFxuICAgIGNvbnN0cnVjdDoge1xuICAgICAgLy8gQ3JlYXRlIGFuIGVsbGlwc2VcbiAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIGVsbGlwc2Uod2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5FbGxpcHNlKCkpLnNpemUod2lkdGgsIGhlaWdodCkubW92ZSgwLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5FbGxpcHNlLCBTVkcuUmVjdCwgU1ZHLkZYLCB7XG4gICAgLy8gUmFkaXVzIHggdmFsdWVcbiAgICByeDogZnVuY3Rpb24gcngoX3J4Mikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cigncngnLCBfcngyKTtcbiAgICB9LFxuICAgIC8vIFJhZGl1cyB5IHZhbHVlXG4gICAgcnk6IGZ1bmN0aW9uIHJ5KF9yeTIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3J5JywgX3J5Mik7XG4gICAgfVxuICB9KTsgLy8gQWRkIGNvbW1vbiBtZXRob2RcblxuICBTVkcuZXh0ZW5kKFNWRy5DaXJjbGUsIFNWRy5FbGxpcHNlLCB7XG4gICAgLy8gTW92ZSBvdmVyIHgtYXhpc1xuICAgIHg6IGZ1bmN0aW9uIHgoX3g0KSB7XG4gICAgICByZXR1cm4gX3g0ID09IG51bGwgPyB0aGlzLmN4KCkgLSB0aGlzLnJ4KCkgOiB0aGlzLmN4KF94NCArIHRoaXMucngoKSk7XG4gICAgfSxcbiAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXG4gICAgeTogZnVuY3Rpb24geShfeTQpIHtcbiAgICAgIHJldHVybiBfeTQgPT0gbnVsbCA/IHRoaXMuY3koKSAtIHRoaXMucnkoKSA6IHRoaXMuY3koX3k0ICsgdGhpcy5yeSgpKTtcbiAgICB9LFxuICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeC1heGlzXG4gICAgY3g6IGZ1bmN0aW9uIGN4KHgpIHtcbiAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmF0dHIoJ2N4JykgOiB0aGlzLmF0dHIoJ2N4JywgeCk7XG4gICAgfSxcbiAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHktYXhpc1xuICAgIGN5OiBmdW5jdGlvbiBjeSh5KSB7XG4gICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5hdHRyKCdjeScpIDogdGhpcy5hdHRyKCdjeScsIHkpO1xuICAgIH0sXG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoX3dpZHRoMykge1xuICAgICAgcmV0dXJuIF93aWR0aDMgPT0gbnVsbCA/IHRoaXMucngoKSAqIDIgOiB0aGlzLnJ4KG5ldyBTVkcuTnVtYmVyKF93aWR0aDMpLmRpdmlkZSgyKSk7XG4gICAgfSxcbiAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodChfaGVpZ2h0Mykge1xuICAgICAgcmV0dXJuIF9oZWlnaHQzID09IG51bGwgPyB0aGlzLnJ5KCkgKiAyIDogdGhpcy5yeShuZXcgU1ZHLk51bWJlcihfaGVpZ2h0MykuZGl2aWRlKDIpKTtcbiAgICB9LFxuICAgIC8vIEN1c3RvbSBzaXplIGZ1bmN0aW9uXG4gICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcy5yeChuZXcgU1ZHLk51bWJlcihwLndpZHRoKS5kaXZpZGUoMikpLnJ5KG5ldyBTVkcuTnVtYmVyKHAuaGVpZ2h0KS5kaXZpZGUoMikpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5MaW5lID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAnbGluZScsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLlNoYXBlLFxuICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzXG4gICAgZXh0ZW5kOiB7XG4gICAgICAvLyBHZXQgYXJyYXlcbiAgICAgIGFycmF5OiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuUG9pbnRBcnJheShbW3RoaXMuYXR0cigneDEnKSwgdGhpcy5hdHRyKCd5MScpXSwgW3RoaXMuYXR0cigneDInKSwgdGhpcy5hdHRyKCd5MicpXV0pO1xuICAgICAgfSxcbiAgICAgIC8vIE92ZXJ3cml0ZSBuYXRpdmUgcGxvdCgpIG1ldGhvZFxuICAgICAgcGxvdDogZnVuY3Rpb24gcGxvdCh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBpZiAoeDEgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFycmF5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHkxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHgxID0ge1xuICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4MSA9IG5ldyBTVkcuUG9pbnRBcnJheSh4MSkudG9MaW5lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKHgxKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuICAgICAgbW92ZTogZnVuY3Rpb24gbW92ZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIodGhpcy5hcnJheSgpLm1vdmUoeCwgeSkudG9MaW5lKCkpO1xuICAgICAgfSxcbiAgICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkudG9MaW5lKCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIGxpbmUgZWxlbWVudFxuICAgICAgbGluZTogZnVuY3Rpb24gbGluZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcbiAgICAgICAgLy8geDEgaXMgbm90IG5lY2Vzc2FyaWx5IGEgbnVtYmVyLCBpdCBjYW4gYWxzbyBiZSBhbiBhcnJheSwgYSBzdHJpbmcgYW5kIGEgU1ZHLlBvaW50QXJyYXlcbiAgICAgICAgcmV0dXJuIFNWRy5MaW5lLnByb3RvdHlwZS5wbG90LmFwcGx5KHRoaXMucHV0KG5ldyBTVkcuTGluZSgpKSwgeDEgIT0gbnVsbCA/IFt4MSwgeTEsIHgyLCB5Ml0gOiBbMCwgMCwgMCwgMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5Qb2x5bGluZSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ3BvbHlsaW5lJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWxpbmUgZWxlbWVudFxuICAgICAgcG9seWxpbmU6IGZ1bmN0aW9uIHBvbHlsaW5lKHApIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBvbHlsaW5lKCkpLnBsb3QocCB8fCBuZXcgU1ZHLlBvaW50QXJyYXkoKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlBvbHlnb24gPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdwb2x5Z29uJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWdvbiBlbGVtZW50XG4gICAgICBwb2x5Z29uOiBmdW5jdGlvbiBwb2x5Z29uKHApIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBvbHlnb24oKSkucGxvdChwIHx8IG5ldyBTVkcuUG9pbnRBcnJheSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBBZGQgcG9seWdvbi1zcGVjaWZpYyBmdW5jdGlvbnNcblxuICBTVkcuZXh0ZW5kKFNWRy5Qb2x5bGluZSwgU1ZHLlBvbHlnb24sIHtcbiAgICAvLyBHZXQgYXJyYXlcbiAgICBhcnJheTogZnVuY3Rpb24gYXJyYXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXkgfHwgKHRoaXMuX2FycmF5ID0gbmV3IFNWRy5Qb2ludEFycmF5KHRoaXMuYXR0cigncG9pbnRzJykpKTtcbiAgICB9LFxuICAgIC8vIFBsb3QgbmV3IHBhdGhcbiAgICBwbG90OiBmdW5jdGlvbiBwbG90KHApIHtcbiAgICAgIHJldHVybiBwID09IG51bGwgPyB0aGlzLmFycmF5KCkgOiB0aGlzLmNsZWFyKCkuYXR0cigncG9pbnRzJywgdHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6IHRoaXMuX2FycmF5ID0gbmV3IFNWRy5Qb2ludEFycmF5KHApKTtcbiAgICB9LFxuICAgIC8vIENsZWFyIGFycmF5IGNhY2hlXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2FycmF5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxuICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cigncG9pbnRzJywgdGhpcy5hcnJheSgpLm1vdmUoeCwgeSkpO1xuICAgIH0sXG4gICAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdwb2ludHMnLCB0aGlzLmFycmF5KCkuc2l6ZShwLndpZHRoLCBwLmhlaWdodCkpO1xuICAgIH1cbiAgfSk7IC8vIHVuaWZ5IGFsbCBwb2ludCB0byBwb2ludCBlbGVtZW50c1xuXG4gIFNWRy5leHRlbmQoU1ZHLkxpbmUsIFNWRy5Qb2x5bGluZSwgU1ZHLlBvbHlnb24sIHtcbiAgICAvLyBEZWZpbmUgbW9ycGhhYmxlIGFycmF5XG4gICAgbW9ycGhBcnJheTogU1ZHLlBvaW50QXJyYXksXG4gICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB4LWF4aXNcbiAgICB4OiBmdW5jdGlvbiB4KF94NSkge1xuICAgICAgcmV0dXJuIF94NSA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZShfeDUsIHRoaXMuYmJveCgpLnkpO1xuICAgIH0sXG4gICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB5LWF4aXNcbiAgICB5OiBmdW5jdGlvbiB5KF95NSkge1xuICAgICAgcmV0dXJuIF95NSA9PSBudWxsID8gdGhpcy5iYm94KCkueSA6IHRoaXMubW92ZSh0aGlzLmJib3goKS54LCBfeTUpO1xuICAgIH0sXG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoX3dpZHRoNCkge1xuICAgICAgdmFyIGIgPSB0aGlzLmJib3goKTtcbiAgICAgIHJldHVybiBfd2lkdGg0ID09IG51bGwgPyBiLndpZHRoIDogdGhpcy5zaXplKF93aWR0aDQsIGIuaGVpZ2h0KTtcbiAgICB9LFxuICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxuICAgIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KF9oZWlnaHQ0KSB7XG4gICAgICB2YXIgYiA9IHRoaXMuYmJveCgpO1xuICAgICAgcmV0dXJuIF9oZWlnaHQ0ID09IG51bGwgPyBiLmhlaWdodCA6IHRoaXMuc2l6ZShiLndpZHRoLCBfaGVpZ2h0NCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlBhdGggPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6ICdwYXRoJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIERlZmluZSBtb3JwaGFibGUgYXJyYXlcbiAgICAgIG1vcnBoQXJyYXk6IFNWRy5QYXRoQXJyYXksXG4gICAgICAvLyBHZXQgYXJyYXlcbiAgICAgIGFycmF5OiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FycmF5IHx8ICh0aGlzLl9hcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KHRoaXMuYXR0cignZCcpKSk7XG4gICAgICB9LFxuICAgICAgLy8gUGxvdCBuZXcgcGF0aFxuICAgICAgcGxvdDogZnVuY3Rpb24gcGxvdChkKSB7XG4gICAgICAgIHJldHVybiBkID09IG51bGwgPyB0aGlzLmFycmF5KCkgOiB0aGlzLmNsZWFyKCkuYXR0cignZCcsIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IGQgOiB0aGlzLl9hcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KGQpKTtcbiAgICAgIH0sXG4gICAgICAvLyBDbGVhciBhcnJheSBjYWNoZVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fYXJyYXk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXG4gICAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZCcsIHRoaXMuYXJyYXkoKS5tb3ZlKHgsIHkpKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xuICAgICAgeDogZnVuY3Rpb24geChfeDYpIHtcbiAgICAgICAgcmV0dXJuIF94NiA9PSBudWxsID8gdGhpcy5iYm94KCkueCA6IHRoaXMubW92ZShfeDYsIHRoaXMuYmJveCgpLnkpO1xuICAgICAgfSxcbiAgICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeS1heGlzXG4gICAgICB5OiBmdW5jdGlvbiB5KF95Nikge1xuICAgICAgICByZXR1cm4gX3k2ID09IG51bGwgPyB0aGlzLmJib3goKS55IDogdGhpcy5tb3ZlKHRoaXMuYmJveCgpLngsIF95Nik7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBzaXplOiBmdW5jdGlvbiBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpKTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxuICAgICAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKF93aWR0aDUpIHtcbiAgICAgICAgcmV0dXJuIF93aWR0aDUgPT0gbnVsbCA/IHRoaXMuYmJveCgpLndpZHRoIDogdGhpcy5zaXplKF93aWR0aDUsIHRoaXMuYmJveCgpLmhlaWdodCk7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gICAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodChfaGVpZ2h0NSkge1xuICAgICAgICByZXR1cm4gX2hlaWdodDUgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmhlaWdodCA6IHRoaXMuc2l6ZSh0aGlzLmJib3goKS53aWR0aCwgX2hlaWdodDUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcGF0aCBlbGVtZW50XG4gICAgICBwYXRoOiBmdW5jdGlvbiBwYXRoKGQpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBhdGgoKSkucGxvdChkIHx8IG5ldyBTVkcuUGF0aEFycmF5KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5JbWFnZSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ2ltYWdlJyxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuU2hhcGUsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIChyZSlsb2FkIGltYWdlXG4gICAgICBsb2FkOiBmdW5jdGlvbiBsb2FkKHVybCkge1xuICAgICAgICBpZiAoIXVybCkgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGltZyA9IG5ldyB3aW5kb3cuSW1hZ2UoKTsgLy8gcHJlbG9hZCBpbWFnZVxuXG4gICAgICAgIFNWRy5vbihpbWcsICdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFNWRy5vZmYoaW1nKTtcbiAgICAgICAgICB2YXIgcCA9IHNlbGYucGFyZW50KFNWRy5QYXR0ZXJuKTtcbiAgICAgICAgICBpZiAocCA9PT0gbnVsbCkgcmV0dXJuOyAvLyBlbnN1cmUgaW1hZ2Ugc2l6ZVxuXG4gICAgICAgICAgaWYgKHNlbGYud2lkdGgoKSA9PSAwICYmIHNlbGYuaGVpZ2h0KCkgPT0gMCkge1xuICAgICAgICAgICAgc2VsZi5zaXplKGltZy53aWR0aCwgaW1nLmhlaWdodCk7XG4gICAgICAgICAgfSAvLyBlbnN1cmUgcGF0dGVybiBzaXplIGlmIG5vdCBzZXRcblxuXG4gICAgICAgICAgaWYgKHAgJiYgcC53aWR0aCgpID09IDAgJiYgcC5oZWlnaHQoKSA9PSAwKSB7XG4gICAgICAgICAgICBwLnNpemUoc2VsZi53aWR0aCgpLCBzZWxmLmhlaWdodCgpKTtcbiAgICAgICAgICB9IC8vIGNhbGxiYWNrXG5cblxuICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5fbG9hZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzZWxmLl9sb2FkZWQuY2FsbChzZWxmLCB7XG4gICAgICAgICAgICAgIHdpZHRoOiBpbWcud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaW1nLmhlaWdodCxcbiAgICAgICAgICAgICAgcmF0aW86IGltZy53aWR0aCAvIGltZy5oZWlnaHQsXG4gICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBTVkcub24oaW1nLCAnZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIFNWRy5vZmYoaW1nKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5fZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGYuX2Vycm9yLmNhbGwoc2VsZiwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIGltZy5zcmMgPSB0aGlzLnNyYyA9IHVybCwgU1ZHLnhsaW5rKTtcbiAgICAgIH0sXG4gICAgICAvLyBBZGQgbG9hZGVkIGNhbGxiYWNrXG4gICAgICBsb2FkZWQ6IGZ1bmN0aW9uIGxvYWRlZChfbG9hZGVkKSB7XG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IF9sb2FkZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBfZXJyb3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIGNyZWF0ZSBpbWFnZSBlbGVtZW50LCBsb2FkIGltYWdlIGFuZCBzZXQgaXRzIHNpemVcbiAgICAgIGltYWdlOiBmdW5jdGlvbiBpbWFnZShzb3VyY2UsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuSW1hZ2UoKSkubG9hZChzb3VyY2UpLnNpemUod2lkdGggfHwgMCwgaGVpZ2h0IHx8IHdpZHRoIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5UZXh0ID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgndGV4dCcpKTtcbiAgICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHLk51bWJlcigxLjMpOyAvLyBzdG9yZSBsZWFkaW5nIHZhbHVlIGZvciByZWJ1aWxkaW5nXG5cbiAgICAgIHRoaXMuX3JlYnVpbGQgPSB0cnVlOyAvLyBlbmFibGUgYXV0b21hdGljIHVwZGF0aW5nIG9mIGR5IHZhbHVlc1xuXG4gICAgICB0aGlzLl9idWlsZCA9IGZhbHNlOyAvLyBkaXNhYmxlIGJ1aWxkIG1vZGUgZm9yIGFkZGluZyBtdWx0aXBsZSBsaW5lc1xuICAgICAgLy8gc2V0IGRlZmF1bHQgZm9udFxuXG4gICAgICB0aGlzLmF0dHIoJ2ZvbnQtZmFtaWx5JywgU1ZHLmRlZmF1bHRzLmF0dHJzWydmb250LWZhbWlseSddKTtcbiAgICB9LFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gTW92ZSBvdmVyIHgtYXhpc1xuICAgICAgeDogZnVuY3Rpb24geChfeDcpIHtcbiAgICAgICAgLy8gYWN0IGFzIGdldHRlclxuICAgICAgICBpZiAoX3g3ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgX3g3KTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXG4gICAgICB5OiBmdW5jdGlvbiB5KF95Nykge1xuICAgICAgICB2YXIgb3kgPSB0aGlzLmF0dHIoJ3knKSxcbiAgICAgICAgICAgIG8gPSB0eXBlb2Ygb3kgPT09ICdudW1iZXInID8gb3kgLSB0aGlzLmJib3goKS55IDogMDsgLy8gYWN0IGFzIGdldHRlclxuXG4gICAgICAgIGlmIChfeTcgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3kgPT09ICdudW1iZXInID8gb3kgLSBvIDogb3k7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgdHlwZW9mIF95Ny52YWx1ZU9mKCkgPT09ICdudW1iZXInID8gX3k3ICsgbyA6IF95Nyk7XG4gICAgICB9LFxuICAgICAgLy8gTW92ZSBjZW50ZXIgb3ZlciB4LWF4aXNcbiAgICAgIGN4OiBmdW5jdGlvbiBjeCh4KSB7XG4gICAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmJib3goKS5jeCA6IHRoaXMueCh4IC0gdGhpcy5iYm94KCkud2lkdGggLyAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBNb3ZlIGNlbnRlciBvdmVyIHktYXhpc1xuICAgICAgY3k6IGZ1bmN0aW9uIGN5KHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN5IDogdGhpcy55KHkgLSB0aGlzLmJib3goKS5oZWlnaHQgLyAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudFxuICAgICAgdGV4dDogZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgICAvLyBhY3QgYXMgZ2V0dGVyXG4gICAgICAgIGlmICh0eXBlb2YgX3RleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFyIF90ZXh0ID0gJyc7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ub2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGFkZCBuZXdsaW5lIGlmIGl0cyBub3QgdGhlIGZpcnN0IGNoaWxkIGFuZCBuZXdMaW5lZCBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgaWYgKGkgIT0gMCAmJiBjaGlsZHJlbltpXS5ub2RlVHlwZSAhPSAzICYmIFNWRy5hZG9wdChjaGlsZHJlbltpXSkuZG9tLm5ld0xpbmVkID09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3RleHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9IC8vIGFkZCBjb250ZW50IG9mIHRoaXMgbm9kZVxuXG5cbiAgICAgICAgICAgIF90ZXh0ICs9IGNoaWxkcmVuW2ldLnRleHRDb250ZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgICAgfSAvLyByZW1vdmUgZXhpc3RpbmcgY29udGVudFxuXG5cbiAgICAgICAgdGhpcy5jbGVhcigpLmJ1aWxkKHRydWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3RleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBjYWxsIGJsb2NrXG4gICAgICAgICAgX3RleHQuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzdG9yZSB0ZXh0IGFuZCBtYWtlIHN1cmUgdGV4dCBpcyBub3QgYmxhbmtcbiAgICAgICAgICBfdGV4dCA9IF90ZXh0LnNwbGl0KCdcXG4nKTsgLy8gYnVpbGQgbmV3IGxpbmVzXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBfdGV4dC5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRzcGFuKF90ZXh0W2ldKS5uZXdMaW5lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGRpc2FibGUgYnVpbGQgbW9kZSBhbmQgcmVidWlsZCBsaW5lc1xuXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGQoZmFsc2UpLnJlYnVpbGQoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTZXQgZm9udCBzaXplXG4gICAgICBzaXplOiBmdW5jdGlvbiBzaXplKF9zaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2ZvbnQtc2l6ZScsIF9zaXplKS5yZWJ1aWxkKCk7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IC8gZ2V0IGxlYWRpbmdcbiAgICAgIGxlYWRpbmc6IGZ1bmN0aW9uIGxlYWRpbmcodmFsdWUpIHtcbiAgICAgICAgLy8gYWN0IGFzIGdldHRlclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRvbS5sZWFkaW5nO1xuICAgICAgICB9IC8vIGFjdCBhcyBzZXR0ZXJcblxuXG4gICAgICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHLk51bWJlcih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYnVpbGQoKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgYWxsIHRoZSBmaXJzdCBsZXZlbCBsaW5lc1xuICAgICAgbGluZXM6IGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgICAgICB2YXIgbm9kZSA9ICh0aGlzLnRleHRQYXRoICYmIHRoaXMudGV4dFBhdGgoKSB8fCB0aGlzKS5ub2RlOyAvLyBmaWx0ZXIgdHNwYW5zIGFuZCBtYXAgdGhlbSB0byBTVkcuanMgaW5zdGFuY2VzXG5cbiAgICAgICAgdmFyIGxpbmVzID0gU1ZHLnV0aWxzLm1hcChTVkcudXRpbHMuZmlsdGVyU1ZHRWxlbWVudHMobm9kZS5jaGlsZE5vZGVzKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIFNWRy5hZG9wdChlbCk7XG4gICAgICAgIH0pOyAvLyByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgU1ZHLnNldFxuXG4gICAgICAgIHJldHVybiBuZXcgU1ZHLlNldChsaW5lcyk7XG4gICAgICB9LFxuICAgICAgLy8gUmVidWlsZCBhcHBlYXJhbmNlIHR5cGVcbiAgICAgIHJlYnVpbGQ6IGZ1bmN0aW9uIHJlYnVpbGQoX3JlYnVpbGQpIHtcbiAgICAgICAgLy8gc3RvcmUgbmV3IHJlYnVpbGQgZmxhZyBpZiBnaXZlblxuICAgICAgICBpZiAodHlwZW9mIF9yZWJ1aWxkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aGlzLl9yZWJ1aWxkID0gX3JlYnVpbGQ7XG4gICAgICAgIH0gLy8gZGVmaW5lIHBvc2l0aW9uIG9mIGFsbCBsaW5lc1xuXG5cbiAgICAgICAgaWYgKHRoaXMuX3JlYnVpbGQpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCA9IDAsXG4gICAgICAgICAgICAgIGR5ID0gdGhpcy5kb20ubGVhZGluZyAqIG5ldyBTVkcuTnVtYmVyKHRoaXMuYXR0cignZm9udC1zaXplJykpO1xuICAgICAgICAgIHRoaXMubGluZXMoKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbS5uZXdMaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoIXNlbGYudGV4dFBhdGgoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cigneCcsIHNlbGYuYXR0cigneCcpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLnRleHQoKSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCArPSBkeTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHIoJ2R5JywgZHkgKyBibGFua0xpbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmZpcmUoJ3JlYnVpbGQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEVuYWJsZSAvIGRpc2FibGUgYnVpbGQgbW9kZVxuICAgICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKF9idWlsZCkge1xuICAgICAgICB0aGlzLl9idWlsZCA9ICEhX2J1aWxkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBvdmVyd3JpdGUgbWV0aG9kIGZyb20gcGFyZW50IHRvIHNldCBkYXRhIHByb3Blcmx5XG4gICAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKG8pIHtcbiAgICAgICAgdGhpcy5kb20gPSBvO1xuICAgICAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWRy5OdW1iZXIoby5sZWFkaW5nIHx8IDEuMyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSB0ZXh0IGVsZW1lbnRcbiAgICAgIHRleHQ6IGZ1bmN0aW9uIHRleHQoX3RleHQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlRleHQoKSkudGV4dChfdGV4dDIpO1xuICAgICAgfSxcbiAgICAgIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IGVsZW1lbnRcbiAgICAgIHBsYWluOiBmdW5jdGlvbiBwbGFpbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlRleHQoKSkucGxhaW4odGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgU1ZHLlRzcGFuID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAndHNwYW4nLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5TaGFwZSxcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gU2V0IHRleHQgY29udGVudFxuICAgICAgdGV4dDogZnVuY3Rpb24gdGV4dChfdGV4dDMpIHtcbiAgICAgICAgaWYgKF90ZXh0MyA9PSBudWxsKSByZXR1cm4gdGhpcy5ub2RlLnRleHRDb250ZW50ICsgKHRoaXMuZG9tLm5ld0xpbmVkID8gJ1xcbicgOiAnJyk7XG4gICAgICAgIHR5cGVvZiBfdGV4dDMgPT09ICdmdW5jdGlvbicgPyBfdGV4dDMuY2FsbCh0aGlzLCB0aGlzKSA6IHRoaXMucGxhaW4oX3RleHQzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gU2hvcnRjdXQgZHhcbiAgICAgIGR4OiBmdW5jdGlvbiBkeChfZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignZHgnLCBfZHgpO1xuICAgICAgfSxcbiAgICAgIC8vIFNob3J0Y3V0IGR5XG4gICAgICBkeTogZnVuY3Rpb24gZHkoX2R5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2R5JywgX2R5KTtcbiAgICAgIH0sXG4gICAgICAvLyBDcmVhdGUgbmV3IGxpbmVcbiAgICAgIG5ld0xpbmU6IGZ1bmN0aW9uIG5ld0xpbmUoKSB7XG4gICAgICAgIC8vIGZldGNoIHRleHQgcGFyZW50XG4gICAgICAgIHZhciB0ID0gdGhpcy5wYXJlbnQoU1ZHLlRleHQpOyAvLyBtYXJrIG5ldyBsaW5lXG5cbiAgICAgICAgdGhpcy5kb20ubmV3TGluZWQgPSB0cnVlOyAvLyBhcHBseSBuZXcgaHnCoW5cblxuICAgICAgICByZXR1cm4gdGhpcy5keSh0LmRvbS5sZWFkaW5nICogdC5hdHRyKCdmb250LXNpemUnKSkuYXR0cigneCcsIHQueCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5UZXh0LCBTVkcuVHNwYW4sIHtcbiAgICAvLyBDcmVhdGUgcGxhaW4gdGV4dCBub2RlXG4gICAgcGxhaW46IGZ1bmN0aW9uIHBsYWluKHRleHQpIHtcbiAgICAgIC8vIGNsZWFyIGlmIGJ1aWxkIG1vZGUgaXMgZGlzYWJsZWRcbiAgICAgIGlmICh0aGlzLl9idWlsZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfSAvLyBjcmVhdGUgdGV4dCBub2RlXG5cblxuICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gQ3JlYXRlIGEgdHNwYW5cbiAgICB0c3BhbjogZnVuY3Rpb24gdHNwYW4odGV4dCkge1xuICAgICAgdmFyIG5vZGUgPSAodGhpcy50ZXh0UGF0aCAmJiB0aGlzLnRleHRQYXRoKCkgfHwgdGhpcykubm9kZSxcbiAgICAgICAgICB0c3BhbiA9IG5ldyBTVkcuVHNwYW4oKTsgLy8gY2xlYXIgaWYgYnVpbGQgbW9kZSBpcyBkaXNhYmxlZFxuXG4gICAgICBpZiAodGhpcy5fYnVpbGQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIH0gLy8gYWRkIG5ldyB0c3BhblxuXG5cbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodHNwYW4ubm9kZSk7XG4gICAgICByZXR1cm4gdHNwYW4udGV4dCh0ZXh0KTtcbiAgICB9LFxuICAgIC8vIENsZWFyIGFsbCBsaW5lc1xuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHZhciBub2RlID0gKHRoaXMudGV4dFBhdGggJiYgdGhpcy50ZXh0UGF0aCgpIHx8IHRoaXMpLm5vZGU7IC8vIHJlbW92ZSBleGlzdGluZyBjaGlsZCBub2Rlc1xuXG4gICAgICB3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gR2V0IGxlbmd0aCBvZiB0ZXh0IGVsZW1lbnRcbiAgICBsZW5ndGg6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLlRleHRQYXRoID0gU1ZHLmludmVudCh7XG4gICAgLy8gSW5pdGlhbGl6ZSBub2RlXG4gICAgY3JlYXRlOiAndGV4dFBhdGgnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5QYXJlbnQsXG4gICAgLy8gRGVmaW5lIHBhcmVudCBjbGFzc1xuICAgIHBhcmVudDogU1ZHLlRleHQsXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIG1vcnBoQXJyYXk6IFNWRy5QYXRoQXJyYXksXG4gICAgICAvLyBDcmVhdGUgcGF0aCBmb3IgdGV4dCB0byBydW4gb25cbiAgICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZCkge1xuICAgICAgICAvLyBjcmVhdGUgdGV4dFBhdGggZWxlbWVudFxuICAgICAgICB2YXIgcGF0aCA9IG5ldyBTVkcuVGV4dFBhdGgoKSxcbiAgICAgICAgICAgIHRyYWNrID0gdGhpcy5kb2MoKS5kZWZzKCkucGF0aChkKTsgLy8gbW92ZSBsaW5lcyB0byB0ZXh0cGF0aFxuXG4gICAgICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgcGF0aC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgfSAvLyBhZGQgdGV4dFBhdGggZWxlbWVudCBhcyBjaGlsZCBub2RlXG5cblxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQocGF0aC5ub2RlKTsgLy8gbGluayB0ZXh0UGF0aCB0byBwYXRoIGFuZCBhZGQgY29udGVudFxuXG4gICAgICAgIHBhdGguYXR0cignaHJlZicsICcjJyArIHRyYWNrLCBTVkcueGxpbmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyByZXR1cm4gdGhlIGFycmF5IG9mIHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcbiAgICAgIGFycmF5OiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFjaygpO1xuICAgICAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5hcnJheSgpIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICAvLyBQbG90IHBhdGggaWYgYW55XG4gICAgICBwbG90OiBmdW5jdGlvbiBwbG90KGQpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFjaygpLFxuICAgICAgICAgICAgcGF0aEFycmF5ID0gbnVsbDtcblxuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICBwYXRoQXJyYXkgPSB0cmFjay5wbG90KGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQgPT0gbnVsbCA/IHBhdGhBcnJheSA6IHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gR2V0IHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcbiAgICAgIHRyYWNrOiBmdW5jdGlvbiB0cmFjaygpIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnRleHRQYXRoKCk7XG5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5yZWZlcmVuY2UoJ2hyZWYnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEdldCB0aGUgdGV4dFBhdGggY2hpbGRcbiAgICAgIHRleHRQYXRoOiBmdW5jdGlvbiB0ZXh0UGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5maXJzdENoaWxkICYmIHRoaXMubm9kZS5maXJzdENoaWxkLm5vZGVOYW1lID09ICd0ZXh0UGF0aCcpIHtcbiAgICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KHRoaXMubm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5OZXN0ZWQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdzdmcnKSk7XG4gICAgICB0aGlzLnN0eWxlKCdvdmVyZmxvdycsICd2aXNpYmxlJyk7XG4gICAgfSxcbiAgICAvLyBJbmhlcml0IGZyb21cbiAgICBpbmhlcml0OiBTVkcuQ29udGFpbmVyLFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgbmVzdGVkIHN2ZyBkb2N1bWVudFxuICAgICAgbmVzdGVkOiBmdW5jdGlvbiBuZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLk5lc3RlZCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBTVkcuQSA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ2EnLFxuICAgIC8vIEluaGVyaXQgZnJvbVxuICAgIGluaGVyaXQ6IFNWRy5Db250YWluZXIsXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIExpbmsgdXJsXG4gICAgICB0bzogZnVuY3Rpb24gdG8odXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCB1cmwsIFNWRy54bGluayk7XG4gICAgICB9LFxuICAgICAgLy8gTGluayBzaG93IGF0dHJpYnV0ZVxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdyh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cignc2hvdycsIHRhcmdldCwgU1ZHLnhsaW5rKTtcbiAgICAgIH0sXG4gICAgICAvLyBMaW5rIHRhcmdldCBhdHRyaWJ1dGVcbiAgICAgIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KF90YXJnZXQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3RhcmdldCcsIF90YXJnZXQyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEFkZCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3RydWN0OiB7XG4gICAgICAvLyBDcmVhdGUgYSBoeXBlcmxpbmsgZWxlbWVudFxuICAgICAgbGluazogZnVuY3Rpb24gbGluayh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQSgpKS50byh1cmwpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcbiAgICAvLyBDcmVhdGUgYSBoeXBlcmxpbmsgZWxlbWVudFxuICAgIGxpbmtUbzogZnVuY3Rpb24gbGlua1RvKHVybCkge1xuICAgICAgdmFyIGxpbmsgPSBuZXcgU1ZHLkEoKTtcblxuICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdXJsLmNhbGwobGluaywgbGluayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5rLnRvKHVybCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLnB1dChsaW5rKS5wdXQodGhpcyk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLk1hcmtlciA9IFNWRy5pbnZlbnQoe1xuICAgIC8vIEluaXRpYWxpemUgbm9kZVxuICAgIGNyZWF0ZTogJ21hcmtlcicsXG4gICAgLy8gSW5oZXJpdCBmcm9tXG4gICAgaW5oZXJpdDogU1ZHLkNvbnRhaW5lcixcbiAgICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xuICAgIGV4dGVuZDoge1xuICAgICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcbiAgICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChfd2lkdGg2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlcldpZHRoJywgX3dpZHRoNik7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XG4gICAgICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodChfaGVpZ2h0Nikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXJrZXJIZWlnaHQnLCBfaGVpZ2h0Nik7XG4gICAgICB9LFxuICAgICAgLy8gU2V0IG1hcmtlciByZWZYIGFuZCByZWZZXG4gICAgICByZWY6IGZ1bmN0aW9uIHJlZih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3JlZlgnLCB4KS5hdHRyKCdyZWZZJywgeSk7XG4gICAgICB9LFxuICAgICAgLy8gVXBkYXRlIG1hcmtlclxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoYmxvY2spIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBjb250ZW50XG4gICAgICAgIHRoaXMuY2xlYXIoKTsgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xuXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIG1hcmtlcjogZnVuY3Rpb24gbWFya2VyKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICAgIC8vIENyZWF0ZSBtYXJrZXIgZWxlbWVudCBpbiBkZWZzXG4gICAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5tYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcbiAgICAvLyBDcmVhdGUgbWFya2VyXG4gICAgbWFya2VyOiBmdW5jdGlvbiBtYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spIHtcbiAgICAgIC8vIFNldCBkZWZhdWx0IHZpZXdib3ggdG8gbWF0Y2ggdGhlIHdpZHRoIGFuZCBoZWlnaHQsIHNldCByZWYgdG8gY3ggYW5kIGN5IGFuZCBzZXQgb3JpZW50IHRvIGF1dG9cbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLk1hcmtlcigpKS5zaXplKHdpZHRoLCBoZWlnaHQpLnJlZih3aWR0aCAvIDIsIGhlaWdodCAvIDIpLnZpZXdib3goMCwgMCwgd2lkdGgsIGhlaWdodCkuYXR0cignb3JpZW50JywgJ2F1dG8nKS51cGRhdGUoYmxvY2spO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5leHRlbmQoU1ZHLkxpbmUsIFNWRy5Qb2x5bGluZSwgU1ZHLlBvbHlnb24sIFNWRy5QYXRoLCB7XG4gICAgLy8gQ3JlYXRlIGFuZCBhdHRhY2ggbWFya2Vyc1xuICAgIG1hcmtlcjogZnVuY3Rpb24gbWFya2VyKF9tYXJrZXIsIHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XG4gICAgICB2YXIgYXR0ciA9IFsnbWFya2VyJ107IC8vIEJ1aWxkIGF0dHJpYnV0ZSBuYW1lXG5cbiAgICAgIGlmIChfbWFya2VyICE9ICdhbGwnKSBhdHRyLnB1c2goX21hcmtlcik7XG4gICAgICBhdHRyID0gYXR0ci5qb2luKCctJyk7IC8vIFNldCBtYXJrZXIgYXR0cmlidXRlXG5cbiAgICAgIF9tYXJrZXIgPSBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBTVkcuTWFya2VyID8gYXJndW1lbnRzWzFdIDogdGhpcy5kb2MoKS5tYXJrZXIod2lkdGgsIGhlaWdodCwgYmxvY2spO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cihhdHRyLCBfbWFya2VyKTtcbiAgICB9XG4gIH0pOyAvLyBEZWZpbmUgbGlzdCBvZiBhdmFpbGFibGUgYXR0cmlidXRlcyBmb3Igc3Ryb2tlIGFuZCBmaWxsXG5cbiAgdmFyIHN1Z2FyID0ge1xuICAgIHN0cm9rZTogWydjb2xvcicsICd3aWR0aCcsICdvcGFjaXR5JywgJ2xpbmVjYXAnLCAnbGluZWpvaW4nLCAnbWl0ZXJsaW1pdCcsICdkYXNoYXJyYXknLCAnZGFzaG9mZnNldCddLFxuICAgIGZpbGw6IFsnY29sb3InLCAnb3BhY2l0eScsICdydWxlJ10sXG4gICAgcHJlZml4OiBmdW5jdGlvbiBwcmVmaXgodCwgYSkge1xuICAgICAgcmV0dXJuIGEgPT0gJ2NvbG9yJyA/IHQgOiB0ICsgJy0nICsgYTtcbiAgICB9IC8vIEFkZCBzdWdhciBmb3IgZmlsbCBhbmQgc3Ryb2tlXG5cbiAgfTtcbiAgWydmaWxsJywgJ3N0cm9rZSddLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICB2YXIgaSxcbiAgICAgICAgZXh0ZW5zaW9uID0ge307XG5cbiAgICBleHRlbnNpb25bbV0gPSBmdW5jdGlvbiAobykge1xuICAgICAgaWYgKHR5cGVvZiBvID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJyB8fCBTVkcuQ29sb3IuaXNSZ2IobykgfHwgbyAmJiB0eXBlb2Ygby5maWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuYXR0cihtLCBvKTtcbiAgICAgIH0gZWxzZSAvLyBzZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSBzdWdhci5maWxsIGFuZCBzdWdhci5zdHJva2UgbGlzdFxuICAgICAgICB7XG4gICAgICAgICAgZm9yIChpID0gc3VnYXJbbV0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChvW3N1Z2FyW21dW2ldXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXR0cihzdWdhci5wcmVmaXgobSwgc3VnYXJbbV1baV0pLCBvW3N1Z2FyW21dW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCBTVkcuRlgsIGV4dGVuc2lvbik7XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCBTVkcuRlgsIHtcbiAgICAvLyBNYXAgcm90YXRpb24gdG8gdHJhbnNmb3JtXG4gICAgcm90YXRlOiBmdW5jdGlvbiByb3RhdGUoZCwgY3gsIGN5KSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICByb3RhdGlvbjogZCxcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3lcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gTWFwIHNrZXcgdG8gdHJhbnNmb3JtXG4gICAgc2tldzogZnVuY3Rpb24gc2tldyh4LCB5LCBjeCwgY3kpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA9PSAzID8gdGhpcy50cmFuc2Zvcm0oe1xuICAgICAgICBza2V3OiB4LFxuICAgICAgICBjeDogeSxcbiAgICAgICAgY3k6IGN4XG4gICAgICB9KSA6IHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgc2tld1g6IHgsXG4gICAgICAgIHNrZXdZOiB5LFxuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBNYXAgc2NhbGUgdG8gdHJhbnNmb3JtXG4gICAgc2NhbGU6IGZ1bmN0aW9uIHNjYWxlKHgsIHksIGN4LCBjeSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT0gMSB8fCBhcmd1bWVudHMubGVuZ3RoID09IDMgPyB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgIHNjYWxlOiB4LFxuICAgICAgICBjeDogeSxcbiAgICAgICAgY3k6IGN4XG4gICAgICB9KSA6IHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgc2NhbGVYOiB4LFxuICAgICAgICBzY2FsZVk6IHksXG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIE1hcCB0cmFuc2xhdGUgdG8gdHJhbnNmb3JtXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBNYXAgZmxpcCB0byB0cmFuc2Zvcm1cbiAgICBmbGlwOiBmdW5jdGlvbiBmbGlwKGEsIG8pIHtcbiAgICAgIG8gPSB0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBhIDogbztcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7XG4gICAgICAgIGZsaXA6IGEgfHwgJ2JvdGgnLFxuICAgICAgICBvZmZzZXQ6IG9cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gTWFwIG1hdHJpeCB0byB0cmFuc2Zvcm1cbiAgICBtYXRyaXg6IGZ1bmN0aW9uIG1hdHJpeChtKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBuZXcgU1ZHLk1hdHJpeChhcmd1bWVudHMubGVuZ3RoID09IDYgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgOiBtKSk7XG4gICAgfSxcbiAgICAvLyBPcGFjaXR5XG4gICAgb3BhY2l0eTogZnVuY3Rpb24gb3BhY2l0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cignb3BhY2l0eScsIHZhbHVlKTtcbiAgICB9LFxuICAgIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGF4aXNcbiAgICBkeDogZnVuY3Rpb24gZHgoeCkge1xuICAgICAgcmV0dXJuIHRoaXMueChuZXcgU1ZHLk51bWJlcih4KS5wbHVzKHRoaXMgaW5zdGFuY2VvZiBTVkcuRlggPyAwIDogdGhpcy54KCkpLCB0cnVlKTtcbiAgICB9LFxuICAgIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB5IGF4aXNcbiAgICBkeTogZnVuY3Rpb24gZHkoeSkge1xuICAgICAgcmV0dXJuIHRoaXMueShuZXcgU1ZHLk51bWJlcih5KS5wbHVzKHRoaXMgaW5zdGFuY2VvZiBTVkcuRlggPyAwIDogdGhpcy55KCkpLCB0cnVlKTtcbiAgICB9LFxuICAgIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGFuZCB5IGF4ZXNcbiAgICBkbW92ZTogZnVuY3Rpb24gZG1vdmUoeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMuZHgoeCkuZHkoeSk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuUmVjdCwgU1ZHLkVsbGlwc2UsIFNWRy5DaXJjbGUsIFNWRy5HcmFkaWVudCwgU1ZHLkZYLCB7XG4gICAgLy8gQWRkIHggYW5kIHkgcmFkaXVzXG4gICAgcmFkaXVzOiBmdW5jdGlvbiByYWRpdXMoeCwgeSkge1xuICAgICAgdmFyIHR5cGUgPSAodGhpcy5fdGFyZ2V0IHx8IHRoaXMpLnR5cGU7XG4gICAgICByZXR1cm4gdHlwZSA9PSAncmFkaWFsJyB8fCB0eXBlID09ICdjaXJjbGUnID8gdGhpcy5hdHRyKCdyJywgbmV3IFNWRy5OdW1iZXIoeCkpIDogdGhpcy5yeCh4KS5yeSh5ID09IG51bGwgPyB4IDogeSk7XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuUGF0aCwge1xuICAgIC8vIEdldCBwYXRoIGxlbmd0aFxuICAgIGxlbmd0aDogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgIH0sXG4gICAgLy8gR2V0IHBvaW50IGF0IGxlbmd0aFxuICAgIHBvaW50QXQ6IGZ1bmN0aW9uIHBvaW50QXQobGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoKTtcbiAgICB9XG4gIH0pO1xuICBTVkcuZXh0ZW5kKFNWRy5QYXJlbnQsIFNWRy5UZXh0LCBTVkcuVHNwYW4sIFNWRy5GWCwge1xuICAgIC8vIFNldCBmb250XG4gICAgZm9udDogZnVuY3Rpb24gZm9udChhLCB2KSB7XG4gICAgICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2IGluIGEpIHtcbiAgICAgICAgICB0aGlzLmZvbnQodiwgYVt2XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEgPT0gJ2xlYWRpbmcnID8gdGhpcy5sZWFkaW5nKHYpIDogYSA9PSAnYW5jaG9yJyA/IHRoaXMuYXR0cigndGV4dC1hbmNob3InLCB2KSA6IGEgPT0gJ3NpemUnIHx8IGEgPT0gJ2ZhbWlseScgfHwgYSA9PSAnd2VpZ2h0JyB8fCBhID09ICdzdHJldGNoJyB8fCBhID09ICd2YXJpYW50JyB8fCBhID09ICdzdHlsZScgPyB0aGlzLmF0dHIoJ2ZvbnQtJyArIGEsIHYpIDogdGhpcy5hdHRyKGEsIHYpO1xuICAgIH1cbiAgfSk7XG4gIFNWRy5TZXQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUobWVtYmVycykge1xuICAgICAgLy8gU2V0IGluaXRpYWwgc3RhdGVcbiAgICAgIEFycmF5LmlzQXJyYXkobWVtYmVycykgPyB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzIDogdGhpcy5jbGVhcigpO1xuICAgIH0sXG4gICAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcbiAgICBleHRlbmQ6IHtcbiAgICAgIC8vIEFkZCBlbGVtZW50IHRvIHNldFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgaWwsXG4gICAgICAgICAgICBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBpbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm1lbWJlcnMucHVzaChlbGVtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIHNldFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZWxlbWVudCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXgoZWxlbWVudCk7IC8vIHJlbW92ZSBnaXZlbiBjaGlsZFxuXG4gICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICB0aGlzLm1lbWJlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBtZW1iZXJzXG4gICAgICBlYWNoOiBmdW5jdGlvbiBlYWNoKGJsb2NrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMubWVtYmVycy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgYmxvY2suYXBwbHkodGhpcy5tZW1iZXJzW2ldLCBbaSwgdGhpcy5tZW1iZXJzXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBSZXN0b3JlIHRvIGRlZmF1bHRzXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgc3RvcmVcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIGEgc2V0XG4gICAgICBsZW5ndGg6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVycy5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyBwcmVzZW50IGluIHNldFxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwO1xuICAgICAgfSxcbiAgICAgIC8vIHJldHVucyBpbmRleCBvZiBnaXZlbiBlbGVtZW50IGluIHNldFxuICAgICAgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVycy5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIC8vIEdldCBtZW1iZXIgYXQgZ2l2ZW4gaW5kZXhcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyc1tpXTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgZmlyc3QgbWVtYmVyXG4gICAgICBmaXJzdDogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgwKTtcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgbGFzdCBtZW1iZXJcbiAgICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLm1lbWJlcnMubGVuZ3RoIC0gMSk7XG4gICAgICB9LFxuICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxuICAgICAgdmFsdWVPZjogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVycztcbiAgICAgIH0sXG4gICAgICAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiBhbGwgbWVtYmVycyBpbmNsdWRlZCBvciBlbXB0eSBib3ggaWYgc2V0IGhhcyBubyBpdGVtc1xuICAgICAgYmJveDogZnVuY3Rpb24gYmJveCgpIHtcbiAgICAgICAgLy8gcmV0dXJuIGFuIGVtcHR5IGJveCBvZiB0aGVyZSBhcmUgbm8gbWVtYmVyc1xuICAgICAgICBpZiAodGhpcy5tZW1iZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTVkcuUkJveCgpO1xuICAgICAgICB9IC8vIGdldCB0aGUgZmlyc3QgcmJveCBhbmQgdXBkYXRlIHRoZSB0YXJnZXQgYmJveFxuXG5cbiAgICAgICAgdmFyIHJib3ggPSB0aGlzLm1lbWJlcnNbMF0ucmJveCh0aGlzLm1lbWJlcnNbMF0uZG9jKCkpO1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIHVzZXIgcmJveCBmb3IgY29ycmVjdCBwb3NpdGlvbiBhbmQgdmlzdWFsIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgcmJveCA9IHJib3gubWVyZ2UodGhpcy5yYm94KHRoaXMuZG9jKCkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByYm94O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQWRkIHBhcmVudCBtZXRob2RcbiAgICBjb25zdHJ1Y3Q6IHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBzZXRcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG1lbWJlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTVkcuU2V0KG1lbWJlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFNWRy5GWC5TZXQgPSBTVkcuaW52ZW50KHtcbiAgICAvLyBJbml0aWFsaXplIG5vZGVcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzZXQpIHtcbiAgICAgIC8vIHN0b3JlIHJlZmVyZW5jZSB0byBzZXRcbiAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgfSk7IC8vIEFsaWFzIG1ldGhvZHNcblxuICBTVkcuU2V0LmluaGVyaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG0sXG4gICAgICAgIG1ldGhvZHMgPSBbXTsgLy8gZ2F0aGVyIHNoYXBlIG1ldGhvZHNcblxuICAgIGZvciAodmFyIG0gaW4gU1ZHLlNoYXBlLnByb3RvdHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiBTVkcuU2hhcGUucHJvdG90eXBlW21dID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTVkcuU2V0LnByb3RvdHlwZVttXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtZXRob2RzLnB1c2gobSk7XG4gICAgICB9XG4gICAgfSAvLyBhcHBseSBzaGFwZSBhbGlhc3Nlc1xuXG5cbiAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgU1ZHLlNldC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5tZW1iZXJzW2ldICYmIHR5cGVvZiB0aGlzLm1lbWJlcnNbaV1bbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5tZW1iZXJzW2ldW21ldGhvZF0uYXBwbHkodGhpcy5tZW1iZXJzW2ldLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRob2QgPT0gJ2FuaW1hdGUnID8gdGhpcy5meCB8fCAodGhpcy5meCA9IG5ldyBTVkcuRlguU2V0KHRoaXMpKSA6IHRoaXM7XG4gICAgICB9O1xuICAgIH0pOyAvLyBjbGVhciBtZXRob2RzIGZvciB0aGUgbmV4dCByb3VuZFxuXG4gICAgbWV0aG9kcyA9IFtdOyAvLyBnYXRoZXIgZnggbWV0aG9kc1xuXG4gICAgZm9yICh2YXIgbSBpbiBTVkcuRlgucHJvdG90eXBlKSB7XG4gICAgICBpZiAodHlwZW9mIFNWRy5GWC5wcm90b3R5cGVbbV0gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFNWRy5GWC5TZXQucHJvdG90eXBlW21dICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1ldGhvZHMucHVzaChtKTtcbiAgICAgIH1cbiAgICB9IC8vIGFwcGx5IGZ4IGFsaWFzc2VzXG5cblxuICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBTVkcuRlguU2V0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnNldC5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNldC5tZW1iZXJzW2ldLmZ4W21ldGhvZF0uYXBwbHkodGhpcy5zZXQubWVtYmVyc1tpXS5meCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XG4gICAgLy8gU3RvcmUgZGF0YSB2YWx1ZXMgb24gc3ZnIG5vZGVzXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YShhLCB2LCByKSB7XG4gICAgICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2IGluIGEpIHtcbiAgICAgICAgICB0aGlzLmRhdGEodiwgYVt2XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmF0dHIoJ2RhdGEtJyArIGEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2RhdGEtJyArIGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHIoJ2RhdGEtJyArIGEsIHYgPT09IG51bGwgPyBudWxsIDogciA9PT0gdHJ1ZSB8fCB0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInID8gdiA6IEpTT04uc3RyaW5naWZ5KHYpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xuICAgIC8vIFJlbWVtYmVyIGFyYml0cmFyeSBkYXRhXG4gICAgcmVtZW1iZXI6IGZ1bmN0aW9uIHJlbWVtYmVyKGssIHYpIHtcbiAgICAgIC8vIHJlbWVtYmVyIGV2ZXJ5IGl0ZW0gaW4gYW4gb2JqZWN0IGluZGl2aWR1YWxseVxuICAgICAgaWYgKF90eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgdiBpbiBrKSB7XG4gICAgICAgICAgdGhpcy5yZW1lbWJlcih2LCBrW3ZdKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyByZXRyaWV2ZSBtZW1vcnlcbiAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1lbW9yeSgpW2tdO1xuICAgICAgICB9IC8vIHN0b3JlIG1lbW9yeVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVtb3J5KClba10gPSB2O1xuICAgICAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBFcmFzZSBhIGdpdmVuIG1lbW9yeVxuICAgIGZvcmdldDogZnVuY3Rpb24gZm9yZ2V0KCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICB0aGlzLl9tZW1vcnkgPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5tZW1vcnkoKVthcmd1bWVudHNbaV1dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gSW5pdGlhbGl6ZSBvciByZXR1cm4gbG9jYWwgbWVtb3J5IG9iamVjdFxuICAgIG1lbW9yeTogZnVuY3Rpb24gbWVtb3J5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21lbW9yeSB8fCAodGhpcy5fbWVtb3J5ID0ge30pO1xuICAgIH1cbiAgfSk7IC8vIE1ldGhvZCBmb3IgZ2V0dGluZyBhbiBlbGVtZW50IGJ5IGlkXG5cbiAgU1ZHLmdldCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRGcm9tUmVmZXJlbmNlKGlkKSB8fCBpZCk7XG4gICAgcmV0dXJuIFNWRy5hZG9wdChub2RlKTtcbiAgfTsgLy8gU2VsZWN0IGVsZW1lbnRzIGJ5IHF1ZXJ5IHN0cmluZ1xuXG5cbiAgU1ZHLnNlbGVjdCA9IGZ1bmN0aW9uIChxdWVyeSwgcGFyZW50KSB7XG4gICAgcmV0dXJuIG5ldyBTVkcuU2V0KFNWRy51dGlscy5tYXAoKHBhcmVudCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChxdWVyeSksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpO1xuICAgIH0pKTtcbiAgfTtcblxuICBTVkcuZXh0ZW5kKFNWRy5QYXJlbnQsIHtcbiAgICAvLyBTY29wZWQgc2VsZWN0IG1ldGhvZFxuICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gU1ZHLnNlbGVjdChxdWVyeSwgdGhpcy5ub2RlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHBhdGhSZWdSZXBsYWNlKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyArIGQucmVwbGFjZShTVkcucmVnZXguZG90cywgJyAuJyk7XG4gIH0gLy8gY3JlYXRlcyBkZWVwIGNsb25lIG9mIGFycmF5XG5cblxuICBmdW5jdGlvbiBhcnJheV9jbG9uZShhcnIpIHtcbiAgICB2YXIgY2xvbmUgPSBhcnIuc2xpY2UoMCk7XG5cbiAgICBmb3IgKHZhciBpID0gY2xvbmUubGVuZ3RoOyBpLS07KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjbG9uZVtpXSkpIHtcbiAgICAgICAgY2xvbmVbaV0gPSBhcnJheV9jbG9uZShjbG9uZVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9IC8vIHRlc3RzIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyBpbnN0YW5jZSBvZiBhbiBvYmplY3RcblxuXG4gIGZ1bmN0aW9uIF9pcyhlbCwgb2JqKSB7XG4gICAgcmV0dXJuIGVsIGluc3RhbmNlb2Ygb2JqO1xuICB9IC8vIHRlc3RzIGlmIGEgZ2l2ZW4gc2VsZWN0b3IgbWF0Y2hlcyBhbiBlbGVtZW50XG5cblxuICBmdW5jdGlvbiBfbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gKGVsLm1hdGNoZXMgfHwgZWwubWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwub01hdGNoZXNTZWxlY3RvcikuY2FsbChlbCwgc2VsZWN0b3IpO1xuICB9IC8vIENvbnZlcnQgZGFzaC1zZXBhcmF0ZWQtc3RyaW5nIHRvIGNhbWVsQ2FzZVxuXG5cbiAgZnVuY3Rpb24gY2FtZWxDYXNlKHMpIHtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgICAgIHJldHVybiBnLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH0gLy8gQ2FwaXRhbGl6ZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcblxuXG4gIGZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICAgIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcbiAgfSAvLyBFbnN1cmUgdG8gc2l4LWJhc2VkIGhleFxuXG5cbiAgZnVuY3Rpb24gZnVsbEhleChoZXgpIHtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSA0ID8gWycjJywgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygyLCAzKSwgaGV4LnN1YnN0cmluZygyLCAzKSwgaGV4LnN1YnN0cmluZygzLCA0KSwgaGV4LnN1YnN0cmluZygzLCA0KV0uam9pbignJykgOiBoZXg7XG4gIH0gLy8gQ29tcG9uZW50IHRvIGhleCB2YWx1ZVxuXG5cbiAgZnVuY3Rpb24gY29tcFRvSGV4KGNvbXApIHtcbiAgICB2YXIgaGV4ID0gY29tcC50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggPT0gMSA/ICcwJyArIGhleCA6IGhleDtcbiAgfSAvLyBDYWxjdWxhdGUgcHJvcG9ydGlvbmFsIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIHdoZW4gbmVjZXNzYXJ5XG5cblxuICBmdW5jdGlvbiBwcm9wb3J0aW9uYWxTaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPT0gbnVsbCB8fCBoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgdmFyIGJveCA9IGVsZW1lbnQuYmJveCgpO1xuXG4gICAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgICB3aWR0aCA9IGJveC53aWR0aCAvIGJveC5oZWlnaHQgKiBoZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIGhlaWdodCA9IGJveC5oZWlnaHQgLyBib3gud2lkdGggKiB3aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9IC8vIERlbHRhIHRyYW5zZm9ybSBwb2ludFxuXG5cbiAgZnVuY3Rpb24gZGVsdGFUcmFuc2Zvcm1Qb2ludChtYXRyaXgsIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCAqIG1hdHJpeC5hICsgeSAqIG1hdHJpeC5jICsgMCxcbiAgICAgIHk6IHggKiBtYXRyaXguYiArIHkgKiBtYXRyaXguZCArIDBcbiAgICB9O1xuICB9IC8vIE1hcCBtYXRyaXggYXJyYXkgdG8gb2JqZWN0XG5cblxuICBmdW5jdGlvbiBhcnJheVRvTWF0cml4KGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYTogYVswXSxcbiAgICAgIGI6IGFbMV0sXG4gICAgICBjOiBhWzJdLFxuICAgICAgZDogYVszXSxcbiAgICAgIGU6IGFbNF0sXG4gICAgICBmOiBhWzVdXG4gICAgfTtcbiAgfSAvLyBQYXJzZSBtYXRyaXggaWYgcmVxdWlyZWRcblxuXG4gIGZ1bmN0aW9uIHBhcnNlTWF0cml4KG1hdHJpeCkge1xuICAgIGlmICghKG1hdHJpeCBpbnN0YW5jZW9mIFNWRy5NYXRyaXgpKSB7XG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeChtYXRyaXgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRyaXg7XG4gIH0gLy8gQWRkIGNlbnRyZSBwb2ludCB0byB0cmFuc2Zvcm0gb2JqZWN0XG5cblxuICBmdW5jdGlvbiBlbnN1cmVDZW50cmUobywgdGFyZ2V0KSB7XG4gICAgby5jeCA9IG8uY3ggPT0gbnVsbCA/IHRhcmdldC5iYm94KCkuY3ggOiBvLmN4O1xuICAgIG8uY3kgPSBvLmN5ID09IG51bGwgPyB0YXJnZXQuYmJveCgpLmN5IDogby5jeTtcbiAgfSAvLyBQYXRoQXJyYXkgSGVscGVyc1xuXG5cbiAgZnVuY3Rpb24gYXJyYXlUb1N0cmluZyhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYS5sZW5ndGgsIHMgPSAnJzsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHMgKz0gYVtpXVswXTtcblxuICAgICAgaWYgKGFbaV1bMV0gIT0gbnVsbCkge1xuICAgICAgICBzICs9IGFbaV1bMV07XG5cbiAgICAgICAgaWYgKGFbaV1bMl0gIT0gbnVsbCkge1xuICAgICAgICAgIHMgKz0gJyAnO1xuICAgICAgICAgIHMgKz0gYVtpXVsyXTtcblxuICAgICAgICAgIGlmIChhW2ldWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHMgKz0gJyAnO1xuICAgICAgICAgICAgcyArPSBhW2ldWzNdO1xuICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICBzICs9IGFbaV1bNF07XG5cbiAgICAgICAgICAgIGlmIChhW2ldWzVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICAgIHMgKz0gYVtpXVs1XTtcbiAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICAgIHMgKz0gYVtpXVs2XTtcblxuICAgICAgICAgICAgICBpZiAoYVtpXVs3XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICAgICAgcyArPSBhW2ldWzddO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMgKyAnICc7XG4gIH0gLy8gRGVlcCBuZXcgaWQgYXNzaWdubWVudFxuXG5cbiAgZnVuY3Rpb24gYXNzaWduTmV3SWQobm9kZSkge1xuICAgIC8vIGRvIHRoZSBzYW1lIGZvciBTVkcgY2hpbGQgbm9kZXMgYXMgd2VsbFxuICAgIGZvciAodmFyIGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaV0gaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCkge1xuICAgICAgICBhc3NpZ25OZXdJZChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBTVkcuYWRvcHQobm9kZSkuaWQoU1ZHLmVpZChub2RlLm5vZGVOYW1lKSk7XG4gIH0gLy8gQWRkIG1vcmUgYm91bmRpbmcgYm94IHByb3BlcnRpZXNcblxuXG4gIGZ1bmN0aW9uIGZ1bGxCb3goYikge1xuICAgIGlmIChiLnggPT0gbnVsbCkge1xuICAgICAgYi54ID0gMDtcbiAgICAgIGIueSA9IDA7XG4gICAgICBiLndpZHRoID0gMDtcbiAgICAgIGIuaGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBiLncgPSBiLndpZHRoO1xuICAgIGIuaCA9IGIuaGVpZ2h0O1xuICAgIGIueDIgPSBiLnggKyBiLndpZHRoO1xuICAgIGIueTIgPSBiLnkgKyBiLmhlaWdodDtcbiAgICBiLmN4ID0gYi54ICsgYi53aWR0aCAvIDI7XG4gICAgYi5jeSA9IGIueSArIGIuaGVpZ2h0IC8gMjtcbiAgICByZXR1cm4gYjtcbiAgfSAvLyBHZXQgaWQgZnJvbSByZWZlcmVuY2Ugc3RyaW5nXG5cblxuICBmdW5jdGlvbiBpZEZyb21SZWZlcmVuY2UodXJsKSB7XG4gICAgdmFyIG0gPSAodXJsIHx8ICcnKS50b1N0cmluZygpLm1hdGNoKFNWRy5yZWdleC5yZWZlcmVuY2UpO1xuICAgIGlmIChtKSByZXR1cm4gbVsxXTtcbiAgfSAvLyBJZiB2YWx1ZXMgbGlrZSAxZS04OCBhcmUgcGFzc2VkLCB0aGlzIGlzIG5vdCBhIHZhbGlkIDMyIGJpdCBmbG9hdCxcbiAgLy8gYnV0IGluIHRob3NlIGNhc2VzLCB3ZSBhcmUgc28gY2xvc2UgdG8gMCB0aGF0IDAgd29ya3Mgd2VsbCFcblxuXG4gIGZ1bmN0aW9uIGZsb2F0MzJTdHJpbmcodikge1xuICAgIHJldHVybiBNYXRoLmFicyh2KSA+IDFlLTM3ID8gdiA6IDA7XG4gIH0gLy8gQ3JlYXRlIG1hdHJpeCBhcnJheSBmb3IgbG9vcGluZ1xuXG5cbiAgdmFyIGFiY2RlZiA9ICdhYmNkZWYnLnNwbGl0KCcnKTsgLy8gQWRkIEN1c3RvbUV2ZW50IHRvIElFOSBhbmQgSUUxMFxuXG4gIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQ29kZSBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnRcbiAgICB2YXIgQ3VzdG9tRXZlbnRQb2x5ID0gZnVuY3Rpb24gQ3VzdG9tRXZlbnRQb2x5KGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZS5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIG9wdGlvbnMuYnViYmxlcywgb3B0aW9ucy5jYW5jZWxhYmxlLCBvcHRpb25zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuXG4gICAgQ3VzdG9tRXZlbnRQb2x5LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgU1ZHLkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnRQb2x5O1xuICB9IGVsc2Uge1xuICAgIFNWRy5DdXN0b21FdmVudCA9IHdpbmRvdy5DdXN0b21FdmVudDtcbiAgfSAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgLyBjYW5jZWxBbmltYXRpb25GcmFtZSBQb2x5ZmlsbCB3aXRoIGZhbGxiYWNrIGJhc2VkIG9uIFBhdWwgSXJpc2hcblxuXG4gIChmdW5jdGlvbiAodykge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgdmFyIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXTtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgICB3LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIH1cblxuICAgIHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgdmFyIGlkID0gdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgIH0sIHRpbWVUb0NhbGwpO1xuICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfTtcblxuICAgIHcuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHcuY2xlYXJUaW1lb3V0O1xuICB9KSh3aW5kb3cpO1xuXG4gIHJldHVybiBTVkc7XG59KTtcblxuLyohIHN2Zy5maWx0ZXIuanMgLSB2Mi4wLjIgLSAyMDE2LTAyLTI0XHJcbiogaHR0cHM6Ly9naXRodWIuY29tL3dvdXQvc3ZnLmZpbHRlci5qc1xyXG4qIENvcHlyaWdodCAoYykgMjAxNiBXb3V0IEZpZXJlbnM7IExpY2Vuc2VkIE1JVCAqL1xyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gIC8vIE1haW4gZmlsdGVyIGNsYXNzXHJcbiAgU1ZHLkZpbHRlciA9IFNWRy5pbnZlbnQoe1xyXG4gICAgY3JlYXRlOiAnZmlsdGVyJyxcclxuICAgIGluaGVyaXQ6IFNWRy5QYXJlbnQsXHJcbiAgICBleHRlbmQ6IHtcclxuICAgICAgLy8gU3RhdGljIHN0cmluZ3NcclxuICAgICAgc291cmNlOiAgICAgICAgICAgJ1NvdXJjZUdyYXBoaWMnLFxyXG4gICAgICBzb3VyY2VBbHBoYTogICAgICAnU291cmNlQWxwaGEnLFxyXG4gICAgICBiYWNrZ3JvdW5kOiAgICAgICAnQmFja2dyb3VuZEltYWdlJyxcclxuICAgICAgYmFja2dyb3VuZEFscGhhOiAgJ0JhY2tncm91bmRBbHBoYScsXHJcbiAgICAgIGZpbGw6ICAgICAgICAgICAgICdGaWxsUGFpbnQnLFxyXG4gICAgICBzdHJva2U6ICAgICAgICAgICAnU3Ryb2tlUGFpbnQnLFxyXG5cclxuICAgICAgYXV0b1NldEluOiB0cnVlLFxyXG4gICAgICAvLyBDdXN0b20gcHV0IG1ldGhvZCBmb3IgbGVhbmVyIGNvZGVcclxuICAgICAgcHV0OiBmdW5jdGlvbihlbGVtZW50LCBpKSB7XHJcbiAgICAgICAgdGhpcy5hZGQoZWxlbWVudCwgaSk7XHJcblxyXG4gICAgICAgIGlmKCFlbGVtZW50LmF0dHIoJ2luJykgJiYgdGhpcy5hdXRvU2V0SW4pe1xyXG4gICAgICAgICAgZWxlbWVudC5hdHRyKCdpbicsdGhpcy5zb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZighZWxlbWVudC5hdHRyKCdyZXN1bHQnKSl7XHJcbiAgICAgICAgICBlbGVtZW50LmF0dHIoJ3Jlc3VsdCcsZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZWxlbWVudFxyXG4gICAgICB9LFxyXG4gICAgICAvLyBCbGVuZCBlZmZlY3RcclxuICAgICAgYmxlbmQ6IGZ1bmN0aW9uKGluMSwgaW4yLCBtb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQmxlbmRFZmZlY3QoaW4xLCBpbjIsIG1vZGUpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBDb2xvck1hdHJpeCBlZmZlY3RcclxuICAgICAgY29sb3JNYXRyaXg6IGZ1bmN0aW9uKHR5cGUsIHZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkNvbG9yTWF0cml4RWZmZWN0KHR5cGUsIHZhbHVlcykpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIENvbnZvbHZlTWF0cml4IGVmZmVjdFxyXG4gICAgICBjb252b2x2ZU1hdHJpeDogZnVuY3Rpb24obWF0cml4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQ29udm9sdmVNYXRyaXhFZmZlY3QobWF0cml4KSlcclxuICAgICAgfSxcclxuICAgICAgLy8gQ29tcG9uZW50VHJhbnNmZXIgZWZmZWN0XHJcbiAgICAgIGNvbXBvbmVudFRyYW5zZmVyOiBmdW5jdGlvbihjb21wb25lbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQ29tcG9uZW50VHJhbnNmZXJFZmZlY3QoY29tcG9uZW50cykpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIENvbXBvc2l0ZSBlZmZlY3RcclxuICAgICAgY29tcG9zaXRlOiBmdW5jdGlvbihpbjEsIGluMiwgb3BlcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Db21wb3NpdGVFZmZlY3QoaW4xLCBpbjIsIG9wZXJhdG9yKSlcclxuICAgICAgfSxcclxuICAgICAgLy8gRmxvb2QgZWZmZWN0XHJcbiAgICAgIGZsb29kOiBmdW5jdGlvbihjb2xvciwgb3BhY2l0eSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkZsb29kRWZmZWN0KGNvbG9yLCBvcGFjaXR5KSlcclxuICAgICAgfSxcclxuICAgICAgLy8gT2Zmc2V0IGVmZmVjdFxyXG4gICAgICBvZmZzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5PZmZzZXRFZmZlY3QoeCx5KSlcclxuICAgICAgfSxcclxuICAgICAgLy8gSW1hZ2UgZWZmZWN0XHJcbiAgICAgIGltYWdlOiBmdW5jdGlvbihzcmMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5JbWFnZUVmZmVjdChzcmMpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBNZXJnZSBlZmZlY3RcclxuICAgICAgbWVyZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vcGFzcyB0aGUgYXJyYXkgb2YgYXJndW1lbnRzIHRvIHRoZSBjb25zdHJ1Y3RvciBiZWNhdXNlIHdlIGRvbnQga25vdyBpZiB0aGUgdXNlciBnYXZlIHVzIGFuIGFycmF5IGFzIHRoZSBmaXJzdCBhcmd1ZW1udCBvciB3ZXRoZXIgdGhleSBsaXN0ZWQgdGhlIGVmZmVjdHMgaW4gdGhlIGFyZ3VtZW50c1xyXG4gICAgICAgIHZhciBhcmdzID0gW3VuZGVmaW5lZF07XHJcbiAgICAgICAgZm9yKHZhciBpIGluIGFyZ3VtZW50cykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyAoU1ZHLk1lcmdlRWZmZWN0LmJpbmQuYXBwbHkoU1ZHLk1lcmdlRWZmZWN0LGFyZ3MpKSlcclxuICAgICAgfSxcclxuICAgICAgLy8gR2F1c3NpYW4gQmx1ciBlZmZlY3RcclxuICAgICAgZ2F1c3NpYW5CbHVyOiBmdW5jdGlvbih4LHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5HYXVzc2lhbkJsdXJFZmZlY3QoeCx5KSlcclxuICAgICAgfSxcclxuICAgICAgLy8gTW9ycGhvbG9neSBlZmZlY3RcclxuICAgICAgbW9ycGhvbG9neTogZnVuY3Rpb24ob3BlcmF0b3IscmFkaXVzKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Nb3JwaG9sb2d5RWZmZWN0KG9wZXJhdG9yLHJhZGl1cykpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIERpZmZ1c2VMaWdodGluZyBlZmZlY3RcclxuICAgICAgZGlmZnVzZUxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkRpZmZ1c2VMaWdodGluZ0VmZmVjdChzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBEaXNwbGFjZW1lbnRNYXAgZWZmZWN0XHJcbiAgICAgIGRpc3BsYWNlbWVudE1hcDogZnVuY3Rpb24oaW4xLGluMixzY2FsZSx4Q2hhbm5lbFNlbGVjdG9yLHlDaGFubmVsU2VsZWN0b3Ipe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkRpc3BsYWNlbWVudE1hcEVmZmVjdChpbjEsaW4yLHNjYWxlLHhDaGFubmVsU2VsZWN0b3IseUNoYW5uZWxTZWxlY3RvcikpXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIFNwZWN1bGFyTGlnaHRpbmcgZWZmZWN0XHJcbiAgICAgIHNwZWN1bGFyTGlnaHRpbmc6IGZ1bmN0aW9uKHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxrZXJuZWxVbml0TGVuZ3RoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5TcGVjdWxhckxpZ2h0aW5nRWZmZWN0KHN1cmZhY2VTY2FsZSxkaWZmdXNlQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxrZXJuZWxVbml0TGVuZ3RoKSlcclxuICAgICAgfSxcclxuICAgICAgLy8gVGlsZSBlZmZlY3RcclxuICAgICAgdGlsZTogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5UaWxlRWZmZWN0KCkpO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyBUdXJidWxlbmNlIGVmZmVjdFxyXG4gICAgICB0dXJidWxlbmNlOiBmdW5jdGlvbihiYXNlRnJlcXVlbmN5LG51bU9jdGF2ZXMsc2VlZCxzdGl0Y2hUaWxlcyx0eXBlKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5UdXJidWxlbmNlRWZmZWN0KGJhc2VGcmVxdWVuY3ksbnVtT2N0YXZlcyxzZWVkLHN0aXRjaFRpbGVzLHR5cGUpKVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBEZWZhdWx0IHN0cmluZyB2YWx1ZVxyXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmF0dHIoJ2lkJykgKyAnKSdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvL2FkZCAuZmlsdGVyIGZ1bmN0aW9uXHJcbiAgU1ZHLmV4dGVuZChTVkcuRGVmcywge1xyXG4gICAgLy8gRGVmaW5lIGZpbHRlclxyXG4gICAgZmlsdGVyOiBmdW5jdGlvbihibG9jaykge1xyXG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5wdXQobmV3IFNWRy5GaWx0ZXIpO1xyXG5cclxuICAgICAgLyogaW52b2tlIHBhc3NlZCBibG9jayAqL1xyXG4gICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIGJsb2NrLmNhbGwoZmlsdGVyLCBmaWx0ZXIpO1xyXG5cclxuICAgICAgcmV0dXJuIGZpbHRlclxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFNWRy5leHRlbmQoU1ZHLkNvbnRhaW5lciwge1xyXG4gICAgLy8gRGVmaW5lIGZpbHRlciBvbiBkZWZzXHJcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKGJsb2NrKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5maWx0ZXIoYmxvY2spXHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwgU1ZHLkcsIFNWRy5OZXN0ZWQsIHtcclxuICAgIC8vIENyZWF0ZSBmaWx0ZXIgZWxlbWVudCBpbiBkZWZzIGFuZCBzdG9yZSByZWZlcmVuY2VcclxuICAgIGZpbHRlcjogZnVuY3Rpb24oYmxvY2spIHtcclxuICAgICAgdGhpcy5maWx0ZXJlciA9IGJsb2NrIGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQgP1xyXG4gICAgICAgIGJsb2NrIDogdGhpcy5kb2MoKS5maWx0ZXIoYmxvY2spO1xyXG5cclxuICAgICAgaWYodGhpcy5kb2MoKSAmJiB0aGlzLmZpbHRlcmVyLmRvYygpICE9PSB0aGlzLmRvYygpKXtcclxuICAgICAgICB0aGlzLmRvYygpLmRlZnMoKS5hZGQodGhpcy5maWx0ZXJlcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuYXR0cignZmlsdGVyJywgdGhpcy5maWx0ZXJlcik7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXJlclxyXG4gICAgfSxcclxuICAgIC8vIFJlbW92ZSBmaWx0ZXJcclxuICAgIHVuZmlsdGVyOiBmdW5jdGlvbihyZW1vdmUpIHtcclxuICAgICAgLyogYWxzbyByZW1vdmUgdGhlIGZpbHRlciBub2RlICovXHJcbiAgICAgIGlmICh0aGlzLmZpbHRlcmVyICYmIHJlbW92ZSA9PT0gdHJ1ZSlcclxuICAgICAgICB0aGlzLmZpbHRlcmVyLnJlbW92ZSgpO1xyXG5cclxuICAgICAgLyogZGVsZXRlIHJlZmVyZW5jZSB0byBmaWx0ZXJlciAqL1xyXG4gICAgICBkZWxldGUgdGhpcy5maWx0ZXJlcjtcclxuXHJcbiAgICAgIC8qIHJlbW92ZSBmaWx0ZXIgYXR0cmlidXRlICovXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2ZpbHRlcicsIG51bGwpXHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIENyZWF0ZSBTVkcuRWZmZWN0IGNsYXNzXHJcbiAgU1ZHLkVmZmVjdCA9IFNWRy5pbnZlbnQoe1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbigpe1xyXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XHJcbiAgICB9LFxyXG4gICAgaW5oZXJpdDogU1ZHLkVsZW1lbnQsXHJcbiAgICBleHRlbmQ6IHtcclxuICAgICAgLy8gU2V0IGluIGF0dHJpYnV0ZVxyXG4gICAgICBpbjogZnVuY3Rpb24oZWZmZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGVmZmVjdCA9PSBudWxsPyB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuc2VsZWN0KCdbcmVzdWx0PVwiJyt0aGlzLmF0dHIoJ2luJykrJ1wiXScpLmdldCgwKSB8fCB0aGlzLmF0dHIoJ2luJykgOiB0aGlzLmF0dHIoJ2luJywgZWZmZWN0KVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBOYW1lZCByZXN1bHRcclxuICAgICAgcmVzdWx0OiBmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0ID09IG51bGw/IHRoaXMuYXR0cigncmVzdWx0JykgOiB0aGlzLmF0dHIoJ3Jlc3VsdCcscmVzdWx0KVxyXG4gICAgICB9LFxyXG4gICAgICAvLyBTdHJpbmdpZmljYXRpb25cclxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gY3JlYXRlIGNsYXNzIGZvciBwYXJlbnQgZWZmZWN0cyBsaWtlIG1lcmdlXHJcbiAgLy8gSW5oZXJpdCBmcm9tIFNWRy5QYXJlbnRcclxuICBTVkcuUGFyZW50RWZmZWN0ID0gU1ZHLmludmVudCh7XHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcclxuICAgIH0sXHJcbiAgICBpbmhlcml0OiBTVkcuUGFyZW50LFxyXG4gICAgZXh0ZW5kOiB7XHJcbiAgICAgIC8vIFNldCBpbiBhdHRyaWJ1dGVcclxuICAgICAgaW46IGZ1bmN0aW9uKGVmZmVjdCkge1xyXG4gICAgICAgIHJldHVybiBlZmZlY3QgPT0gbnVsbD8gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLnNlbGVjdCgnW3Jlc3VsdD1cIicrdGhpcy5hdHRyKCdpbicpKydcIl0nKS5nZXQoMCkgfHwgdGhpcy5hdHRyKCdpbicpIDogdGhpcy5hdHRyKCdpbicsIGVmZmVjdClcclxuICAgICAgfSxcclxuICAgICAgLy8gTmFtZWQgcmVzdWx0XHJcbiAgICAgIHJlc3VsdDogZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsPyB0aGlzLmF0dHIoJ3Jlc3VsdCcpIDogdGhpcy5hdHRyKCdyZXN1bHQnLHJlc3VsdClcclxuICAgICAgfSxcclxuICAgICAgLy8gU3RyaW5naWZpY2F0aW9uXHJcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vY2hhaW5pbmdcclxuICB2YXIgY2hhaW5pbmdFZmZlY3RzID0ge1xyXG4gICAgLy8gQmxlbmQgZWZmZWN0XHJcbiAgICBibGVuZDogZnVuY3Rpb24oaW4yLCBtb2RlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuYmxlbmQodGhpcywgaW4yLCBtb2RlKSAvL3Bhc3MgdGhpcyBhcyB0aGUgZmlyc3QgaW5wdXRcclxuICAgIH0sXHJcbiAgICAvLyBDb2xvck1hdHJpeCBlZmZlY3RcclxuICAgIGNvbG9yTWF0cml4OiBmdW5jdGlvbih0eXBlLCB2YWx1ZXMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5jb2xvck1hdHJpeCh0eXBlLCB2YWx1ZXMpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gQ29udm9sdmVNYXRyaXggZWZmZWN0XHJcbiAgICBjb252b2x2ZU1hdHJpeDogZnVuY3Rpb24obWF0cml4KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuY29udm9sdmVNYXRyaXgobWF0cml4KS5pbih0aGlzKVxyXG4gICAgfSxcclxuICAgIC8vIENvbXBvbmVudFRyYW5zZmVyIGVmZmVjdFxyXG4gICAgY29tcG9uZW50VHJhbnNmZXI6IGZ1bmN0aW9uKGNvbXBvbmVudHMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5jb21wb25lbnRUcmFuc2Zlcihjb21wb25lbnRzKS5pbih0aGlzKVxyXG4gICAgfSxcclxuICAgIC8vIENvbXBvc2l0ZSBlZmZlY3RcclxuICAgIGNvbXBvc2l0ZTogZnVuY3Rpb24oaW4yLCBvcGVyYXRvcikge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmNvbXBvc2l0ZSh0aGlzLCBpbjIsIG9wZXJhdG9yKSAvL3Bhc3MgdGhpcyBhcyB0aGUgZmlyc3QgaW5wdXRcclxuICAgIH0sXHJcbiAgICAvLyBGbG9vZCBlZmZlY3RcclxuICAgIGZsb29kOiBmdW5jdGlvbihjb2xvciwgb3BhY2l0eSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmZsb29kKGNvbG9yLCBvcGFjaXR5KSAvL3RoaXMgZWZmZWN0IGRvbnQgaGF2ZSBpbnB1dHNcclxuICAgIH0sXHJcbiAgICAvLyBPZmZzZXQgZWZmZWN0XHJcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5vZmZzZXQoeCx5KS5pbih0aGlzKVxyXG4gICAgfSxcclxuICAgIC8vIEltYWdlIGVmZmVjdFxyXG4gICAgaW1hZ2U6IGZ1bmN0aW9uKHNyYykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmltYWdlKHNyYykgLy90aGlzIGVmZmVjdCBkb250IGhhdmUgaW5wdXRzXHJcbiAgICB9LFxyXG4gICAgLy8gTWVyZ2UgZWZmZWN0XHJcbiAgICBtZXJnZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkubWVyZ2UuYXBwbHkodGhpcy5wYXJlbnQoKSxbdGhpc10uY29uY2F0KGFyZ3VtZW50cykpIC8vcGFzcyB0aGlzIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxyXG4gICAgfSxcclxuICAgIC8vIEdhdXNzaWFuIEJsdXIgZWZmZWN0XHJcbiAgICBnYXVzc2lhbkJsdXI6IGZ1bmN0aW9uKHgseSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmdhdXNzaWFuQmx1cih4LHkpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gTW9ycGhvbG9neSBlZmZlY3RcclxuICAgIG1vcnBob2xvZ3k6IGZ1bmN0aW9uKG9wZXJhdG9yLHJhZGl1cyl7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkubW9ycGhvbG9neShvcGVyYXRvcixyYWRpdXMpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gRGlmZnVzZUxpZ2h0aW5nIGVmZmVjdFxyXG4gICAgZGlmZnVzZUxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLmRpZmZ1c2VMaWdodGluZyhzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gRGlzcGxhY2VtZW50TWFwIGVmZmVjdFxyXG4gICAgZGlzcGxhY2VtZW50TWFwOiBmdW5jdGlvbihpbjIsc2NhbGUseENoYW5uZWxTZWxlY3Rvcix5Q2hhbm5lbFNlbGVjdG9yKXtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5kaXNwbGFjZW1lbnRNYXAodGhpcyxpbjIsc2NhbGUseENoYW5uZWxTZWxlY3Rvcix5Q2hhbm5lbFNlbGVjdG9yKSAvL3Bhc3MgdGhpcyBhcyB0aGUgZmlyc3QgaW5wdXRcclxuICAgIH0sXHJcbiAgICAvLyBTcGVjdWxhckxpZ2h0aW5nIGVmZmVjdFxyXG4gICAgc3BlY3VsYXJMaWdodGluZzogZnVuY3Rpb24oc3VyZmFjZVNjYWxlLGRpZmZ1c2VDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLnNwZWN1bGFyTGlnaHRpbmcoc3VyZmFjZVNjYWxlLGRpZmZ1c2VDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LGtlcm5lbFVuaXRMZW5ndGgpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gVGlsZSBlZmZlY3RcclxuICAgIHRpbGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkudGlsZSgpLmluKHRoaXMpXHJcbiAgICB9LFxyXG4gICAgLy8gVHVyYnVsZW5jZSBlZmZlY3RcclxuICAgIHR1cmJ1bGVuY2U6IGZ1bmN0aW9uKGJhc2VGcmVxdWVuY3ksbnVtT2N0YXZlcyxzZWVkLHN0aXRjaFRpbGVzLHR5cGUpe1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLnR1cmJ1bGVuY2UoYmFzZUZyZXF1ZW5jeSxudW1PY3RhdmVzLHNlZWQsc3RpdGNoVGlsZXMsdHlwZSkuaW4odGhpcylcclxuICAgIH1cclxuICB9O1xyXG4gIFNWRy5leHRlbmQoU1ZHLkVmZmVjdCxjaGFpbmluZ0VmZmVjdHMpO1xyXG4gIFNWRy5leHRlbmQoU1ZHLlBhcmVudEVmZmVjdCxjaGFpbmluZ0VmZmVjdHMpO1xyXG5cclxuICAvL2NyZWEgY2xhc3MgZm9yIGNoaWxkIGVmZmVjdHMsIGxpa2UgTWVyZ2VOb2RlLCBGdW5jUiBhbmQgbGlnaHRzXHJcbiAgU1ZHLkNoaWxkRWZmZWN0ID0gU1ZHLmludmVudCh7XHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcclxuICAgIH0sXHJcbiAgICBpbmhlcml0OiBTVkcuRWxlbWVudCxcclxuICAgIGV4dGVuZDoge1xyXG4gICAgaW46IGZ1bmN0aW9uKGVmZmVjdCl7XHJcbiAgICAgIHRoaXMuYXR0cignaW4nLGVmZmVjdCk7XHJcbiAgICB9XHJcbiAgICAvL2RvbnQgaW5jbHVkZSBhbnkgXCJyZXN1bHRcIiBmdW5jdGlvbnMgYmVjYXVzZSB0aGVzZSB0eXBlcyBvZiBub2RlcyBkb250IGhhdmUgdGhlbVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBDcmVhdGUgYWxsIGRpZmZlcmVudCBlZmZlY3RzXHJcbiAgdmFyIGVmZmVjdHMgPSB7XHJcbiAgICBibGVuZDogZnVuY3Rpb24oaW4xLGluMixtb2RlKXtcclxuICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICBpbjogaW4xLFxyXG4gICAgICAgIGluMjogaW4yLFxyXG4gICAgICAgIG1vZGU6IG1vZGUgfHwgJ25vcm1hbCdcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY29sb3JNYXRyaXg6IGZ1bmN0aW9uKHR5cGUsdmFsdWVzKXtcclxuICAgICAgaWYgKHR5cGUgPT0gJ21hdHJpeCcpXHJcbiAgICAgICAgdmFsdWVzID0gbm9ybWFsaXNlTWF0cml4KHZhbHVlcyk7XHJcblxyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIHR5cGU6ICAgdHlwZVxyXG4gICAgICAsIHZhbHVlczogdHlwZW9mIHZhbHVlcyA9PSAndW5kZWZpbmVkJyA/IG51bGwgOiB2YWx1ZXNcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY29udm9sdmVNYXRyaXg6IGZ1bmN0aW9uKG1hdHJpeCl7XHJcbiAgICAgIG1hdHJpeCA9IG5vcm1hbGlzZU1hdHJpeChtYXRyaXgpO1xyXG5cclxuICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICBvcmRlcjogICAgICAgIE1hdGguc3FydChtYXRyaXguc3BsaXQoJyAnKS5sZW5ndGgpXHJcbiAgICAgICwga2VybmVsTWF0cml4OiBtYXRyaXhcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgY29tcG9zaXRlOiBmdW5jdGlvbihpbjEsIGluMiwgb3BlcmF0b3Ipe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIGluOiBpbjEsXHJcbiAgICAgICAgaW4yOiBpbjIsXHJcbiAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGZsb29kOiBmdW5jdGlvbihjb2xvcixvcGFjaXR5KXtcclxuICAgICAgdGhpcy5hdHRyKCdmbG9vZC1jb2xvcicsY29sb3IpO1xyXG4gICAgICBpZihvcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignZmxvb2Qtb3BhY2l0eScsb3BhY2l0eSk7XHJcbiAgICB9LFxyXG4gICAgb2Zmc2V0OiBmdW5jdGlvbih4LHkpe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIGR4OiB4LFxyXG4gICAgICAgIGR5OiB5XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGltYWdlOiBmdW5jdGlvbihzcmMpe1xyXG4gICAgICB0aGlzLmF0dHIoJ2hyZWYnLCBzcmMsIFNWRy54bGluayk7XHJcbiAgICB9LFxyXG4gICAgZGlzcGxhY2VtZW50TWFwOiBmdW5jdGlvbihpbjEsaW4yLHNjYWxlLHhDaGFubmVsU2VsZWN0b3IseUNoYW5uZWxTZWxlY3Rvcil7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgaW46IGluMSxcclxuICAgICAgICBpbjI6IGluMixcclxuICAgICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgICAgeENoYW5uZWxTZWxlY3RvcjogeENoYW5uZWxTZWxlY3RvcixcclxuICAgICAgICB5Q2hhbm5lbFNlbGVjdG9yOiB5Q2hhbm5lbFNlbGVjdG9yXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGdhdXNzaWFuQmx1cjogZnVuY3Rpb24oeCx5KXtcclxuICAgICAgaWYoeCAhPSBudWxsIHx8IHkgIT0gbnVsbClcclxuICAgICAgICB0aGlzLmF0dHIoJ3N0ZERldmlhdGlvbicsIGxpc3RTdHJpbmcoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5hdHRyKCdzdGREZXZpYXRpb24nLCAnMCAwJyk7XHJcbiAgICB9LFxyXG4gICAgbW9ycGhvbG9neTogZnVuY3Rpb24ob3BlcmF0b3IscmFkaXVzKXtcclxuICAgICAgdGhpcy5hdHRyKHtcclxuICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IsXHJcbiAgICAgICAgcmFkaXVzOiByYWRpdXNcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgdGlsZTogZnVuY3Rpb24oKXtcclxuXHJcbiAgICB9LFxyXG4gICAgdHVyYnVsZW5jZTogZnVuY3Rpb24oYmFzZUZyZXF1ZW5jeSxudW1PY3RhdmVzLHNlZWQsc3RpdGNoVGlsZXMsdHlwZSl7XHJcbiAgICAgIHRoaXMuYXR0cih7XHJcbiAgICAgICAgbnVtT2N0YXZlczogbnVtT2N0YXZlcyxcclxuICAgICAgICBzZWVkOiBzZWVkLFxyXG4gICAgICAgIHN0aXRjaFRpbGVzOiBzdGl0Y2hUaWxlcyxcclxuICAgICAgICBiYXNlRnJlcXVlbmN5OiBiYXNlRnJlcXVlbmN5LFxyXG4gICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gQ3JlYXRlIGFsbCBwYXJlbnQgZWZmZWN0c1xyXG4gIHZhciBwYXJlbnRFZmZlY3RzID0ge1xyXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHZhciBjaGlsZHJlbjtcclxuXHJcbiAgICAgIC8vdGVzdCB0byBzZWUgaWYgd2UgaGF2ZSBhIHNldFxyXG4gICAgICBpZihhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBTVkcuU2V0KXtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgYXJndW1lbnRzWzBdLmVhY2goZnVuY3Rpb24oaSl7XHJcbiAgICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgU1ZHLk1lcmdlTm9kZSlcclxuICAgICAgICAgICAgdGhhdC5wdXQodGhpcyk7XHJcbiAgICAgICAgICBlbHNlIGlmKHRoaXMgaW5zdGFuY2VvZiBTVkcuRWZmZWN0IHx8IHRoaXMgaW5zdGFuY2VvZiBTVkcuUGFyZW50RWZmZWN0KVxyXG4gICAgICAgICAgICB0aGF0LnB1dChuZXcgU1ZHLk1lcmdlTm9kZSh0aGlzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZXtcclxuICAgICAgICAvL2lmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBhcnJheSB1c2UgaXRcclxuICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpXHJcbiAgICAgICAgICBjaGlsZHJlbiA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBjaGlsZHJlbiA9IGFyZ3VtZW50cztcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgIGlmKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgU1ZHLk1lcmdlTm9kZSl7XHJcbiAgICAgICAgICAgIHRoaXMucHV0KGNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgdGhpcy5wdXQobmV3IFNWRy5NZXJnZU5vZGUoY2hpbGRyZW5baV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRUcmFuc2ZlcjogZnVuY3Rpb24oY29tcG9udGVudHMpe1xyXG4gICAgICAvKiBjcmVhdGUgcmdiIHNldCAqL1xyXG4gICAgICB0aGlzLnJnYiA9IG5ldyBTVkcuU2V0XHJcblxyXG4gICAgICAvKiBjcmVhdGUgY29tcG9uZW50cyAqL1xyXG4gICAgICA7KFsncicsICdnJywgJ2InLCAnYSddKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICAvKiBjcmVhdGUgY29tcG9uZW50ICovXHJcbiAgICAgICAgdGhpc1tjXSA9IG5ldyBTVkdbJ0Z1bmMnICsgYy50b1VwcGVyQ2FzZSgpXSgnaWRlbnRpdHknKTtcclxuXHJcbiAgICAgICAgLyogc3RvcmUgY29tcG9uZW50IGluIHNldCAqL1xyXG4gICAgICAgIHRoaXMucmdiLmFkZCh0aGlzW2NdKTtcclxuXHJcbiAgICAgICAgLyogYWRkIGNvbXBvbmVudCBub2RlICovXHJcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXNbY10ubm9kZSk7XHJcbiAgICAgIH0uYmluZCh0aGlzKSk7IC8vbG9zdCBjb250ZXh0IGluIGZvcmVhY2hcclxuXHJcbiAgICAgIC8qIHNldCBjb21wb25lbnRzICovXHJcbiAgICAgIGlmIChjb21wb250ZW50cykge1xyXG4gICAgICAgIGlmIChjb21wb250ZW50cy5yZ2IpIHtcclxuKFsncicsICdnJywgJ2InXSkuZm9yRWFjaChmdW5jdGlvbihjKSB7XHJcbiAgICAgICAgICAgIHRoaXNbY10uYXR0cihjb21wb250ZW50cy5yZ2IpO1xyXG4gICAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICBkZWxldGUgY29tcG9udGVudHMucmdiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogc2V0IGluZGl2aWR1YWwgY29tcG9uZW50cyAqL1xyXG4gICAgICAgIGZvciAodmFyIGMgaW4gY29tcG9udGVudHMpXHJcbiAgICAgICAgICB0aGlzW2NdLmF0dHIoY29tcG9udGVudHNbY10pO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGlmZnVzZUxpZ2h0aW5nOiBmdW5jdGlvbihzdXJmYWNlU2NhbGUsZGlmZnVzZUNvbnN0YW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIHN1cmZhY2VTY2FsZTogc3VyZmFjZVNjYWxlLFxyXG4gICAgICAgIGRpZmZ1c2VDb25zdGFudDogZGlmZnVzZUNvbnN0YW50LFxyXG4gICAgICAgIGtlcm5lbFVuaXRMZW5ndGg6IGtlcm5lbFVuaXRMZW5ndGhcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgc3BlY3VsYXJMaWdodGluZzogZnVuY3Rpb24oc3VyZmFjZVNjYWxlLGRpZmZ1c2VDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LGtlcm5lbFVuaXRMZW5ndGgpe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIHN1cmZhY2VTY2FsZTogc3VyZmFjZVNjYWxlLFxyXG4gICAgICAgIGRpZmZ1c2VDb25zdGFudDogZGlmZnVzZUNvbnN0YW50LFxyXG4gICAgICAgIHNwZWN1bGFyRXhwb25lbnQ6IHNwZWN1bGFyRXhwb25lbnQsXHJcbiAgICAgICAga2VybmVsVW5pdExlbmd0aDoga2VybmVsVW5pdExlbmd0aFxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gQ3JlYXRlIGNoaWxkIGVmZmVjdHMgbGlrZSBQb2ludExpZ2h0IGFuZCBNZXJnZU5vZGVcclxuICB2YXIgY2hpbGRFZmZlY3RzID0ge1xyXG4gICAgZGlzdGFudExpZ2h0OiBmdW5jdGlvbihhemltdXRoLCBlbGV2YXRpb24pe1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIGF6aW11dGg6IGF6aW11dGgsXHJcbiAgICAgICAgZWxldmF0aW9uOiBlbGV2YXRpb25cclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcG9pbnRMaWdodDogZnVuY3Rpb24oeCx5LHope1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIHg6IHgsXHJcbiAgICAgICAgeTogeSxcclxuICAgICAgICB6OiB6XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHNwb3RMaWdodDogZnVuY3Rpb24oeCx5LHoscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFope1xyXG4gICAgICB0aGlzLmF0dHIoe1xyXG4gICAgICAgIHg6IHgsXHJcbiAgICAgICAgeTogeSxcclxuICAgICAgICB6OiB6LFxyXG4gICAgICAgIHBvaW50c0F0WDogcG9pbnRzQXRYLFxyXG4gICAgICAgIHBvaW50c0F0WTogcG9pbnRzQXRZLFxyXG4gICAgICAgIHBvaW50c0F0WjogcG9pbnRzQXRaXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIG1lcmdlTm9kZTogZnVuY3Rpb24oaW4xKXtcclxuICAgICAgdGhpcy5hdHRyKCdpbicsaW4xKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSBjb21wb250ZW50IGZ1bmN0aW9uc1xyXG4gIDsoWydyJywgJ2cnLCAnYicsICdhJ10pLmZvckVhY2goZnVuY3Rpb24oYykge1xyXG4gICAgLyogY3JlYXRlIGNsYXNzICovXHJcbiAgICBjaGlsZEVmZmVjdHNbJ0Z1bmMnICsgYy50b1VwcGVyQ2FzZSgpXSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgdGhpcy5hdHRyKCd0eXBlJyx0eXBlKTtcclxuXHJcbiAgICAgIC8vIHRha2UgZGlmZmVudCBhcmd1bWVudHMgYmFzZWQgb24gdGhlIHR5cGVcclxuICAgICAgc3dpdGNoKHR5cGUpe1xyXG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcclxuICAgICAgICAgIHRoaXMuYXR0cigndGFibGVWYWx1ZXMnLGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ2xpbmVhcic6XHJcbiAgICAgICAgICB0aGlzLmF0dHIoJ3Nsb3BlJyxhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgdGhpcy5hdHRyKCdpbnRlcmNlcHQnLGFyZ3VtZW50c1syXSk7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ2dhbW1hJzpcclxuICAgICAgICAgIHRoaXMuYXR0cignYW1wbGl0dWRlJyxhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgdGhpcy5hdHRyKCdleHBvbmVudCcsYXJndW1lbnRzWzJdKTtcclxuICAgICAgICAgIHRoaXMuYXR0cignb2Zmc2V0Jyxhcmd1bWVudHNbMl0pO1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy9jcmVhdGUgZWZmZWN0c1xyXG4gIGZvcmVhY2goZWZmZWN0cyxmdW5jdGlvbihlZmZlY3QsaSl7XHJcblxyXG4gICAgLyogY2FwaXRhbGl6ZSBuYW1lICovXHJcbiAgICB2YXIgbmFtZSA9IGkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpLnNsaWNlKDEpO1xyXG4gICAgdmFyIHByb3RvID0ge307XHJcblxyXG4gICAgLyogY3JlYXRlIGNsYXNzICovXHJcbiAgICBTVkdbbmFtZSArICdFZmZlY3QnXSA9IFNWRy5pbnZlbnQoe1xyXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vY2FsbCBzdXBlclxyXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdmZScgKyBuYW1lKSk7XHJcblxyXG4gICAgICAgIC8vY2FsbCBjb25zdHJ1Y3RvciBmb3IgdGhpcyBlZmZlY3RcclxuICAgICAgICBlZmZlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAvL3NldCB0aGUgcmVzdWx0XHJcbiAgICAgICAgdGhpcy5yZXN1bHQodGhpcy5hdHRyKCdpZCcpICsgJ091dCcpO1xyXG4gICAgICB9LFxyXG4gICAgICBpbmhlcml0OiBTVkcuRWZmZWN0LFxyXG4gICAgICBleHRlbmQ6IHByb3RvXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgLy9jcmVhdGUgcGFyZW50IGVmZmVjdHNcclxuICBmb3JlYWNoKHBhcmVudEVmZmVjdHMsZnVuY3Rpb24oZWZmZWN0LGkpe1xyXG5cclxuICAgIC8qIGNhcGl0YWxpemUgbmFtZSAqL1xyXG4gICAgdmFyIG5hbWUgPSBpLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaS5zbGljZSgxKTtcclxuICAgIHZhciBwcm90byA9IHt9O1xyXG5cclxuICAgIC8qIGNyZWF0ZSBjbGFzcyAqL1xyXG4gICAgU1ZHW25hbWUgKyAnRWZmZWN0J10gPSBTVkcuaW52ZW50KHtcclxuICAgICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL2NhbGwgc3VwZXJcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnZmUnICsgbmFtZSkpO1xyXG5cclxuICAgICAgICAvL2NhbGwgY29uc3RydWN0b3IgZm9yIHRoaXMgZWZmZWN0XHJcbiAgICAgICAgZWZmZWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgLy9zZXQgdGhlIHJlc3VsdFxyXG4gICAgICAgIHRoaXMucmVzdWx0KHRoaXMuYXR0cignaWQnKSArICdPdXQnKTtcclxuICAgICAgfSxcclxuICAgICAgaW5oZXJpdDogU1ZHLlBhcmVudEVmZmVjdCxcclxuICAgICAgZXh0ZW5kOiBwcm90b1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIC8vY3JlYXRlIGNoaWxkIGVmZmVjdHNcclxuICBmb3JlYWNoKGNoaWxkRWZmZWN0cyxmdW5jdGlvbihlZmZlY3QsaSl7XHJcblxyXG4gICAgLyogY2FwaXRhbGl6ZSBuYW1lICovXHJcbiAgICB2YXIgbmFtZSA9IGkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpLnNsaWNlKDEpO1xyXG4gICAgdmFyIHByb3RvID0ge307XHJcblxyXG4gICAgLyogY3JlYXRlIGNsYXNzICovXHJcbiAgICBTVkdbbmFtZV0gPSBTVkcuaW52ZW50KHtcclxuICAgICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvL2NhbGwgc3VwZXJcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnZmUnICsgbmFtZSkpO1xyXG5cclxuICAgICAgICAvL2NhbGwgY29uc3RydWN0b3IgZm9yIHRoaXMgZWZmZWN0XHJcbiAgICAgICAgZWZmZWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcclxuICAgICAgfSxcclxuICAgICAgaW5oZXJpdDogU1ZHLkNoaWxkRWZmZWN0LFxyXG4gICAgICBleHRlbmQ6IHByb3RvXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgLy8gRWZmZWN0LXNwZWNpZmljIGV4dGVuc2lvbnNcclxuICBTVkcuZXh0ZW5kKFNWRy5NZXJnZUVmZmVjdCx7XHJcbiAgICBpbjogZnVuY3Rpb24oZWZmZWN0KXtcclxuICAgICAgaWYoZWZmZWN0IGluc3RhbmNlb2YgU1ZHLk1lcmdlTm9kZSlcclxuICAgICAgICB0aGlzLmFkZChlZmZlY3QsMCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmFkZChuZXcgU1ZHLk1lcmdlTm9kZShlZmZlY3QpLDApO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9KTtcclxuICBTVkcuZXh0ZW5kKFNWRy5Db21wb3NpdGVFZmZlY3QsU1ZHLkJsZW5kRWZmZWN0LFNWRy5EaXNwbGFjZW1lbnRNYXBFZmZlY3Qse1xyXG4gICAgaW4yOiBmdW5jdGlvbihlZmZlY3Qpe1xyXG4gICAgICAgIHJldHVybiBlZmZlY3QgPT0gbnVsbD8gdGhpcy5wYXJlbnQoKSAmJiB0aGlzLnBhcmVudCgpLnNlbGVjdCgnW3Jlc3VsdD1cIicrdGhpcy5hdHRyKCdpbjInKSsnXCJdJykuZ2V0KDApIHx8IHRoaXMuYXR0cignaW4yJykgOiB0aGlzLmF0dHIoJ2luMicsIGVmZmVjdClcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gUHJlc2V0c1xyXG4gIFNWRy5maWx0ZXIgPSB7XHJcbiAgICBzZXBpYXRvbmU6ICBbIC4zNDMsIC42NjksIC4xMTksIDAsIDBcclxuICAgICAgICAgICAgICAgICwgLjI0OSwgLjYyNiwgLjEzMCwgMCwgMFxyXG4gICAgICAgICAgICAgICAgLCAuMTcyLCAuMzM0LCAuMTExLCAwLCAwXHJcbiAgICAgICAgICAgICAgICAsIC4wMDAsIC4wMDAsIC4wMDAsIDEsIDAgXVxyXG4gIH07XHJcblxyXG4gIC8vIEhlbHBlcnNcclxuICBmdW5jdGlvbiBub3JtYWxpc2VNYXRyaXgobWF0cml4KSB7XHJcbiAgICAvKiBjb252ZXJ0IHBvc3NpYmxlIGFycmF5IHZhbHVlIHRvIHN0cmluZyAqL1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0cml4KSlcclxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5BcnJheShtYXRyaXgpO1xyXG5cclxuICAgIC8qIGVuc3VyZSB0aGVyZSBhcmUgbm8gbGVhZGluZywgdGFpbGluZyBvciBkb3VibGUgc3BhY2VzICovXHJcbiAgICByZXR1cm4gbWF0cml4LnRvU3RyaW5nKCkucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsaXN0U3RyaW5nKGxpc3QpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSlcclxuICAgICAgcmV0dXJuIGxpc3RcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoLCBzID0gW107IGkgPCBsOyBpKyspXHJcbiAgICAgIHMucHVzaChsaXN0W2ldKTtcclxuXHJcbiAgICByZXR1cm4gcy5qb2luKCcgJylcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZvcmVhY2goKXsgLy9sb29wcyB0aHJvdWdoIG11dGlwbGUgb2JqZWN0c1xyXG4gICAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xyXG4gICAgaWYodHlwZW9mIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdID09ICdmdW5jdGlvbicpe1xyXG4gICAgICBmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdO1xyXG4gICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLGFyZ3VtZW50cy5sZW5ndGgtMSwxKTtcclxuICAgIH1cclxuICAgIGZvcih2YXIgayBpbiBhcmd1bWVudHMpe1xyXG4gICAgICBmb3IodmFyIGkgaW4gYXJndW1lbnRzW2tdKXtcclxuICAgICAgICBmbihhcmd1bWVudHNba11baV0saSxhcmd1bWVudHNba10pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSkuY2FsbCh1bmRlZmluZWQpO1xuXG4oZnVuY3Rpb24oKSB7XHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5QYXRoQXJyYXksIHtcclxuICBtb3JwaDogZnVuY3Rpb24oYXJyYXkpIHtcclxuXHJcbiAgICB2YXIgc3RhcnRBcnIgPSB0aGlzLnZhbHVlXHJcbiAgICAgICwgIGRlc3RBcnIgPSB0aGlzLnBhcnNlKGFycmF5KTtcclxuXHJcbiAgICB2YXIgc3RhcnRPZmZzZXRNID0gMFxyXG4gICAgICAsICBkZXN0T2Zmc2V0TSA9IDA7XHJcblxyXG4gICAgdmFyIHN0YXJ0T2Zmc2V0TmV4dE0gPSBmYWxzZVxyXG4gICAgICAsICBkZXN0T2Zmc2V0TmV4dE0gPSBmYWxzZTtcclxuXHJcbiAgICB3aGlsZSh0cnVlKXtcclxuICAgICAgLy8gc3RvcCBpZiB0aGVyZSBpcyBubyBNIGFueW1vcmVcclxuICAgICAgaWYoc3RhcnRPZmZzZXRNID09PSBmYWxzZSAmJiBkZXN0T2Zmc2V0TSA9PT0gZmFsc2UpIGJyZWFrXHJcblxyXG4gICAgICAvLyBmaW5kIHRoZSBuZXh0IE0gaW4gcGF0aCBhcnJheVxyXG4gICAgICBzdGFydE9mZnNldE5leHRNID0gZmluZE5leHRNKHN0YXJ0QXJyLCBzdGFydE9mZnNldE0gPT09IGZhbHNlID8gZmFsc2UgOiBzdGFydE9mZnNldE0rMSk7XHJcbiAgICAgICBkZXN0T2Zmc2V0TmV4dE0gPSBmaW5kTmV4dE0oIGRlc3RBcnIsICBkZXN0T2Zmc2V0TSA9PT0gZmFsc2UgPyBmYWxzZSA6ICBkZXN0T2Zmc2V0TSsxKTtcclxuXHJcbiAgICAgIC8vIFdlIGhhdmUgdG8gYWRkIG9uZSBNIHRvIHRoZSBzdGFydEFycmF5XHJcbiAgICAgIGlmKHN0YXJ0T2Zmc2V0TSA9PT0gZmFsc2Upe1xyXG4gICAgICAgIHZhciBiYm94ID0gbmV3IFNWRy5QYXRoQXJyYXkocmVzdWx0LnN0YXJ0KS5iYm94KCk7XHJcblxyXG4gICAgICAgIC8vIHdoZW4gdGhlIGxhc3QgYmxvY2sgaGFkIG5vIGJvdW5kaW5nIGJveCB3ZSBzaW1wbHkgdGFrZSB0aGUgZmlyc3QgTSB3ZSBnb3RcclxuICAgICAgICBpZihiYm94LmhlaWdodCA9PSAwIHx8IGJib3gud2lkdGggPT0gMCl7XHJcbiAgICAgICAgICBzdGFydE9mZnNldE0gPSAgc3RhcnRBcnIucHVzaChzdGFydEFyclswXSkgLSAxO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgLy8gd2UgdGFrZSB0aGUgbWlkZGxlIG9mIHRoZSBiYm94IGluc3RlYWQgd2hlbiB3ZSBnb3Qgb25lXHJcbiAgICAgICAgICBzdGFydE9mZnNldE0gPSBzdGFydEFyci5wdXNoKCBbJ00nLCBiYm94LnggKyBiYm94LndpZHRoLzIsIGJib3gueSArIGJib3guaGVpZ2h0LzIgXSApIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdlIGhhdmUgdG8gYWRkIG9uZSBNIHRvIHRoZSBkZXN0QXJyYXlcclxuICAgICAgaWYoIGRlc3RPZmZzZXRNID09PSBmYWxzZSl7XHJcbiAgICAgICAgdmFyIGJib3ggPSBuZXcgU1ZHLlBhdGhBcnJheShyZXN1bHQuZGVzdCkuYmJveCgpO1xyXG5cclxuICAgICAgICBpZihiYm94LmhlaWdodCA9PSAwIHx8IGJib3gud2lkdGggPT0gMCl7XHJcbiAgICAgICAgICBkZXN0T2Zmc2V0TSA9ICBkZXN0QXJyLnB1c2goZGVzdEFyclswXSkgLSAxO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgZGVzdE9mZnNldE0gPSAgZGVzdEFyci5wdXNoKCBbJ00nLCBiYm94LnggKyBiYm94LndpZHRoLzIsIGJib3gueSArIGJib3guaGVpZ2h0LzIgXSApIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGhhbmRsZSBibG9jayBmcm9tIE0gdG8gbmV4dCBNXHJcbiAgICAgIHZhciByZXN1bHQgPSBoYW5kbGVCbG9jayhzdGFydEFyciwgc3RhcnRPZmZzZXRNLCBzdGFydE9mZnNldE5leHRNLCBkZXN0QXJyLCBkZXN0T2Zmc2V0TSwgZGVzdE9mZnNldE5leHRNKTtcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSB0aGUgYXJyYXlzIHRvIHRoZWlyIG5ldyB2YWx1ZXNcclxuICAgICAgc3RhcnRBcnIgPSBzdGFydEFyci5zbGljZSgwLCBzdGFydE9mZnNldE0pLmNvbmNhdChyZXN1bHQuc3RhcnQsIHN0YXJ0T2Zmc2V0TmV4dE0gPT09IGZhbHNlID8gW10gOiBzdGFydEFyci5zbGljZShzdGFydE9mZnNldE5leHRNKSk7XHJcbiAgICAgICBkZXN0QXJyID0gIGRlc3RBcnIuc2xpY2UoMCwgIGRlc3RPZmZzZXRNKS5jb25jYXQocmVzdWx0LmRlc3QgLCAgZGVzdE9mZnNldE5leHRNID09PSBmYWxzZSA/IFtdIDogIGRlc3RBcnIuc2xpY2UoIGRlc3RPZmZzZXROZXh0TSkpO1xyXG5cclxuICAgICAgLy8gdXBkYXRlIG9mZnNldHNcclxuICAgICAgc3RhcnRPZmZzZXRNID0gc3RhcnRPZmZzZXROZXh0TSA9PT0gZmFsc2UgPyBmYWxzZSA6IHN0YXJ0T2Zmc2V0TSArIHJlc3VsdC5zdGFydC5sZW5ndGg7XHJcbiAgICAgICBkZXN0T2Zmc2V0TSA9ICBkZXN0T2Zmc2V0TmV4dE0gPT09IGZhbHNlID8gZmFsc2UgOiAgZGVzdE9mZnNldE0gKyByZXN1bHQuZGVzdC5sZW5ndGg7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvcHkgYmFjayBhcnJheXNcclxuICAgIHRoaXMudmFsdWUgPSBzdGFydEFycjtcclxuICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU1ZHLlBhdGhBcnJheSgpO1xyXG4gICAgdGhpcy5kZXN0aW5hdGlvbi52YWx1ZSA9IGRlc3RBcnI7XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbn0pO1xyXG5cclxuXHJcblxyXG4vLyBzb3JyeSBmb3IgdGhlIGxvbmcgZGVjbGFyYXRpb25cclxuLy8gc2xpY2VzIG91dCBvbmUgYmxvY2sgKGZyb20gTSB0byBNKSBhbmQgc3luY3Jvbml6ZSBpdCBzbyB0aGUgdHlwZXMgYW5kIGxlbmd0aCBtYXRjaFxyXG5mdW5jdGlvbiBoYW5kbGVCbG9jayhzdGFydEFyciwgc3RhcnRPZmZzZXRNLCBzdGFydE9mZnNldE5leHRNLCBkZXN0QXJyLCBkZXN0T2Zmc2V0TSwgZGVzdE9mZnNldE5leHRNLCB1bmRlZmluZWQpe1xyXG5cclxuICAvLyBzbGljZSBvdXQgdGhlIGJsb2NrIHdlIG5lZWRcclxuICB2YXIgc3RhcnRBcnJUZW1wID0gc3RhcnRBcnIuc2xpY2Uoc3RhcnRPZmZzZXRNLCBzdGFydE9mZnNldE5leHRNIHx8IHVuZGVmaW5lZClcclxuICAgICwgIGRlc3RBcnJUZW1wID0gIGRlc3RBcnIuc2xpY2UoIGRlc3RPZmZzZXRNLCAgZGVzdE9mZnNldE5leHRNIHx8IHVuZGVmaW5lZCk7XHJcblxyXG4gIHZhciBpID0gMFxyXG4gICAgLCBwb3NTdGFydCA9IHtwb3M6WzAsMF0sIHN0YXJ0OlswLDBdfVxyXG4gICAgLCBwb3NEZXN0ICA9IHtwb3M6WzAsMF0sIHN0YXJ0OlswLDBdfTtcclxuXHJcbiAgZG97XHJcblxyXG4gICAgLy8gY29udmVydCBzaG9ydGhhbmQgdHlwZXMgdG8gbG9uZyBmb3JtXHJcbiAgICBzdGFydEFyclRlbXBbaV0gPSBzaW1wbHlmeS5jYWxsKHBvc1N0YXJ0LCBzdGFydEFyclRlbXBbaV0pO1xyXG4gICAgIGRlc3RBcnJUZW1wW2ldID0gc2ltcGx5ZnkuY2FsbChwb3NEZXN0ICwgIGRlc3RBcnJUZW1wW2ldKTtcclxuXHJcbiAgICAvLyBjaGVjayBpZiBib3RoIHNoYXBlIHR5cGVzIG1hdGNoXHJcbiAgICAvLyAyIGVsbGlwdGljYWwgYXJjIGN1cnZlIGNvbW1hbmRzICgnQScpLCBhcmUgY29uc2lkZXJlZCBkaWZmZXJlbnQgaWYgdGhlXHJcbiAgICAvLyBmbGFncyAobGFyZ2UtYXJjLWZsYWcsIHN3ZWVwLWZsYWcpIGRvbid0IG1hdGNoXHJcbiAgICBpZihzdGFydEFyclRlbXBbaV1bMF0gIT0gZGVzdEFyclRlbXBbaV1bMF0gfHwgc3RhcnRBcnJUZW1wW2ldWzBdID09ICdNJyB8fFxyXG4gICAgICAgIChzdGFydEFyclRlbXBbaV1bMF0gPT0gJ0EnICYmXHJcbiAgICAgICAgICAoc3RhcnRBcnJUZW1wW2ldWzRdICE9IGRlc3RBcnJUZW1wW2ldWzRdIHx8IHN0YXJ0QXJyVGVtcFtpXVs1XSAhPSBkZXN0QXJyVGVtcFtpXVs1XSlcclxuICAgICAgICApXHJcbiAgICAgICkge1xyXG5cclxuICAgICAgLy8gaWYgbm90LCBjb252ZXJ0IHNoYXBlcyB0byBiZXppZXJlXHJcbiAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoc3RhcnRBcnJUZW1wLCBbaSwgMV0uY29uY2F0KHRvQmV6aWVyZS5jYWxsKHBvc1N0YXJ0LCBzdGFydEFyclRlbXBbaV0pKSk7XHJcbiAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGRlc3RBcnJUZW1wLCBbaSwgMV0uY29uY2F0KHRvQmV6aWVyZS5jYWxsKHBvc0Rlc3QsIGRlc3RBcnJUZW1wW2ldKSkpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBvbmx5IHVwZGF0ZSBwb3NpdGlvbnMgb3RoZXJ3aXNlXHJcbiAgICAgIHN0YXJ0QXJyVGVtcFtpXSA9IHNldFBvc0FuZFJlZmxlY3Rpb24uY2FsbChwb3NTdGFydCwgc3RhcnRBcnJUZW1wW2ldKTtcclxuICAgICAgIGRlc3RBcnJUZW1wW2ldID0gc2V0UG9zQW5kUmVmbGVjdGlvbi5jYWxsKHBvc0Rlc3QgLCAgZGVzdEFyclRlbXBbaV0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyB3ZSBhcmUgYXQgdGhlIGVuZCBhdCBib3RoIGFycmF5cy4gc3RvcCBoZXJlXHJcbiAgICBpZigrK2kgPT0gc3RhcnRBcnJUZW1wLmxlbmd0aCAmJiBpID09IGRlc3RBcnJUZW1wLmxlbmd0aCkgYnJlYWtcclxuXHJcbiAgICAvLyBkZXN0QXJyYXkgaXMgbG9uZ2VyLiBBZGQgb25lIGVsZW1lbnRcclxuICAgIGlmKGkgPT0gc3RhcnRBcnJUZW1wLmxlbmd0aCl7XHJcbiAgICAgIHN0YXJ0QXJyVGVtcC5wdXNoKFtcclxuICAgICAgICAnQycsXHJcbiAgICAgICAgcG9zU3RhcnQucG9zWzBdLFxyXG4gICAgICAgIHBvc1N0YXJ0LnBvc1sxXSxcclxuICAgICAgICBwb3NTdGFydC5wb3NbMF0sXHJcbiAgICAgICAgcG9zU3RhcnQucG9zWzFdLFxyXG4gICAgICAgIHBvc1N0YXJ0LnBvc1swXSxcclxuICAgICAgICBwb3NTdGFydC5wb3NbMV0sXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0YXJ0QXJyIGlzIGxvbmdlci4gQWRkIG9uZSBlbGVtZW50XHJcbiAgICBpZihpID09IGRlc3RBcnJUZW1wLmxlbmd0aCl7XHJcbiAgICAgIGRlc3RBcnJUZW1wLnB1c2goW1xyXG4gICAgICAgICdDJyxcclxuICAgICAgICBwb3NEZXN0LnBvc1swXSxcclxuICAgICAgICBwb3NEZXN0LnBvc1sxXSxcclxuICAgICAgICBwb3NEZXN0LnBvc1swXSxcclxuICAgICAgICBwb3NEZXN0LnBvc1sxXSxcclxuICAgICAgICBwb3NEZXN0LnBvc1swXSxcclxuICAgICAgICBwb3NEZXN0LnBvc1sxXVxyXG4gICAgICBdKTtcclxuICAgIH1cclxuXHJcblxyXG4gIH13aGlsZSh0cnVlKVxyXG5cclxuICAvLyByZXR1cm4gdGhlIHVwZGF0ZWQgYmxvY2tcclxuICByZXR1cm4ge3N0YXJ0OnN0YXJ0QXJyVGVtcCwgZGVzdDpkZXN0QXJyVGVtcH1cclxufVxyXG5cclxuLy8gY29udmVydHMgc2hvcnRoYW5kIHR5cGVzIHRvIGxvbmcgZm9ybVxyXG5mdW5jdGlvbiBzaW1wbHlmeSh2YWwpe1xyXG5cclxuICBzd2l0Y2godmFsWzBdKXtcclxuICAgIGNhc2UgJ3onOiAvLyBzaG9ydGhhbmQgbGluZSB0byBzdGFydFxyXG4gICAgY2FzZSAnWic6XHJcbiAgICAgIHZhbFswXSA9ICdMJztcclxuICAgICAgdmFsWzFdID0gdGhpcy5zdGFydFswXTtcclxuICAgICAgdmFsWzJdID0gdGhpcy5zdGFydFsxXTtcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ0gnOiAvLyBzaG9ydGhhbmQgaG9yaXpvbnRhbCBsaW5lXHJcbiAgICAgIHZhbFswXSA9ICdMJztcclxuICAgICAgdmFsWzJdID0gdGhpcy5wb3NbMV07XHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlICdWJzogLy8gc2hvcnRoYW5kIHZlcnRpY2FsIGxpbmVcclxuICAgICAgdmFsWzBdID0gJ0wnO1xyXG4gICAgICB2YWxbMl0gPSB2YWxbMV07XHJcbiAgICAgIHZhbFsxXSA9IHRoaXMucG9zWzBdO1xyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnVCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWMgYmV6aWVyZVxyXG4gICAgICB2YWxbMF0gPSAnUSc7XHJcbiAgICAgIHZhbFszXSA9IHZhbFsxXTtcclxuICAgICAgdmFsWzRdID0gdmFsWzJdO1xyXG4gICAgICB2YWxbMV0gPSB0aGlzLnJlZmxlY3Rpb25bMV07XHJcbiAgICAgIHZhbFsyXSA9IHRoaXMucmVmbGVjdGlvblswXTtcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ1MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyZVxyXG4gICAgICB2YWxbMF0gPSAnQyc7XHJcbiAgICAgIHZhbFs2XSA9IHZhbFs0XTtcclxuICAgICAgdmFsWzVdID0gdmFsWzNdO1xyXG4gICAgICB2YWxbNF0gPSB2YWxbMl07XHJcbiAgICAgIHZhbFszXSA9IHZhbFsxXTtcclxuICAgICAgdmFsWzJdID0gdGhpcy5yZWZsZWN0aW9uWzFdO1xyXG4gICAgICB2YWxbMV0gPSB0aGlzLnJlZmxlY3Rpb25bMF07XHJcbiAgICAgIGJyZWFrXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdmFsXHJcblxyXG59XHJcblxyXG4vLyB1cGRhdGVzIHJlZmxlY3Rpb24gcG9pbnQgYW5kIGN1cnJlbnQgcG9zaXRpb25cclxuZnVuY3Rpb24gc2V0UG9zQW5kUmVmbGVjdGlvbih2YWwpe1xyXG5cclxuICB2YXIgbGVuID0gdmFsLmxlbmd0aDtcclxuXHJcbiAgdGhpcy5wb3MgPSBbIHZhbFtsZW4tMl0sIHZhbFtsZW4tMV0gXTtcclxuXHJcbiAgaWYoJ1NDUVQnLmluZGV4T2YodmFsWzBdKSAhPSAtMSlcclxuICAgIHRoaXMucmVmbGVjdGlvbiA9IFsgMiAqIHRoaXMucG9zWzBdIC0gdmFsW2xlbi00XSwgMiAqIHRoaXMucG9zWzFdIC0gdmFsW2xlbi0zXSBdO1xyXG5cclxuICByZXR1cm4gdmFsXHJcbn1cclxuXHJcbi8vIGNvbnZlcnRzIGFsbCB0eXBlcyB0byBjdWJpYyBiZXppZXJlXHJcbmZ1bmN0aW9uIHRvQmV6aWVyZSh2YWwpe1xyXG4gIHZhciByZXRWYWwgPSBbdmFsXTtcclxuXHJcbiAgc3dpdGNoKHZhbFswXSl7XHJcbiAgICBjYXNlICdNJzogLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgTVxyXG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSBbdmFsWzFdLCB2YWxbMl1dO1xyXG4gICAgICByZXR1cm4gcmV0VmFsXHJcbiAgICBjYXNlICdMJzpcclxuICAgICAgdmFsWzVdID0gdmFsWzNdID0gdmFsWzFdO1xyXG4gICAgICB2YWxbNl0gPSB2YWxbNF0gPSB2YWxbMl07XHJcbiAgICAgIHZhbFsxXSA9IHRoaXMucG9zWzBdO1xyXG4gICAgICB2YWxbMl0gPSB0aGlzLnBvc1sxXTtcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ1EnOlxyXG4gICAgICB2YWxbNl0gPSB2YWxbNF07XHJcbiAgICAgIHZhbFs1XSA9IHZhbFszXTtcclxuICAgICAgdmFsWzRdID0gdmFsWzRdICogMS8zICsgdmFsWzJdICogMi8zO1xyXG4gICAgICB2YWxbM10gPSB2YWxbM10gKiAxLzMgKyB2YWxbMV0gKiAyLzM7XHJcbiAgICAgIHZhbFsyXSA9IHRoaXMucG9zWzFdICogMS8zICsgdmFsWzJdICogMi8zO1xyXG4gICAgICB2YWxbMV0gPSB0aGlzLnBvc1swXSAqIDEvMyArIHZhbFsxXSAqIDIvMztcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ0EnOlxyXG4gICAgICByZXRWYWwgPSBhcmNUb0JlemllcmUodGhpcy5wb3MsIHZhbCk7XHJcbiAgICAgIHZhbCA9IHJldFZhbFswXTtcclxuICAgICAgYnJlYWtcclxuICB9XHJcblxyXG4gIHZhbFswXSA9ICdDJztcclxuICB0aGlzLnBvcyA9IFt2YWxbNV0sIHZhbFs2XV07XHJcbiAgdGhpcy5yZWZsZWN0aW9uID0gWzIgKiB2YWxbNV0gLSB2YWxbM10sIDIgKiB2YWxbNl0gLSB2YWxbNF1dO1xyXG5cclxuICByZXR1cm4gcmV0VmFsXHJcblxyXG59XHJcblxyXG4vLyBmaW5kcyB0aGUgbmV4dCBwb3NpdGlvbiBvZiB0eXBlIE1cclxuZnVuY3Rpb24gZmluZE5leHRNKGFyciwgb2Zmc2V0KXtcclxuXHJcbiAgaWYob2Zmc2V0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlXHJcblxyXG4gIGZvcih2YXIgaSA9IG9mZnNldCwgbGVuID0gYXJyLmxlbmd0aDtpIDwgbGVuOysraSl7XHJcblxyXG4gICAgaWYoYXJyW2ldWzBdID09ICdNJykgcmV0dXJuIGlcclxuXHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuXHJcblxyXG4vLyBDb252ZXJ0IGFuIGFyYyBzZWdtZW50IGludG8gZXF1aXZhbGVudCBjdWJpYyBCZXppZXIgY3VydmVzXHJcbi8vIERlcGVuZGluZyBvbiB0aGUgYXJjLCB1cCB0byA0IGN1cnZlcyBtaWdodCBiZSB1c2VkIHRvIHJlcHJlc2VudCBpdCBzaW5jZSBhXHJcbi8vIGN1cnZlIGdpdmVzIGEgZ29vZCBhcHByb3hpbWF0aW9uIGZvciBvbmx5IGEgcXVhcnRlciBvZiBhbiBlbGxpcHNlXHJcbi8vIFRoZSBjdXJ2ZXMgYXJlIHJldHVybmVkIGFzIGFuIGFycmF5IG9mIFNWRyBjdXJ2ZSBjb21tYW5kczpcclxuLy8gWyBbJ0MnLCB4MSwgeTEsIHgyLCB5MiwgeCwgeV0gLi4uIF1cclxuZnVuY3Rpb24gYXJjVG9CZXppZXJlKHBvcywgdmFsKSB7XHJcbiAgICAvLyBQYXJhbWV0ZXJzIGV4dHJhY3Rpb24sIGhhbmRsZSBvdXQtb2YtcmFuZ2UgcGFyYW1ldGVycyBhcyBzcGVjaWZpZWQgaW4gdGhlIFNWRyBzcGVjXHJcbiAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI0FyY091dE9mUmFuZ2VQYXJhbWV0ZXJzXHJcbiAgICB2YXIgcnggPSBNYXRoLmFicyh2YWxbMV0pLCByeSA9IE1hdGguYWJzKHZhbFsyXSksIHhBeGlzUm90YXRpb24gPSB2YWxbM10gJSAzNjBcclxuICAgICAgLCBsYXJnZUFyY0ZsYWcgPSB2YWxbNF0sIHN3ZWVwRmxhZyA9IHZhbFs1XSwgeCA9IHZhbFs2XSwgeSA9IHZhbFs3XVxyXG4gICAgICAsIEEgPSBuZXcgU1ZHLlBvaW50KHBvcyksIEIgPSBuZXcgU1ZHLlBvaW50KHgsIHkpXHJcbiAgICAgICwgcHJpbWVkQ29vcmQsIGxhbWJkYSwgbWF0LCBrLCBjLCBjU3F1YXJlLCB0LCBPLCBPQSwgT0IsIHRldGFTdGFydCwgdGV0YUVuZFxyXG4gICAgICAsIGRlbHRhVGV0YSwgbmJTZWN0b3JzLCBmLCBhcmNTZWdQb2ludHMsIGFuZ2xlLCBzaW5BbmdsZSwgY29zQW5nbGUsIHB0LCBpLCBpbFxyXG4gICAgICAsIHJldFZhbCA9IFtdLCB4MSwgeTEsIHgyLCB5MjtcclxuXHJcbiAgICAvLyBFbnN1cmUgcmFkaWkgYXJlIG5vbi16ZXJvXHJcbiAgICBpZihyeCA9PT0gMCB8fCByeSA9PT0gMCB8fCAoQS54ID09PSBCLnggJiYgQS55ID09PSBCLnkpKSB7XHJcbiAgICAgIC8vIHRyZWF0IHRoaXMgYXJjIGFzIGEgc3RyYWlnaHQgbGluZSBzZWdtZW50XHJcbiAgICAgIHJldHVybiBbWydDJywgQS54LCBBLnksIEIueCwgQi55LCBCLngsIEIueV1dXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRW5zdXJlIHJhZGlpIGFyZSBsYXJnZSBlbm91Z2ggdXNpbmcgdGhlIGFsZ29yaXRobSBwcm92aWRlZCBpbiB0aGUgU1ZHIHNwZWNcclxuICAgIC8vIFNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjQ29ycmVjdGlvbk91dE9mUmFuZ2VSYWRpaVxyXG4gICAgcHJpbWVkQ29vcmQgPSBuZXcgU1ZHLlBvaW50KChBLngtQi54KS8yLCAoQS55LUIueSkvMikudHJhbnNmb3JtKG5ldyBTVkcuTWF0cml4KCkucm90YXRlKHhBeGlzUm90YXRpb24pKTtcclxuICAgIGxhbWJkYSA9IChwcmltZWRDb29yZC54ICogcHJpbWVkQ29vcmQueCkgLyAocnggKiByeCkgKyAocHJpbWVkQ29vcmQueSAqIHByaW1lZENvb3JkLnkpIC8gKHJ5ICogcnkpO1xyXG4gICAgaWYobGFtYmRhID4gMSkge1xyXG4gICAgICBsYW1iZGEgPSBNYXRoLnNxcnQobGFtYmRhKTtcclxuICAgICAgcnggPSBsYW1iZGEqcng7XHJcbiAgICAgIHJ5ID0gbGFtYmRhKnJ5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRvIHNpbXBsaWZ5IGNhbGN1bGF0aW9ucywgd2UgbWFrZSB0aGUgYXJjIHBhcnQgb2YgYSB1bml0IGNpcmNsZSAocmF5b24gaXMgMSkgaW5zdGVhZCBvZiBhbiBlbGxpcHNlXHJcbiAgICBtYXQgPSBuZXcgU1ZHLk1hdHJpeCgpLnJvdGF0ZSh4QXhpc1JvdGF0aW9uKS5zY2FsZSgxL3J4LCAxL3J5KS5yb3RhdGUoLXhBeGlzUm90YXRpb24pO1xyXG4gICAgQSA9IEEudHJhbnNmb3JtKG1hdCk7XHJcbiAgICBCID0gQi50cmFuc2Zvcm0obWF0KTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRpc3RhbmNlIGJldHdlZW4gdGhlIGluaXRpYWwgYW5kIGZpbmFsIHBvaW50IG9mIHRoZSBhcmNcclxuICAgIGsgPSBbQi54LUEueCwgQi55LUEueV07XHJcblxyXG4gICAgLy8gRmluZCB0aGUgbGVuZ3RoIG9mIHRoZSBjaG9yZCBmb3JtZWQgYnkgQSBhbmQgQlxyXG4gICAgY1NxdWFyZSA9IGtbMF0qa1swXSArIGtbMV0qa1sxXTtcclxuICAgIGMgPSBNYXRoLnNxcnQoY1NxdWFyZSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSByYXRpb3Mgb2YgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRpc3RhbmNlIG9uIHRoZSBsZW5ndGggb2YgdGhlIGNob3JkXHJcbiAgICBrWzBdIC89IGM7XHJcbiAgICBrWzFdIC89IGM7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjaXJjbGUgY2VudGVyIGFuZCB0aGUgY2hvcmQgbWlkcG9pbnRcclxuICAgIC8vIHVzaW5nIHRoaXMgZm9ybXVsYTogdCA9IHNxcnQocl4yIC0gY14yIC8gNClcclxuICAgIC8vIHdoZXJlIHQgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNpcmxlIGNlbnRlciBhbmQgdGhlIGNob3JkIG1pZHBvaW50LFxyXG4gICAgLy8gICAgICAgciBpcyB0aGUgcmF5b24gb2YgdGhlIGNpcmNsZSBhbmQgYyBpcyB0aGUgY2hvcmQgbGVuZ3RoXHJcbiAgICAvLyBGcm9tOiBodHRwOi8vd3d3LmFqZGVzaWduZXIuY29tL3BocGNpcmNsZS9jaXJjbGVfc2VnbWVudF9jaG9yZF90LnBocFxyXG4gICAgLy8gQmVjYXVzZSBvZiB0aGUgaW1wcmVjaXNpb24gb2YgZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgY1NxdWFyZSBtaWdodCBlbmRcclxuICAgIC8vIHVwIGJlaW5nIHNsaWdodGx5IGFib3ZlIDQgd2hpY2ggd291bGQgcmVzdWx0IGluIGEgbmVnYXRpdmUgcmFkaWNhbmRcclxuICAgIC8vIFRvIHByZXZlbnQgdGhhdCwgYSB0ZXN0IGlzIG1hZGUgYmVmb3JlIGNvbXB1dGluZyB0aGUgc3F1YXJlIHJvb3RcclxuICAgIHQgPSAoY1NxdWFyZSA8IDQpID8gTWF0aC5zcXJ0KDEgLSBjU3F1YXJlLzQpIDogMDtcclxuXHJcbiAgICAvLyBGb3IgbW9zdCBzaXR1YXRpb25zLCB0aGVyZSBhcmUgYWN0dWFsbHkgdHdvIGRpZmZlcmVudCBlbGxpcHNlcyB0aGF0XHJcbiAgICAvLyBzYXRpc2Z5IHRoZSBjb25zdHJhaW50cyBpbXBvc2VkIGJ5IHRoZSBwb2ludHMgQSBhbmQgQiwgdGhlIHJhZGlpIHJ4IGFuZCByeSxcclxuICAgIC8vIGFuZCB0aGUgeEF4aXNSb3RhdGlvblxyXG4gICAgLy8gV2hlbiB0aGUgZmxhZ3MgbGFyZ2VBcmNGbGFnIGFuZCBzd2VlcEZsYWcgYXJlIGVxdWFsLCBpdCBtZWFucyB0aGF0IHRoZVxyXG4gICAgLy8gc2Vjb25kIGVsbGlwc2UgaXMgdXNlZCBhcyBhIHNvbHV0aW9uXHJcbiAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YUVsbGlwdGljYWxBcmNDb21tYW5kc1xyXG4gICAgaWYobGFyZ2VBcmNGbGFnID09PSBzd2VlcEZsYWcpIHtcclxuICAgICAgICB0ICo9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGZyb20gdGhlIG1pZHBvaW50IG9mIHRoZSBjaG9yZFxyXG4gICAgLy8gVGhpcyBpcyBkb25lIGJ5IG11bHRpcGx5aW5nIHRoZSByYXRpb3MgY2FsY3VsYXRlZCBwcmV2aW91c2x5IGJ5IHRoZSBkaXN0YW5jZSBiZXR3ZWVuXHJcbiAgICAvLyB0aGUgY2lyY2xlIGNlbnRlciBhbmQgdGhlIGNob3JkIG1pZHBvaW50IGFuZCB1c2luZyB0aGVzZSB2YWx1ZXMgdG8gZ28gZnJvbSB0aGUgbWlkcG9pbnRcclxuICAgIC8vIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gICAgLy8gVGhlIG5lZ2F0aXZlIG9mIHRoZSB2ZXJ0aWNhbCBkaXN0YW5jZSByYXRpbyBpcyB1c2VkIHRvIG1vZGlmeSB0aGUgeCBjb29yZGluYXRlIHdoaWxlXHJcbiAgICAvLyB0aGUgaG9yaXpvbnRhbCBkaXN0YW5jZSByYXRpbyBpcyB1c2VkIHRvIG1vZGlmeSB0aGUgeSBjb29yZGluYXRlXHJcbiAgICAvLyBUaGF0IGlzIGJlY2F1c2UgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGNob3JkIGFuZCBwZXJwZW5kaWN1bGFyXHJcbiAgICAvLyBsaW5lcyBhcmUgbmVnYXRpdmUgcmVjaXByb2NhbHNcclxuICAgIE8gPSBuZXcgU1ZHLlBvaW50KChCLngrQS54KS8yICsgdCota1sxXSwgKEIueStBLnkpLzIgKyB0KmtbMF0pO1xyXG4gICAgLy8gTW92ZSB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgYXQgdGhlIG9yaWdpblxyXG4gICAgT0EgPSBuZXcgU1ZHLlBvaW50KEEueC1PLngsIEEueS1PLnkpO1xyXG4gICAgT0IgPSBuZXcgU1ZHLlBvaW50KEIueC1PLngsIEIueS1PLnkpO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3RhcnQgYW5kIGVuZCBhbmdsZVxyXG4gICAgdGV0YVN0YXJ0ID0gTWF0aC5hY29zKE9BLngvTWF0aC5zcXJ0KE9BLngqT0EueCArIE9BLnkqT0EueSkpO1xyXG4gICAgaWYgKE9BLnkgPCAwKSB7XHJcbiAgICAgIHRldGFTdGFydCAqPSAtMTtcclxuICAgIH1cclxuICAgIHRldGFFbmQgPSBNYXRoLmFjb3MoT0IueC9NYXRoLnNxcnQoT0IueCpPQi54ICsgT0IueSpPQi55KSk7XHJcbiAgICBpZiAoT0IueSA8IDApIHtcclxuICAgICAgdGV0YUVuZCAqPSAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBzd2VlcC1mbGFnIGlzICcxJywgdGhlbiB0aGUgYXJjIHdpbGwgYmUgZHJhd24gaW4gYSBcInBvc2l0aXZlLWFuZ2xlXCIgZGlyZWN0aW9uLFxyXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIGVuZCBhbmdsZSBpcyBhYm92ZSB0aGUgc3RhcnQgYW5nbGVcclxuICAgIGlmIChzd2VlcEZsYWcgJiYgdGV0YVN0YXJ0ID4gdGV0YUVuZCkge1xyXG4gICAgICB0ZXRhRW5kICs9IDIqTWF0aC5QSTtcclxuICAgIH1cclxuICAgIC8vIElmIHN3ZWVwLWZsYWcgaXMgJzAnLCB0aGVuIHRoZSBhcmMgd2lsbCBiZSBkcmF3biBpbiBhIFwibmVnYXRpdmUtYW5nbGVcIiBkaXJlY3Rpb24sXHJcbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgZW5kIGFuZ2xlIGlzIGJlbG93IHRoZSBzdGFydCBhbmdsZVxyXG4gICAgaWYgKCFzd2VlcEZsYWcgJiYgdGV0YVN0YXJ0IDwgdGV0YUVuZCkge1xyXG4gICAgICB0ZXRhRW5kIC09IDIqTWF0aC5QSTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIHRoZSBudW1iZXIgb2YgQmV6aWVyIGN1cnZlcyB0aGF0IGFyZSByZXF1aXJlZCB0byByZXByZXNlbnQgdGhlIGFyY1xyXG4gICAgLy8gQSBjdWJpYyBCZXppZXIgY3VydmUgZ2l2ZXMgYSBnb29kIGVub3VnaCBhcHByb3hpbWF0aW9uIHdoZW4gcmVwcmVzZW50aW5nIGF0IG1vc3QgYSBxdWFydGVyIG9mIGEgY2lyY2xlXHJcbiAgICBuYlNlY3RvcnMgPSBNYXRoLmNlaWwoTWF0aC5hYnModGV0YVN0YXJ0LXRldGFFbmQpICogMi9NYXRoLlBJKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludHMgb2YgYWxsIHRoZSBCZXppZXIgY3VydmVzIHJlcXVpcmVkIHRvIHJlcHJlc2VudCB0aGUgYXJjXHJcbiAgICAvLyBGb3IgYW4gaW4tZGVwdGggZXhwbGFuYXRpb24gb2YgdGhpcyBwYXJ0IHNlZTogaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNjaXJjbGVzX2N1YmljXHJcbiAgICBhcmNTZWdQb2ludHMgPSBbXTtcclxuICAgIGFuZ2xlID0gdGV0YVN0YXJ0O1xyXG4gICAgZGVsdGFUZXRhID0gKHRldGFFbmQtdGV0YVN0YXJ0KS9uYlNlY3RvcnM7XHJcbiAgICBmID0gNCpNYXRoLnRhbihkZWx0YVRldGEvNCkvMztcclxuICAgIGZvciAoaSA9IDA7IGkgPD0gbmJTZWN0b3JzOyBpKyspIHsgLy8gVGhlIDw9IGlzIGJlY2F1c2UgYSBCZXppZXIgY3VydmUgaGF2ZSBhIHN0YXJ0IGFuZCBhIGVuZHBvaW50XHJcbiAgICAgIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHJcbiAgICAgIHB0ID0gbmV3IFNWRy5Qb2ludChPLngrY29zQW5nbGUsIE8ueStzaW5BbmdsZSk7XHJcbiAgICAgIGFyY1NlZ1BvaW50c1tpXSA9IFtuZXcgU1ZHLlBvaW50KHB0LngrZipzaW5BbmdsZSwgcHQueS1mKmNvc0FuZ2xlKSwgcHQsIG5ldyBTVkcuUG9pbnQocHQueC1mKnNpbkFuZ2xlLCBwdC55K2YqY29zQW5nbGUpXTtcclxuXHJcbiAgICAgIGFuZ2xlICs9IGRlbHRhVGV0YTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgb2YgdGhlIGZpcnN0IHNlZ21lbnQgcG9pbnQgYW5kIHJlbW92ZSB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb2YgdGhlIGxhc3Qgc2VnbWVudCBwb2ludFxyXG4gICAgLy8gVGhlc2UgdHdvIGNvbnRyb2wgcG9pbnRzIGFyZSBub3QgdXNlZCBpbiB0aGUgYXBwcm94aW1hdGlvbiBvZiB0aGUgYXJjLCB0aGF0IGlzIHdoeSB0aGV5IGFyZSByZW1vdmVkXHJcbiAgICBhcmNTZWdQb2ludHNbMF1bMF0gPSBhcmNTZWdQb2ludHNbMF1bMV0uY2xvbmUoKTtcclxuICAgIGFyY1NlZ1BvaW50c1thcmNTZWdQb2ludHMubGVuZ3RoLTFdWzJdID0gYXJjU2VnUG9pbnRzW2FyY1NlZ1BvaW50cy5sZW5ndGgtMV1bMV0uY2xvbmUoKTtcclxuXHJcbiAgICAvLyBSZXZlcnQgdGhlIHRyYW5zZm9ybWF0aW9uIHRoYXQgd2FzIGFwcGxpZWQgdG8gbWFrZSB0aGUgYXJjIHBhcnQgb2YgYSB1bml0IGNpcmNsZSBpbnN0ZWFkIG9mIGFuIGVsbGlwc2VcclxuICAgIG1hdCA9IG5ldyBTVkcuTWF0cml4KCkucm90YXRlKHhBeGlzUm90YXRpb24pLnNjYWxlKHJ4LCByeSkucm90YXRlKC14QXhpc1JvdGF0aW9uKTtcclxuICAgIGZvciAoaSA9IDAsIGlsID0gYXJjU2VnUG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcclxuICAgICAgYXJjU2VnUG9pbnRzW2ldWzBdID0gYXJjU2VnUG9pbnRzW2ldWzBdLnRyYW5zZm9ybShtYXQpO1xyXG4gICAgICBhcmNTZWdQb2ludHNbaV1bMV0gPSBhcmNTZWdQb2ludHNbaV1bMV0udHJhbnNmb3JtKG1hdCk7XHJcbiAgICAgIGFyY1NlZ1BvaW50c1tpXVsyXSA9IGFyY1NlZ1BvaW50c1tpXVsyXS50cmFuc2Zvcm0obWF0KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ29udmVydCB0aGUgc2VnbWVudHMgcG9pbnRzIHRvIFNWRyBjdXJ2ZSBjb21tYW5kc1xyXG4gICAgZm9yIChpID0gMSwgaWwgPSBhcmNTZWdQb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xyXG4gICAgICBwdCA9IGFyY1NlZ1BvaW50c1tpLTFdWzJdO1xyXG4gICAgICB4MSA9IHB0Lng7XHJcbiAgICAgIHkxID0gcHQueTtcclxuXHJcbiAgICAgIHB0ID0gYXJjU2VnUG9pbnRzW2ldWzBdO1xyXG4gICAgICB4MiA9IHB0Lng7XHJcbiAgICAgIHkyID0gcHQueTtcclxuXHJcbiAgICAgIHB0ID0gYXJjU2VnUG9pbnRzW2ldWzFdO1xyXG4gICAgICB4ID0gcHQueDtcclxuICAgICAgeSA9IHB0Lnk7XHJcblxyXG4gICAgICByZXRWYWwucHVzaChbJ0MnLCB4MSwgeTEsIHgyLCB5MiwgeCwgeV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXRWYWxcclxufVxyXG59KCkpO1xuXG4vKiEgc3ZnLmRyYWdnYWJsZS5qcyAtIHYyLjIuMSAtIDIwMTYtMDgtMjVcclxuKiBodHRwczovL2dpdGh1Yi5jb20vd291dC9zdmcuZHJhZ2dhYmxlLmpzXHJcbiogQ29weXJpZ2h0IChjKSAyMDE2IFdvdXQgRmllcmVuczsgTGljZW5zZWQgTUlUICovXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgLy8gY3JlYXRlcyBoYW5kbGVyLCBzYXZlcyBpdFxyXG4gIGZ1bmN0aW9uIERyYWdIYW5kbGVyKGVsKXtcclxuICAgIGVsLnJlbWVtYmVyKCdfZHJhZ2dhYmxlJywgdGhpcyk7XHJcbiAgICB0aGlzLmVsID0gZWw7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gU2V0cyBuZXcgcGFyYW1ldGVyLCBzdGFydHMgZHJhZ2dpbmdcclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQsIHZhbCl7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgdGhpcy5jb25zdHJhaW50ID0gY29uc3RyYWludDtcclxuICAgIHRoaXMudmFsdWUgPSB2YWw7XHJcbiAgICB0aGlzLmVsLm9uKCdtb3VzZWRvd24uZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5zdGFydChlKTsgfSk7XHJcbiAgICB0aGlzLmVsLm9uKCd0b3VjaHN0YXJ0LmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuc3RhcnQoZSk7IH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIHRyYW5zZm9ybXMgb25lIHBvaW50IGZyb20gc2NyZWVuIHRvIHVzZXIgY29vcmRzXHJcbiAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLnRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24oZXZlbnQsIG9mZnNldCl7XHJcbiAgICAgIGV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xyXG4gICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIHx8IGV2ZW50O1xyXG4gICAgICB0aGlzLnAueCA9IHRvdWNoZXMucGFnZVggLSAob2Zmc2V0IHx8IDApO1xyXG4gICAgICB0aGlzLnAueSA9IHRvdWNoZXMucGFnZVk7XHJcbiAgICAgIHJldHVybiB0aGlzLnAubWF0cml4VHJhbnNmb3JtKHRoaXMubSlcclxuICB9O1xyXG4gIFxyXG4gIC8vIGdldHMgZWxlbWVudHMgYm91bmRpbmcgYm94IHdpdGggc3BlY2lhbCBoYW5kbGluZyBvZiBncm91cHMsIG5lc3RlZCBhbmQgdXNlXHJcbiAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLmdldEJCb3ggPSBmdW5jdGlvbigpe1xyXG5cclxuICAgIHZhciBib3ggPSB0aGlzLmVsLmJib3goKTtcclxuXHJcbiAgICBpZih0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLk5lc3RlZCkgYm94ID0gdGhpcy5lbC5yYm94KCk7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLmVsIGluc3RhbmNlb2YgU1ZHLkcgfHwgdGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5Vc2UgfHwgdGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5OZXN0ZWQpIHtcclxuICAgICAgYm94LnggPSB0aGlzLmVsLngoKTtcclxuICAgICAgYm94LnkgPSB0aGlzLmVsLnkoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYm94XHJcbiAgfTtcclxuXHJcbiAgLy8gc3RhcnQgZHJhZ2dpbmdcclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihlKXtcclxuXHJcbiAgICAvLyBjaGVjayBmb3IgbGVmdCBidXR0b25cclxuICAgIGlmKGUudHlwZSA9PSAnY2xpY2snfHwgZS50eXBlID09ICdtb3VzZWRvd24nIHx8IGUudHlwZSA9PSAnbW91c2Vtb3ZlJyl7XHJcbiAgICAgIGlmKChlLndoaWNoIHx8IGUuYnV0dG9ucykgIT0gMSl7XHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAvLyBmaXJlIGJlZm9yZWRyYWcgZXZlbnRcclxuICAgIHRoaXMuZWwuZmlyZSgnYmVmb3JlZHJhZycsIHsgZXZlbnQ6IGUsIGhhbmRsZXI6IHRoaXMgfSk7XHJcblxyXG4gICAgLy8gc2VhcmNoIGZvciBwYXJlbnQgb24gdGhlIGZseSB0byBtYWtlIHN1cmUgd2UgY2FuIGNhbGxcclxuICAgIC8vIGRyYWdnYWJsZSgpIGV2ZW4gd2hlbiBlbGVtZW50IGlzIG5vdCBpbiB0aGUgZG9tIGN1cnJlbnRseVxyXG4gICAgdGhpcy5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLmVsLnBhcmVudChTVkcuTmVzdGVkKSB8fCB0aGlzLmVsLnBhcmVudChTVkcuRG9jKTtcclxuICAgIHRoaXMucCA9IHRoaXMucGFyZW50Lm5vZGUuY3JlYXRlU1ZHUG9pbnQoKTtcclxuXHJcbiAgICAvLyBzYXZlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcbiAgICB0aGlzLm0gPSB0aGlzLmVsLm5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpO1xyXG5cclxuICAgIHZhciBib3ggPSB0aGlzLmdldEJCb3goKTtcclxuICAgIFxyXG4gICAgdmFyIGFuY2hvck9mZnNldDtcclxuICAgIFxyXG4gICAgLy8gZml4IHRleHQtYW5jaG9yIGluIHRleHQtZWxlbWVudCAoIzM3KVxyXG4gICAgaWYodGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5UZXh0KXtcclxuICAgICAgYW5jaG9yT2Zmc2V0ID0gdGhpcy5lbC5ub2RlLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xyXG4gICAgICAgIFxyXG4gICAgICBzd2l0Y2godGhpcy5lbC5hdHRyKCd0ZXh0LWFuY2hvcicpKXtcclxuICAgICAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICAgICAgYW5jaG9yT2Zmc2V0IC89IDI7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgIGFuY2hvck9mZnNldCA9IDA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLnN0YXJ0UG9pbnRzID0ge1xyXG4gICAgICAvLyBXZSB0YWtlIGFic29sdXRlIGNvb3JkaW5hdGVzIHNpbmNlIHdlIGFyZSBqdXN0IHVzaW5nIGEgZGVsdGEgaGVyZVxyXG4gICAgICBwb2ludDogdGhpcy50cmFuc2Zvcm1Qb2ludChlLCBhbmNob3JPZmZzZXQpLFxyXG4gICAgICBib3g6ICAgYm94LFxyXG4gICAgICB0cmFuc2Zvcm06IHRoaXMuZWwudHJhbnNmb3JtKClcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIGFkZCBkcmFnIGFuZCBlbmQgZXZlbnRzIHRvIHdpbmRvd1xyXG4gICAgU1ZHLm9uKHdpbmRvdywgJ21vdXNlbW92ZS5kcmFnJywgZnVuY3Rpb24oZSl7IF90aGlzLmRyYWcoZSk7IH0pO1xyXG4gICAgU1ZHLm9uKHdpbmRvdywgJ3RvdWNobW92ZS5kcmFnJywgZnVuY3Rpb24oZSl7IF90aGlzLmRyYWcoZSk7IH0pO1xyXG4gICAgU1ZHLm9uKHdpbmRvdywgJ21vdXNldXAuZHJhZycsIGZ1bmN0aW9uKGUpeyBfdGhpcy5lbmQoZSk7IH0pO1xyXG4gICAgU1ZHLm9uKHdpbmRvdywgJ3RvdWNoZW5kLmRyYWcnLCBmdW5jdGlvbihlKXsgX3RoaXMuZW5kKGUpOyB9KTtcclxuXHJcbiAgICAvLyBmaXJlIGRyYWdzdGFydCBldmVudFxyXG4gICAgdGhpcy5lbC5maXJlKCdkcmFnc3RhcnQnLCB7ZXZlbnQ6IGUsIHA6IHRoaXMuc3RhcnRQb2ludHMucG9pbnQsIG06IHRoaXMubSwgaGFuZGxlcjogdGhpc30pO1xyXG5cclxuICAgIC8vIHByZXZlbnQgYnJvd3NlciBkcmFnIGJlaGF2aW9yXHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgLy8gcHJldmVudCBwcm9wYWdhdGlvbiB0byBhIHBhcmVudCB0aGF0IG1pZ2h0IGFsc28gaGF2ZSBkcmFnZ2luZyBlbmFibGVkXHJcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIH07XHJcblxyXG4gIC8vIHdoaWxlIGRyYWdnaW5nXHJcbiAgRHJhZ0hhbmRsZXIucHJvdG90eXBlLmRyYWcgPSBmdW5jdGlvbihlKXtcclxuXHJcbiAgICB2YXIgYm94ID0gdGhpcy5nZXRCQm94KClcclxuICAgICAgLCBwICAgPSB0aGlzLnRyYW5zZm9ybVBvaW50KGUpXHJcbiAgICAgICwgeCAgID0gdGhpcy5zdGFydFBvaW50cy5ib3gueCArIHAueCAtIHRoaXMuc3RhcnRQb2ludHMucG9pbnQueFxyXG4gICAgICAsIHkgICA9IHRoaXMuc3RhcnRQb2ludHMuYm94LnkgKyBwLnkgLSB0aGlzLnN0YXJ0UG9pbnRzLnBvaW50LnlcclxuICAgICAgLCBjICAgPSB0aGlzLmNvbnN0cmFpbnRcclxuICAgICAgLCBneCAgPSBwLnggLSB0aGlzLnN0YXJ0UG9pbnRzLnBvaW50LnhcclxuICAgICAgLCBneSAgPSBwLnkgLSB0aGlzLnN0YXJ0UG9pbnRzLnBvaW50Lnk7XHJcbiAgICAgIFxyXG4gICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdkcmFnbW92ZScsIHtcclxuICAgICAgICBkZXRhaWw6IHtcclxuICAgICAgICAgICAgZXZlbnQ6IGVcclxuICAgICAgICAgICwgcDogcFxyXG4gICAgICAgICAgLCBtOiB0aGlzLm1cclxuICAgICAgICAgICwgaGFuZGxlcjogdGhpc1xyXG4gICAgICAgIH1cclxuICAgICAgLCBjYW5jZWxhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgICAgXHJcbiAgICB0aGlzLmVsLmZpcmUoZXZlbnQpO1xyXG4gICAgXHJcbiAgICBpZihldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm4gcFxyXG5cclxuICAgIC8vIG1vdmUgdGhlIGVsZW1lbnQgdG8gaXRzIG5ldyBwb3NpdGlvbiwgaWYgcG9zc2libGUgYnkgY29uc3RyYWludFxyXG4gICAgaWYgKHR5cGVvZiBjID09ICdmdW5jdGlvbicpIHtcclxuXHJcbiAgICAgIHZhciBjb29yZCA9IGMuY2FsbCh0aGlzLmVsLCB4LCB5LCB0aGlzLm0pO1xyXG5cclxuICAgICAgLy8gYm9vbCwganVzdCBzaG93IHVzIGlmIG1vdmVtZW50IGlzIGFsbG93ZWQgb3Igbm90XHJcbiAgICAgIGlmICh0eXBlb2YgY29vcmQgPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgY29vcmQgPSB7XHJcbiAgICAgICAgICB4OiBjb29yZCxcclxuICAgICAgICAgIHk6IGNvb3JkXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgdHJ1ZSwgd2UganVzdCBtb3ZlLiBJZiAhZmFsc2UgaXRzIGEgbnVtYmVyIGFuZCB3ZSBtb3ZlIGl0IHRoZXJlXHJcbiAgICAgIGlmIChjb29yZC54ID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5lbC54KHgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvb3JkLnggIT09IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5lbC54KGNvb3JkLngpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29vcmQueSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuZWwueSh5KTtcclxuICAgICAgfSBlbHNlIGlmIChjb29yZC55ICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuZWwueShjb29yZC55KTtcclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGMgPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgIC8vIGtlZXAgZWxlbWVudCB3aXRoaW4gY29uc3RyYWluZWQgYm94XHJcbiAgICAgIGlmIChjLm1pblggIT0gbnVsbCAmJiB4IDwgYy5taW5YKVxyXG4gICAgICAgIHggPSBjLm1pblg7XHJcbiAgICAgIGVsc2UgaWYgKGMubWF4WCAhPSBudWxsICYmIHggPiBjLm1heFggLSBib3gud2lkdGgpe1xyXG4gICAgICAgIHggPSBjLm1heFggLSBib3gud2lkdGg7XHJcbiAgICAgIH1pZiAoYy5taW5ZICE9IG51bGwgJiYgeSA8IGMubWluWSlcclxuICAgICAgICB5ID0gYy5taW5ZO1xyXG4gICAgICBlbHNlIGlmIChjLm1heFkgIT0gbnVsbCAmJiB5ID4gYy5tYXhZIC0gYm94LmhlaWdodClcclxuICAgICAgICB5ID0gYy5tYXhZIC0gYm94LmhlaWdodDtcclxuICAgICAgICBcclxuICAgICAgaWYodGhpcy5lbCBpbnN0YW5jZW9mIFNWRy5HKVxyXG4gICAgICAgIHRoaXMuZWwubWF0cml4KHRoaXMuc3RhcnRQb2ludHMudHJhbnNmb3JtKS50cmFuc2Zvcm0oe3g6Z3gsIHk6IGd5fSwgdHJ1ZSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLmVsLm1vdmUoeCwgeSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIHNvIHdlIGNhbiB1c2UgaXQgaW4gdGhlIGVuZC1tZXRob2QsIHRvb1xyXG4gICAgcmV0dXJuIHBcclxuICB9O1xyXG5cclxuICBEcmFnSGFuZGxlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZSl7XHJcblxyXG4gICAgLy8gZmluYWwgZHJhZ1xyXG4gICAgdmFyIHAgPSB0aGlzLmRyYWcoZSk7XHJcblxyXG4gICAgLy8gZmlyZSBkcmFnZW5kIGV2ZW50XHJcbiAgICB0aGlzLmVsLmZpcmUoJ2RyYWdlbmQnLCB7IGV2ZW50OiBlLCBwOiBwLCBtOiB0aGlzLm0sIGhhbmRsZXI6IHRoaXMgfSk7XHJcblxyXG4gICAgLy8gdW5iaW5kIGV2ZW50c1xyXG4gICAgU1ZHLm9mZih3aW5kb3csICdtb3VzZW1vdmUuZHJhZycpO1xyXG4gICAgU1ZHLm9mZih3aW5kb3csICd0b3VjaG1vdmUuZHJhZycpO1xyXG4gICAgU1ZHLm9mZih3aW5kb3csICdtb3VzZXVwLmRyYWcnKTtcclxuICAgIFNWRy5vZmYod2luZG93LCAndG91Y2hlbmQuZHJhZycpO1xyXG5cclxuICB9O1xyXG5cclxuICBTVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgICAvLyBNYWtlIGVsZW1lbnQgZHJhZ2dhYmxlXHJcbiAgICAvLyBDb25zdHJhaW50IG1pZ2h0IGJlIGFuIG9iamVjdCAoYXMgZGVzY3JpYmVkIGluIHJlYWRtZS5tZCkgb3IgYSBmdW5jdGlvbiBpbiB0aGUgZm9ybSBcImZ1bmN0aW9uICh4LCB5KVwiIHRoYXQgZ2V0cyBjYWxsZWQgYmVmb3JlIGV2ZXJ5IG1vdmUuXHJcbiAgICAvLyBUaGUgZnVuY3Rpb24gY2FuIHJldHVybiBhIGJvb2xlYW4gb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtIHt4LCB5fSwgdG8gd2hpY2ggdGhlIGVsZW1lbnQgd2lsbCBiZSBtb3ZlZC4gXCJGYWxzZVwiIHNraXBzIG1vdmluZywgdHJ1ZSBtb3ZlcyB0byByYXcgeCwgeS5cclxuICAgIGRyYWdnYWJsZTogZnVuY3Rpb24odmFsdWUsIGNvbnN0cmFpbnQpIHtcclxuXHJcbiAgICAgIC8vIENoZWNrIHRoZSBwYXJhbWV0ZXJzIGFuZCByZWFzc2lnbiBpZiBuZWVkZWRcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNvbnN0cmFpbnQgPSB2YWx1ZTtcclxuICAgICAgICB2YWx1ZSA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBkcmFnSGFuZGxlciA9IHRoaXMucmVtZW1iZXIoJ19kcmFnZ2FibGUnKSB8fCBuZXcgRHJhZ0hhbmRsZXIodGhpcyk7XHJcblxyXG4gICAgICAvLyBXaGVuIG5vIHBhcmFtZXRlciBpcyBnaXZlbiwgdmFsdWUgaXMgdHJ1ZVxyXG4gICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogdmFsdWU7XHJcblxyXG4gICAgICBpZih2YWx1ZSkgZHJhZ0hhbmRsZXIuaW5pdChjb25zdHJhaW50IHx8IHt9LCB2YWx1ZSk7XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZWRvd24uZHJhZycpO1xyXG4gICAgICAgIHRoaXMub2ZmKCd0b3VjaHN0YXJ0LmRyYWcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG59KS5jYWxsKHVuZGVmaW5lZCk7XG5cbihmdW5jdGlvbigpIHtcblxuZnVuY3Rpb24gU2VsZWN0SGFuZGxlcihlbCkge1xyXG5cclxuICAgIHRoaXMuZWwgPSBlbDtcclxuICAgIGVsLnJlbWVtYmVyKCdfc2VsZWN0SGFuZGxlcicsIHRoaXMpO1xyXG4gICAgdGhpcy5wb2ludFNlbGVjdGlvbiA9IHtpc1NlbGVjdGVkOiBmYWxzZX07XHJcbiAgICB0aGlzLnJlY3RTZWxlY3Rpb24gPSB7aXNTZWxlY3RlZDogZmFsc2V9O1xyXG5cclxufVxyXG5cclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG5cclxuICAgIHZhciBiYm94ID0gdGhpcy5lbC5iYm94KCk7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICAvLyBNZXJnaW5nIHRoZSBkZWZhdWx0cyBhbmQgdGhlIG9wdGlvbnMtb2JqZWN0IHRvZ2V0aGVyXHJcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuZWwuc2VsZWN0aXplLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zW2ldID0gdGhpcy5lbC5zZWxlY3RpemUuZGVmYXVsdHNbaV07XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBhcmVudCA9IHRoaXMuZWwucGFyZW50KCk7XHJcbiAgICB0aGlzLm5lc3RlZCA9ICh0aGlzLm5lc3RlZCB8fCB0aGlzLnBhcmVudC5ncm91cCgpKTtcclxuICAgIHRoaXMubmVzdGVkLm1hdHJpeChuZXcgU1ZHLk1hdHJpeCh0aGlzLmVsKS50cmFuc2xhdGUoYmJveC54LCBiYm94LnkpKTtcclxuXHJcbiAgICAvLyBXaGVuIGRlZXBTZWxlY3QgaXMgZW5hYmxlZCBhbmQgdGhlIGVsZW1lbnQgaXMgYSBsaW5lL3BvbHlsaW5lL3BvbHlnb24sIGRyYXcgb25seSBwb2ludHMgZm9yIG1vdmluZ1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwU2VsZWN0ICYmIFsnbGluZScsICdwb2x5bGluZScsICdwb2x5Z29uJ10uaW5kZXhPZih0aGlzLmVsLnR5cGUpICE9PSAtMSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0UG9pbnRzKHZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RSZWN0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9ic2VydmUoKTtcclxuICAgIHRoaXMuY2xlYW51cCgpO1xyXG5cclxufTtcclxuXHJcblNlbGVjdEhhbmRsZXIucHJvdG90eXBlLnNlbGVjdFBvaW50cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgIHRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCA9IHZhbHVlO1xyXG5cclxuICAgIC8vIFdoZW4gc2V0IGlzIGFscmVhZHkgdGhlcmUgd2UgZG9udCBoYXZlIHRvIGNyZWF0ZSBvbmVcclxuICAgIGlmICh0aGlzLnBvaW50U2VsZWN0aW9uLnNldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBvdXIgc2V0IG9mIGVsZW1lbnRzXHJcbiAgICB0aGlzLnBvaW50U2VsZWN0aW9uLnNldCA9IHRoaXMucGFyZW50LnNldCgpO1xyXG4gICAgLy8gZHJhdyB0aGUgY2lyY2xlcyBhbmQgbWFyayB0aGUgZWxlbWVudCBhcyBzZWxlY3RlZFxyXG4gICAgdGhpcy5kcmF3Q2lyY2xlcygpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcbi8vIGNyZWF0ZSB0aGUgcG9pbnQtYXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIDIgcG9pbnRzIG9mIGEgbGluZSBvciBzaW1wbHkgdGhlIHBvaW50cy1hcnJheSBvZiBwb2x5bGluZS9wb2x5Z29uXHJcblNlbGVjdEhhbmRsZXIucHJvdG90eXBlLmdldFBvaW50QXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmJveCA9IHRoaXMuZWwuYmJveCgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmVsLmFycmF5KCkudmFsdWVPZigpLm1hcChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICByZXR1cm4gW2VsWzBdIC0gYmJveC54LCBlbFsxXSAtIGJib3gueV07XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8vIFRoZSBmdW5jdGlvbiB0byBkcmF3IHRoZSBjaXJjbGVzXHJcblNlbGVjdEhhbmRsZXIucHJvdG90eXBlLmRyYXdDaXJjbGVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXMsIGFycmF5ID0gdGhpcy5nZXRQb2ludEFycmF5KCk7XHJcblxyXG4gICAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgb2YgcG9pbnRzXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuXHJcbiAgICAgICAgdmFyIGN1cnJpZWRFdmVudCA9IChmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBldiA9IGV2IHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0ID8gZXYucHJldmVudERlZmF1bHQoKSA6IGV2LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGV2LnBhZ2VYIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGV2LnBhZ2VZIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5lbC5maXJlKCdwb2ludCcsIHt4OiB4LCB5OiB5LCBpOiBrLCBldmVudDogZXZ9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KShpKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGV2ZXJ5IHBvaW50IHRvIHRoZSBzZXRcclxuICAgICAgICB0aGlzLnBvaW50U2VsZWN0aW9uLnNldC5hZGQoXHJcbiAgICAgICAgICAgIC8vIGEgY2lyY2xlIHdpdGggb3VyIGNzcy1jbGFzc2VzIGFuZCBhIHRvdWNoc3RhcnQtZXZlbnQgd2hpY2ggZmlyZXMgb3VyIGV2ZW50IGZvciBtb3ZpbmcgcG9pbnRzXHJcbiAgICAgICAgICAgIHRoaXMubmVzdGVkLmNpcmNsZSh0aGlzLm9wdGlvbnMucmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgLmNlbnRlcihhcnJheVtpXVswXSwgYXJyYXlbaV1bMV0pXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfcG9pbnQnKVxyXG4gICAgICAgICAgICAgICAgLm9uKCd0b3VjaHN0YXJ0JywgY3VycmllZEV2ZW50KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBjdXJyaWVkRXZlbnQpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vLyBldmVyeSB0aW1lIGEgY2lyY2xlIGlzIG1vdmVkLCB3ZSBoYXZlIHRvIHVwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIG91ciBjaXJjbGVcclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUudXBkYXRlUG9pbnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmdldFBvaW50QXJyYXkoKTtcclxuXHJcbiAgICB0aGlzLnBvaW50U2VsZWN0aW9uLnNldC5lYWNoKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3goKSA9PT0gYXJyYXlbaV1bMF0gJiYgdGhpcy5jeSgpID09PSBhcnJheVtpXVsxXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2VudGVyKGFycmF5W2ldWzBdLCBhcnJheVtpXVsxXSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblNlbGVjdEhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZVJlY3RTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmJveCA9IHRoaXMuZWwuYmJveCgpO1xyXG5cclxuICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDApLmF0dHIoe1xyXG4gICAgICAgIHdpZHRoOiBiYm94LndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogYmJveC5oZWlnaHRcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHNldC5nZXQoMSkgaXMgYWx3YXlzIGluIHRoZSB1cHBlciBsZWZ0IGNvcm5lci4gbm8gbmVlZCB0byBtb3ZlIGl0XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnBvaW50cykge1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDIpLmNlbnRlcihiYm94LndpZHRoLCAwKTtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCgzKS5jZW50ZXIoYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDQpLmNlbnRlcigwLCBiYm94LmhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuZ2V0KDUpLmNlbnRlcihiYm94LndpZHRoIC8gMiwgMCk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoNikuY2VudGVyKGJib3gud2lkdGgsIGJib3guaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoNykuY2VudGVyKGJib3gud2lkdGggLyAyLCBiYm94LmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoOCkuY2VudGVyKDAsIGJib3guaGVpZ2h0IC8gMik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yb3RhdGlvblBvaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb2ludHMpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoOSkuY2VudGVyKGJib3gud2lkdGggLyAyLCAyMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoMSkuY2VudGVyKGJib3gud2lkdGggLyAyLCAyMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuc2VsZWN0UmVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHRoaXMsIGJib3ggPSB0aGlzLmVsLmJib3goKTtcclxuXHJcbiAgICB0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCA9IHZhbHVlO1xyXG5cclxuICAgIC8vIHdoZW4gc2V0IGlzIGFscmVhZHkgcFxyXG4gICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldCA9IHRoaXMucmVjdFNlbGVjdGlvbi5zZXQgfHwgdGhpcy5wYXJlbnQuc2V0KCk7XHJcblxyXG4gICAgLy8gaGVscGVyRnVuY3Rpb24gdG8gY3JlYXRlIGEgbW91c2UtZG93biBmdW5jdGlvbiB3aGljaCB0cmlnZ2VycyB0aGUgZXZlbnQgc3BlY2lmaWVkIGluIGBldmVudE5hbWVgXHJcbiAgICBmdW5jdGlvbiBnZXRNb3NlRG93bkZ1bmMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBldiA9IGV2IHx8IHdpbmRvdy5ldmVudDtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQgPyBldi5wcmV2ZW50RGVmYXVsdCgpIDogZXYucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeCA9IGV2LnBhZ2VYIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICAgICAgICAgIHZhciB5ID0gZXYucGFnZVkgfHwgZXYudG91Y2hlc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgX3RoaXMuZWwuZmlyZShldmVudE5hbWUsIHt4OiB4LCB5OiB5LCBldmVudDogZXZ9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNyZWF0ZSB0aGUgc2VsZWN0aW9uLXJlY3RhbmdsZSBhbmQgYWRkIHRoZSBjc3MtY2xhc3NcclxuICAgIGlmICghdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoMCkpIHtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmFkZCh0aGlzLm5lc3RlZC5yZWN0KGJib3gud2lkdGgsIGJib3guaGVpZ2h0KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3NSZWN0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHJhdyBQb2ludHMgYXQgdGhlIGVkZ2VzLCBpZiBlbmFibGVkXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnBvaW50cyAmJiAhdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5nZXQoMSkpIHtcclxuICAgICAgICB2YXIgZW5hbWUgPVwidG91Y2hzdGFydFwiLCBtbmFtZSA9IFwibW91c2Vkb3duXCI7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcigwLCAwKS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfbHQnKS5vbihtbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdsdCcpKS5vbihlbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdsdCcpKSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcihiYm94LndpZHRoLCAwKS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfcnQnKS5vbihtbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdydCcpKS5vbihlbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdydCcpKSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcihiYm94LndpZHRoLCBiYm94LmhlaWdodCkuYXR0cignY2xhc3MnLCB0aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMgKyAnX3JiJykub24obW5hbWUsIGdldE1vc2VEb3duRnVuYygncmInKSkub24oZW5hbWUsIGdldE1vc2VEb3duRnVuYygncmInKSkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuYWRkKHRoaXMubmVzdGVkLmNpcmNsZSh0aGlzLm9wdGlvbnMucmFkaXVzKS5jZW50ZXIoMCwgYmJveC5oZWlnaHQpLmF0dHIoJ2NsYXNzJywgdGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzICsgJ19sYicpLm9uKG1uYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ2xiJykpLm9uKGVuYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ2xiJykpKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcihiYm94LndpZHRoIC8gMiwgMCkuYXR0cignY2xhc3MnLCB0aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMgKyAnX3QnKS5vbihtbmFtZSwgZ2V0TW9zZURvd25GdW5jKCd0JykpLm9uKGVuYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ3QnKSkpO1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuYWRkKHRoaXMubmVzdGVkLmNpcmNsZSh0aGlzLm9wdGlvbnMucmFkaXVzKS5jZW50ZXIoYmJveC53aWR0aCwgYmJveC5oZWlnaHQgLyAyKS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfcicpLm9uKG1uYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ3InKSkub24oZW5hbWUsIGdldE1vc2VEb3duRnVuYygncicpKSk7XHJcbiAgICAgICAgdGhpcy5yZWN0U2VsZWN0aW9uLnNldC5hZGQodGhpcy5uZXN0ZWQuY2lyY2xlKHRoaXMub3B0aW9ucy5yYWRpdXMpLmNlbnRlcihiYm94LndpZHRoIC8gMiwgYmJveC5oZWlnaHQpLmF0dHIoJ2NsYXNzJywgdGhpcy5vcHRpb25zLmNsYXNzUG9pbnRzICsgJ19iJykub24obW5hbWUsIGdldE1vc2VEb3duRnVuYygnYicpKS5vbihlbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdiJykpKTtcclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmFkZCh0aGlzLm5lc3RlZC5jaXJjbGUodGhpcy5vcHRpb25zLnJhZGl1cykuY2VudGVyKDAsIGJib3guaGVpZ2h0IC8gMikuYXR0cignY2xhc3MnLCB0aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMgKyAnX2wnKS5vbihtbmFtZSwgZ2V0TW9zZURvd25GdW5jKCdsJykpLm9uKGVuYW1lLCBnZXRNb3NlRG93bkZ1bmMoJ2wnKSkpO1xyXG5cclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENsYXNzKF90aGlzLm9wdGlvbnMuY2xhc3NQb2ludHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRyYXcgcm90YXRpb25QaW50LCBpZiBlbmFibGVkXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0aW9uUG9pbnQgJiYgKCh0aGlzLm9wdGlvbnMucG9pbnRzICYmICF0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCg5KSkgfHwgKCF0aGlzLm9wdGlvbnMucG9pbnRzICYmICF0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmdldCgxKSkpKSB7XHJcblxyXG4gICAgICAgIHZhciBjdXJyaWVkRXZlbnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgZXYgPSBldiB8fCB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0ID8gZXYucHJldmVudERlZmF1bHQoKSA6IGV2LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHggPSBldi5wYWdlWCB8fCBldi50b3VjaGVzWzBdLnBhZ2VYO1xyXG4gICAgICAgICAgICB2YXIgeSA9IGV2LnBhZ2VZIHx8IGV2LnRvdWNoZXNbMF0ucGFnZVk7XHJcbiAgICAgICAgICAgIF90aGlzLmVsLmZpcmUoJ3JvdCcsIHt4OiB4LCB5OiB5LCBldmVudDogZXZ9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQuYWRkKHRoaXMubmVzdGVkLmNpcmNsZSh0aGlzLm9wdGlvbnMucmFkaXVzKS5jZW50ZXIoYmJveC53aWR0aCAvIDIsIDIwKS5hdHRyKCdjbGFzcycsIHRoaXMub3B0aW9ucy5jbGFzc1BvaW50cyArICdfcm90JylcclxuICAgICAgICAgICAgLm9uKFwidG91Y2hzdGFydFwiLCBjdXJyaWVkRXZlbnQpLm9uKFwibW91c2Vkb3duXCIsIGN1cnJpZWRFdmVudCkpO1xyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5TZWxlY3RIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBiYm94ID0gdGhpcy5lbC5iYm94KCk7XHJcbiAgICB0aGlzLm5lc3RlZC5tYXRyaXgobmV3IFNWRy5NYXRyaXgodGhpcy5lbCkudHJhbnNsYXRlKGJib3gueCwgYmJveC55KSk7XHJcblxyXG4gICAgaWYgKHRoaXMucmVjdFNlbGVjdGlvbi5pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVSZWN0U2VsZWN0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlUG9pbnRTZWxlY3Rpb24oKTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5TZWxlY3RIYW5kbGVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICBpZiAoTXV0YXRpb25PYnNlcnZlcikge1xyXG4gICAgICAgIGlmICh0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCB8fCB0aGlzLnBvaW50U2VsZWN0aW9uLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlckluc3QgPSB0aGlzLm9ic2VydmVySW5zdCB8fCBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVyKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVySW5zdC5vYnNlcnZlKHRoaXMuZWwubm9kZSwge2F0dHJpYnV0ZXM6IHRydWV9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlckluc3QuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJJbnN0O1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdET01BdHRyTW9kaWZpZWQuc2VsZWN0Jyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCB8fCB0aGlzLnBvaW50U2VsZWN0aW9uLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5vbignRE9NQXR0ck1vZGlmaWVkLnNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuU2VsZWN0SGFuZGxlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvL3ZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgaWYgKCF0aGlzLnJlY3RTZWxlY3Rpb24uaXNTZWxlY3RlZCAmJiB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0KSB7XHJcbiAgICAgICAgLy8gc3RvcCB3YXRjaGluZyB0aGUgZWxlbWVudCwgcmVtb3ZlIHRoZSBzZWxlY3Rpb25cclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlY3RTZWxlY3Rpb24uc2V0LmNsZWFyKCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucmVjdFNlbGVjdGlvbi5zZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLnBvaW50U2VsZWN0aW9uLmlzU2VsZWN0ZWQgJiYgdGhpcy5wb2ludFNlbGVjdGlvbi5zZXQpIHtcclxuICAgICAgICAvLyBSZW1vdmUgYWxsIHBvaW50cywgY2xlYXIgdGhlIHNldCwgc3RvcCB3YXRjaGluZyB0aGUgZWxlbWVudFxyXG4gICAgICAgIHRoaXMucG9pbnRTZWxlY3Rpb24uc2V0LmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnBvaW50U2VsZWN0aW9uLnNldC5jbGVhcigpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBvaW50U2VsZWN0aW9uLnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMucG9pbnRTZWxlY3Rpb24uaXNTZWxlY3RlZCAmJiAhdGhpcy5yZWN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICB0aGlzLm5lc3RlZC5yZW1vdmUoKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5uZXN0ZWQ7XHJcblxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAgIC8vIFNlbGVjdCBlbGVtZW50IHdpdGggbW91c2VcclxuICAgIHNlbGVjdGl6ZTogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoZSBwYXJhbWV0ZXJzIGFuZCByZWFzc2lnbiBpZiBuZWVkZWRcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzZWxlY3RIYW5kbGVyID0gdGhpcy5yZW1lbWJlcignX3NlbGVjdEhhbmRsZXInKSB8fCBuZXcgU2VsZWN0SGFuZGxlcih0aGlzKTtcclxuXHJcbiAgICAgICAgc2VsZWN0SGFuZGxlci5pbml0KHZhbHVlID09PSB1bmRlZmluZWQgPyB0cnVlIDogdmFsdWUsIG9wdGlvbnMgfHwge30pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxuU1ZHLkVsZW1lbnQucHJvdG90eXBlLnNlbGVjdGl6ZS5kZWZhdWx0cyA9IHtcclxuICAgIHBvaW50czogdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdHJ1ZSwgcG9pbnRzIGF0IHRoZSBlZGdlcyBhcmUgZHJhd24uIE5lZWRlZCBmb3IgcmVzaXplIVxyXG4gICAgY2xhc3NSZWN0OiAnc3ZnX3NlbGVjdF9ib3VuZGluZ1JlY3QnLCAgICAvLyBDc3MtY2xhc3MgYWRkZWQgdG8gdGhlIHJlY3RcclxuICAgIGNsYXNzUG9pbnRzOiAnc3ZnX3NlbGVjdF9wb2ludHMnLCAgICAgICAgLy8gQ3NzLWNsYXNzIGFkZGVkIHRvIHRoZSBwb2ludHNcclxuICAgIHJhZGl1czogNywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmFkaXVzIG9mIHRoZSBwb2ludHNcclxuICAgIHJvdGF0aW9uUG9pbnQ6IHRydWUsICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdHJ1ZSwgcm90YXRpb24gcG9pbnQgaXMgZHJhd24uIE5lZWRlZCBmb3Igcm90YXRpb24hXHJcbiAgICBkZWVwU2VsZWN0OiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRydWUsIG1vdmluZyBvZiBzaW5nbGUgcG9pbnRzIGlzIHBvc3NpYmxlIChvbmx5IGxpbmUsIHBvbHlsaW5lLCBwb2x5b24pXHJcbn07XG59KCkpO1xuXG4oZnVuY3Rpb24oKSB7XG4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZUhhbmRsZXIoZWwpIHtcclxuXHJcbiAgICAgICAgZWwucmVtZW1iZXIoJ19yZXNpemVIYW5kbGVyJywgdGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLmxhc3RVcGRhdGVDYWxsID0gbnVsbDtcclxuICAgICAgICB0aGlzLnAgPSBlbC5kb2MoKS5ub2RlLmNyZWF0ZVNWR1BvaW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUudHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbih4LCB5LCBtKXtcclxuXHJcbiAgICAgICAgdGhpcy5wLnggPSB4IC0gKHRoaXMub2Zmc2V0LnggLSB3aW5kb3cucGFnZVhPZmZzZXQpO1xyXG4gICAgICAgIHRoaXMucC55ID0geSAtICh0aGlzLm9mZnNldC55IC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucC5tYXRyaXhUcmFuc2Zvcm0obSB8fCB0aGlzLm0pO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUuX2V4dHJhY3RQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgLy8gRXh0cmFjdCBhIHBvc2l0aW9uIGZyb20gYSBtb3VzZS90b3VjaCBldmVudC5cclxuICAgICAgICAvLyBSZXR1cm5zIHsgeDogLi4sIHk6IC4uIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBldmVudC5jbGllbnRYICE9IG51bGwgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxyXG4gICAgICAgICAgICB5OiBldmVudC5jbGllbnRZICE9IG51bGwgPyBldmVudC5jbGllbnRZIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRZXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5zdG9wKCk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zID09PSAnc3RvcCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XHJcblxyXG4gICAgICAgIC8vIE1lcmdlIG9wdGlvbnMgYW5kIGRlZmF1bHRzXHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmVsLnJlc2l6ZS5kZWZhdWx0cykge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPSB0aGlzLmVsLnJlc2l6ZS5kZWZhdWx0c1tpXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW2ldICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2UgbGlzdGVuIHRvIGFsbCB0aGVzZSBldmVudHMgd2hpY2ggYXJlIHNwZWNpZnlpbmcgZGlmZmVyZW50IGVkZ2VzXHJcbiAgICAgICAgdGhpcy5lbC5vbignbHQucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgLy8gTGVmdC1Ub3BcclxuICAgICAgICB0aGlzLmVsLm9uKCdydC5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7ICAvLyBSaWdodC1Ub3BcclxuICAgICAgICB0aGlzLmVsLm9uKCdyYi5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7ICAvLyBSaWdodC1Cb3R0b21cclxuICAgICAgICB0aGlzLmVsLm9uKCdsYi5yZXNpemUnLCBmdW5jdGlvbihlKXsgX3RoaXMucmVzaXplKGUgfHwgd2luZG93LmV2ZW50KTsgfSk7ICAvLyBMZWZ0LUJvdHRvbVxyXG5cclxuICAgICAgICB0aGlzLmVsLm9uKCd0LnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgICAvLyBUb3BcclxuICAgICAgICB0aGlzLmVsLm9uKCdyLnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgICAvLyBSaWdodFxyXG4gICAgICAgIHRoaXMuZWwub24oJ2IucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgIC8vIEJvdHRvbVxyXG4gICAgICAgIHRoaXMuZWwub24oJ2wucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAgIC8vIExlZnRcclxuXHJcbiAgICAgICAgdGhpcy5lbC5vbigncm90LnJlc2l6ZScsIGZ1bmN0aW9uKGUpeyBfdGhpcy5yZXNpemUoZSB8fCB3aW5kb3cuZXZlbnQpOyB9KTsgLy8gUm90YXRpb25cclxuXHJcbiAgICAgICAgdGhpcy5lbC5vbigncG9pbnQucmVzaXplJywgZnVuY3Rpb24oZSl7IF90aGlzLnJlc2l6ZShlIHx8IHdpbmRvdy5ldmVudCk7IH0pOyAvLyBQb2ludC1Nb3ZpbmdcclxuXHJcbiAgICAgICAgLy8gVGhpcyBjYWxsIGVuc3VyZXMsIHRoYXQgdGhlIHBsdWdpbiByZWFjdHMgdG8gYSBjaGFuZ2Ugb2Ygc25hcFRvR3JpZCBpbW1lZGlhdGVseVxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmVsLm9mZignbHQucmVzaXplJyk7XHJcbiAgICAgICAgdGhpcy5lbC5vZmYoJ3J0LnJlc2l6ZScpO1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdyYi5yZXNpemUnKTtcclxuICAgICAgICB0aGlzLmVsLm9mZignbGIucmVzaXplJyk7XHJcblxyXG4gICAgICAgIHRoaXMuZWwub2ZmKCd0LnJlc2l6ZScpO1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdyLnJlc2l6ZScpO1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdiLnJlc2l6ZScpO1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCdsLnJlc2l6ZScpO1xyXG5cclxuICAgICAgICB0aGlzLmVsLm9mZigncm90LnJlc2l6ZScpO1xyXG5cclxuICAgICAgICB0aGlzLmVsLm9mZigncG9pbnQucmVzaXplJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5tID0gdGhpcy5lbC5ub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IHsgeDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfTtcclxuXHJcbiAgICAgICAgdmFyIHR4UHQgPSB0aGlzLl9leHRyYWN0UG9zaXRpb24oZXZlbnQuZGV0YWlsLmV2ZW50KTtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZWwudHlwZSwgLy8gdGhlIHR5cGUgb2YgZWxlbWVudFxyXG4gICAgICAgICAgICBwOiB0aGlzLnRyYW5zZm9ybVBvaW50KHR4UHQueCwgdHhQdC55KSxcclxuICAgICAgICAgICAgeDogZXZlbnQuZGV0YWlsLngsICAgICAgLy8geC1wb3NpdGlvbiBvZiB0aGUgbW91c2Ugd2hlbiByZXNpemluZyBzdGFydGVkXHJcbiAgICAgICAgICAgIHk6IGV2ZW50LmRldGFpbC55LCAgICAgIC8vIHktcG9zaXRpb24gb2YgdGhlIG1vdXNlIHdoZW4gcmVzaXppbmcgc3RhcnRlZFxyXG4gICAgICAgICAgICBib3g6IHRoaXMuZWwuYmJveCgpLCAgICAvLyBUaGUgYm91bmRpbmctYm94IG9mIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLmVsLnRyYW5zZm9ybSgpLnJvdGF0aW9uICAvLyBUaGUgY3VycmVudCByb3RhdGlvbiBvZiB0aGUgZWxlbWVudFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEFkZCBmb250LXNpemUgcGFyYW1ldGVyIGlmIHRoZSBlbGVtZW50IHR5cGUgaXMgdGV4dFxyXG4gICAgICAgIGlmICh0aGlzLmVsLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5mb250U2l6ZSA9IHRoaXMuZWwuYXR0cigpW1wiZm9udC1zaXplXCJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGhlIGktcGFyYW0gaW4gdGhlIGV2ZW50IGhvbGRzIHRoZSBpbmRleCBvZiB0aGUgcG9pbnQgd2hpY2ggaXMgbW92ZWQsIHdoZW4gdXNpbmcgYGRlZXBTZWxlY3RgXHJcbiAgICAgICAgaWYgKGV2ZW50LmRldGFpbC5pICE9PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcG9pbnQgYXJyYXlcclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5lbC5hcnJheSgpLnZhbHVlT2YoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGluZGV4IGFuZCB0aGUgcG9pbnQgd2hpY2ggaXMgbW92ZWRcclxuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmkgPSBldmVudC5kZXRhaWwuaTtcclxuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLnBvaW50Q29vcmRzID0gW2FycmF5W2V2ZW50LmRldGFpbC5pXVswXSwgYXJyYXlbZXZlbnQuZGV0YWlsLmldWzFdXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExldHMgY2hlY2sgd2hpY2ggZWRnZSBvZiB0aGUgYm91bmRpbmctYm94IHdhcyBjbGlja2VkIGFuZCByZXNpemUgdGhlIHRoaXMuZWwgYWNjb3JkaW5nIHRvIHRoaXNcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIExlZnQtVG9wLUVkZ2VcclxuICAgICAgICAgICAgY2FzZSAnbHQnOlxyXG4gICAgICAgICAgICAgICAgLy8gV2UgYnVpbGQgYSBjYWxjdWxhdGluZyBmdW5jdGlvbiBmb3IgZXZlcnkgY2FzZSB3aGljaCBnaXZlcyB1cyB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSB0aGlzLmVsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByb2NlZHVyZSBpcyBhbHdheXMgdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB3ZSBzbmFwIHRoZSBlZGdlIHRvIHRoZSBnaXZlbiBncmlkIChzbmFwcGluZyB0byAxcHggZ3JpZCBpcyBub3JtYWwgcmVzaXppbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdlIGNoZWNrIGlmIHRoZSBuZXcgaGVpZ2h0IGFuZCB3aWR0aCBzdGlsbCB2YWxpZCAoPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC0gc25hcFswXSA+IDAgJiYgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5pZiB2YWxpZCwgd2UgcmVzaXplIHRoZSB0aGlzLmVsICh3aGljaCBjYW4gaW5jbHVkZSBtb3ZpbmcgYmVjYXVzZSB0aGUgY29vcmQtc3lzdGVtIHN0YXJ0cyBhdCB0aGUgbGVmdC10b3AgYW5kIHRoaXMgZWRnZSBpcyBtb3Zpbmcgc29tZXRpbWVzIHdoZW4gcmVzaXplZClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGJ1dCBmaXJzdCBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyB0ZXh0IGJveCwgc28gd2UgY2FuIGNoYW5nZSB0aGUgZm9udCBzaXplIGluc3RlYWQgb2ZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIHdpZHRoIGFuZCBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuYXR0cihcImZvbnQtc2l6ZVwiLCB0aGlzLnBhcmFtZXRlcnMuZm9udFNpemUgLSBzbmFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcCA9IHRoaXMuY2hlY2tBc3BlY3RSYXRpbyhzbmFwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LnggKyBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LnkgKyBzbmFwWzFdKS5zaXplKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCAtIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIFJpZ2h0LVRvcFxyXG4gICAgICAgICAgICBjYXNlICdydCc6XHJcbiAgICAgICAgICAgICAgICAvLyBzLmEuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZLCAxIDw8IDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSA+IDAgJiYgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgLSBzbmFwWzFdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54IC0gc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuYXR0cihcImZvbnQtc2l6ZVwiLCB0aGlzLnBhcmFtZXRlcnMuZm9udFNpemUgKyBzbmFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcCA9IHRoaXMuY2hlY2tBc3BlY3RSYXRpbyhzbmFwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LngsIHRoaXMucGFyYW1ldGVycy5ib3gueSArIHNuYXBbMV0pLnNpemUodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCArIHNuYXBbMF0sIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC0gc25hcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gUmlnaHQtQm90dG9tXHJcbiAgICAgICAgICAgIGNhc2UgJ3JiJzpcclxuICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSA+IDAgJiYgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgKyBzbmFwWzFdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54IC0gc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuYXR0cihcImZvbnQtc2l6ZVwiLCB0aGlzLnBhcmFtZXRlcnMuZm9udFNpemUgKyBzbmFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcCA9IHRoaXMuY2hlY2tBc3BlY3RSYXRpbyhzbmFwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LngsIHRoaXMucGFyYW1ldGVycy5ib3gueSkuc2l6ZSh0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgKyBzbmFwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBMZWZ0LUJvdHRvbVxyXG4gICAgICAgICAgICBjYXNlICdsYic6XHJcbiAgICAgICAgICAgICAgICAvLyBzLmEuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGMgPSBmdW5jdGlvbiAoZGlmZlgsIGRpZmZZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXAgPSB0aGlzLnNuYXBUb0dyaWQoZGlmZlgsIGRpZmZZLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAtIHNuYXBbMF0gPiAwICYmIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0ICsgc25hcFsxXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy50eXBlID09PSBcInRleHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCArIHNuYXBbMF0sIHRoaXMucGFyYW1ldGVycy5ib3gueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLmF0dHIoXCJmb250LXNpemVcIiwgdGhpcy5wYXJhbWV0ZXJzLmZvbnRTaXplIC0gc25hcFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXAgPSB0aGlzLmNoZWNrQXNwZWN0UmF0aW8oc25hcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLm1vdmUodGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgc25hcFswXSwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KS5zaXplKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIFRvcFxyXG4gICAgICAgICAgICBjYXNlICd0JzpcclxuICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIDEgPDwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC0gc25hcFsxXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSB0aGUgZm9udC1yZXNpemluZyBpZiBpdCBpcyBub3QgZnJvbSB0aGUgY29ybmVyIG9mIGJvdW5kaW5nLWJveFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LngsIHRoaXMucGFyYW1ldGVycy5ib3gueSArIHNuYXBbMV0pLmhlaWdodCh0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCAtIHNuYXBbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIFJpZ2h0XHJcbiAgICAgICAgICAgIGNhc2UgJ3InOlxyXG4gICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwID0gdGhpcy5zbmFwVG9HcmlkKGRpZmZYLCBkaWZmWSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggKyBzbmFwWzBdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LngsIHRoaXMucGFyYW1ldGVycy5ib3gueSkud2lkdGgodGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCArIHNuYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIC8vIEJvdHRvbVxyXG4gICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgICAgIC8vIHMuYS5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsYyA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCArIHNuYXBbMV0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5tb3ZlKHRoaXMucGFyYW1ldGVycy5ib3gueCwgdGhpcy5wYXJhbWV0ZXJzLmJveC55KS5oZWlnaHQodGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQgKyBzbmFwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBMZWZ0XHJcbiAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG4gICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwID0gdGhpcy5zbmFwVG9HcmlkKGRpZmZYLCBkaWZmWSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLnR5cGUgPT09IFwidGV4dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwubW92ZSh0aGlzLnBhcmFtZXRlcnMuYm94LnggKyBzbmFwWzBdLCB0aGlzLnBhcmFtZXRlcnMuYm94LnkpLndpZHRoKHRoaXMucGFyYW1ldGVycy5ib3gud2lkdGggLSBzbmFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3RhdGlvblxyXG4gICAgICAgICAgICBjYXNlICdyb3QnOlxyXG4gICAgICAgICAgICAgICAgLy8gcy5hLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB5ZXMgdGhpcyBpcyBraW5kYSBzdHVwaWQgYnV0IHdlIG5lZWQgdGhlIG1vdXNlIGNvb3JkcyBiYWNrLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB7eDogZGlmZlggKyB0aGlzLnBhcmFtZXRlcnMucC54LCB5OiBkaWZmWSArIHRoaXMucGFyYW1ldGVycy5wLnl9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBtaW51cyBtaWRkbGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc0FuZ2xlID0gTWF0aC5hdGFuMigodGhpcy5wYXJhbWV0ZXJzLnAueSAtIHRoaXMucGFyYW1ldGVycy5ib3gueSAtIHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC8gMiksICh0aGlzLnBhcmFtZXRlcnMucC54IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC54IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAvIDIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIG1pbnVzIG1pZGRsZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwQW5nbGUgPSBNYXRoLmF0YW4yKChjdXJyZW50LnkgLSB0aGlzLnBhcmFtZXRlcnMuYm94LnkgLSB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCAvIDIpLCAoY3VycmVudC54IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC54IC0gdGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAvIDIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gKHBBbmdsZSAtIHNBbmdsZSkgKiAxODAgLyBNYXRoLlBJO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIG1vdmUgdGhlIGVsZW1lbnQgdG8gdGhlIGNlbnRlciBvZiB0aGUgYm94IGZpcnN0IGFuZCBjaGFuZ2UgdGhlIHJvdGF0aW9uIGFmdGVyd2FyZHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHJvdGF0aW9uIGFsd2F5cyB3b3JrcyBhcm91bmQgYSByb3RhdGlvbi1jZW50ZXIsIHdoaWNoIGlzIGNoYW5nZWQgd2hlbiBtb3ZpbmcgdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHNvIHNldCB0aGUgbmV3IHJvdGF0aW9uIGNlbnRlciB0byB0aGUgY2VudGVyIG9mIHRoZSBib3guXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5jZW50ZXIodGhpcy5wYXJhbWV0ZXJzLmJveC5jeCwgdGhpcy5wYXJhbWV0ZXJzLmJveC5jeSkucm90YXRlKHRoaXMucGFyYW1ldGVycy5yb3RhdGlvbiArIGFuZ2xlIC0gYW5nbGUgJSB0aGlzLm9wdGlvbnMuc25hcFRvQW5nbGUsIHRoaXMucGFyYW1ldGVycy5ib3guY3gsIHRoaXMucGFyYW1ldGVycy5ib3guY3kpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgLy8gTW92aW5nIG9uZSBzaW5nbGUgUG9pbnQgKG5lZWRlZCB3aGVuIGFuIGVsZW1lbnQgaXMgZGVlcFNlbGVjdGVkIHdoaWNoIG1lYW5zIHlvdSBjYW4gbW92ZSBldmVyeSBzaW5nbGUgcG9pbnQgb2YgdGhlIG9iamVjdClcclxuICAgICAgICAgICAgY2FzZSAncG9pbnQnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTbmFwcGluZyB0aGUgcG9pbnQgdG8gdGhlIGdyaWRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcCA9IHRoaXMuc25hcFRvR3JpZChkaWZmWCwgZGlmZlksIHRoaXMucGFyYW1ldGVycy5wb2ludENvb3Jkc1swXSwgdGhpcy5wYXJhbWV0ZXJzLnBvaW50Q29vcmRzWzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwb2ludCBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuZWwuYXJyYXkoKS52YWx1ZU9mKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBtb3ZlZCBwb2ludCBpbiB0aGUgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVt0aGlzLnBhcmFtZXRlcnMuaV1bMF0gPSB0aGlzLnBhcmFtZXRlcnMucG9pbnRDb29yZHNbMF0gKyBzbmFwWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3RoaXMucGFyYW1ldGVycy5pXVsxXSA9IHRoaXMucGFyYW1ldGVycy5wb2ludENvb3Jkc1sxXSArIHNuYXBbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZCBwbG90IHRoZSBuZXcgdGhpcy5lbFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWwucGxvdChhcnJheSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5lbC5maXJlKCdyZXNpemVzdGFydCcsIHtkeDogdGhpcy5wYXJhbWV0ZXJzLngsIGR5OiB0aGlzLnBhcmFtZXRlcnMueSwgZXZlbnQ6IGV2ZW50fSk7XHJcbiAgICAgICAgLy8gV2hlbiByZXNpemluZyBzdGFydGVkLCB3ZSBoYXZlIHRvIHJlZ2lzdGVyIGV2ZW50cyBmb3IuLi5cclxuICAgICAgICAvLyBUb3VjaGVzLlxyXG4gICAgICAgIFNWRy5vbih3aW5kb3csICd0b3VjaG1vdmUucmVzaXplJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGUoZSB8fCB3aW5kb3cuZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFNWRy5vbih3aW5kb3csICd0b3VjaGVuZC5yZXNpemUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgX3RoaXMuZG9uZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE1vdXNlLlxyXG4gICAgICAgIFNWRy5vbih3aW5kb3csICdtb3VzZW1vdmUucmVzaXplJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlKGUgfHwgd2luZG93LmV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBTVkcub24od2luZG93LCAnbW91c2V1cC5yZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRvbmUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoZSB1cGRhdGUtZnVuY3Rpb24gcmVkcmF3cyB0aGUgZWxlbWVudCBldmVyeSB0aW1lIHRoZSBtb3VzZSBpcyBtb3ZpbmdcclxuICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cclxuICAgICAgICBpZiAoIWV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RVcGRhdGVDYWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGModGhpcy5sYXN0VXBkYXRlQ2FsbFswXSwgdGhpcy5sYXN0VXBkYXRlQ2FsbFsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG1vdXNlcG9zaXRpb24gYXQgc3RhcnQgYW5kIG5vd1xyXG4gICAgICAgIHZhciB0eFB0ID0gdGhpcy5fZXh0cmFjdFBvc2l0aW9uKGV2ZW50KTtcclxuICAgICAgICB2YXIgcCA9IHRoaXMudHJhbnNmb3JtUG9pbnQodHhQdC54LCB0eFB0LnkpO1xyXG5cclxuICAgICAgICB2YXIgZGlmZlggPSBwLnggLSB0aGlzLnBhcmFtZXRlcnMucC54LFxyXG4gICAgICAgICAgICBkaWZmWSA9IHAueSAtIHRoaXMucGFyYW1ldGVycy5wLnk7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZUNhbGwgPSBbZGlmZlgsIGRpZmZZXTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgcG9zaXRpb24gYW5kIGhlaWdodCAvIHdpZHRoIG9mIHRoZSBlbGVtZW50XHJcbiAgICAgICAgdGhpcy5jYWxjKGRpZmZYLCBkaWZmWSk7XHJcblxyXG4gICAgICAgLy8gRW1pdCBhbiBldmVudCB0byBzYXkgd2UgaGF2ZSBjaGFuZ2VkLlxyXG4gICAgICAgIHRoaXMuZWwuZmlyZSgncmVzaXppbmcnLCB7ZHg6IGRpZmZYLCBkeTogZGlmZlksIGV2ZW50OiBldmVudH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJcyBjYWxsZWQgb24gbW91c2V1cC5cclxuICAgIC8vIFJlbW92ZXMgdGhlIHVwZGF0ZS1mdW5jdGlvbiBmcm9tIHRoZSBtb3VzZW1vdmUgZXZlbnRcclxuICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlQ2FsbCA9IG51bGw7XHJcbiAgICAgICAgU1ZHLm9mZih3aW5kb3csICdtb3VzZW1vdmUucmVzaXplJyk7XHJcbiAgICAgICAgU1ZHLm9mZih3aW5kb3csICdtb3VzZXVwLnJlc2l6ZScpO1xyXG4gICAgICAgIFNWRy5vZmYod2luZG93LCAndG91Y2htb3ZlLnJlc2l6ZScpO1xyXG4gICAgICAgIFNWRy5vZmYod2luZG93LCAndG91Y2hlbmQucmVzaXplJyk7XHJcbiAgICAgICAgdGhpcy5lbC5maXJlKCdyZXNpemVkb25lJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoZSBmbGFnIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHJlc2l6aW5nIGlzIHVzZWQgd2l0aCBhIGxlZnQtUG9pbnQgKGZpcnN0IGJpdCkgYW5kIHRvcC1wb2ludCAoc2Vjb25kIGJpdClcclxuICAgIC8vIEluIHRoaXMgY2FzZXMgdGhlIHRlbXAtdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGRpZmZlcmVudGx5XHJcbiAgICBSZXNpemVIYW5kbGVyLnByb3RvdHlwZS5zbmFwVG9HcmlkID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSwgZmxhZywgcG9pbnRDb29yZHNZKSB7XHJcblxyXG4gICAgICAgIHZhciB0ZW1wO1xyXG5cclxuICAgICAgICAvLyBJZiBgcG9pbnRDb29yZHNZYCBpcyBnaXZlbiwgYSBzaW5nbGUgUG9pbnQgaGFzIHRvIGJlIHNuYXBwZWQgKGRlZXBTZWxlY3QpLiBUaGF0J3Mgd2h5IHdlIG5lZWQgYSBkaWZmZXJlbnQgdGVtcC12YWx1ZVxyXG4gICAgICAgIGlmICh0eXBlb2YgcG9pbnRDb29yZHNZICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgZmxhZyA9IHBvaW50Q29vcmRzWCBpbiB0aGlzIGNhc2VcclxuICAgICAgICAgICAgdGVtcCA9IFsoZmxhZyArIGRpZmZYKSAlIHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkLCAocG9pbnRDb29yZHNZICsgZGlmZlkpICUgdGhpcy5vcHRpb25zLnNuYXBUb0dyaWRdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGNoZWNrIGlmIHRoZSBmbGFnIGlzIHNldCBhbmQgaWYgbm90IHdlIHNldCBhIGRlZmF1bHQtdmFsdWUgKGJvdGggYml0cyBzZXQgLSB3aGljaCBtZWFucyB1cHBlci1sZWZ0LWVkZ2UpXHJcbiAgICAgICAgICAgIGZsYWcgPSBmbGFnID09IG51bGwgPyAxIHwgMSA8PCAxIDogZmxhZztcclxuICAgICAgICAgICAgdGVtcCA9IFsodGhpcy5wYXJhbWV0ZXJzLmJveC54ICsgZGlmZlggKyAoZmxhZyAmIDEgPyAwIDogdGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCkpICUgdGhpcy5vcHRpb25zLnNuYXBUb0dyaWQsICh0aGlzLnBhcmFtZXRlcnMuYm94LnkgKyBkaWZmWSArIChmbGFnICYgKDEgPDwgMSkgPyAwIDogdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQpKSAlIHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkXTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBkaWZmWCAtPSAoTWF0aC5hYnModGVtcFswXSkgPCB0aGlzLm9wdGlvbnMuc25hcFRvR3JpZCAvIDIgP1xyXG4gICAgICAgICAgICAgICAgICB0ZW1wWzBdIDpcclxuICAgICAgICAgICAgICAgICAgdGVtcFswXSAtIChkaWZmWCA8IDAgPyAtdGhpcy5vcHRpb25zLnNuYXBUb0dyaWQgOiB0aGlzLm9wdGlvbnMuc25hcFRvR3JpZCkpO1xyXG4gICAgICAgIGRpZmZZIC09IChNYXRoLmFicyh0ZW1wWzFdKSA8IHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkIC8gMiA/XHJcbiAgICAgICAgICAgICAgICAgIHRlbXBbMV0gOlxyXG4gICAgICAgICAgICAgICAgICB0ZW1wWzFdIC0gKGRpZmZZIDwgMCA/IC10aGlzLm9wdGlvbnMuc25hcFRvR3JpZCA6IHRoaXMub3B0aW9ucy5zbmFwVG9HcmlkKSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRUb0JveChkaWZmWCwgZGlmZlksIGZsYWcsIHBvaW50Q29vcmRzWSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBrZWVwIGVsZW1lbnQgd2l0aGluIGNvbnN0cmFpbmVkIGJveFxyXG4gICAgUmVzaXplSGFuZGxlci5wcm90b3R5cGUuY29uc3RyYWludFRvQm94ID0gZnVuY3Rpb24gKGRpZmZYLCBkaWZmWSwgZmxhZywgcG9pbnRDb29yZHNZKSB7XHJcbiAgICAgICAgLy9yZXR1cm4gW2RpZmZYLCBkaWZmWV1cclxuICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucy5jb25zdHJhaW50IHx8IHt9O1xyXG4gICAgICAgIHZhciBvcmdYLCBvcmdZO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHBvaW50Q29vcmRzWSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIG9yZ1ggPSBmbGFnO1xyXG4gICAgICAgICAgb3JnWSA9IHBvaW50Q29vcmRzWTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb3JnWCA9IHRoaXMucGFyYW1ldGVycy5ib3gueCArIChmbGFnICYgMSA/IDAgOiB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoKTtcclxuICAgICAgICAgIG9yZ1kgPSB0aGlzLnBhcmFtZXRlcnMuYm94LnkgKyAoZmxhZyAmICgxPDwxKSA/IDAgOiB0aGlzLnBhcmFtZXRlcnMuYm94LmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGMubWluWCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWCArIGRpZmZYIDwgYy5taW5YKSB7XHJcbiAgICAgICAgICBkaWZmWCA9IGMubWluWCAtIG9yZ1g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGMubWF4WCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWCArIGRpZmZYID4gYy5tYXhYKSB7XHJcbiAgICAgICAgICBkaWZmWCA9IGMubWF4WCAtIG9yZ1g7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGMubWluWSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWSArIGRpZmZZIDwgYy5taW5ZKSB7XHJcbiAgICAgICAgICBkaWZmWSA9IGMubWluWSAtIG9yZ1k7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGMubWF4WSAhPT0gJ3VuZGVmaW5lZCcgJiYgb3JnWSArIGRpZmZZID4gYy5tYXhZKSB7XHJcbiAgICAgICAgICBkaWZmWSA9IGMubWF4WSAtIG9yZ1k7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gW2RpZmZYLCBkaWZmWV07XHJcbiAgICB9O1xyXG5cclxuICAgIFJlc2l6ZUhhbmRsZXIucHJvdG90eXBlLmNoZWNrQXNwZWN0UmF0aW8gPSBmdW5jdGlvbiAoc25hcCkge1xyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNhdmVBc3BlY3RSYXRpbykge1xyXG4gICAgICAgICAgICByZXR1cm4gc25hcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB1cGRhdGVkU25hcCA9IHNuYXAuc2xpY2UoKTtcclxuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoIC8gdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIG5ld1cgPSB0aGlzLnBhcmFtZXRlcnMuYm94LndpZHRoICsgc25hcFswXTtcclxuICAgICAgICB2YXIgbmV3SCA9IHRoaXMucGFyYW1ldGVycy5ib3guaGVpZ2h0IC0gc25hcFsxXTtcclxuICAgICAgICB2YXIgbmV3QXNwZWN0UmF0aW8gPSBuZXdXIC8gbmV3SDtcclxuXHJcbiAgICAgICAgaWYgKG5ld0FzcGVjdFJhdGlvIDwgYXNwZWN0UmF0aW8pIHtcclxuICAgICAgICAgICAgLy8gSGVpZ2h0IGlzIHRvbyBiaWcuIEFkYXB0IGl0XHJcbiAgICAgICAgICAgIHVwZGF0ZWRTbmFwWzFdID0gbmV3VyAvIGFzcGVjdFJhdGlvIC0gdGhpcy5wYXJhbWV0ZXJzLmJveC5oZWlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuZXdBc3BlY3RSYXRpbyA+IGFzcGVjdFJhdGlvKSB7XHJcbiAgICAgICAgICAgIC8vIFdpZHRoIGlzIHRvbyBiaWcuIEFkYXB0IGl0XHJcbiAgICAgICAgICAgIHVwZGF0ZWRTbmFwWzBdID0gdGhpcy5wYXJhbWV0ZXJzLmJveC53aWR0aCAtIG5ld0ggKiBhc3BlY3RSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1cGRhdGVkU25hcDtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIFNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAgICAgICAvLyBSZXNpemUgZWxlbWVudCB3aXRoIG1vdXNlXHJcbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuICAgICAgICAgICAgKHRoaXMucmVtZW1iZXIoJ19yZXNpemVIYW5kbGVyJykgfHwgbmV3IFJlc2l6ZUhhbmRsZXIodGhpcykpLmluaXQob3B0aW9ucyB8fCB7fSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pO1xyXG5cclxuICAgIFNWRy5FbGVtZW50LnByb3RvdHlwZS5yZXNpemUuZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgc25hcFRvQW5nbGU6IDAuMSwgICAgICAgLy8gU3BlY2lmaWVzIHRoZSBzcGVlZCB0aGUgcm90YXRpb24gaXMgaGFwcGVuaW5nIHdoZW4gbW92aW5nIHRoZSBtb3VzZVxyXG4gICAgICAgIHNuYXBUb0dyaWQ6IDEsICAgICAgICAgIC8vIFNuYXBzIHRvIGEgZ3JpZCBvZiBgc25hcFRvR3JpZGAgUGl4ZWxzXHJcbiAgICAgICAgY29uc3RyYWludDoge30sICAgICAgICAgLy8ga2VlcCBlbGVtZW50IHdpdGhpbiBjb25zdHJhaW5lZCBib3hcclxuICAgICAgICBzYXZlQXNwZWN0UmF0aW86IGZhbHNlICAvLyBTYXZlIGFzcGVjdCByYXRpbyB3aGVuIHJlc2l6aW5nIHVzaW5nIGx0LCBydCwgcmIgb3IgbGIgcG9pbnRzXHJcbiAgICB9O1xyXG5cclxufSkuY2FsbCh0aGlzKTtcbn0oKSk7XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGluc2VydEF0ID0gcmVmLmluc2VydEF0O1xuXG4gIGlmICghY3NzIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzcyA9IFwiLmFwZXhjaGFydHMtY2FudmFzIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgLyogY2Fubm90IGdpdmUgb3ZlcmZsb3c6IGhpZGRlbiBhcyBpdCB3aWxsIGNyb3AgdG9vbHRpcHMgd2hpY2ggb3ZlcmZsb3cgb3V0c2lkZSBjaGFydCBhcmVhICovXFxufVxcblxcbi8qIHNjcm9sbGJhciBpcyBub3QgdmlzaWJsZSBieSBkZWZhdWx0IGZvciBsZWdlbmQsIGhlbmNlIGZvcmNpbmcgdGhlIHZpc2liaWxpdHkgKi9cXG4uYXBleGNoYXJ0cy1jYW52YXMgOjotd2Via2l0LXNjcm9sbGJhciB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICB3aWR0aDogNnB4O1xcbn1cXG4uYXBleGNoYXJ0cy1jYW52YXMgOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsMCwwLC41KTtcXG4gIGJveC1zaGFkb3c6IDAgMCAxcHggcmdiYSgyNTUsMjU1LDI1NSwuNSk7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDAgMCAxcHggcmdiYSgyNTUsMjU1LDI1NSwuNSk7XFxufVxcblxcbi5hcGV4Y2hhcnRzLWlubmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLmxlZ2VuZC1tb3VzZW92ZXItaW5hY3RpdmUge1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxuICBvcGFjaXR5OiAwLjIwO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy1zZXJpZXMtY29sbGFwc2VkIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLWdyaWRsaW5lLCAuYXBleGNoYXJ0cy10ZXh0IHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwIHtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGJveC1zaGFkb3c6IDJweCAycHggNnB4IC00cHggIzk5OTtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxlZnQ6IDYycHg7XFxuICBvcGFjaXR5OiAwO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDIwcHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHotaW5kZXg6IDEyO1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAubGlnaHQge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2UzZTNlMztcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45Nik7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAuZGFyayB7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMzAsMzAsMzAsIDAuOCk7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAgKiB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcCAuYXBleGNoYXJ0cy1tYXJrZXIsXFxuLmFwZXhjaGFydHMtYXJlYS1zZXJpZXMgLmFwZXhjaGFydHMtYXJlYSxcXG4uYXBleGNoYXJ0cy1saW5lIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLmFjdGl2ZSB7XFxuICBvcGFjaXR5OiAxO1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGl0bGUge1xcbiAgcGFkZGluZzogNnB4O1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgbWFyZ2luLWJvdHRvbTogNHB4O1xcbn1cXG4uYXBleGNoYXJ0cy10b29sdGlwLmxpZ2h0IC5hcGV4Y2hhcnRzLXRvb2x0aXAtdGl0bGUge1xcbiAgYmFja2dyb3VuZDogI0VDRUZGMTtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGRkO1xcbn1cXG4uYXBleGNoYXJ0cy10b29sdGlwLmRhcmsgLmFwZXhjaGFydHMtdG9vbHRpcC10aXRsZSB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNyk7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzIyMjtcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC10ZXh0LXZhbHVlLFxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LXZhbHVlIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLXRleHQtei1sYWJlbDplbXB0eSxcXG4uYXBleGNoYXJ0cy10b29sdGlwLXRleHQtei12YWx1ZTplbXB0eSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy10b29sdGlwLXRleHQtdmFsdWUsIFxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtdGV4dC16LXZhbHVlIHtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtbWFya2VyIHtcXG4gIHdpZHRoOiAxMnB4O1xcbiAgaGVpZ2h0OiAxMnB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiAwcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtc2VyaWVzLWdyb3VwIHtcXG4gIHBhZGRpbmc6IDAgMTBweDtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAganVzdGlmeS1jb250ZW50OiBsZWZ0O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXAuYWN0aXZlIC5hcGV4Y2hhcnRzLXRvb2x0aXAtbWFya2VyIHtcXG4gIG9wYWNpdHk6IDE7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtc2VyaWVzLWdyb3VwLmFjdGl2ZSwgLmFwZXhjaGFydHMtdG9vbHRpcC1zZXJpZXMtZ3JvdXA6bGFzdC1jaGlsZCB7XFxuICBwYWRkaW5nLWJvdHRvbTogNHB4O1xcbn1cXG4uYXBleGNoYXJ0cy10b29sdGlwLXktZ3JvdXAge1xcbiAgcGFkZGluZzogNnB4IDAgNXB4O1xcbn1cXG4uYXBleGNoYXJ0cy10b29sdGlwLWNhbmRsZXN0aWNrIHtcXG4gIHBhZGRpbmc6IDRweCA4cHg7XFxufVxcbi5hcGV4Y2hhcnRzLXRvb2x0aXAtY2FuZGxlc3RpY2sgPiBkaXYge1xcbiAgbWFyZ2luOiA0cHggMDtcXG59XFxuLmFwZXhjaGFydHMtdG9vbHRpcC1jYW5kbGVzdGljayBzcGFuLnZhbHVlIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAge1xcbiAgb3BhY2l0eTogMDtcXG4gIHBhZGRpbmc6IDlweCAxMHB4O1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBjb2xvcjogIzM3M2QzZjtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDEwO1xcblxcdGJhY2tncm91bmQ6ICNFQ0VGRjE7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjOTBBNEFFO1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcDphZnRlciwgLmFwZXhjaGFydHMteGF4aXN0b29sdGlwOmJlZm9yZSB7XFxuXFx0bGVmdDogNTAlO1xcblxcdGJvcmRlcjogc29saWQgdHJhbnNwYXJlbnQ7XFxuXFx0Y29udGVudDogXFxcIiBcXFwiO1xcblxcdGhlaWdodDogMDtcXG5cXHR3aWR0aDogMDtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcDphZnRlciB7XFxuXFx0Ym9yZGVyLWNvbG9yOiByZ2JhKDIzNiwgMjM5LCAyNDEsIDApO1xcblxcdGJvcmRlci13aWR0aDogNnB4O1xcblxcdG1hcmdpbi1sZWZ0OiAtNnB4O1xcbn1cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXA6YmVmb3JlIHtcXG5cXHRib3JkZXItY29sb3I6IHJnYmEoMTQ0LCAxNjQsIDE3NCwgMCk7XFxuXFx0Ym9yZGVyLXdpZHRoOiA3cHg7XFxuXFx0bWFyZ2luLWxlZnQ6IC03cHg7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC1ib3R0b206YWZ0ZXIsIC5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC1ib3R0b206YmVmb3JlIHtcXG4gIGJvdHRvbTogMTAwJTtcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLWJvdHRvbTphZnRlciB7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjRUNFRkYxO1xcbn1cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtYm90dG9tOmJlZm9yZSB7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjOTBBNEFFO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtdG9wOmFmdGVyLCAuYXBleGNoYXJ0cy14YXhpc3Rvb2x0aXAtdG9wOmJlZm9yZSB7XFxuICB0b3A6IDEwMCU7XFxufVxcbi5hcGV4Y2hhcnRzLXhheGlzdG9vbHRpcC10b3A6YWZ0ZXIge1xcbiAgYm9yZGVyLXRvcC1jb2xvcjogI0VDRUZGMTtcXG59XFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLXRvcDpiZWZvcmUge1xcbiAgYm9yZGVyLXRvcC1jb2xvcjogIzkwQTRBRTtcXG59XFxuXFxuLmFwZXhjaGFydHMteGF4aXN0b29sdGlwLmFjdGl2ZSB7XFxuICBvcGFjaXR5OiAxO1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcCB7XFxuICBvcGFjaXR5OiAwO1xcbiAgcGFkZGluZzogNHB4IDEwcHg7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIGNvbG9yOiAjMzczZDNmO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMTA7XFxuXFx0YmFja2dyb3VuZDogI0VDRUZGMTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM5MEE0QUU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcDphZnRlciwgLmFwZXhjaGFydHMteWF4aXN0b29sdGlwOmJlZm9yZSB7XFxuXFx0dG9wOiA1MCU7XFxuXFx0Ym9yZGVyOiBzb2xpZCB0cmFuc3BhcmVudDtcXG5cXHRjb250ZW50OiBcXFwiIFxcXCI7XFxuXFx0aGVpZ2h0OiAwO1xcblxcdHdpZHRoOiAwO1xcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwOmFmdGVyIHtcXG5cXHRib3JkZXItY29sb3I6IHJnYmEoMjM2LCAyMzksIDI0MSwgMCk7XFxuXFx0Ym9yZGVyLXdpZHRoOiA2cHg7XFxuXFx0bWFyZ2luLXRvcDogLTZweDtcXG59XFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwOmJlZm9yZSB7XFxuXFx0Ym9yZGVyLWNvbG9yOiByZ2JhKDE0NCwgMTY0LCAxNzQsIDApO1xcblxcdGJvcmRlci13aWR0aDogN3B4O1xcblxcdG1hcmdpbi10b3A6IC03cHg7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1sZWZ0OmFmdGVyLCAuYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtbGVmdDpiZWZvcmUge1xcbiAgbGVmdDogMTAwJTtcXG59XFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLWxlZnQ6YWZ0ZXIge1xcbiAgYm9yZGVyLWxlZnQtY29sb3I6ICNFQ0VGRjE7XFxufVxcbi5hcGV4Y2hhcnRzLXlheGlzdG9vbHRpcC1sZWZ0OmJlZm9yZSB7XFxuICBib3JkZXItbGVmdC1jb2xvcjogIzkwQTRBRTtcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLXJpZ2h0OmFmdGVyLCAuYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXG4gIHJpZ2h0OiAxMDAlO1xcbn1cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtcmlnaHQ6YWZ0ZXIge1xcbiAgYm9yZGVyLXJpZ2h0LWNvbG9yOiAjRUNFRkYxO1xcbn1cXG4uYXBleGNoYXJ0cy15YXhpc3Rvb2x0aXAtcmlnaHQ6YmVmb3JlIHtcXG4gIGJvcmRlci1yaWdodC1jb2xvcjogIzkwQTRBRTtcXG59XFxuXFxuLmFwZXhjaGFydHMteWF4aXN0b29sdGlwLmFjdGl2ZSB7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy14Y3Jvc3NoYWlycywgLmFwZXhjaGFydHMteWNyb3NzaGFpcnMge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBvcGFjaXR5OiAwO1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXhjcm9zc2hhaXJzLmFjdGl2ZSwgLmFwZXhjaGFydHMteWNyb3NzaGFpcnMuYWN0aXZlIHtcXG4gIG9wYWNpdHk6IDE7XFxuICB0cmFuc2l0aW9uOiAwLjE1cyBlYXNlIGFsbDtcXG59XFxuXFxuLmFwZXhjaGFydHMteWNyb3NzaGFpcnMtaGlkZGVuIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXpvb20tcmVjdCB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuLmFwZXhjaGFydHMtc2VsZWN0aW9uLXJlY3Qge1xcbiAgY3Vyc29yOiBtb3ZlO1xcbn1cXG5cXG4uc3ZnX3NlbGVjdF9wb2ludHMsIC5zdmdfc2VsZWN0X3BvaW50c19yb3Qge1xcbiAgb3BhY2l0eTogMDtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG59XFxuLnN2Z19zZWxlY3RfcG9pbnRzX2wsIC5zdmdfc2VsZWN0X3BvaW50c19yIHtcXG4gIGN1cnNvcjogZXctcmVzaXplO1xcbiAgb3BhY2l0eTogMTtcXG4gIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICBmaWxsOiAjODg4O1xcbn1cXG4uYXBleGNoYXJ0cy1jYW52YXMuem9vbWFibGUgLmhvdmVyaW5nLXpvb20ge1xcbiAgY3Vyc29yOiBjcm9zc2hhaXJcXG59XFxuLmFwZXhjaGFydHMtY2FudmFzLnpvb21hYmxlIC5ob3ZlcmluZy1wYW4ge1xcbiAgY3Vyc29yOiBtb3ZlXFxufVxcblxcbi5hcGV4Y2hhcnRzLXhheGlzLFxcbi5hcGV4Y2hhcnRzLXlheGlzIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy16b29tLWljb24sIFxcbi5hcGV4Y2hhcnRzLXpvb20taW4taWNvbixcXG4uYXBleGNoYXJ0cy16b29tLW91dC1pY29uLFxcbi5hcGV4Y2hhcnRzLXJlc2V0LXpvb20taWNvbiwgXFxuLmFwZXhjaGFydHMtcGFuLWljb24sIFxcbi5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uLFxcbi5hcGV4Y2hhcnRzLW1lbnUtaWNvbiwgXFxuLmFwZXhjaGFydHMtdG9vbGJhci1jdXN0b20taWNvbiB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMjBweDtcXG4gIGxpbmUtaGVpZ2h0OiAyNHB4O1xcbiAgY29sb3I6ICM2RTgxOTI7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXpvb20taWNvbiBzdmcsIFxcbi5hcGV4Y2hhcnRzLXpvb20taW4taWNvbiBzdmcsXFxuLmFwZXhjaGFydHMtem9vbS1vdXQtaWNvbiBzdmcsXFxuLmFwZXhjaGFydHMtcmVzZXQtem9vbS1pY29uIHN2ZyxcXG4uYXBleGNoYXJ0cy1tZW51LWljb24gc3ZnIHtcXG4gIGZpbGw6ICM2RTgxOTI7XFxufVxcbi5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uIHN2ZyB7XFxuICBmaWxsOiAjNDQ0O1xcbiAgdHJhbnNmb3JtOiBzY2FsZSgwLjc2KVxcbn1cXG4uYXBleGNoYXJ0cy16b29tLWljb24uc2VsZWN0ZWQgc3ZnLCBcXG4uYXBleGNoYXJ0cy1zZWxlY3Rpb24taWNvbi5zZWxlY3RlZCBzdmcsIFxcbi5hcGV4Y2hhcnRzLXJlc2V0LXpvb20taWNvbi5zZWxlY3RlZCBzdmcge1xcbiAgZmlsbDogIzAwOEZGQjtcXG59XFxuLmFwZXhjaGFydHMtc2VsZWN0aW9uLWljb246bm90KC5zZWxlY3RlZCk6aG92ZXIgc3ZnLFxcbi5hcGV4Y2hhcnRzLXpvb20taWNvbjpub3QoLnNlbGVjdGVkKTpob3ZlciBzdmcsIFxcbi5hcGV4Y2hhcnRzLXpvb20taW4taWNvbjpob3ZlciBzdmcsIFxcbi5hcGV4Y2hhcnRzLXpvb20tb3V0LWljb246aG92ZXIgc3ZnLCBcXG4uYXBleGNoYXJ0cy1yZXNldC16b29tLWljb246aG92ZXIgc3ZnLCBcXG4uYXBleGNoYXJ0cy1tZW51LWljb246aG92ZXIgc3ZnIHtcXG4gIGZpbGw6ICMzMzM7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXNlbGVjdGlvbi1pY29uLCAuYXBleGNoYXJ0cy1tZW51LWljb24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uYXBleGNoYXJ0cy1yZXNldC16b29tLWljb24ge1xcbiAgbWFyZ2luLWxlZnQ6IDVweDtcXG59XFxuLmFwZXhjaGFydHMtem9vbS1pY29uLCAuYXBleGNoYXJ0cy1yZXNldC16b29tLWljb24sIC5hcGV4Y2hhcnRzLW1lbnUtaWNvbiB7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDAuODUpO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy16b29tLWluLWljb24sIC5hcGV4Y2hhcnRzLXpvb20tb3V0LWljb24ge1xcbiAgdHJhbnNmb3JtOiBzY2FsZSgwLjcpXFxufVxcblxcbi5hcGV4Y2hhcnRzLXpvb20tb3V0LWljb24ge1xcbiAgbWFyZ2luLXJpZ2h0OiAzcHg7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXBhbi1pY29uIHtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMC42Mik7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAxcHg7XFxuICB0b3A6IDBweDtcXG59XFxuLmFwZXhjaGFydHMtcGFuLWljb24gc3ZnIHtcXG4gIGZpbGw6ICNmZmY7XFxuICBzdHJva2U6ICM2RTgxOTI7XFxuICBzdHJva2Utd2lkdGg6IDI7XFxufVxcbi5hcGV4Y2hhcnRzLXBhbi1pY29uLnNlbGVjdGVkIHN2ZyB7XFxuICBzdHJva2U6ICMwMDhGRkI7XFxufVxcbi5hcGV4Y2hhcnRzLXBhbi1pY29uOm5vdCguc2VsZWN0ZWQpOmhvdmVyIHN2ZyB7XFxuICBzdHJva2U6ICMzMzM7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2xiYXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMTE7XFxuICB0b3A6IDBweDtcXG4gIHJpZ2h0OiAzcHg7XFxuICBtYXgtd2lkdGg6IDE3NnB4O1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBwYWRkaW5nOiAwcHggNnB4IDJweCA2cHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjsgXFxufVxcblxcbi5hcGV4Y2hhcnRzLXRvb2xiYXIgc3ZnIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy1tZW51IHtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDEwMCU7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgcGFkZGluZzogM3B4O1xcbiAgcmlnaHQ6IDEwcHg7XFxuICBvcGFjaXR5OiAwO1xcbiAgbWluLXdpZHRoOiAxMTBweDtcXG4gIHRyYW5zaXRpb246IDAuMTVzIGVhc2UgYWxsO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5hcGV4Y2hhcnRzLW1lbnUub3BlbiB7XFxuICBvcGFjaXR5OiAxO1xcbiAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gIHRyYW5zaXRpb246IDAuMTVzIGVhc2UgYWxsO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy1tZW51LWl0ZW0ge1xcbiAgcGFkZGluZzogNnB4IDdweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmFwZXhjaGFydHMtbWVudS1pdGVtOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6ICNlZWU7XFxufVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAuYXBleGNoYXJ0cy10b29sYmFyIHtcXG4gICAgLypvcGFjaXR5OiAwOyovXFxuICB9XFxuXFxuICAuYXBleGNoYXJ0cy1jYW52YXM6aG92ZXIgLmFwZXhjaGFydHMtdG9vbGJhciB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9IFxcbn1cXG5cXG4uYXBleGNoYXJ0cy1kYXRhbGFiZWwuaGlkZGVuIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLXBpZS1sYWJlbCxcXG4uYXBleGNoYXJ0cy1kYXRhbGFiZWwsIC5hcGV4Y2hhcnRzLWRhdGFsYWJlbC1sYWJlbCwgLmFwZXhjaGFydHMtZGF0YWxhYmVsLXZhbHVlIHtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy1waWUtbGFiZWwtZGVsYXkge1xcbiAgb3BhY2l0eTogMDtcXG4gIGFuaW1hdGlvbi1uYW1lOiBvcGFxdWU7XFxuICBhbmltYXRpb24tZHVyYXRpb246IDAuM3M7XFxuICBhbmltYXRpb24tZmlsbC1tb2RlOiBmb3J3YXJkcztcXG4gIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2U7XFxufVxcblxcbi5hcGV4Y2hhcnRzLWNhbnZhcyAuaGlkZGVuIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcblxcbi5hcGV4Y2hhcnRzLWhpZGUgLmFwZXhjaGFydHMtc2VyaWVzLXBvaW50cyB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG5cXG4uYXBleGNoYXJ0cy1hcmVhLXNlcmllcyAuYXBleGNoYXJ0cy1zZXJpZXMtbWFya2VycyAuYXBleGNoYXJ0cy1tYXJrZXIubm8tcG9pbnRlci1ldmVudHMsXFxuLmFwZXhjaGFydHMtbGluZS1zZXJpZXMgLmFwZXhjaGFydHMtc2VyaWVzLW1hcmtlcnMgLmFwZXhjaGFydHMtbWFya2VyLm5vLXBvaW50ZXItZXZlbnRzLCAuYXBleGNoYXJ0cy1yYWRhci1zZXJpZXMgcGF0aCwgLmFwZXhjaGFydHMtcmFkYXItc2VyaWVzIHBvbHlnb24ge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi8qIG1hcmtlcnMgKi9cXG5cXG4uYXBleGNoYXJ0cy1tYXJrZXIge1xcbiAgdHJhbnNpdGlvbjogMC4xNXMgZWFzZSBhbGw7XFxufVxcblxcbkBrZXlmcmFtZXMgb3BhcXVlIHtcXG4gIDAlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcbn1cIjtcbnN0eWxlSW5qZWN0KGNzcyk7XG5cbi8qXG4gKiBjbGFzc0xpc3QuanM6IENyb3NzLWJyb3dzZXIgZnVsbCBlbGVtZW50LmNsYXNzTGlzdCBpbXBsZW1lbnRhdGlvbi5cbiAqIDEuMi4yMDE3MTIxMFxuICpcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqIExpY2Vuc2U6IERlZGljYXRlZCB0byB0aGUgcHVibGljIGRvbWFpbi5cbiAqICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4gKi9cblxuLypnbG9iYWwgc2VsZiwgZG9jdW1lbnQsIERPTUV4Y2VwdGlvbiAqL1xuXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL2NsYXNzTGlzdC5qcyAqL1xuaWYgKFwiZG9jdW1lbnRcIiBpbiBzZWxmKSB7XG4gIC8vIEZ1bGwgcG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcbiAgLy8gSW5jbHVkaW5nIElFIDwgRWRnZSBtaXNzaW5nIFNWR0VsZW1lbnQuY2xhc3NMaXN0XG4gIGlmICghKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIikpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiAhKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpKSkge1xuICAgIChmdW5jdGlvbiAodmlldykge1xuXG4gICAgICBpZiAoISgnRWxlbWVudCcgaW4gdmlldykpIHJldHVybjtcblxuICAgICAgdmFyIGNsYXNzTGlzdFByb3AgPSBcImNsYXNzTGlzdFwiLFxuICAgICAgICAgIHByb3RvUHJvcCA9IFwicHJvdG90eXBlXCIsXG4gICAgICAgICAgZWxlbUN0clByb3RvID0gdmlldy5FbGVtZW50W3Byb3RvUHJvcF0sXG4gICAgICAgICAgb2JqQ3RyID0gT2JqZWN0LFxuICAgICAgICAgIHN0clRyaW0gPSBTdHJpbmdbcHJvdG9Qcm9wXS50cmltIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgICB9LFxuICAgICAgICAgIGFyckluZGV4T2YgPSBBcnJheVtwcm90b1Byb3BdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSAvLyBWZW5kb3JzOiBwbGVhc2UgYWxsb3cgY29udGVudCBjb2RlIHRvIGluc3RhbnRpYXRlIERPTUV4Y2VwdGlvbnNcbiAgICAgICxcbiAgICAgICAgICBET01FeCA9IGZ1bmN0aW9uIERPTUV4KHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gdHlwZTtcbiAgICAgICAgdGhpcy5jb2RlID0gRE9NRXhjZXB0aW9uW3R5cGVdO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgfSxcbiAgICAgICAgICBjaGVja1Rva2VuQW5kR2V0SW5kZXggPSBmdW5jdGlvbiBjaGVja1Rva2VuQW5kR2V0SW5kZXgoY2xhc3NMaXN0LCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXgoXCJTWU5UQVhfRVJSXCIsIFwiVGhlIHRva2VuIG11c3Qgbm90IGJlIGVtcHR5LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgvXFxzLy50ZXN0KHRva2VuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeChcIklOVkFMSURfQ0hBUkFDVEVSX0VSUlwiLCBcIlRoZSB0b2tlbiBtdXN0IG5vdCBjb250YWluIHNwYWNlIGNoYXJhY3RlcnMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyckluZGV4T2YuY2FsbChjbGFzc0xpc3QsIHRva2VuKTtcbiAgICAgIH0sXG4gICAgICAgICAgQ2xhc3NMaXN0ID0gZnVuY3Rpb24gQ2xhc3NMaXN0KGVsZW0pIHtcbiAgICAgICAgdmFyIHRyaW1tZWRDbGFzc2VzID0gc3RyVHJpbS5jYWxsKGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiksXG4gICAgICAgICAgICBjbGFzc2VzID0gdHJpbW1lZENsYXNzZXMgPyB0cmltbWVkQ2xhc3Nlcy5zcGxpdCgvXFxzKy8pIDogW10sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGNsYXNzZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnB1c2goY2xhc3Nlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgICAgICBjbGFzc0xpc3RQcm90byA9IENsYXNzTGlzdFtwcm90b1Byb3BdID0gW10sXG4gICAgICAgICAgY2xhc3NMaXN0R2V0dGVyID0gZnVuY3Rpb24gY2xhc3NMaXN0R2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IENsYXNzTGlzdCh0aGlzKTtcbiAgICAgIH07IC8vIE1vc3QgRE9NRXhjZXB0aW9uIGltcGxlbWVudGF0aW9ucyBkb24ndCBhbGxvdyBjYWxsaW5nIERPTUV4Y2VwdGlvbidzIHRvU3RyaW5nKClcbiAgICAgIC8vIG9uIG5vbi1ET01FeGNlcHRpb25zLiBFcnJvcidzIHRvU3RyaW5nKCkgaXMgc3VmZmljaWVudCBoZXJlLlxuXG5cbiAgICAgIERPTUV4W3Byb3RvUHJvcF0gPSBFcnJvcltwcm90b1Byb3BdO1xuXG4gICAgICBjbGFzc0xpc3RQcm90by5pdGVtID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbaV0gfHwgbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB+Y2hlY2tUb2tlbkFuZEdldEluZGV4KHRoaXMsIHRva2VuICsgXCJcIik7XG4gICAgICB9O1xuXG4gICAgICBjbGFzc0xpc3RQcm90by5hZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICB1cGRhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcblxuICAgICAgICAgIGlmICghfmNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCsraSA8IGwpO1xuXG4gICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbCA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHVwZGF0ZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGluZGV4O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXSArIFwiXCI7XG4gICAgICAgICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xuXG4gICAgICAgICAgd2hpbGUgKH5pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgrK2kgPCBsKTtcblxuICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjbGFzc0xpc3RQcm90by50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRhaW5zKHRva2VuKSxcbiAgICAgICAgICAgIG1ldGhvZCA9IHJlc3VsdCA/IGZvcmNlICE9PSB0cnVlICYmIFwicmVtb3ZlXCIgOiBmb3JjZSAhPT0gZmFsc2UgJiYgXCJhZGRcIjtcblxuICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgdGhpc1ttZXRob2RdKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JjZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZm9yY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiAodG9rZW4sIHJlcGxhY2VtZW50X3Rva2VuKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0b2tlbiArIFwiXCIpO1xuXG4gICAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnNwbGljZShpbmRleCwgMSwgcmVwbGFjZW1lbnRfdG9rZW4pO1xuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNsYXNzTGlzdFByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKFwiIFwiKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGNsYXNzTGlzdFByb3BEZXNjID0ge1xuICAgICAgICAgIGdldDogY2xhc3NMaXN0R2V0dGVyLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgLy8gSUUgOCBkb2Vzbid0IHN1cHBvcnQgZW51bWVyYWJsZTp0cnVlXG4gICAgICAgICAgLy8gYWRkaW5nIHVuZGVmaW5lZCB0byBmaWdodCB0aGlzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9pc3N1ZXMvMzZcbiAgICAgICAgICAvLyBtb2Rlcm5pZSBJRTgtTVNXNyBtYWNoaW5lIGhhcyBJRTggOC4wLjYwMDEuMTg3MDIgYW5kIGlzIGFmZmVjdGVkXG4gICAgICAgICAgaWYgKGV4Lm51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGV4Lm51bWJlciA9PT0gLTB4N0ZGNUVDNTQpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2JqQ3RyW3Byb3RvUHJvcF0uX19kZWZpbmVHZXR0ZXJfXykge1xuICAgICAgICBlbGVtQ3RyUHJvdG8uX19kZWZpbmVHZXR0ZXJfXyhjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RHZXR0ZXIpO1xuICAgICAgfVxuICAgIH0pKHNlbGYpO1xuICB9IC8vIFRoZXJlIGlzIGZ1bGwgb3IgcGFydGlhbCBuYXRpdmUgY2xhc3NMaXN0IHN1cHBvcnQsIHNvIGp1c3QgY2hlY2sgaWYgd2UgbmVlZFxuICAvLyB0byBub3JtYWxpemUgdGhlIGFkZC9yZW1vdmUgYW5kIHRvZ2dsZSBBUElzLlxuXG5cbiAgKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpO1xuICAgIHRlc3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjMVwiLCBcImMyXCIpOyAvLyBQb2x5ZmlsbCBmb3IgSUUgMTAvMTEgYW5kIEZpcmVmb3ggPDI2LCB3aGVyZSBjbGFzc0xpc3QuYWRkIGFuZFxuICAgIC8vIGNsYXNzTGlzdC5yZW1vdmUgZXhpc3QgYnV0IHN1cHBvcnQgb25seSBvbmUgYXJndW1lbnQgYXQgYSB0aW1lLlxuXG4gICAgaWYgKCF0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjMlwiKSkge1xuICAgICAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZChtZXRob2QpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZVttZXRob2RdO1xuXG4gICAgICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIG9yaWdpbmFsLmNhbGwodGhpcywgdG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNyZWF0ZU1ldGhvZCgnYWRkJyk7XG4gICAgICBjcmVhdGVNZXRob2QoJ3JlbW92ZScpO1xuICAgIH1cblxuICAgIHRlc3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJjM1wiLCBmYWxzZSk7IC8vIFBvbHlmaWxsIGZvciBJRSAxMCBhbmQgRmlyZWZveCA8MjQsIHdoZXJlIGNsYXNzTGlzdC50b2dnbGUgZG9lcyBub3RcbiAgICAvLyBzdXBwb3J0IHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cbiAgICBpZiAodGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzNcIikpIHtcbiAgICAgIHZhciBfdG9nZ2xlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGU7XG5cbiAgICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKHRva2VuLCBmb3JjZSkge1xuICAgICAgICBpZiAoMSBpbiBhcmd1bWVudHMgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcbiAgICAgICAgICByZXR1cm4gZm9yY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAvLyByZXBsYWNlKCkgcG9seWZpbGxcblxuXG4gICAgaWYgKCEoXCJyZXBsYWNlXCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIikuY2xhc3NMaXN0KSkge1xuICAgICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHRva2VuLCByZXBsYWNlbWVudF90b2tlbikge1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgICAgIGluZGV4ID0gdG9rZW5zLmluZGV4T2YodG9rZW4gKyBcIlwiKTtcblxuICAgICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICB0aGlzLnJlbW92ZS5hcHBseSh0aGlzLCB0b2tlbnMpO1xuICAgICAgICAgIHRoaXMuYWRkKHJlcGxhY2VtZW50X3Rva2VuKTtcbiAgICAgICAgICB0aGlzLmFkZC5hcHBseSh0aGlzLCB0b2tlbnMuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRlc3RFbGVtZW50ID0gbnVsbDtcbiAgfSkoKTtcbn1cblxuLyoqXG4qIERldGVjdCBFbGVtZW50IFJlc2l6ZVxuKlxuKiBodHRwczovL2dpdGh1Yi5jb20vc2RlY2ltYS9qYXZhc2NyaXB0LWRldGVjdC1lbGVtZW50LXJlc2l6ZVxuKiBTZWJhc3RpYW4gRGVjaW1hXG4qXG4qIHZlcnNpb246IDAuNS4zXG4qKi9cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHlsZXNDcmVhdGVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gcmVzZXRUcmlnZ2VycyhlbGVtZW50KSB7XG4gICAgdmFyIHRyaWdnZXJzID0gZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18sXG4gICAgICAgIGV4cGFuZCA9IHRyaWdnZXJzLmZpcnN0RWxlbWVudENoaWxkLFxuICAgICAgICBjb250cmFjdCA9IHRyaWdnZXJzLmxhc3RFbGVtZW50Q2hpbGQsXG4gICAgICAgIGV4cGFuZENoaWxkID0gZXhwYW5kLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIGNvbnRyYWN0LnNjcm9sbExlZnQgPSBjb250cmFjdC5zY3JvbGxXaWR0aDtcbiAgICBjb250cmFjdC5zY3JvbGxUb3AgPSBjb250cmFjdC5zY3JvbGxIZWlnaHQ7XG4gICAgZXhwYW5kQ2hpbGQuc3R5bGUud2lkdGggPSBleHBhbmQub2Zmc2V0V2lkdGggKyAxICsgJ3B4JztcbiAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSBleHBhbmQub2Zmc2V0SGVpZ2h0ICsgMSArICdweCc7XG4gICAgZXhwYW5kLnNjcm9sbExlZnQgPSBleHBhbmQuc2Nyb2xsV2lkdGg7XG4gICAgZXhwYW5kLnNjcm9sbFRvcCA9IGV4cGFuZC5zY3JvbGxIZWlnaHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1RyaWdnZXJzKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRXaWR0aCAhPSBlbGVtZW50Ll9fcmVzaXplTGFzdF9fLndpZHRoIHx8IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICE9IGVsZW1lbnQuX19yZXNpemVMYXN0X18uaGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsTGlzdGVuZXIoZSkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcztcbiAgICByZXNldFRyaWdnZXJzKHRoaXMpO1xuICAgIGlmICh0aGlzLl9fcmVzaXplUkFGX18pIGNhbmNlbEZyYW1lKHRoaXMuX19yZXNpemVSQUZfXyk7XG4gICAgdGhpcy5fX3Jlc2l6ZVJBRl9fID0gcmVxdWVzdEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjaGVja1RyaWdnZXJzKGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuX19yZXNpemVMYXN0X18ud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBlbGVtZW50Ll9fcmVzaXplTGFzdF9fLmhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIGZuLmNhbGwoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3R5bGVzKCkge1xuICAgIGlmICghc3R5bGVzQ3JlYXRlZCkge1xuICAgICAgLy8gb3BhY2l0eTowIHdvcmtzIGFyb3VuZCBhIGNocm9tZSBidWcgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI4NjM2MFxuICAgICAgdmFyIGNzcyA9IChhbmltYXRpb25LZXlmcmFtZXMgfHwgJycpICsgJy5yZXNpemUtdHJpZ2dlcnMgeyAnICsgKGFuaW1hdGlvblN0eWxlIHx8ICcnKSArICd2aXNpYmlsaXR5OiBoaWRkZW47IG9wYWNpdHk6IDA7IH0gJyArICcucmVzaXplLXRyaWdnZXJzLCAucmVzaXplLXRyaWdnZXJzID4gZGl2LCAuY29udHJhY3QtdHJpZ2dlcjpiZWZvcmUgeyBjb250ZW50OiBcXFwiIFxcXCI7IGRpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgaGVpZ2h0OiAxMDAlOyB3aWR0aDogMTAwJTsgb3ZlcmZsb3c6IGhpZGRlbjsgfSAucmVzaXplLXRyaWdnZXJzID4gZGl2IHsgYmFja2dyb3VuZDogI2VlZTsgb3ZlcmZsb3c6IGF1dG87IH0gLmNvbnRyYWN0LXRyaWdnZXI6YmVmb3JlIHsgd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJTsgfScsXG4gICAgICAgICAgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSxcbiAgICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgICB9XG5cbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgc3R5bGVzQ3JlYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlcXVlc3RGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIDIwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIHJhZihmbik7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBjYW5jZWxGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuY2VsID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LmNsZWFyVGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gY2FuY2VsKGlkKTtcbiAgICB9O1xuICB9KCk7XG4gIC8qIERldGVjdCBDU1MgQW5pbWF0aW9ucyBzdXBwb3J0IHRvIGRldGVjdCBlbGVtZW50IGRpc3BsYXkvcmUtYXR0YWNoICovXG5cblxuICB2YXIgYW5pbWF0aW9uID0gZmFsc2UsXG4gICAgICBrZXlmcmFtZXByZWZpeCA9ICcnLFxuICAgICAgYW5pbWF0aW9uc3RhcnRldmVudCA9ICdhbmltYXRpb25zdGFydCcsXG4gICAgICBkb21QcmVmaXhlcyA9ICdXZWJraXQgTW96IE8gbXMnLnNwbGl0KCcgJyksXG4gICAgICBzdGFydEV2ZW50cyA9ICd3ZWJraXRBbmltYXRpb25TdGFydCBhbmltYXRpb25zdGFydCBvQW5pbWF0aW9uU3RhcnQgTVNBbmltYXRpb25TdGFydCcuc3BsaXQoJyAnKSxcbiAgICAgIHBmeCA9ICcnO1xuICB7XG4gICAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zha2VlbGVtZW50Jyk7XG5cbiAgICBpZiAoZWxtLnN0eWxlLmFuaW1hdGlvbk5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYW5pbWF0aW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21QcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxtLnN0eWxlW2RvbVByZWZpeGVzW2ldICsgJ0FuaW1hdGlvbk5hbWUnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGZ4ID0gZG9tUHJlZml4ZXNbaV07XG4gICAgICAgICAga2V5ZnJhbWVwcmVmaXggPSAnLScgKyBwZngudG9Mb3dlckNhc2UoKSArICctJztcbiAgICAgICAgICBhbmltYXRpb25zdGFydGV2ZW50ID0gc3RhcnRFdmVudHNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGFuaW1hdGlvbk5hbWUgPSAncmVzaXplYW5pbSc7XG4gIHZhciBhbmltYXRpb25LZXlmcmFtZXMgPSAnQCcgKyBrZXlmcmFtZXByZWZpeCArICdrZXlmcmFtZXMgJyArIGFuaW1hdGlvbk5hbWUgKyAnIHsgZnJvbSB7IG9wYWNpdHk6IDA7IH0gdG8geyBvcGFjaXR5OiAwOyB9IH0gJztcbiAgdmFyIGFuaW1hdGlvblN0eWxlID0ga2V5ZnJhbWVwcmVmaXggKyAnYW5pbWF0aW9uOiAxbXMgJyArIGFuaW1hdGlvbk5hbWUgKyAnOyAnO1xuXG4gIHdpbmRvdy5hZGRSZXNpemVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBmbikge1xuICAgIGlmICghZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18pIHtcbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09ICdzdGF0aWMnKSBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIGNyZWF0ZVN0eWxlcygpO1xuICAgICAgZWxlbWVudC5fX3Jlc2l6ZUxhc3RfXyA9IHt9O1xuICAgICAgZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fID0gW107XG4gICAgICAoZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkuY2xhc3NOYW1lID0gJ3Jlc2l6ZS10cmlnZ2Vycyc7XG4gICAgICBlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcnNfXy5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImV4cGFuZC10cmlnZ2VyXCI+PGRpdj48L2Rpdj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJjb250cmFjdC10cmlnZ2VyXCI+PC9kaXY+JztcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18pO1xuICAgICAgcmVzZXRUcmlnZ2VycyhlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsTGlzdGVuZXIsIHRydWUpO1xuICAgICAgLyogTGlzdGVuIGZvciBhIGNzcyBhbmltYXRpb24gdG8gZGV0ZWN0IGVsZW1lbnQgZGlzcGxheS9yZS1hdHRhY2ggKi9cblxuICAgICAgYW5pbWF0aW9uc3RhcnRldmVudCAmJiBlbGVtZW50Ll9fcmVzaXplVHJpZ2dlcnNfXy5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGlvbnN0YXJ0ZXZlbnQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmFuaW1hdGlvbk5hbWUgPT0gYW5pbWF0aW9uTmFtZSkge1xuICAgICAgICAgIHJlc2V0VHJpZ2dlcnMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5wdXNoKGZuKTtcbiAgfTtcblxuICB3aW5kb3cucmVtb3ZlUmVzaXplTGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZm4pIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fLnNwbGljZShlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX18uaW5kZXhPZihmbiksIDEpO1xuXG4gICAgICBpZiAoIWVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxMaXN0ZW5lcik7XG4gICAgICAgIGVsZW1lbnQuX19yZXNpemVUcmlnZ2Vyc19fID0gIWVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5fX3Jlc2l6ZVRyaWdnZXJzX18pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbndpbmRvdy5BcGV4ID0ge307XG4vKipcbiAqXG4gKiBAbW9kdWxlIEFwZXhDaGFydHNcbiAqKi9cblxudmFyIEFwZXhDaGFydHMkMSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFwZXhDaGFydHMoZWwsIG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXBleENoYXJ0cyk7XG5cbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMuY3R4ID0gdGhpczsgLy8gUGFzcyB0aGUgdXNlciBzdXBwbGllZCBvcHRpb25zIHRvIHRoZSBCYXNlIENsYXNzIHdoZXJlIHRoZXNlIG9wdGlvbnMgd2lsbCBiZSBleHRlbmRlZCB3aXRoIGRlZmF1bHRzLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGZyb20gQmFzZSBDbGFzcyB3aWxsIGJlY29tZSB0aGUgY29uZmlnIG9iamVjdCBpbiB0aGUgZW50aXJlIGNvZGViYXNlLlxuXG4gICAgdGhpcy53ID0gbmV3IEJhc2Uob3B0cykuaW5pdCgpO1xuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLncuZ2xvYmFscy5jdWlkID0gKE1hdGgucmFuZG9tKCkgKyAxKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDQpO1xuICAgIHRoaXMudy5nbG9iYWxzLmNoYXJ0SUQgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmlkID8gdGhpcy53LmNvbmZpZy5jaGFydC5pZCA6IHRoaXMudy5nbG9iYWxzLmN1aWQ7XG4gICAgdGhpcy5pbml0TW9kdWxlcygpO1xuICAgIHRoaXMuY3JlYXRlID0gVXRpbHMuYmluZCh0aGlzLmNyZWF0ZSwgdGhpcyk7XG4gICAgdGhpcy53aW5kb3dSZXNpemVIYW5kbGVyID0gdGhpcy53aW5kb3dSZXNpemUuYmluZCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHByaW1hcnkgbWV0aG9kIHVzZXIgd2lsbCBjYWxsIHRvIHJlbmRlciB0aGUgY2hhcnQuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEFwZXhDaGFydHMsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBtYWluIG1ldGhvZFxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbmx5IGRyYXcgY2hhcnQsIGlmIGVsZW1lbnQgZm91bmRcbiAgICAgICAgaWYgKF90aGlzLmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBBcGV4Ll9jaGFydEluc3RhbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIEFwZXguX2NoYXJ0SW5zdGFuY2VzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzLncuY29uZmlnLmNoYXJ0LmlkKSB7XG4gICAgICAgICAgICBBcGV4Ll9jaGFydEluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IF90aGlzLncuZ2xvYmFscy5jaGFydElELFxuICAgICAgICAgICAgICBncm91cDogX3RoaXMudy5jb25maWcuY2hhcnQuZ3JvdXAsXG4gICAgICAgICAgICAgIGNoYXJ0OiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBzZXQgdGhlIGxvY2FsZSBoZXJlXG5cblxuICAgICAgICAgIF90aGlzLnNldExvY2FsZShfdGhpcy53LmNvbmZpZy5jaGFydC5kZWZhdWx0TG9jYWxlKTtcblxuICAgICAgICAgIHZhciBiZWZvcmVNb3VudCA9IF90aGlzLncuY29uZmlnLmNoYXJ0LmV2ZW50cy5iZWZvcmVNb3VudDtcblxuICAgICAgICAgIGlmICh0eXBlb2YgYmVmb3JlTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGJlZm9yZU1vdW50KF90aGlzLCBfdGhpcy53KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5maXJlRXZlbnQoJ2JlZm9yZU1vdW50JywgW190aGlzLCBfdGhpcy53XSk7XG5cbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgX3RoaXMud2luZG93UmVzaXplSGFuZGxlcik7XG4gICAgICAgICAgd2luZG93LmFkZFJlc2l6ZUxpc3RlbmVyKF90aGlzLmVsLnBhcmVudE5vZGUsIF90aGlzLnBhcmVudFJlc2l6ZUNhbGxiYWNrLmJpbmQoX3RoaXMpKTtcblxuICAgICAgICAgIHZhciBncmFwaERhdGEgPSBfdGhpcy5jcmVhdGUoX3RoaXMudy5jb25maWcuc2VyaWVzLCB7fSk7XG5cbiAgICAgICAgICBpZiAoIWdyYXBoRGF0YSkgcmV0dXJuIHJlc29sdmUoX3RoaXMpO1xuXG4gICAgICAgICAgX3RoaXMubW91bnQoZ3JhcGhEYXRhKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUoZ3JhcGhEYXRhKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy53LmNvbmZpZy5jaGFydC5ldmVudHMubW91bnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBfdGhpcy53LmNvbmZpZy5jaGFydC5ldmVudHMubW91bnRlZChfdGhpcywgX3RoaXMudyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLmZpcmVFdmVudCgnbW91bnRlZCcsIFtfdGhpcywgX3RoaXMud10pO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7IC8vIGhhbmRsZSBlcnJvciBpbiBjYXNlIG5vIGRhdGEgb3IgZWxlbWVudCBub3QgZm91bmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdFbGVtZW50IG5vdCBmb3VuZCcpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRNb2R1bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRNb2R1bGVzKCkge1xuICAgICAgdGhpcy5hbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jdHgpO1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IG5ldyBBbm5vdGF0aW9ucyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmNvcmUgPSBuZXcgQ29yZSh0aGlzLmVsLCB0aGlzKTtcbiAgICAgIHRoaXMuZ3JpZCA9IG5ldyBHcmlkKHRoaXMpO1xuICAgICAgdGhpcy5jb3JlVXRpbHMgPSBuZXcgQ29yZVV0aWxzKHRoaXMpO1xuICAgICAgdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHt9KTtcbiAgICAgIHRoaXMuY3Jvc3NoYWlycyA9IG5ldyBDcm9zc2hhaXJzKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBPcHRpb25zKCk7XG4gICAgICB0aGlzLnJlc3BvbnNpdmUgPSBuZXcgUmVzcG9uc2l2ZSh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnNlcmllcyA9IG5ldyBTZXJpZXModGhpcy5jdHgpO1xuICAgICAgdGhpcy50aGVtZSA9IG5ldyBUaGVtZSh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmZvcm1hdHRlcnMgPSBuZXcgRm9ybWF0dGVycyh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnRpdGxlU3VidGl0bGUgPSBuZXcgVGl0bGVTdWJ0aXRsZSh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5jdHgpO1xuICAgICAgdGhpcy50b29sYmFyID0gbmV3IFRvb2xiYXIodGhpcy5jdHgpO1xuICAgICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnModGhpcy5jdHgpO1xuICAgICAgdGhpcy56b29tUGFuU2VsZWN0aW9uID0gbmV3IFpvb21QYW5TZWxlY3Rpb24odGhpcy5jdHgpO1xuICAgICAgdGhpcy53Lmdsb2JhbHMudG9vbHRpcCA9IG5ldyBUb29sdGlwKHRoaXMuY3R4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5hbWUkJDEsIGhhbmRsZXIpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAody5nbG9iYWxzLmV2ZW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lJCQxKSkge1xuICAgICAgICB3Lmdsb2JhbHMuZXZlbnRzW25hbWUkJDFdLnB1c2goaGFuZGxlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lmdsb2JhbHMuZXZlbnRzW25hbWUkJDFdID0gW2hhbmRsZXJdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSQkMSwgaGFuZGxlcikge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmV2ZW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lJCQxKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IHcuZ2xvYmFscy5ldmVudHNbbmFtZSQkMV0uaW5kZXhPZihoYW5kbGVyKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB3Lmdsb2JhbHMuZXZlbnRzW25hbWUkJDFdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcmVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlRXZlbnQobmFtZSQkMSwgYXJncykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmICghdy5nbG9iYWxzLmV2ZW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lJCQxKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghYXJncyB8fCAhYXJncy5sZW5ndGgpIHtcbiAgICAgICAgYXJncyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZzID0gdy5nbG9iYWxzLmV2ZW50c1tuYW1lJCQxXTtcbiAgICAgIHZhciBsID0gZXZzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgZXZzW2ldLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHNlciwgb3B0cykge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB0aGlzLmluaXRNb2R1bGVzKCk7XG4gICAgICB2YXIgZ2wgPSB0aGlzLncuZ2xvYmFscztcbiAgICAgIGdsLm5vRGF0YSA9IGZhbHNlO1xuICAgICAgZ2wuYW5pbWF0aW9uRW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZS5jaGVja1Jlc3BvbnNpdmVDb25maWcob3B0cyk7XG5cbiAgICAgIGlmICh0aGlzLmVsID09PSBudWxsKSB7XG4gICAgICAgIGdsLmFuaW1hdGlvbkVuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29yZS5zZXR1cEVsZW1lbnRzKCk7XG5cbiAgICAgIGlmIChnbC5zdmdXaWR0aCA9PT0gMCkge1xuICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBoaWRkZW4sIHNraXAgZHJhd2luZ1xuICAgICAgICBnbC5hbmltYXRpb25FbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tYm8gPSBDb3JlVXRpbHMuY2hlY2tDb21ib1NlcmllcyhzZXIpO1xuICAgICAgZ2wuY29tYm9DaGFydHMgPSBjb21iby5jb21ib0NoYXJ0cztcbiAgICAgIGdsLmNvbWJvQ2hhcnRzSGFzQmFycyA9IGNvbWJvLmNvbWJvQ2hhcnRzSGFzQmFycztcblxuICAgICAgaWYgKHNlci5sZW5ndGggPT09IDAgfHwgc2VyLmxlbmd0aCA9PT0gMSAmJiBzZXJbMF0uZGF0YSAmJiBzZXJbMF0uZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXJpZXMuaGFuZGxlTm9EYXRhKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0dXBFdmVudEhhbmRsZXJzKCk7XG4gICAgICB0aGlzLmNvcmUucGFyc2VEYXRhKHNlcik7IC8vIHRoaXMgaXMgYSBnb29kIHRpbWUgdG8gc2V0IHRoZW1lIGNvbG9ycyBmaXJzdFxuXG4gICAgICB0aGlzLnRoZW1lLmluaXQoKTsgLy8gbGFiZWxGb3JtYXR0ZXJzIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGRpbWVuc2lvbnMgYXMgaW4gZGltZW5zaW9ucyB3ZSBuZWVkIHRleHQgbGFiZWxzIHdpZHRoXG4gICAgICAvLyBhcyBtYXJrZXJzIGFjY2VwdHMgYXJyYXksIHdlIG5lZWQgdG8gc2V0dXAgZ2xvYmFsIG1hcmtlcnMgZm9yIGVhc2llciBhY2Nlc3NcblxuICAgICAgdmFyIG1hcmtlcnMgPSBuZXcgTWFya2Vycyh0aGlzKTtcbiAgICAgIG1hcmtlcnMuc2V0R2xvYmFsTWFya2VyU2l6ZSgpO1xuICAgICAgdGhpcy5mb3JtYXR0ZXJzLnNldExhYmVsRm9ybWF0dGVycygpO1xuICAgICAgdGhpcy50aXRsZVN1YnRpdGxlLmRyYXcoKTsgLy8gbGVnZW5kIGlzIGNhbGN1bGF0ZWQgaGVyZSBiZWZvcmUgY29yZUNhbGN1bGF0aW9ucyBiZWNhdXNlIGl0IGFmZmVjdHMgdGhlIHBsb3R0YWJsZSBhcmVhXG5cbiAgICAgIHRoaXMubGVnZW5kLmluaXQoKTsgLy8gY2hlY2sgd2hldGhlciBpbiBtdWx0aXBsZSBzZXJpZXMsIGFsbCBzZXJpZXMgc2hhcmUgdGhlIHNhbWUgWFxuXG4gICAgICB0aGlzLnNlcmllcy5oYXNBbGxTZXJpZXNFcXVhbFgoKTsgLy8gY29yZUNhbGN1bGF0aW9ucyB3aWxsIGdpdmUgdGhlIG1pbi9tYXggcmFuZ2UgYW5kIHlheGlzL2F4aXMgdmFsdWVzLiBJdCBzaG91bGQgYmUgY2FsbGVkIGhlcmUgdG8gc2V0IHNlcmllcyB2YXJpYWJsZSBmcm9tIGNvbmZpZyB0byBnbG9iYWxzXG5cbiAgICAgIGlmIChnbC5heGlzQ2hhcnRzKSB7XG4gICAgICAgIHRoaXMuY29yZS5jb3JlQ2FsY3VsYXRpb25zKCk7XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLnhheGlzLnR5cGUgIT09ICdjYXRlZ29yeScpIHtcbiAgICAgICAgICAvLyBhcyB3ZSBoYXZlIG1pblggYW5kIG1heFggdmFsdWVzLCBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgRGF0ZVRpbWVGb3JtYXQgZm9yIHRpbWUgc2VyaWVzXG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZXJzLnNldExhYmVsRm9ybWF0dGVycygpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHdlIG5lZWQgdG8gZ2VuZXJhdGUgeWF4aXMgZm9yIGhlYXRtYXAgc2VwYXJhdGVseSBhcyB3ZSBhcmUgbm90IHNob3dpbmcgbnVtZXJpY3MgdGhlcmUsIGJ1dCBzZXJpZXNOYW1lcy4gVGhlcmUgYXJlIHNvbWUgdHdlYWtzIHdoaWNoIGFyZSByZXF1aXJlZCBmb3IgaGVhdG1hcCB0byBhbGlnbiBsYWJlbHMgY29ycmVjdGx5IHdoaWNoIGFyZSBkb25lIGluIGJlbG93IGZ1bmN0aW9uXG4gICAgICAvLyBBbHNvIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgY2FsY3V0aW5nIERpbWVudGlvbnMgcGxvdENvb3JkcygpIG1ldGhvZCBvZiBEaW1lbnNpb25zXG5cblxuICAgICAgdGhpcy5mb3JtYXR0ZXJzLmhlYXRtYXBMYWJlbEZvcm1hdHRlcnMoKTsgLy8gV2UgZ290IHBsb3R0YWJsZSBhcmVhIGhlcmUsIG5leHQgdGFzayB3b3VsZCBiZSB0byBjYWxjdWxhdGUgYXhpcyBhcmVhc1xuXG4gICAgICB0aGlzLmRpbWVuc2lvbnMucGxvdENvb3JkcygpO1xuICAgICAgdmFyIHh5UmF0aW9zID0gdGhpcy5jb3JlLnh5U2V0dGluZ3MoKTtcbiAgICAgIHRoaXMuZ3JpZC5jcmVhdGVHcmlkTWFzaygpO1xuICAgICAgdmFyIGVsR3JhcGggPSB0aGlzLmNvcmUucGxvdENoYXJ0VHlwZShzZXIsIHh5UmF0aW9zKTsgLy8gYWZ0ZXIgYWxsIHRoZSBkcmF3aW5nIGNhbGN1bGF0aW9ucywgc2hpZnQgdGhlIGdyYXBoaWNhbCBhcmVhIChhY3R1YWwgY2hhcnRzL2JhcnMpIGV4Y2x1ZGluZyBsZWdlbmRzXG5cbiAgICAgIHRoaXMuY29yZS5zaGlmdEdyYXBoUG9zaXRpb24oKTtcbiAgICAgIHZhciBkaW0gPSB7XG4gICAgICAgIHBsb3Q6IHtcbiAgICAgICAgICBsZWZ0OiB3Lmdsb2JhbHMudHJhbnNsYXRlWCxcbiAgICAgICAgICB0b3A6IHcuZ2xvYmFscy50cmFuc2xhdGVZLFxuICAgICAgICAgIHdpZHRoOiB3Lmdsb2JhbHMuZ3JpZFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogdy5nbG9iYWxzLmdyaWRIZWlnaHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsR3JhcGg6IGVsR3JhcGgsXG4gICAgICAgIHh5UmF0aW9zOiB4eVJhdGlvcyxcbiAgICAgICAgZWxJbm5lcjogdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbCxcbiAgICAgICAgZGltZW5zaW9uczogZGltXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHZhciBncmFwaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIHcgPSBtZS53O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBubyBkYXRhIHRvIGRpc3BsYXlcbiAgICAgICAgaWYgKG1lLmVsID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vdCBlbm91Z2ggZGF0YSB0byBkaXNwbGF5IG9yIHRhcmdldCBlbGVtZW50IG5vdCBmb3VuZCcpKTtcbiAgICAgICAgfSBlbHNlIGlmIChncmFwaERhdGEgPT09IG51bGwgfHwgdy5nbG9iYWxzLmFsbFNlcmllc0NvbGxhcHNlZCkge1xuICAgICAgICAgIG1lLnNlcmllcy5oYW5kbGVOb0RhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmNvcmUuZHJhd0F4aXMody5jb25maWcuY2hhcnQudHlwZSwgZ3JhcGhEYXRhLnh5UmF0aW9zKTtcbiAgICAgICAgbWUuZ3JpZCA9IG5ldyBHcmlkKG1lKTtcblxuICAgICAgICBpZiAody5jb25maWcuZ3JpZC5wb3NpdGlvbiA9PT0gJ2JhY2snKSB7XG4gICAgICAgICAgbWUuZ3JpZC5kcmF3R3JpZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcuY29uZmlnLmFubm90YXRpb25zLnBvc2l0aW9uID09PSAnYmFjaycpIHtcbiAgICAgICAgICBtZS5hbm5vdGF0aW9ucy5kcmF3QW5ub3RhdGlvbnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncmFwaERhdGEuZWxHcmFwaCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBncmFwaERhdGEuZWxHcmFwaC5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgdy5nbG9iYWxzLmRvbS5lbEdyYXBoaWNhbC5hZGQoZ3JhcGhEYXRhLmVsR3JhcGhbZ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3Lmdsb2JhbHMuZG9tLmVsR3JhcGhpY2FsLmFkZChncmFwaERhdGEuZWxHcmFwaCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAody5jb25maWcuZ3JpZC5wb3NpdGlvbiA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgIG1lLmdyaWQuZHJhd0dyaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy54YXhpcy5jcm9zc2hhaXJzLnBvc2l0aW9uID09PSAnZnJvbnQnKSB7XG4gICAgICAgICAgbWUuY3Jvc3NoYWlycy5kcmF3WENyb3NzaGFpcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy55YXhpc1swXS5jcm9zc2hhaXJzLnBvc2l0aW9uID09PSAnZnJvbnQnKSB7XG4gICAgICAgICAgbWUuY3Jvc3NoYWlycy5kcmF3WUNyb3NzaGFpcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3LmNvbmZpZy5hbm5vdGF0aW9ucy5wb3NpdGlvbiA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgIG1lLmFubm90YXRpb25zLmRyYXdBbm5vdGF0aW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3Lmdsb2JhbHMubm9EYXRhKSB7XG4gICAgICAgICAgLy8gZHJhdyB0b29sdGlwcyBhdCB0aGUgZW5kXG4gICAgICAgICAgaWYgKHcuY29uZmlnLnRvb2x0aXAuZW5hYmxlZCAmJiAhdy5nbG9iYWxzLm5vRGF0YSkge1xuICAgICAgICAgICAgbWUudy5nbG9iYWxzLnRvb2x0aXAuZHJhd1Rvb2x0aXAoZ3JhcGhEYXRhLnh5UmF0aW9zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAody5nbG9iYWxzLmF4aXNDaGFydHMgJiYgdy5nbG9iYWxzLmlzWE51bWVyaWMpIHtcbiAgICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC56b29tLmVuYWJsZWQgfHwgdy5jb25maWcuY2hhcnQuc2VsZWN0aW9uICYmIHcuY29uZmlnLmNoYXJ0LnNlbGVjdGlvbi5lbmFibGVkIHx8IHcuY29uZmlnLmNoYXJ0LnBhbiAmJiB3LmNvbmZpZy5jaGFydC5wYW4uZW5hYmxlZCkge1xuICAgICAgICAgICAgICBtZS56b29tUGFuU2VsZWN0aW9uLmluaXQoe1xuICAgICAgICAgICAgICAgIHh5UmF0aW9zOiBncmFwaERhdGEueHlSYXRpb3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b29scyA9IHcuY29uZmlnLmNoYXJ0LnRvb2xiYXIudG9vbHM7XG4gICAgICAgICAgICB0b29scy56b29tID0gZmFsc2U7XG4gICAgICAgICAgICB0b29scy56b29taW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRvb2xzLnpvb21vdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRvb2xzLnNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgdG9vbHMucGFuID0gZmFsc2U7XG4gICAgICAgICAgICB0b29scy5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3LmNvbmZpZy5jaGFydC50b29sYmFyLnNob3cgJiYgIXcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIG1lLnRvb2xiYXIuY3JlYXRlVG9vbGJhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3Lmdsb2JhbHMubWVtb3J5Lm1ldGhvZHNUb0V4ZWMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHcuZ2xvYmFscy5tZW1vcnkubWV0aG9kc1RvRXhlYy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm4ubWV0aG9kKGZuLnBhcmFtcywgZmFsc2UsIGZuLmNvbnRleHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJQcmV2aW91c1BhdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyUHJldmlvdXNQYXRocygpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5nbG9iYWxzLnByZXZpb3VzUGF0aHMgPSBbXTtcbiAgICAgIHcuZ2xvYmFscy5hbGxTZXJpZXNDb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXMgPSBbXTtcbiAgICAgIHcuZ2xvYmFscy5jb2xsYXBzZWRTZXJpZXNJbmRpY2VzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB1c2VycyB0byB1cGRhdGUgT3B0aW9ucyBhZnRlciB0aGUgY2hhcnQgaGFzIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBIG5ldyBjb25maWcgb2JqZWN0IGNhbiBiZSBwYXNzZWQgd2hpY2ggd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgZXhpc3RpbmcgY29uZmlnIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVkcmF3IC0gc2hvdWxkIHJlZHJhdyBmcm9tIGJlZ2lubmluZyBvciBzaG91bGQgdXNlIGV4aXN0aW5nIHBhdGhzIGFuZCByZWRyYXcgZnJvbSB0aGVyZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYW5pbWF0ZSAtIHNob3VsZCBhbmltYXRlIG9yIG5vdCBvbiB1cGRhdGluZyBPcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0aW9ucyQkMSkge1xuICAgICAgdmFyIHJlZHJhdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgYW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgIHZhciBvdmVyd3JpdGVJbml0aWFsQ29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICAgIGlmIChvcHRpb25zJCQxLnNlcmllcykge1xuICAgICAgICBpZiAob3B0aW9ucyQkMS5zZXJpZXNbMF0uZGF0YSkge1xuICAgICAgICAgIG9wdGlvbnMkJDEuc2VyaWVzID0gb3B0aW9ucyQkMS5zZXJpZXMubWFwKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgdy5jb25maWcuc2VyaWVzW2ldLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHMubmFtZSA/IHMubmFtZSA6IHcuY29uZmlnLnNlcmllc1tpXS5uYW1lLFxuICAgICAgICAgICAgICB0eXBlOiBzLnR5cGUgPyBzLnR5cGUgOiB3LmNvbmZpZy5zZXJpZXNbaV0udHlwZSxcbiAgICAgICAgICAgICAgZGF0YTogcy5kYXRhID8gcy5kYXRhIDogdy5jb25maWcuc2VyaWVzW2ldLmRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIHVzZXIgdXBkYXRlZCB0aGUgc2VyaWVzIHZpYSB1cGRhdGVPcHRpb25zKCkgZnVuY3Rpb24uXG4gICAgICAgIC8vIEhlbmNlLCB3ZSBuZWVkIHRvIHJlc2V0IGF4aXMgbWluL21heCB0byBhdm9pZCB6b29taW5nIGlzc3Vlc1xuXG5cbiAgICAgICAgdGhpcy5yZXZlcnREZWZhdWx0QXhpc01pbk1heCgpO1xuICAgICAgfSAvLyB1c2VyIGhhcyBzZXQgeC1heGlzIG1pbi9tYXggZXh0ZXJuYWxseSAtIGhlbmNlIHdlIG5lZWQgdG8gZm9yY2VmdWxseSBzZXQgdGhlIHhheGlzIG1pbi9tYXhcblxuXG4gICAgICBpZiAob3B0aW9ucyQkMS54YXhpcykge1xuICAgICAgICBpZiAob3B0aW9ucyQkMS54YXhpcy5taW4gfHwgb3B0aW9ucyQkMS54YXhpcy5tYXgpIHtcbiAgICAgICAgICB0aGlzLmZvcmNlWEF4aXNVcGRhdGUob3B0aW9ucyQkMSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZml4ZXMgYXBleGNoYXJ0cy5qcyMzNjkgYW5kIHJlYWN0LWFwZXhjaGFydHMjNDYgKi9cblxuXG4gICAgICAgIGlmIChvcHRpb25zJCQxLnhheGlzLmNhdGVnb3JpZXMgJiYgb3B0aW9ucyQkMS54YXhpcy5jYXRlZ29yaWVzLmxlbmd0aCAmJiB3LmNvbmZpZy54YXhpcy5jb252ZXJ0ZWRDYXRUb051bWVyaWMpIHtcbiAgICAgICAgICBvcHRpb25zJCQxID0gRGVmYXVsdHMuY29udmVydENhdFRvTnVtZXJpYyhvcHRpb25zJCQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAody5nbG9iYWxzLmNvbGxhcHNlZFNlcmllc0luZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmNsZWFyUHJldmlvdXNQYXRocygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlT3B0aW9ucyhvcHRpb25zJCQxLCByZWRyYXcsIGFuaW1hdGUsIG92ZXJ3cml0ZUluaXRpYWxDb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwcml2YXRlIG1ldGhvZCB0byB1cGRhdGUgT3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gQSBuZXcgY29uZmlnIG9iamVjdCBjYW4gYmUgcGFzc2VkIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGNvbmZpZyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlZHJhdyAtIHNob3VsZCByZWRyYXcgZnJvbSBiZWdpbm5pbmcgb3Igc2hvdWxkIHVzZSBleGlzdGluZyBwYXRocyBhbmQgcmVkcmF3IGZyb20gdGhlcmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGUgLSBzaG91bGQgYW5pbWF0ZSBvciBub3Qgb24gdXBkYXRpbmcgT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlSW5pdGlhbENvbmZpZyAtIHNob3VsZCB1cGRhdGUgdGhlIGluaXRpYWwgY29uZmlnIG9yIG5vdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZU9wdGlvbnMob3B0aW9ucyQkMSkge1xuICAgICAgdmFyIHJlZHJhdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgYW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgIHZhciBvdmVyd3JpdGVJbml0aWFsQ29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICAgIHZhciBjaGFydHMgPSB0aGlzLmdldFN5bmNlZENoYXJ0cygpO1xuICAgICAgY2hhcnRzLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHZhciB3ID0gY2gudztcbiAgICAgICAgdy5nbG9iYWxzLnNob3VsZEFuaW1hdGUgPSBhbmltYXRlO1xuXG4gICAgICAgIGlmICghcmVkcmF3KSB7XG4gICAgICAgICAgdy5nbG9iYWxzLnJlc2l6ZWQgPSB0cnVlO1xuICAgICAgICAgIHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICAgICAgY2guc2VyaWVzLmdldFByZXZpb3VzUGF0aHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyQkMSAmJiBfdHlwZW9mKG9wdGlvbnMkJDEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoLmNvbmZpZyA9IG5ldyBDb25maWcob3B0aW9ucyQkMSk7XG4gICAgICAgICAgb3B0aW9ucyQkMSA9IENvcmVVdGlscy5leHRlbmRBcnJheVByb3BzKGNoLmNvbmZpZywgb3B0aW9ucyQkMSk7XG4gICAgICAgICAgdy5jb25maWcgPSBVdGlscy5leHRlbmQody5jb25maWcsIG9wdGlvbnMkJDEpO1xuXG4gICAgICAgICAgaWYgKG92ZXJ3cml0ZUluaXRpYWxDb25maWcpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZm9yZ2V0IHRoZSBsYXN0WEF4aXMgYW5kIGxhc3RZQXhpcyBpcyB1c2VyIGZvcmNlZnVsbHkgb3ZlcndyaXRlSW5pdGlhbENvbmZpZy4gSWYgd2UgZG8gbm90IGRvIHRoaXMsIGFuZCBuZXh0IHRpbWUgd2hlbiB1c2VyIHpvb21zIHRoZSBjaGFydCBhZnRlciBzZXR0aW5nIHlheGlzLm1pbi9tYXggb3IgeGF4aXMubWluL21heCAtIHRoZSBzdG9yZWQgbGFzdFhBeGlzIHdpbGwgbmV2ZXIgYWxsb3cgdGhlIGNoYXJ0IHRvIHVzZSB0aGUgdXBkYXRlZCBtaW4vbWF4IGJ5IHVzZXIuXG4gICAgICAgICAgICB3Lmdsb2JhbHMubGFzdFhBeGlzID0gW107XG4gICAgICAgICAgICB3Lmdsb2JhbHMubGFzdFlBeGlzID0gW107IC8vIEFmdGVyIGZvcmdldHRpbmcgbGFzdEF4ZXMsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgbmV3IGNvbmZpZyBpbiBpbml0aWFsQ29uZmlnL2luaXRpYWxTZXJpZXNcblxuICAgICAgICAgICAgdy5nbG9iYWxzLmluaXRpYWxDb25maWcgPSBVdGlscy5leHRlbmQoe30sIHcuY29uZmlnKTtcbiAgICAgICAgICAgIHcuZ2xvYmFscy5pbml0aWFsU2VyaWVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh3LmNvbmZpZy5zZXJpZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2gudXBkYXRlKG9wdGlvbnMkJDEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB1c2VycyB0byB1cGRhdGUgU2VyaWVzIGFmdGVyIHRoZSBjaGFydCBoYXMgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBzZXJpZXMgLSBOZXcgc2VyaWVzIHdoaWNoIHdpbGwgb3ZlcnJpZGUgdGhlIGV4aXN0aW5nXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2VyaWVzKCkge1xuICAgICAgdmFyIG5ld1NlcmllcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgYW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBvdmVyd3JpdGVJbml0aWFsU2VyaWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgdGhpcy5yZXZlcnREZWZhdWx0QXhpc01pbk1heCgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZVNlcmllcyhuZXdTZXJpZXMsIGFuaW1hdGUsIG92ZXJ3cml0ZUluaXRpYWxTZXJpZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdXNlcnMgdG8gYXBwZW5kIGEgbmV3IHNlcmllcyBhZnRlciB0aGUgY2hhcnQgaGFzIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gbmV3U2VyaWUgLSBOZXcgc2VyaWUgd2hpY2ggd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZXhpc3Rpbmcgc2VyaWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRTZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kU2VyaWVzKG5ld1NlcmllKSB7XG4gICAgICB2YXIgYW5pbWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBuZXdTZXJpZXMgPSB0aGlzLncuY29uZmlnLnNlcmllcy5zbGljZSgpO1xuICAgICAgbmV3U2VyaWVzLnB1c2gobmV3U2VyaWUpO1xuICAgICAgdGhpcy5yZXZlcnREZWZhdWx0QXhpc01pbk1heCgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZVNlcmllcyhuZXdTZXJpZXMsIGFuaW1hdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCB0byB1cGRhdGUgU2VyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gc2VyaWVzIC0gTmV3IHNlcmllcyB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBleGlzdGluZ1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU2VyaWVzKG5ld1NlcmllcywgYW5pbWF0ZSkge1xuICAgICAgdmFyIG92ZXJ3cml0ZUluaXRpYWxTZXJpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB0aGlzLncuZ2xvYmFscy5zaG91bGRBbmltYXRlID0gYW5pbWF0ZTtcbiAgICAgIHcuZ2xvYmFscy5kYXRhQ2hhbmdlZCA9IHRydWU7IC8vIGlmIHVzZXIgaGFzIGNvbGxhcHNlZCBzb21lIHNlcmllcyB3aXRoIGxlZ2VuZCwgd2UgbmVlZCB0byBjbGVhciB0aG9zZVxuXG4gICAgICBpZiAody5nbG9iYWxzLmFsbFNlcmllc0NvbGxhcHNlZCkge1xuICAgICAgICB3Lmdsb2JhbHMuYWxsU2VyaWVzQ29sbGFwc2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzLmdldFByZXZpb3VzUGF0aHMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4aXN0aW5nU2VyaWVzOyAvLyBheGlzIGNoYXJ0c1xuXG4gICAgICBpZiAobmV3U2VyaWVzWzBdLmRhdGEpIHtcbiAgICAgICAgZXhpc3RpbmdTZXJpZXMgPSBuZXdTZXJpZXMubWFwKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHcuY29uZmlnLnNlcmllc1tpXSwge1xuICAgICAgICAgICAgbmFtZTogcy5uYW1lID8gcy5uYW1lIDogdy5jb25maWcuc2VyaWVzW2ldLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiBzLnR5cGUgPyBzLnR5cGUgOiB3LmNvbmZpZy5zZXJpZXNbaV0udHlwZSxcbiAgICAgICAgICAgIGRhdGE6IHMuZGF0YSA/IHMuZGF0YSA6IHcuY29uZmlnLnNlcmllc1tpXS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB3LmNvbmZpZy5zZXJpZXMgPSBleGlzdGluZ1NlcmllcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vbi1heGlzIGNoYXJ0IChwaWUvcmFkaWFsYmFyKVxuICAgICAgICB3LmNvbmZpZy5zZXJpZXMgPSBuZXdTZXJpZXMuc2xpY2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG92ZXJ3cml0ZUluaXRpYWxTZXJpZXMpIHtcbiAgICAgICAgdy5nbG9iYWxzLmluaXRpYWxDb25maWcuc2VyaWVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh3LmNvbmZpZy5zZXJpZXMpKTtcbiAgICAgICAgdy5nbG9iYWxzLmluaXRpYWxTZXJpZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHcuY29uZmlnLnNlcmllcykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBjaGFydHMgaW4gdGhlIHNhbWUgXCJncm91cFwiIChpbmNsdWRpbmcgdGhlIGluc3RhbmNlIHdoaWNoIGlzIGNhbGxlZCB1cG9uKSB0byBzeW5jIHRoZW0gd2hlbiB1c2VyIHpvb21zIGluL291dCBvciBwYW4uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTeW5jZWRDaGFydHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3luY2VkQ2hhcnRzKCkge1xuICAgICAgdmFyIGNoYXJ0R3JvdXBzID0gdGhpcy5nZXRHcm91cGVkQ2hhcnRzKCk7XG4gICAgICB2YXIgYWxsQ2hhcnRzID0gW3RoaXNdO1xuXG4gICAgICBpZiAoY2hhcnRHcm91cHMubGVuZ3RoKSB7XG4gICAgICAgIGFsbENoYXJ0cyA9IFtdO1xuICAgICAgICBjaGFydEdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChjaCkge1xuICAgICAgICAgIGFsbENoYXJ0cy5wdXNoKGNoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGxDaGFydHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjaGFydHMgaW4gdGhlIHNhbWUgXCJncm91cFwiIChleGNsdWRpbmcgdGhlIGluc3RhbmNlIHdoaWNoIGlzIGNhbGxlZCB1cG9uKSB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gdGhlIG90aGVyIGNoYXJ0cyBvZiB0aGUgc2FtZSBncm91cCAoZWcuLCB0b29sdGlwIGhvdmVyaW5nKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0R3JvdXBlZENoYXJ0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcm91cGVkQ2hhcnRzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBBcGV4Ll9jaGFydEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIGlmIChjaC5ncm91cCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIudy5jb25maWcuY2hhcnQuZ3JvdXAgPT09IGNoLmdyb3VwID8gY2guY2hhcnQgOiBfdGhpczI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHVzZXJzIHRvIGFwcGVuZCBEYXRhIHRvIHNlcmllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG5ld0RhdGEgLSBOZXcgZGF0YSBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgc2VyaWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZERhdGEobmV3RGF0YSkge1xuICAgICAgdmFyIG92ZXJ3cml0ZUluaXRpYWxTZXJpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgbWUudy5nbG9iYWxzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIG1lLnNlcmllcy5nZXRQcmV2aW91c1BhdGhzKCk7XG4gICAgICB2YXIgbmV3U2VyaWVzID0gbWUudy5jb25maWcuc2VyaWVzLnNsaWNlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2VyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3RGF0YVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5ld0RhdGFbaV0uZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbmV3U2VyaWVzW2ldLmRhdGEucHVzaChuZXdEYXRhW2ldLmRhdGFbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZS53LmNvbmZpZy5zZXJpZXMgPSBuZXdTZXJpZXM7XG5cbiAgICAgIGlmIChvdmVyd3JpdGVJbml0aWFsU2VyaWVzKSB7XG4gICAgICAgIG1lLncuZ2xvYmFscy5pbml0aWFsU2VyaWVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZS53LmNvbmZpZy5zZXJpZXMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUob3B0aW9ucyQkMSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMzLmNsZWFyKCk7XG5cbiAgICAgICAgdmFyIGdyYXBoRGF0YSA9IF90aGlzMy5jcmVhdGUoX3RoaXMzLncuY29uZmlnLnNlcmllcywgb3B0aW9ucyQkMSk7XG5cbiAgICAgICAgaWYgKCFncmFwaERhdGEpIHJldHVybiByZXNvbHZlKF90aGlzMyk7XG5cbiAgICAgICAgX3RoaXMzLm1vdW50KGdyYXBoRGF0YSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfdGhpczMudy5jb25maWcuY2hhcnQuZXZlbnRzLnVwZGF0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF90aGlzMy53LmNvbmZpZy5jaGFydC5ldmVudHMudXBkYXRlZChfdGhpczMsIF90aGlzMy53KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczMuZmlyZUV2ZW50KCd1cGRhdGVkJywgW190aGlzMywgX3RoaXMzLnddKTtcblxuICAgICAgICAgIF90aGlzMy53Lmdsb2JhbHMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZShfdGhpczMpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yY2VYQXhpc1VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JjZVhBeGlzVXBkYXRlKG9wdGlvbnMkJDEpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMkJDEueGF4aXMubWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3LmNvbmZpZy54YXhpcy5taW4gPSBvcHRpb25zJCQxLnhheGlzLm1pbjtcbiAgICAgICAgdy5nbG9iYWxzLmxhc3RYQXhpcy5taW4gPSBvcHRpb25zJCQxLnhheGlzLm1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zJCQxLnhheGlzLm1heCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdy5jb25maWcueGF4aXMubWF4ID0gb3B0aW9ucyQkMS54YXhpcy5tYXg7XG4gICAgICAgIHcuZ2xvYmFscy5sYXN0WEF4aXMubWF4ID0gb3B0aW9ucyQkMS54YXhpcy5tYXg7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV2ZXJ0cyB0aGUgeWF4aXMgYW5kIHhheGlzIG1pbi9tYXggdmFsdWVzIHRvIHdoYXQgaXQgd2FzIHdoZW4gdGhlIGNoYXJ0IHdhcyBkZWZpbmVkLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZml4ZXMgYW4gaW1wb3J0YW50IGJ1ZyB3aGVyZSBhIHVzZXIgbWlnaHQgbG9hZCBhIG5ldyBzZXJpZXMgYWZ0ZXIgem9vbWluZyBpbi9vdXQgb2YgcHJldmlvdXMgc2VyaWVzIHdoaWNoIHJlc3VsdGVkIGluIHdyb25nIG1pbi9tYXhcbiAgICAgKiBBbHNvLCB0aGlzIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgaW50ZXJuYWxseSBvbiB6b29tL3BhbiAtIHRoZSByZXNldCBzaG91bGQgb25seSBoYXBwZW4gd2hlbiB1c2VyIGNhbGxzIHRoZSB1cGRhdGVTZXJpZXMoKSBmdW5jdGlvbiBleHRlcm5hbGx5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnREZWZhdWx0QXhpc01pbk1heFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnREZWZhdWx0QXhpc01pbk1heCgpIHtcbiAgICAgIHZhciB3ID0gdGhpcy53O1xuICAgICAgdy5jb25maWcueGF4aXMubWluID0gdy5nbG9iYWxzLmxhc3RYQXhpcy5taW47XG4gICAgICB3LmNvbmZpZy54YXhpcy5tYXggPSB3Lmdsb2JhbHMubGFzdFhBeGlzLm1heDtcbiAgICAgIHcuY29uZmlnLnlheGlzLm1hcChmdW5jdGlvbiAoeWF4ZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHcuZ2xvYmFscy56b29tZWQpIHtcbiAgICAgICAgICAvLyBpZiB1c2VyIGhhcyB6b29tZWQsIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAgICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBnZXQgdGhlIGxhc3RBeGlzIG1pbiBhbmQgbWF4XG4gICAgICAgICAgaWYgKHR5cGVvZiB3Lmdsb2JhbHMubGFzdFlBeGlzW2luZGV4XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHlheGUubWluID0gdy5nbG9iYWxzLmxhc3RZQXhpc1tpbmRleF0ubWluO1xuICAgICAgICAgICAgeWF4ZS5tYXggPSB3Lmdsb2JhbHMubGFzdFlBeGlzW2luZGV4XS5tYXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBpZiAodGhpcy56b29tUGFuU2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuem9vbVBhblNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRvb2xiYXIpIHtcbiAgICAgICAgdGhpcy50b29sYmFyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hbmltYXRpb25zID0gbnVsbDtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBudWxsO1xuICAgICAgdGhpcy5jb3JlID0gbnVsbDtcbiAgICAgIHRoaXMuZ3JpZCA9IG51bGw7XG4gICAgICB0aGlzLnNlcmllcyA9IG51bGw7XG4gICAgICB0aGlzLnJlc3BvbnNpdmUgPSBudWxsO1xuICAgICAgdGhpcy50aGVtZSA9IG51bGw7XG4gICAgICB0aGlzLmZvcm1hdHRlcnMgPSBudWxsO1xuICAgICAgdGhpcy50aXRsZVN1YnRpdGxlID0gbnVsbDtcbiAgICAgIHRoaXMubGVnZW5kID0gbnVsbDtcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IG51bGw7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICAgICAgdGhpcy5jcm9zc2hhaXJzID0gbnVsbDtcbiAgICAgIHRoaXMuem9vbVBhblNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLnRvb2xiYXIgPSBudWxsO1xuICAgICAgdGhpcy53Lmdsb2JhbHMudG9vbHRpcCA9IG51bGw7XG4gICAgICB0aGlzLmNsZWFyRG9tRWxlbWVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2lsbFNWR1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsU1ZHKGRyYXcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZHJhdy5lYWNoKGZ1bmN0aW9uIChpLCBjaGlsZHJlbikge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJyonKTtcbiAgICAgICAgICB0aGlzLm9mZigpO1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgZHJhdy51bmdyb3VwKCk7XG4gICAgICAgIGRyYXcuY2xlYXIoKTtcbiAgICAgICAgcmVzb2x2ZSgnZG9uZScpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyRG9tRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJEb21FbGVtZW50cygpIHtcbiAgICAgIHZhciBkb21FbHMgPSB0aGlzLncuZ2xvYmFscy5kb207XG5cbiAgICAgIGlmICh0aGlzLmVsICE9PSBudWxsKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgY2hpbGQgZWxlbWVudHMgLSByZXNldHRpbmcgdGhlIHdob2xlIGNoYXJ0XG4gICAgICAgIHdoaWxlICh0aGlzLmVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICB0aGlzLmVsLnJlbW92ZUNoaWxkKHRoaXMuZWwuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5raWxsU1ZHKGRvbUVscy5QYXBlcik7XG4gICAgICBkb21FbHMuUGFwZXIucmVtb3ZlKCk7XG4gICAgICBkb21FbHMuZWxXcmFwID0gbnVsbDtcbiAgICAgIGRvbUVscy5lbEdyYXBoaWNhbCA9IG51bGw7XG4gICAgICBkb21FbHMuZWxMZWdlbmRXcmFwID0gbnVsbDtcbiAgICAgIGRvbUVscy5iYXNlRWwgPSBudWxsO1xuICAgICAgZG9tRWxzLmVsR3JpZFJlY3QgPSBudWxsO1xuICAgICAgZG9tRWxzLmVsR3JpZFJlY3RNYXNrID0gbnVsbDtcbiAgICAgIGRvbUVscy5lbEdyaWRSZWN0TWFya2VyTWFzayA9IG51bGw7XG4gICAgICBkb21FbHMuZWxEZWZzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgY2hhcnQgaW5zdGFuY2UgYnkgcmVtb3ZpbmcgYWxsIGVsZW1lbnRzIHdoaWNoIGFsc28gY2xlYW4gdXAgZXZlbnQgbGlzdGVuZXJzIG9uIHRob3NlIGVsZW1lbnRzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5jbGVhcigpOyAvLyByZW1vdmUgdGhlIGNoYXJ0J3MgaW5zdGFuY2UgZnJvbSB0aGUgZ2xvYmFsIEFwZXguX2NoYXJ0SW5zdGFuY2VzXG5cbiAgICAgIHZhciBjaGFydElEID0gdGhpcy53LmNvbmZpZy5jaGFydC5pZDtcblxuICAgICAgaWYgKGNoYXJ0SUQpIHtcbiAgICAgICAgQXBleC5fY2hhcnRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgIGlmIChjLmlkID09PSBjaGFydElEKSB7XG4gICAgICAgICAgICBBcGV4Ll9jaGFydEluc3RhbmNlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMud2luZG93UmVzaXplSGFuZGxlcik7XG4gICAgICB3aW5kb3cucmVtb3ZlUmVzaXplTGlzdGVuZXIodGhpcy5lbC5wYXJlbnROb2RlLCB0aGlzLnBhcmVudFJlc2l6ZUNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gcHJvdmlkZSBkYXRhIGF0dHJzIGluIHRoZSBlbGVtZW50IGFuZCB0aGUgY2hhcnQgd2lsbCByZW5kZXIgYXV0b21hdGljYWxseSB3aGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBzZWFyY2hpbmcgZm9yIHRoZSBlbGVtZW50cyBjb250YWluaW5nICdkYXRhLWFwZXhjaGFydHMnIGF0dHJpYnV0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlU2VyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVNlcmllcyhzZXJpZXNOYW1lKSB7XG4gICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IHRoaXMuc2VyaWVzLmdldFNlcmllc0J5TmFtZShzZXJpZXNOYW1lKTtcbiAgICAgIHZhciBzZXJpZXNDbnQgPSBwYXJzZUludCh0YXJnZXRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YTpyZWFsSW5kZXgnKSk7XG4gICAgICB2YXIgaXNIaWRkZW4gPSB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnYXBleGNoYXJ0cy1zZXJpZXMtY29sbGFwc2VkJyk7XG4gICAgICB0aGlzLmxlZ2VuZC50b2dnbGVEYXRhU2VyaWVzKHNlcmllc0NudCwgaXNIaWRkZW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFRvZ2dsZVNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFRvZ2dsZVNlcmllcygpIHtcbiAgICAgIHRoaXMubGVnZW5kLnJlc2V0VG9nZ2xlRGF0YVNlcmllcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cEV2ZW50SGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIGNsaWNrYWJsZUFyZWEgPSB3Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKHcuZ2xvYmFscy5jaGFydENsYXNzKTtcbiAgICAgIHZhciBldmVudExpc3QgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAnbW91c2V1cCcsICd0b3VjaGVuZCddO1xuICAgICAgZXZlbnRMaXN0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNsaWNrYWJsZUFyZWEuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJyAmJiBlLndoaWNoID09PSAxKSA7IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNldXAnICYmIGUud2hpY2ggPT09IDEgfHwgZS50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHcuY29uZmlnLmNoYXJ0LmV2ZW50cy5jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB3LmNvbmZpZy5jaGFydC5ldmVudHMuY2xpY2soZSwgbWUsIHcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5maXJlRXZlbnQoJ2NsaWNrJywgW2UsIG1lLCB3XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb3JlLnNldHVwQnJ1c2hIYW5kbGVyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFhheGlzQW5ub3RhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRYYXhpc0Fubm90YXRpb24ob3B0cykge1xuICAgICAgdmFyIHB1c2hUb01lbW9yeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBtZSA9IGNvbnRleHQ7XG4gICAgICB9XG5cbiAgICAgIG1lLmFubm90YXRpb25zLmFkZFhheGlzQW5ub3RhdGlvbkV4dGVybmFsKG9wdHMsIHB1c2hUb01lbW9yeSwgbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRZYXhpc0Fubm90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWWF4aXNBbm5vdGF0aW9uKG9wdHMpIHtcbiAgICAgIHZhciBwdXNoVG9NZW1vcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgbWUgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBtZS5hbm5vdGF0aW9ucy5hZGRZYXhpc0Fubm90YXRpb25FeHRlcm5hbChvcHRzLCBwdXNoVG9NZW1vcnksIG1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUG9pbnRBbm5vdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBvaW50QW5ub3RhdGlvbihvcHRzKSB7XG4gICAgICB2YXIgcHVzaFRvTWVtb3J5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIG1lID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgbWUuYW5ub3RhdGlvbnMuYWRkUG9pbnRBbm5vdGF0aW9uRXh0ZXJuYWwob3B0cywgcHVzaFRvTWVtb3J5LCBtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQW5ub3RhdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJBbm5vdGF0aW9ucygpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBtZSA9IGNvbnRleHQ7XG4gICAgICB9XG5cbiAgICAgIG1lLmFubm90YXRpb25zLmNsZWFyQW5ub3RhdGlvbnMobWUpO1xuICAgIH0gLy8gVGhpcyBtZXRob2QgaXMgbmV2ZXIgdXNlZCBpbnRlcm5hbGx5IGFuZCB3aWxsIGJlIG9ubHkgY2FsbGVkIGV4dGVybmFsbHkgb24gdGhlIGNoYXJ0IGluc3RhbmNlLlxuICAgIC8vIEhlbmNlLCB3ZSBuZWVkIHRvIGtlZXAgYWxsIHRoZXNlIGVsZW1lbnRzIGluIG1lbW9yeSB3aGVuIHRoZSBjaGFydCBnZXRzIHVwZGF0ZWQgYW5kIHJlZHJhdyBhZ2FpblxuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUZXh0KG9wdGlvbnMkJDEpIHtcbiAgICAgIHZhciBwdXNoVG9NZW1vcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgbWUgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBtZS5hbm5vdGF0aW9ucy5hZGRUZXh0KG9wdGlvbnMkJDEsIHB1c2hUb01lbW9yeSwgbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDaGFydEFyZWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhcnRBcmVhKCkge1xuICAgICAgdmFyIGVsID0gdGhpcy53Lmdsb2JhbHMuZG9tLmJhc2VFbC5xdWVyeVNlbGVjdG9yKCcuYXBleGNoYXJ0cy1pbm5lcicpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZXJpZXNUb3RhbFhSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXJpZXNUb3RhbFhSYW5nZShtaW5YLCBtYXhYKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb3JlVXRpbHMuZ2V0U2VyaWVzVG90YWxzWFJhbmdlKG1pblgsIG1heFgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRIaWdoZXN0VmFsdWVJblNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIaWdoZXN0VmFsdWVJblNlcmllcygpIHtcbiAgICAgIHZhciBzZXJpZXNJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZSQxKHRoaXMuY3R4KTtcbiAgICAgIHZhciBtaW5ZbWF4WSA9IHJhbmdlLmdldE1pbllNYXhZKHNlcmllc0luZGV4KTtcbiAgICAgIHJldHVybiBtaW5ZbWF4WS5oaWdoZXN0WTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TG93ZXN0VmFsdWVJblNlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb3dlc3RWYWx1ZUluU2VyaWVzKCkge1xuICAgICAgdmFyIHNlcmllc0luZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlJDEodGhpcy5jdHgpO1xuICAgICAgdmFyIG1pblltYXhZID0gcmFuZ2UuZ2V0TWluWU1heFkoc2VyaWVzSW5kZXgpO1xuICAgICAgcmV0dXJuIG1pblltYXhZLmxvd2VzdFk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlcmllc1RvdGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlcmllc1RvdGFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMudy5nbG9iYWxzLnNlcmllc1RvdGFscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9jYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvY2FsZShsb2NhbGVOYW1lKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRMb2NhbGVWYWx1ZXMobG9jYWxlTmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEN1cnJlbnRMb2NhbGVWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VycmVudExvY2FsZVZhbHVlcyhsb2NhbGVOYW1lKSB7XG4gICAgICB2YXIgbG9jYWxlcyA9IHRoaXMudy5jb25maWcuY2hhcnQubG9jYWxlczsgLy8gY2hlY2sgaWYgdXNlciBoYXMgc3BlY2lmaWVkIGxvY2FsZXMgaW4gZ2xvYmFsIEFwZXggdmFyaWFibGVcbiAgICAgIC8vIGlmIHllcyAtIHRoZW4gZXh0ZW5kIHRob3NlIHdpdGggbG9jYWwgY2hhcnQncyBsb2NhbGVcblxuICAgICAgaWYgKHdpbmRvdy5BcGV4LmNoYXJ0ICYmIHdpbmRvdy5BcGV4LmNoYXJ0LmxvY2FsZXMgJiYgd2luZG93LkFwZXguY2hhcnQubG9jYWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxvY2FsZXMgPSB0aGlzLncuY29uZmlnLmNoYXJ0LmxvY2FsZXMuY29uY2F0KHdpbmRvdy5BcGV4LmNoYXJ0LmxvY2FsZXMpO1xuICAgICAgfSAvLyBmaW5kIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXkgb2YgbG9jYWxlcyB3aGljaCB1c2VyIGhhcyBzZXQgKGVpdGhlciBieSBjaGFydC5kZWZhdWx0TG9jYWxlIG9yIGJ5IGNhbGxpbmcgc2V0TG9jYWxlKCkgbWV0aG9kLilcblxuXG4gICAgICB2YXIgc2VsZWN0ZWRMb2NhbGUgPSBsb2NhbGVzLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5uYW1lID09PSBsb2NhbGVOYW1lO1xuICAgICAgfSlbMF07XG5cbiAgICAgIGlmIChzZWxlY3RlZExvY2FsZSkge1xuICAgICAgICAvLyBjcmVhdGUgYSBjb21wbGV0ZSBsb2NhbGUgb2JqZWN0IGJ5IGV4dGVuZGluZyBkZWZhdWx0cyBzbyB5b3UgZG9uJ3QgZ2V0IHVuZGVmaW5lZCBlcnJvcnMuXG4gICAgICAgIHZhciByZXQgPSBVdGlscy5leHRlbmQoZW4sIHNlbGVjdGVkTG9jYWxlKTsgLy8gc3RvcmUgdGhlc2UgbG9jYWxlIG9wdGlvbnMgaW4gZ2xvYmFsIHZhciBmb3IgZWFzZSBhY2Nlc3NcblxuICAgICAgICB0aGlzLncuZ2xvYmFscy5sb2NhbGUgPSByZXQub3B0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbG9jYWxlIG5hbWUgcHJvdmlkZWQuIFBsZWFzZSBtYWtlIHN1cmUgeW91IHNldCB0aGUgY29ycmVjdCBsb2NhbGUgbmFtZSBpbiBvcHRpb25zJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN2Z1VybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdmdVcmwoKSB7XG4gICAgICB2YXIgZXhwID0gbmV3IEV4cG9ydHModGhpcy5jdHgpO1xuICAgICAgcmV0dXJuIGV4cC5zdmdVcmwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YVVSSVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRhVVJJKCkge1xuICAgICAgdmFyIGV4cCA9IG5ldyBFeHBvcnRzKHRoaXMuY3R4KTtcbiAgICAgIHJldHVybiBleHAuZGF0YVVSSSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXBlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXBlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLncuZ2xvYmFscy5kb20uUGFwZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcmVudFJlc2l6ZUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcmVudFJlc2l6ZUNhbGxiYWNrKCkge1xuICAgICAgaWYgKHRoaXMudy5nbG9iYWxzLmFuaW1hdGlvbkVuZGVkKSB7XG4gICAgICAgIHRoaXMud2luZG93UmVzaXplKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB3aW5kb3cgcmVzaXplIGFuZCByZS1kcmF3IHRoZSB3aG9sZSBjaGFydC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIndpbmRvd1Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aW5kb3dSZXNpemUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudy5nbG9iYWxzLnJlc2l6ZVRpbWVyKTtcbiAgICAgIHRoaXMudy5nbG9iYWxzLnJlc2l6ZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczQudy5nbG9iYWxzLnJlc2l6ZWQgPSB0cnVlO1xuICAgICAgICBfdGhpczQudy5nbG9iYWxzLmRhdGFDaGFuZ2VkID0gZmFsc2U7IC8vIHdlIG5lZWQgdG8gcmVkcmF3IHRoZSB3aG9sZSBjaGFydCBvbiB3aW5kb3cgcmVzaXplICh3aXRoIGEgc21hbGwgZGVsYXkpLlxuXG4gICAgICAgIF90aGlzNC51cGRhdGUoKTtcbiAgICAgIH0sIDE1MCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaW5pdE9uTG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0T25Mb2FkKCkge1xuICAgICAgdmFyIGVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWFwZXhjaGFydHNdJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IGVsc1tpXTtcbiAgICAgICAgdmFyIG9wdGlvbnMkJDEgPSBKU09OLnBhcnNlKGVsc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3B0aW9ucycpKTtcbiAgICAgICAgdmFyIGFwZXhDaGFydCA9IG5ldyBBcGV4Q2hhcnRzKGVsLCBvcHRpb25zJCQxKTtcbiAgICAgICAgYXBleENoYXJ0LnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHN0YXRpYyBtZXRob2QgYWxsb3dzIHVzZXJzIHRvIGNhbGwgY2hhcnQgbWV0aG9kcyB3aXRob3V0IG5lY2Vzc2FyaWx5IGZyb20gdGhlXG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIGNoYXJ0IGluIGNhc2UgdXNlciBoYXMgYXNzaWduZWQgY2hhcnRJRCB0byB0aGUgdGFyZ2V0dGVkIGNoYXJ0LlxuICAgICAqIFRoZSBjaGFydElEIGlzIHVzZWQgZm9yIG1hcHBpbmcgdGhlIGluc3RhbmNlIHN0b3JlZCBpbiBBcGV4Ll9jaGFydEluc3RhbmNlcyBnbG9iYWwgdmFyaWFibGVcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaGVscGZ1bCBpbiBjYXNlcyB3aGVuIHlvdSBkb24ndCBoYXZlIHJlZmVyZW5jZSBvZiB0aGUgY2hhcnQgaW5zdGFuY2VcbiAgICAgKiBlYXNpbHkgYW5kIG5lZWQgdG8gY2FsbCB0aGUgbWV0aG9kIGZyb20gYW55d2hlcmUuXG4gICAgICogRm9yIGVnLCBpbiBSZWFjdC9WdWUgYXBwbGljYXRpb25zIHdoZW4geW91IGhhdmUgbWFueSBwYXJlbnQvY2hpbGQgY29tcG9uZW50cyxcbiAgICAgKiBhbmQgbmVlZCBlYXN5IHJlZmVyZW5jZSB0byBvdGhlciBjaGFydHMgZm9yIHBlcmZvcm1pbmcgZHluYW1pYyBvcGVyYXRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRJRCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciB3aGljaCB3aWxsIGJlIHVzZWQgdG8gY2FsbCBtZXRob2RzXG4gICAgICogb24gdGhhdCBjaGFydCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIG1ldGhvZCBuYW1lIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIFRoZSBwYXJhbWV0ZXJzIHdoaWNoIGFyZSBhY2NlcHRlZCBpbiB0aGUgb3JpZ2luYWwgbWV0aG9kIHdpbGwgYmUgcGFzc2VkIGhlcmUgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJleGVjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4ZWMoY2hhcnRJRCwgZm4pIHtcbiAgICAgIHZhciBjaGFydCA9IHRoaXMuZ2V0Q2hhcnRCeUlEKGNoYXJ0SUQpO1xuICAgICAgaWYgKCFjaGFydCkgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3B0cyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIG9wdHNbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGZuKSB7XG4gICAgICAgIGNhc2UgJ3VwZGF0ZU9wdGlvbnMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC51cGRhdGVPcHRpb25zLmFwcGx5KGNoYXJ0LCBvcHRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndXBkYXRlU2VyaWVzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQudXBkYXRlU2VyaWVzLmFwcGx5KGNoYXJ0LCBvcHRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnYXBwZW5kRGF0YSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0LmFwcGVuZERhdGEuYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdhZGRYYXhpc0Fubm90YXRpb24nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC5hZGRYYXhpc0Fubm90YXRpb24uYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdhZGRZYXhpc0Fubm90YXRpb24nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC5hZGRZYXhpc0Fubm90YXRpb24uYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdhZGRQb2ludEFubm90YXRpb24nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC5hZGRQb2ludEFubm90YXRpb24uYXBwbHkoY2hhcnQsIG9wdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdjbGVhckFubm90YXRpb25zJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQuY2xlYXJBbm5vdGF0aW9ucy5hcHBseShjaGFydCwgb3B0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFydC5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFV0aWxzLmV4dGVuZCh0YXJnZXQsIHNvdXJjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENoYXJ0QnlJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGFydEJ5SUQoY2hhcnRJRCkge1xuICAgICAgdmFyIGMgPSBBcGV4Ll9jaGFydEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHJldHVybiBjaC5pZCA9PT0gY2hhcnRJRDtcbiAgICAgIH0pWzBdO1xuXG4gICAgICByZXR1cm4gYy5jaGFydDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXBleENoYXJ0cztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgQXBleENoYXJ0cyQxO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIF90eXBlb2Y9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0sX2V4dGVuZHM9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIHI9YXJndW1lbnRzW3RdO2Zvcih2YXIgbiBpbiByKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLG4pJiYoZVtuXT1yW25dKX1yZXR1cm4gZX0sX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gdCYmbihlLnByb3RvdHlwZSx0KSxyJiZuKGUsciksZX19KCksX2FwZXhjaGFydHM9cmVxdWlyZShcImFwZXhjaGFydHNcIiksX2FwZXhjaGFydHMyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwZXhjaGFydHMpLF9yZWFjdD1yZXF1aXJlKFwicmVhY3RcIiksX3JlYWN0Mj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCksX3Byb3BUeXBlcz1yZXF1aXJlKFwicHJvcC10eXBlc1wiKSxfcHJvcFR5cGVzMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLHQscil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1yLGV9ZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsdCl7dmFyIHI9e307Zm9yKHZhciBuIGluIGUpMDw9dC5pbmRleE9mKG4pfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSYmKHJbbl09ZVtuXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIF9pbmhlcml0cyhlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfXdpbmRvdy5BcGV4Q2hhcnRzPV9hcGV4Y2hhcnRzMi5kZWZhdWx0O3ZhciBDaGFydHM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihlKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxyKTt2YXIgdD1fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLChyLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHIpKS5jYWxsKHRoaXMsZSkpO3JldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlUmVmP3QuY2hhcnRSZWY9X3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZVJlZigpOnQuc2V0UmVmPWZ1bmN0aW9uKGUpe3JldHVybiB0LmNoYXJ0UmVmPWV9LHQuY2hhcnQ9bnVsbCx0fXJldHVybiBfaW5oZXJpdHMocixfcmVhY3QuQ29tcG9uZW50KSxfY3JlYXRlQ2xhc3Mocixbe2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcm9wcyx0PShlLnR5cGUsZS53aWR0aCxlLmhlaWdodCxlLnNlcmllcyxlLm9wdGlvbnMsX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsW1widHlwZVwiLFwid2lkdGhcIixcImhlaWdodFwiLFwic2VyaWVzXCIsXCJvcHRpb25zXCJdKSk7cmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsX2V4dGVuZHMoe3JlZjpfcmVhY3QyLmRlZmF1bHQuY3JlYXRlUmVmP3RoaXMuY2hhcnRSZWY6dGhpcy5zZXRSZWZ9LHQpKX19LHtrZXk6XCJjb21wb25lbnREaWRNb3VudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9X3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZVJlZj90aGlzLmNoYXJ0UmVmLmN1cnJlbnQ6dGhpcy5jaGFydFJlZjt0aGlzLmNoYXJ0PW5ldyBfYXBleGNoYXJ0czIuZGVmYXVsdChlLHRoaXMuZ2V0Q29uZmlnKCkpLHRoaXMuY2hhcnQucmVuZGVyKCl9fSx7a2V5OlwiZ2V0Q29uZmlnXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByb3BzLHQ9ZS50eXBlLHI9ZS5oZWlnaHQsbj1lLndpZHRoLG89ZS5zZXJpZXMsaT1lLm9wdGlvbnMsYT17Y2hhcnQ6e3R5cGU6dCxoZWlnaHQ6cix3aWR0aDpufSxzZXJpZXM6b307cmV0dXJuIHRoaXMuZXh0ZW5kKGksYSl9fSx7a2V5OlwiaXNPYmplY3RcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09PSh2b2lkIDA9PT1lP1widW5kZWZpbmVkXCI6X3R5cGVvZihlKSkmJiFBcnJheS5pc0FycmF5KGUpJiZudWxsIT1lfX0se2tleTpcImV4dGVuZFwiLHZhbHVlOmZ1bmN0aW9uKHQscil7dmFyIG49dGhpcztcImZ1bmN0aW9uXCIhPXR5cGVvZiBPYmplY3QuYXNzaWduJiYoT2JqZWN0LmFzc2lnbj1mdW5jdGlvbihlKXtpZihudWxsPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7Zm9yKHZhciB0PU9iamVjdChlKSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dmFyIG49YXJndW1lbnRzW3JdO2lmKG51bGwhPW4pZm9yKHZhciBvIGluIG4pbi5oYXNPd25Qcm9wZXJ0eShvKSYmKHRbb109bltvXSl9cmV0dXJuIHR9KTt2YXIgbz1PYmplY3QuYXNzaWduKHt9LHQpO3JldHVybiB0aGlzLmlzT2JqZWN0KHQpJiZ0aGlzLmlzT2JqZWN0KHIpJiZPYmplY3Qua2V5cyhyKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe24uaXNPYmplY3QocltlXSkmJmUgaW4gdD9vW2VdPW4uZXh0ZW5kKHRbZV0scltlXSk6T2JqZWN0LmFzc2lnbihvLF9kZWZpbmVQcm9wZXJ0eSh7fSxlLHJbZV0pKX0pLG99fSx7a2V5OlwiY29tcG9uZW50RGlkVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoIXRoaXMuY2hhcnQpcmV0dXJuIG51bGw7dmFyIHQ9dGhpcy5wcm9wcyxyPXQub3B0aW9ucyxuPXQuc2VyaWVzLG89SlNPTi5zdHJpbmdpZnkoZS5vcHRpb25zKSxpPUpTT04uc3RyaW5naWZ5KGUuc2VyaWVzKSxhPUpTT04uc3RyaW5naWZ5KHIpLHM9SlNPTi5zdHJpbmdpZnkobik7bz09PWEmJmk9PT1zfHwoaT09PXM/dGhpcy5jaGFydC51cGRhdGVPcHRpb25zKHRoaXMuZ2V0Q29uZmlnKCkpOm89PT1hP3RoaXMuY2hhcnQudXBkYXRlU2VyaWVzKG4pOnRoaXMuY2hhcnQudXBkYXRlT3B0aW9ucyh0aGlzLmdldENvbmZpZygpKSl9fSx7a2V5OlwiY29tcG9uZW50V2lsbFVubW91bnRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2hhcnQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuY2hhcnQuZGVzdHJveSYmdGhpcy5jaGFydC5kZXN0cm95KCl9fV0pLHJ9KCk7KGV4cG9ydHMuZGVmYXVsdD1DaGFydHMpLnByb3BUeXBlcz17dHlwZTpfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkLHdpZHRoOl9wcm9wVHlwZXMyLmRlZmF1bHQuYW55LGhlaWdodDpfcHJvcFR5cGVzMi5kZWZhdWx0LmFueSxzZXJpZXM6X3Byb3BUeXBlczIuZGVmYXVsdC5hcnJheS5pc1JlcXVpcmVkLG9wdGlvbnM6X3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZH0sQ2hhcnRzLmRlZmF1bHRQcm9wcz17dHlwZTpcImxpbmVcIix3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCJhdXRvXCJ9OyIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XG4iXSwic291cmNlUm9vdCI6IiJ9